

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/feiji.png">
  <link rel="icon" type="image/png" href="/img/feiji.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="sunzy">
  <meta name="keywords" content="">
  <title>VPN - 一路走到黑</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/a11y-light.min.css" />
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Sunzy'blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('https://i.loli.net/2020/10/24/eBR35xZYEbuzSW9.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-07-21 16:04" pubdate>
        2021年7月21日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.1k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      82
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">VPN</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：10 个月前
                
              </p>
            
            <div class="markdown-body" id="post-body">
              <p>操作系统大作业</p>
<span id="more"></span>

<h1 id="一、基于UDP-TCP的VPN"><a href="#一、基于UDP-TCP的VPN" class="headerlink" title="一、基于UDP/TCP的VPN"></a>一、基于UDP/TCP的VPN</h1><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><ul>
<li>tun 接口</li>
<li>VPN搭建</li>
<li>隧道转发数据包</li>
</ul>
<h3 id="tun-设备"><a href="#tun-设备" class="headerlink" title="tun 设备"></a>tun 设备</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>tun(/tap) 是 Linux 内核 2.4.x 版本之后实现的虚拟网络设备，不同于物理网卡靠硬件网卡实现，tap/tun 虚拟网卡完全由软件来实现，功能和硬件实现完全没有差别，它们都属于网络设备，都可以配置 IP，都归 Linux 网络设备管理模块统一管理。</p>
<h4 id="TUN-工作机制"><a href="#TUN-工作机制" class="headerlink" title="TUN 工作机制"></a><strong>TUN 工作机制</strong></h4><p>TUN 设备是一种虚拟网络设备，通过此设备，程序可以方便得模拟网络行为。其工作方式如图</p>
<img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210707171052692.png" srcset="/img/loading.gif" alt="image-20210707171052692" style="zoom:80%;">

<p>Linux Tun/Tap驱动程序为应用程序提供了两种交互方式：虚拟网络接口和字符设备/dev/net/tun。写入字符设备/dev/net/tun的数据会发送到虚拟网络接口中；发送到虚拟网络接口中的数据也会出现在该字符设备上。</p>
<p>应用程序可以通过标准的Socket API向Tun/Tap接口发送IP数据包，就好像对一个真实的网卡进行操作一样。除了应用程序以外，操作系统也会根据TCP/IP协议栈的处理向Tun/Tap接口发送IP数据包或者以太网数据包，例如ARP或者ICMP数据包。Tun/Tap驱动程序会将Tun/Tap接口收到的数据包原样写入到/dev/net/tun字符设备上，处理Tun/Tap数据的应用程序如VPN程序可以从该设备上读取到数据包，以进行相应处理。</p>
<p>应用程序也可以通过/dev/net/tun字符设备写入数据包，这种情况下该字符设备上写入的数据包会被发送到Tun/Tap虚拟接口上，进入操作系统的TCP/IP协议栈进行相应处理，就像从物理网卡进入操作系统的数据一样。</p>
<h3 id="搭建-VPN"><a href="#搭建-VPN" class="headerlink" title="搭建 VPN"></a>搭建 VPN</h3><p><strong>其工作流程为：</strong></p>
<p>通过程序可以从<code>/dev/net/tun</code>字符设备中读取<code>(read)</code>或者写入<code>(write)</code>数据，再通过将Tun结合物理网络设备使用,我们可以创建一个点对点的隧道。如下图所示，左边主机上应用程序发送到Tun虚拟设备上的IP数据包被VPN程序通过字符设备接收，然后再通过一个UDP隧道发送到右端的VPN服务器上，VPN服务器将隧道负载中的原始IP数据包写入字符设备，这些IP包就会出现在右侧的Tun虚拟设备上，最后通过操作系统协议栈和socket接口发送到右侧的应用程序上。</p>
<img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210707180318134.png" srcset="/img/loading.gif" alt="image-20210707180318134" style="zoom:80%;">

<h3 id="通过隧道发送-接收包"><a href="#通过隧道发送-接收包" class="headerlink" title="通过隧道发送/接收包"></a>通过隧道发送/接收包</h3><blockquote>
<p>当隧道建立后，如何通过隧道发送/接收数据包是需要解决的问题</p>
</blockquote>
<ul>
<li><p>通过隧道发送</p>
<p>通过TUN接口获得一个IP包—&gt;加密（或者验证)—&gt;把它作为载荷发送到隧道另一端</p>
</li>
<li><p>通过隧道接收</p>
<p>通过隧道接收载荷—&gt;解密并验证数据—&gt;获得真实的包数据—&gt;把包数据写到TUN接口。</p>
</li>
</ul>
<p>如下图所示</p>
<p><img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210707214533426.png" srcset="/img/loading.gif" alt="image-20210707214533426"></p>
<p><strong>监听socket和tun0网卡，然后转发数据包</strong></p>
<p>每一个隧道应用都有两种接口: socket接口、TUN接口，两种接口都需要监听，需要在两种接口间转发数据。</p>
<p><img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210708092049656.png" srcset="/img/loading.gif" alt="image-20210708092049656"></p>
<h2 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h2><p>在编写程序之前需要做一些准备，程序流程图如下</p>
<img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210708092000296.png" srcset="/img/loading.gif" alt="image-20210708092000296" style="zoom:80%;">

<p>从图中可知程序中主要包含四个部分</p>
<ul>
<li>创建tun0网卡</li>
<li>客户端和服务器socket连接</li>
<li>转发来自tunnel和tun0数据</li>
<li>主程序，监听接口阻塞进程</li>
</ul>
<p><code>vpnclient</code> 和 <code>vpnserver</code> 程序是 VPN 隧道的两端。它们通过套接字使用  UDP 相互通信。客户端和服务器之间的虚线描绘了 VPN 隧道的路径。 VPN 客户端和服务器程序通过 TUN 接口连接到主机系统，通过它他们做两件事：</p>
<p>（1）从主机系统获取 IP 数据包，因此数据包可以通过隧道发送</p>
<p>（2）从隧道获取 IP 数据包，然后将其转发到托管系统，该系统会将数据包转发到其最终目的地。</p>
<img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210707184214724.png" srcset="/img/loading.gif" alt="image-20210707184214724" style="zoom: 80%;">

<h3 id="创建tun网卡"><a href="#创建tun网卡" class="headerlink" title="创建tun网卡"></a>创建tun网卡</h3><p>在上图中可以看到客户端和服务器都需要一个tun网卡，所以需要在两台主机上都创建一个tun0网卡，从而形成<code>tunnel</code>，实现通信</p>
<p>使用命令创建tun网卡</p>
<div class="hljs"><pre><code class="hljs shell">ip tuntap add dev tun0 mode tun</code></pre></div>

<p>当上面的命令执行完再使用<code>ifconfig -a</code>就可以看到刚刚创建的<code>tun0</code>网卡，再使用如下的命令对其配置</p>
<div class="hljs"><pre><code class="hljs apache"><span class="hljs-attribute">ifconfig</span> tun<span class="hljs-number">0</span> <span class="hljs-number">192.168.53.5</span>/<span class="hljs-number">24</span> up</code></pre></div>

<p>但是这里为了程序执行方便，直接在程序中创建虚拟网卡</p>
<div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">createTunDevice</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-comment">// 创建 tun0 网卡 </span>
   <span class="hljs-keyword">int</span> tunfd;
   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ifreq</span> <span class="hljs-title">ifr</span>;</span>
   <span class="hljs-built_in">memset</span>(&amp;ifr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(ifr));
    
   ifr.ifr_flags = IFF_TUN | IFF_NO_PI;   <span class="hljs-comment">// tun设备不包含以太网头部</span>
   tunfd = open(<span class="hljs-string">&quot;/dev/net/tun&quot;</span>, O_RDWR);  <span class="hljs-comment">// 打开文件</span>
   ioctl(tunfd, TUNSETIFF, &amp;ifr);         <span class="hljs-comment">// 打开设备</span>
   <span class="hljs-keyword">return</span> tunfd;
    <span class="hljs-comment">// 该函数执行完后 执行命令ifconfig tunX 192.168.53.5/24 up 为tun网卡设置IP并开启</span>
&#125;</code></pre></div>

<h3 id="socket连接"><a href="#socket连接" class="headerlink" title="socket连接"></a>socket连接</h3><p><code>VPN server</code></p>
<h4 id="UDP连接"><a href="#UDP连接" class="headerlink" title="UDP连接"></a>UDP连接</h4><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">initUDPServer</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">int</span> sockfd;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server</span>;</span>
    <span class="hljs-keyword">char</span> buff[<span class="hljs-number">100</span>];

    <span class="hljs-built_in">memset</span>(&amp;server, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(server));
    server.sin_family = AF_INET;       <span class="hljs-comment">// 服务器地址类型为IPV4            </span>
    server.sin_addr.s_addr = htonl(INADDR_ANY);  <span class="hljs-comment">//服务器IP</span>
    server.sin_port = htons(PORT_NUMBER);        <span class="hljs-comment">// 端口号</span>

    sockfd = socket(AF_INET, SOCK_DGRAM, <span class="hljs-number">0</span>);  <span class="hljs-comment">//创建UDP的套接字</span>
    bind(sockfd, (struct sockaddr*) &amp;server, <span class="hljs-keyword">sizeof</span>(server));  <span class="hljs-comment">// socket绑定地址和端口</span>
    <span class="hljs-comment">// 等待连接</span>
    bzero(buff, <span class="hljs-number">100</span>);   <span class="hljs-comment">//清空缓冲区</span>
    <span class="hljs-keyword">int</span> peerAddrLen = <span class="hljs-keyword">sizeof</span>(struct sockaddr_in); <span class="hljs-comment">//初始化结构体</span>
    <span class="hljs-keyword">int</span> len = recvfrom(sockfd, buff, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>,(struct sockaddr *) &amp;peerAddr, &amp;peerAddrLen);      <span class="hljs-comment">// 等待接收数据 </span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Connected with the client: %s\n&quot;</span>, buff);
    <span class="hljs-keyword">return</span> sockfd;
&#125;</code></pre></div>

<p><code>VPN client</code></p>
<div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">connectToUDPServer</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//创建socket连接 连接到vpn服务器</span>
    <span class="hljs-keyword">int</span> sockfd;
    <span class="hljs-keyword">char</span> *hello=<span class="hljs-string">&quot;Hello&quot;</span>;
	<span class="hljs-comment">//指定服务器的地址结构</span>
    <span class="hljs-built_in">memset</span>(&amp;peerAddr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(peerAddr));
    peerAddr.sin_family = AF_INET;      <span class="hljs-comment">// 服务器地址类型为IPV4   </span>
    peerAddr.sin_port = htons(PORT_NUMBER);
    peerAddr.sin_addr.s_addr = inet_addr(SERVER_IP);

    sockfd = socket(AF_INET, SOCK_DGRAM, <span class="hljs-number">0</span>);
  
    sendto(sockfd, hello, <span class="hljs-built_in">strlen</span>(hello), <span class="hljs-number">0</span>,    <span class="hljs-comment">// 连接服务器后发送一个消息 hello</span>
                (struct sockaddr *) &amp;peerAddr, <span class="hljs-keyword">sizeof</span>(peerAddr));
    <span class="hljs-keyword">return</span> sockfd;
&#125;</code></pre></div>

<h4 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h4><p><code>VPN server</code></p>
<div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">initTCPServer</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">sa_server</span>;</span>
    <span class="hljs-keyword">int</span> listen_sock;

    listen_sock= socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
    CHK_ERR(listen_sock, <span class="hljs-string">&quot;socket&quot;</span>);
    <span class="hljs-built_in">memset</span> (&amp;sa_server, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-keyword">sizeof</span>(sa_server));
    sa_server.sin_family      = AF_INET;
    sa_server.sin_addr.s_addr = INADDR_ANY;
    sa_server.sin_port        = htons (<span class="hljs-number">4433</span>);
    <span class="hljs-keyword">int</span> err = bind(listen_sock, (struct sockaddr*)&amp;sa_server, <span class="hljs-keyword">sizeof</span>(sa_server));
    CHK_ERR(err, <span class="hljs-string">&quot;bind&quot;</span>);
    err = listen(listen_sock, <span class="hljs-number">5</span>);
    CHK_ERR(err, <span class="hljs-string">&quot;listen&quot;</span>);
    <span class="hljs-keyword">return</span> listen_sock;
&#125;</code></pre></div>

<p><code>VPN client</code></p>
<div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">initTCPClient</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* hostname, <span class="hljs-keyword">int</span> port)</span></span>
<span class="hljs-function"></span>&#123;
   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server_addr</span>;</span>

   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hostent</span>* <span class="hljs-title">hp</span> =</span> gethostbyname(hostname);
	<span class="hljs-comment">// 创建TCP socket</span>
   <span class="hljs-keyword">int</span> sockfd= socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

   <span class="hljs-comment">// 填写ip 端口 和协议信息</span>
   <span class="hljs-built_in">memset</span> (&amp;server_addr, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-keyword">sizeof</span>(server_addr));
   <span class="hljs-built_in">memcpy</span>(&amp;(server_addr.sin_addr.s_addr), hp-&gt;h_addr, hp-&gt;h_length);
   server_addr.sin_port   = htons (port);
   server_addr.sin_family = AF_INET;

   <span class="hljs-comment">// 连接目的地址</span>
   connect(sockfd, (struct sockaddr*) &amp;server_addr,
           <span class="hljs-keyword">sizeof</span>(server_addr));
   <span class="hljs-keyword">return</span> sockfd;
&#125;</code></pre></div>



<h3 id="转发端口数据"><a href="#转发端口数据" class="headerlink" title="转发端口数据"></a>转发端口数据</h3><p>客户端程序和服务器端程序都需要以下两个库函数</p>
<blockquote>
<p>int sendto(int s, const void * msg, int len, unsigned int flags, const struct sockaddr * to, int tolen);</p>
<p>函数说明：sendto() 用来将数据由指定的socket 传给对方主机. 参数s 为已建好连线的socket, 如果利用UDP协议则不需经过连线操作. 参数msg 指向欲连线的数据内容, 参数flags 一般设0,  参数to 用来指定欲传送的网络地址, 结构sockaddr 请参考bind(). 参数tolen 为sockaddr 的结果长度.</p>
<p>int recvfrom(int s, void *buf, int len, unsigned int flags, struct sockaddr *from,int *fromlen);</p>
<p>函数说明：recv()用来接收远程主机经指定的socket 传来的数据, 并把数据存到由参数buf 指向的内存空间, 参数len 为可接收数据的最大长度. 参数flags 一般设0,  参数from 用来指定欲传送的网络地址, 结构sockaddr 请参考bind(). 参数fromlen 为sockaddr 的结构长度.</p>
</blockquote>
<p>从tun0接收数据转发到tunnel</p>
<div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tunSelected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tunfd, <span class="hljs-keyword">int</span> sockfd)</span></span>&#123;
    <span class="hljs-keyword">int</span>  len;
    <span class="hljs-keyword">char</span> buff[BUFF_SIZE];  <span class="hljs-comment">//定义接收数的缓冲区</span>

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Got a packet from TUN\n&quot;</span>);
    bzero(buff, BUFF_SIZE);  <span class="hljs-comment">// 清空缓冲区</span>
    len = read(tunfd, buff, BUFF_SIZE);   <span class="hljs-comment">// 读取来自tun0网卡的数据，保存在缓冲区中</span>
    sendto(sockfd, buff, len, <span class="hljs-number">0</span>, (struct sockaddr *) &amp;peerAddr, <span class="hljs-keyword">sizeof</span>(peerAddr));
    <span class="hljs-comment">// 通过socket发送数据</span>
&#125;</code></pre></div>

<p>从tunnel接收数据转发到tun0</p>
<div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">socketSelected</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> tunfd, <span class="hljs-keyword">int</span> sockfd)</span></span>&#123;
    <span class="hljs-keyword">int</span>  len;
    <span class="hljs-keyword">char</span> buff[BUFF_SIZE];
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Got a packet from the tunnel\n&quot;</span>);
    bzero(buff, BUFF_SIZE);
    len = recvfrom(sockfd, buff, BUFF_SIZE, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 接收数据至buff，保存数据的长度</span>
    write(tunfd, buff, len);								<span class="hljs-comment">// 通过write发送到tun0</span>
&#125;</code></pre></div>



<h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><p>主要作用，调用之前的函数，创建tun0网卡；建立基于udp的socket连接；循环接收数据</p>
<p>用到的库函数</p>
<blockquote>
<p>int select(int n, fd_set * readfds, fd_set * writefds, fd_set * exceptfds, struct timeval * timeout);</p>
<p>函数说明：select()用来等待文件描述词状态的改变，会阻塞进程. 参数n 代表最大的文件描述词加1, 参数readfds、writefds 和exceptfds 称为描述词组, 是用来回传该描述词的读, 写或例外的状况. 底下的宏提供了处理这三种描述词组的方式：</p>
<p>  FD_CLR(inr fd, fd_set*  set); 用来清除描述词组set 中相关fd 的位<br>  FD_ISSET(int fd, fd_set * set); 用来测试描述词组set 中相关fd 的位是否为真<br>  FD_SET(int fd, fd_set* set); 用来设置描述词组set 中相关fd 的位<br>  FD_ZERO(fd_set * set); 用来清除描述词组set 的全部位 </p>
<p>FD_ISSET</p>
<p>检测fd在fdset集合中的状态是否变化，当检测到fd状态发生变化时返回真，否则，返回假（也可以认为集合中指定的文件描述符是否可以读写）。</p>
<p>fd_set</p>
<p>可以理解为一个集合，这个集合中存放的是文件描述符(file descriptor)，即文件句柄，它用一位来表示一个fd（下面会仔细介绍）</p>
</blockquote>
<div class="hljs"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> * argv[])</span> </span>&#123;
   <span class="hljs-keyword">int</span> tunfd, sockfd;

   tunfd  = createTunDevice(); <span class="hljs-comment">// 创建tun0网卡 </span>
   sockfd = connectToUDPServer(); <span class="hljs-comment">// 建立socket连接</span>
    
   <span class="hljs-comment">// 进入主循环</span>
   <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;
     fd_set readFDSet;

     FD_ZERO(&amp;readFDSet);   <span class="hljs-comment">// 将set清零使集合中不含任何fd</span>
     FD_SET(sockfd, &amp;readFDSet); <span class="hljs-comment">// 将socketfd加入set集合</span>
     FD_SET(tunfd, &amp;readFDSet);  <span class="hljs-comment">// 将tunfd加入set集合</span>
     select(FD_SETSIZE, &amp;readFDSet, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);  <span class="hljs-comment">// 监听两个端口 阻塞进程，知道有一个端口收到数据</span>
													    <span class="hljs-comment">// 当收到数据程序继续执行 对数据进行转发</span>
     <span class="hljs-keyword">if</span> (FD_ISSET(tunfd,  &amp;readFDSet))                  <span class="hljs-comment">// 当tun的文件fd可以读写</span>
         tunSelected(tunfd, sockfd);
     <span class="hljs-keyword">if</span> (FD_ISSET(sockfd, &amp;readFDSet))                  <span class="hljs-comment">// 当socket的文件fd可以读写</span>
         socketSelected(tunfd, sockfd);
  &#125;
&#125;</code></pre></div>



<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p><code>VPN server</code></p>
<div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/if.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/if_tun.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ioctl.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PORT_NUMBER 55555</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUFF_SIZE 2000</span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">peerAddr</span>;</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">createTunDevice</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-comment">// 创建 tun0 网卡 </span>
   <span class="hljs-keyword">int</span> tunfd;
   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ifreq</span> <span class="hljs-title">ifr</span>;</span>
   <span class="hljs-built_in">memset</span>(&amp;ifr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(ifr));
    
   ifr.ifr_flags = IFF_TUN | IFF_NO_PI;   <span class="hljs-comment">// tun设备不包含以太网头部</span>
   tunfd = open(<span class="hljs-string">&quot;/dev/net/tun&quot;</span>, O_RDWR);  <span class="hljs-comment">// 打开文件</span>
   ioctl(tunfd, TUNSETIFF, &amp;ifr);         <span class="hljs-comment">// 打开设备</span>
   <span class="hljs-keyword">return</span> tunfd;
    <span class="hljs-comment">// 该函数执行完后 执行命令ifconfig tunX 192.168.53.5/24 up 为tun网卡设置IP并开启</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">initUDPServer</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">int</span> sockfd;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server</span>;</span>
    <span class="hljs-keyword">char</span> buff[<span class="hljs-number">100</span>];

    <span class="hljs-built_in">memset</span>(&amp;server, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(server));
    server.sin_family = AF_INET;       <span class="hljs-comment">// 服务器地址类型为IPV4            </span>
    server.sin_addr.s_addr = htonl(INADDR_ANY);  <span class="hljs-comment">//服务器IP</span>
    server.sin_port = htons(PORT_NUMBER);        <span class="hljs-comment">// 端口号</span>

    sockfd = socket(AF_INET, SOCK_DGRAM, <span class="hljs-number">0</span>);  <span class="hljs-comment">//创建UDP的套接字</span>
    bind(sockfd, (struct sockaddr*) &amp;server, <span class="hljs-keyword">sizeof</span>(server));  <span class="hljs-comment">// socket绑定地址和端口</span>
    <span class="hljs-comment">// 等待连接</span>
    bzero(buff, <span class="hljs-number">100</span>);   <span class="hljs-comment">//清空缓冲区</span>
    <span class="hljs-keyword">int</span> peerAddrLen = <span class="hljs-keyword">sizeof</span>(struct sockaddr_in); <span class="hljs-comment">//初始化结构体</span>
    <span class="hljs-keyword">int</span> len = recvfrom(sockfd, buff, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>,(struct sockaddr *) &amp;peerAddr, &amp;peerAddrLen);      <span class="hljs-comment">// 等待接收数据 </span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Connected with the client: %s\n&quot;</span>, buff);
    <span class="hljs-keyword">return</span> sockfd;
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tunSelected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tunfd, <span class="hljs-keyword">int</span> sockfd)</span></span>&#123;
    <span class="hljs-keyword">int</span>  len;
    <span class="hljs-keyword">char</span> buff[BUFF_SIZE];  <span class="hljs-comment">//定义接收数的缓冲区</span>

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Got a packet from TUN\n&quot;</span>);
    bzero(buff, BUFF_SIZE);  <span class="hljs-comment">// 清空缓冲区</span>
    len = read(tunfd, buff, BUFF_SIZE);   <span class="hljs-comment">// 读取来自tun0网卡的数据，保存在缓冲区中</span>
    sendto(sockfd, buff, len, <span class="hljs-number">0</span>, (struct sockaddr *) &amp;peerAddr, <span class="hljs-keyword">sizeof</span>(peerAddr));
    <span class="hljs-comment">// 通过socket发送数据</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">socketSelected</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> tunfd, <span class="hljs-keyword">int</span> sockfd)</span></span>&#123;
    <span class="hljs-keyword">int</span>  len;
    <span class="hljs-keyword">char</span> buff[BUFF_SIZE];
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Got a packet from the tunnel\n&quot;</span>);
    bzero(buff, BUFF_SIZE);
    len = recvfrom(sockfd, buff, BUFF_SIZE, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 接收数据至buff，保存数据的长度</span>
    write(tunfd, buff, len);                <span class="hljs-comment">// 通过write发送到tun0</span>
&#125;


<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> * argv[])</span> </span>&#123;
   <span class="hljs-keyword">int</span> tunfd, sockfd;

   tunfd  = createTunDevice(); <span class="hljs-comment">// 创建tun0网卡 </span>
   sockfd = connectToUDPServer(); <span class="hljs-comment">// 建立socket连接</span>
    
   <span class="hljs-comment">// 进入主循环</span>
   <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;
     fd_set readFDSet;

     FD_ZERO(&amp;readFDSet);   <span class="hljs-comment">// 将set清零使集合中不含任何fd</span>
     FD_SET(sockfd, &amp;readFDSet); <span class="hljs-comment">// 将socketfd加入set集合</span>
     FD_SET(tunfd, &amp;readFDSet);  <span class="hljs-comment">// 将tunfd加入set集合</span>
     select(FD_SETSIZE, &amp;readFDSet, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);  <span class="hljs-comment">// 监听两个端口 阻塞进程，知道有一个端口收到数据</span>
                              <span class="hljs-comment">// 当收到数据程序继续执行 对数据进行转发</span>
     <span class="hljs-keyword">if</span> (FD_ISSET(tunfd,  &amp;readFDSet))                  <span class="hljs-comment">// 当tun的文件fd可以读写</span>
         tunSelected(tunfd, sockfd);
     <span class="hljs-keyword">if</span> (FD_ISSET(sockfd, &amp;readFDSet))                  <span class="hljs-comment">// 当socket的文件fd可以读写</span>
         socketSelected(tunfd, sockfd);
  &#125;
&#125;
</code></pre></div>



<p><code>VPN client</code></p>
<div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/if.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/if_tun.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ioctl.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUFF_SIZE 2000</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PORT_NUMBER 55555</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SERVER_IP <span class="hljs-meta-string">&quot;10.0.2.8&quot;</span> <span class="hljs-comment">// VPN 服务器ip</span></span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">peerAddr</span>;</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">createTunDevice</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-comment">// 创建 tun0 网卡 </span>
   <span class="hljs-keyword">int</span> tunfd;
   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ifreq</span> <span class="hljs-title">ifr</span>;</span>
   <span class="hljs-built_in">memset</span>(&amp;ifr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(ifr));
    
   ifr.ifr_flags = IFF_TUN | IFF_NO_PI;   <span class="hljs-comment">// tun设备不包含以太网头部</span>
   tunfd = open(<span class="hljs-string">&quot;/dev/net/tun&quot;</span>, O_RDWR);  <span class="hljs-comment">// 打开文件</span>
   ioctl(tunfd, TUNSETIFF, &amp;ifr);         <span class="hljs-comment">// 打开设备</span>
   <span class="hljs-keyword">return</span> tunfd;
    <span class="hljs-comment">// 该函数执行完后 执行命令ifconfig tunX 192.168.53.5/24 up 为tun网卡设置IP并开启</span>
&#125;


<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">connectToUDPServer</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//创建socket连接 连接到vpn服务器</span>
    <span class="hljs-keyword">int</span> sockfd;
    <span class="hljs-keyword">char</span> *hello=<span class="hljs-string">&quot;Hello&quot;</span>;
  <span class="hljs-comment">//指定服务器的地址结构</span>
    <span class="hljs-built_in">memset</span>(&amp;peerAddr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(peerAddr));
    peerAddr.sin_family = AF_INET;      <span class="hljs-comment">// 服务器地址类型为IPV4   </span>
    peerAddr.sin_port = htons(PORT_NUMBER);
    peerAddr.sin_addr.s_addr = inet_addr(SERVER_IP);

    sockfd = socket(AF_INET, SOCK_DGRAM, <span class="hljs-number">0</span>);
  
    sendto(sockfd, hello, <span class="hljs-built_in">strlen</span>(hello), <span class="hljs-number">0</span>,    <span class="hljs-comment">// 连接服务器后发送一个消息 hello</span>
                (struct sockaddr *) &amp;peerAddr, <span class="hljs-keyword">sizeof</span>(peerAddr));
    <span class="hljs-keyword">return</span> sockfd;
&#125;



<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tunSelected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tunfd, <span class="hljs-keyword">int</span> sockfd)</span></span>&#123;
    <span class="hljs-keyword">int</span>  len;
    <span class="hljs-keyword">char</span> buff[BUFF_SIZE];  <span class="hljs-comment">//定义接收数的缓冲区</span>

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Got a packet from TUN\n&quot;</span>);
    bzero(buff, BUFF_SIZE);  <span class="hljs-comment">// 清空缓冲区</span>
    len = read(tunfd, buff, BUFF_SIZE);   <span class="hljs-comment">// 读取来自tun0网卡的数据，保存在缓冲区中</span>
    sendto(sockfd, buff, len, <span class="hljs-number">0</span>, (struct sockaddr *) &amp;peerAddr, <span class="hljs-keyword">sizeof</span>(peerAddr));
    <span class="hljs-comment">// 通过socket发送数据</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">socketSelected</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> tunfd, <span class="hljs-keyword">int</span> sockfd)</span></span>&#123;
    <span class="hljs-keyword">int</span>  len;
    <span class="hljs-keyword">char</span> buff[BUFF_SIZE];
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Got a packet from the tunnel\n&quot;</span>);
    bzero(buff, BUFF_SIZE);
    len = recvfrom(sockfd, buff, BUFF_SIZE, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 接收数据至buff，保存数据的长度</span>
    write(tunfd, buff, len);                <span class="hljs-comment">// 通过write发送到tun0</span>
&#125;


<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> * argv[])</span> </span>&#123;
   <span class="hljs-keyword">int</span> tunfd, sockfd;

   tunfd  = createTunDevice(); <span class="hljs-comment">// 创建tun0网卡 </span>
   sockfd = connectToUDPServer(); <span class="hljs-comment">// 建立socket连接</span>
    
   <span class="hljs-comment">// 进入主循环</span>
   <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;
     fd_set readFDSet;

     FD_ZERO(&amp;readFDSet);   <span class="hljs-comment">// 将set清零使集合中不含任何fd</span>
     FD_SET(sockfd, &amp;readFDSet); <span class="hljs-comment">// 将socketfd加入set集合</span>
     FD_SET(tunfd, &amp;readFDSet);  <span class="hljs-comment">// 将tunfd加入set集合</span>
     select(FD_SETSIZE, &amp;readFDSet, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);  <span class="hljs-comment">// 监听两个端口 阻塞进程，知道有一个端口收到数据</span>
                              <span class="hljs-comment">// 当收到数据程序继续执行 对数据进行转发</span>
     <span class="hljs-keyword">if</span> (FD_ISSET(tunfd,  &amp;readFDSet))                  <span class="hljs-comment">// 当tun的文件fd可以读写</span>
         tunSelected(tunfd, sockfd);
     <span class="hljs-keyword">if</span> (FD_ISSET(sockfd, &amp;readFDSet))                  <span class="hljs-comment">// 当socket的文件fd可以读写</span>
         socketSelected(tunfd, sockfd);
  &#125;
&#125;</code></pre></div>

<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ul>
<li>实验装置</li>
<li>拓扑图</li>
<li>主机物理网卡配置</li>
</ul>
<h3 id="实验装置"><a href="#实验装置" class="headerlink" title="实验装置"></a>实验装置</h3><blockquote>
<p>host u：ubuntu 18.04</p>
<p>VPNserver：ubuntu 18.04</p>
<p>host V：ubuntu 18.04</p>
</blockquote>
<h3 id="网络拓扑图"><a href="#网络拓扑图" class="headerlink" title="网络拓扑图"></a>网络拓扑图</h3><blockquote>
<p>本次实验需要三台主机，分别作为host U(VPN 用户)，VPN服务, host V(内网主机)。</p>
<p>host V处于192.168.60.0/24网段，属于内网。</p>
<p>host U处于10.0.2.0/24网段，属于外网，host V 和 host U在没有VPN的情况下无法通信。</p>
<p>VPN server有两张网卡，一张网卡的IP地址为192.168.60.1处于192.168.60.0/24网段，作为host V的网关，并可以与其通信；而另一张网卡地址为10.0.2.8属于外网网段，可以与host U通信，同时其作为host U的VPN服务器，实现与host V通信。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210707152524640.png" srcset="/img/loading.gif" alt="image-20210707152524640"></p>
<h3 id="主机物理网卡配置"><a href="#主机物理网卡配置" class="headerlink" title="主机物理网卡配置"></a>主机物理网卡配置</h3><table>
<thead>
<tr>
<th align="center">主机</th>
<th align="center">角色</th>
<th align="center">IP地址</th>
</tr>
</thead>
<tbody><tr>
<td align="center">客户机</td>
<td align="center">VPN客户机/host U</td>
<td align="center">10.0.2.7/24</td>
</tr>
<tr>
<td align="center">服务器</td>
<td align="center">VPN服务器/网关</td>
<td align="center">10.0.2.8/24<br>192.168.60.1/24</td>
</tr>
<tr>
<td align="center">内网主机</td>
<td align="center">host V</td>
<td align="center">192.168.60.101/24</td>
</tr>
</tbody></table>
<p><strong>tun0 虚拟网卡配置</strong></p>
<table>
<thead>
<tr>
<th align="center">主机</th>
<th align="center">虚拟接口</th>
<th align="center">IP地址</th>
</tr>
</thead>
<tbody><tr>
<td align="center">服务器</td>
<td align="center">tun0</td>
<td align="center">192.168.53.1/24</td>
</tr>
<tr>
<td align="center">客户机</td>
<td align="center">tun0</td>
<td align="center">192.168.53.5/24</td>
</tr>
</tbody></table>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>运行了三台ubuntu的虚拟机，关系如上面描述</p>
<p><img src="C:/Users/Sunzh/AppData/Roaming/Typora/typora-user-images/image-20210707224946836.png" srcset="/img/loading.gif" alt="image-20210707224946836"></p>
<h4 id="服务器主机"><a href="#服务器主机" class="headerlink" title="服务器主机"></a>服务器主机</h4><p>服务器主机需要两块网卡，这里通过VM再添加一块网卡即可，配置如图</p>
<img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210707225616855.png" srcset="/img/loading.gif" alt="image-20210707225616855" style="zoom:67%;">

<p>运行<code>vpnserver</code>程序，运行后会出现一个<code>tun0</code>网卡</p>
<p><img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210707225804438.png" srcset="/img/loading.gif" alt="image-20210707225804438"></p>
<p>使用命令配置<code>tun0</code></p>
<div class="hljs"><pre><code class="hljs apache"><span class="hljs-attribute">ifconfig</span> tun<span class="hljs-number">0</span> <span class="hljs-number">192.168.53.1</span>/<span class="hljs-number">24</span> up</code></pre></div>

<p><img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210707230038034.png" srcset="/img/loading.gif" alt="image-20210707230038034"></p>
<p>由于 VPN Server 需要在私网和隧道之间转发数据包，因此它也需要充当网关，这是通过在 VPN Server 上启用 IP 转发来实现的。</p>
<div class="hljs"><pre><code class="hljs apache"><span class="hljs-attribute">sysctl</span> net.ipv<span class="hljs-number">4</span>.ip_forward=<span class="hljs-number">1</span></code></pre></div>

<h4 id="host-v"><a href="#host-v" class="headerlink" title="host v"></a>host v</h4><p>客户端运行<code>./vpnclient</code>，之后会出现一个<code>tun0</code>接口，然后对其配置</p>
<div class="hljs"><pre><code class="hljs apache"><span class="hljs-attribute">ifconfig</span> tun<span class="hljs-number">0</span> <span class="hljs-number">192.168.53.5</span>/<span class="hljs-number">24</span> up</code></pre></div>

<img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210707232611251.png" srcset="/img/loading.gif" alt="image-20210707232611251" style="zoom:67%;">

<h4 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h4><p>经过以上两步，隧道就建立起来了，然后我们设置路由路径以将预期流量引导到客户端和服务器机器上的隧道。在 host v上，我们将所有进入专用网络 (192.168.60.0/24) 的数据包定向到 tun0 接口，数据包将从该接口通过 VPN 隧道转发。我们使用 route 命令在 host v 上添加以下路由条目：</p>
<div class="hljs"><pre><code class="hljs apache"><span class="hljs-attribute">route</span> add -net <span class="hljs-number">192.168.60.0</span>/<span class="hljs-number">24</span> tun<span class="hljs-number">0</span></code></pre></div>

<p><img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210707233335994.png" srcset="/img/loading.gif" alt="image-20210707233335994"></p>
<p>在服务器主机上，将流向 192.168.53.0/24 网络的流量定向到 tun0 接口</p>
<p><img src="C:/Users/Sunzh/AppData/Roaming/Typora/typora-user-images/image-20210707233447176.png" srcset="/img/loading.gif" alt="image-20210707233447176"></p>
<p>内网主机上为了通过 VPN 隧道将 Host V （内网主机）回复发送到 Host U，我们在 Host V 上添加了一个路由条目，它将去往 Host U 网络的数据包路由到 VPN Serve。从 VPN Server，这个数据包将通过 VPN 隧道到达 VPN Client，最终到达 Host U。 下面显示了 Host V 上的路由条目</p>
<div class="hljs"><pre><code class="hljs apache"><span class="hljs-attribute">route</span> add -net <span class="hljs-number">192.168.53.0</span>/<span class="hljs-number">24</span> gw <span class="hljs-number">192.168.60.1</span> ens<span class="hljs-number">33</span></code></pre></div>

<p><img src="C:/Users/Sunzh/AppData/Roaming/Typora/typora-user-images/image-20210707234034756.png" srcset="/img/loading.gif" alt="image-20210707234034756"></p>
<h2 id="验证通信"><a href="#验证通信" class="headerlink" title="验证通信"></a>验证通信</h2><h3 id="ping-测试"><a href="#ping-测试" class="headerlink" title="ping 测试"></a>ping 测试</h3><p>cliet ping 内网主机</p>
<p><img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210707232714091.png" srcset="/img/loading.gif" alt="image-20210707232714091"></p>
<p>内网主机ping client</p>
<p><img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210707233045553.png" srcset="/img/loading.gif" alt="image-20210707233045553"></p>
<p>内网主机追踪路由，可以看到经过网关<code>192.168.60.1</code>到达了目的地址</p>
<p><img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210707174129705.png" srcset="/img/loading.gif" alt="image-20210707174129705"></p>
<p>查看vpnclient和vpnserver程序的运行情况</p>
<p><strong>VPN client</strong></p>
<blockquote>
<p>在发送 ping 请求时，vpnclient反映已收到 TUN 接口上的数据包（ping 请求）并连续收到隧道中的包（ping 回复）</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210707234515470.png" srcset="/img/loading.gif" alt="image-20210707234515470" style="zoom: 67%;"><img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210708000049518.png" srcset="/img/loading.gif" alt="image-20210708000049518"></p>
<p><strong>VPN server</strong></p>
<blockquote>
<p>在 vpnserver上，程序反映从隧道接收数据包（ping 请求），然后从 TUN 接收数据包（ping 回复）</p>
</blockquote>
<img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210707234610430.png" srcset="/img/loading.gif" alt="image-20210707234610430" style="zoom:67%;">

<h3 id="ssh测试"><a href="#ssh测试" class="headerlink" title="ssh测试"></a>ssh测试</h3><p>在host V执行</p>
<div class="hljs"><pre><code class="hljs sh">ssh root@192.168.60.101</code></pre></div>

<img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210708000433140.png" srcset="/img/loading.gif" alt="image-20210708000433140" style="zoom:80%;">

<p>在 host U上执行</p>
<div class="hljs"><pre><code class="hljs sh">ssh root@10.0.2.7</code></pre></div>

<img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210708000944524.png" srcset="/img/loading.gif" alt="image-20210708000944524" style="zoom:80%;">

<p>通过上面的测试可以确定两台主机可以通过VPN程序进行远程控制。</p>
<h1 id="二、TSL-VPN"><a href="#二、TSL-VPN" class="headerlink" title="二、TSL VPN"></a>二、TSL VPN</h1><p>有了上面基于TCP的VPN，再做TSL就会简单很多。</p>
<h2 id="程序实现-1"><a href="#程序实现-1" class="headerlink" title="程序实现"></a>程序实现</h2><h3 id="ssl初始化"><a href="#ssl初始化" class="headerlink" title="ssl初始化"></a>ssl初始化</h3><p>创建SSL数据结构，用于建立TLS连接</p>
<p><code>VPN server</code></p>
<div class="hljs"><pre><code class="hljs c"><span class="hljs-function">SSL* <span class="hljs-title">SSLLibInit</span><span class="hljs-params">()</span> </span>&#123;
   SSL_METHOD *meth;
   SSL_CTX* ctx;
   SSL *ssl;
   <span class="hljs-keyword">int</span> err;

   <span class="hljs-comment">// OpenSSL 初始化</span>
   SSL_library_init();
   SSL_load_error_strings();
   SSLeay_add_ssl_algorithms();
   
   <span class="hljs-comment">// SSL 初始化</span>
   meth = (SSL_METHOD *)TLSv1_2_method();
   ctx = SSL_CTX_new(meth);
   SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, <span class="hljs-literal">NULL</span>);
   <span class="hljs-comment">// 加载服务器证书和私钥文件</span>
   SSL_CTX_use_certificate_file(ctx, <span class="hljs-string">&quot;./cert_server/server.pem&quot;</span>, SSL_FILETYPE_PEM);
   SSL_CTX_use_PrivateKey_file(ctx, <span class="hljs-string">&quot;./cert_server/server-key.pem&quot;</span>, SSL_FILETYPE_PEM);
   ssl = SSL_new (ctx);
   <span class="hljs-keyword">return</span> ssl;
&#125;</code></pre></div>

<p><code>VPN client</code></p>
<div class="hljs"><pre><code class="hljs c"><span class="hljs-function">SSL* <span class="hljs-title">setupTLSClient</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* hostname)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-comment">// OpenSSL 初始化</span>
   SSL_library_init();
   SSL_load_error_strings();
   SSLeay_add_ssl_algorithms();
   SSL_METHOD *meth;
   SSL_CTX* ctx;
   SSL* ssl;

   meth = (SSL_METHOD *)TLSv1_2_method();
   ctx = SSL_CTX_new(meth);

   SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER, verify_callback);  <span class="hljs-comment">//指明是否要求提供证书</span>
   <span class="hljs-keyword">if</span> (SSL_CTX_load_verify_locations(ctx,<span class="hljs-literal">NULL</span>, CA_DIR) &lt; <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//加载可信CA证书，进行证书验证</span>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error setting the verify locations. \n&quot;</span>);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
   &#125;
   ssl = SSL_new (ctx);

   X509_VERIFY_PARAM *vpm = SSL_get0_param(ssl); 
   X509_VERIFY_PARAM_set1_host(vpm, hostname, <span class="hljs-number">0</span>);

   <span class="hljs-keyword">return</span> ssl;
&#125;</code></pre></div>

<h3 id="TCP连接-1"><a href="#TCP连接-1" class="headerlink" title="TCP连接"></a>TCP连接</h3><p>TCP连接与上面的连接一样。</p>
<h3 id="TLS握手"><a href="#TLS握手" class="headerlink" title="TLS握手"></a>TLS握手</h3><blockquote>
<p>SSL_set_fd()将SSL绑定到一个TCP连接<br>调用SSL_connec()启动与服务器的TLS握手协议)</p>
</blockquote>
<div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/*----------------TLS initialization ----------------*/</span>
ssl   = setupTLSClient(hostname);
<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;TLSClientsetup initialisation is successful\n&quot;</span>);

<span class="hljs-comment">/*----------------Create a TCP connection ---------------*/</span>
<span class="hljs-keyword">int</span> sockfd = setupTCPClient(hostname, port);
<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;TCPClientsetup is successful\n&quot;</span>);

<span class="hljs-comment">/*----------------TLS handshake ---------------------*/</span>
SSL_set_fd(ssl, sockfd);  <span class="hljs-comment">//绑定TCP连接</span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SSL_set_fd() is successful\n&quot;</span>);
<span class="hljs-keyword">int</span> err = SSL_connect(ssl); CHK_SSL(err);
<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SSL connection is successful\n&quot;</span>);
<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SSL connection using %s\n&quot;</span>, SSL_get_cipher(ssl));</code></pre></div>

<h3 id="数据转发"><a href="#数据转发" class="headerlink" title="数据转发"></a>数据转发</h3><p>数据转发的原理与基于UDP/TCP的VPN 的原理</p>
<div class="hljs"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">processRequest</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tunfd, SSL* ssl, <span class="hljs-keyword">int</span> sockfd)</span></span>
<span class="hljs-function"></span>&#123;
   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;
     fd_set readFDSet;

     FD_ZERO(&amp;readFDSet);
     FD_SET(sockfd, &amp;readFDSet);
     FD_SET(tunfd, &amp;readFDSet);
     select(FD_SETSIZE, &amp;readFDSet, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);

     <span class="hljs-keyword">if</span> (FD_ISSET(tunfd,  &amp;readFDSet)) tunSelected(tunfd, sockfd, ssl);
     <span class="hljs-keyword">if</span> (FD_ISSET(sockfd, &amp;readFDSet)) socketSelected(tunfd, sockfd, ssl);
   &#125;
&#125;</code></pre></div>



<h2 id="实验环境-1"><a href="#实验环境-1" class="headerlink" title="实验环境"></a>实验环境</h2><p>由于在上ubuntu 18.04上运行时，程序出现错误，所以使用了seedLab 提供的 ubuntu 16.04重新搭建了实验环境。各个网卡信息与上面的实验一样。</p>
<blockquote>
<p>host U：ubuntu 16.04</p>
<p>VPNserver：ubuntu 16.04</p>
<p>host V：ubuntu 16.04</p>
</blockquote>
<h3 id="主机物理网卡配置-1"><a href="#主机物理网卡配置-1" class="headerlink" title="主机物理网卡配置"></a>主机物理网卡配置</h3><table>
<thead>
<tr>
<th align="center">主机</th>
<th align="center">角色</th>
<th align="center">IP地址</th>
</tr>
</thead>
<tbody><tr>
<td align="center">客户机</td>
<td align="center">VPN客户机/host U</td>
<td align="center">10.0.2.7/24</td>
</tr>
<tr>
<td align="center">服务器</td>
<td align="center">VPN服务器/网关</td>
<td align="center">10.0.2.8/24<br>192.168.60.1/24</td>
</tr>
<tr>
<td align="center">内网主机</td>
<td align="center">host V</td>
<td align="center">192.168.60.101/24</td>
</tr>
</tbody></table>
<h3 id="连通性测试"><a href="#连通性测试" class="headerlink" title="连通性测试"></a>连通性测试</h3><p>配置完各个网卡的IP地址后</p>
<ul>
<li><p>host U 可以 ping 通 VPNserver (10.0.2.0/24)</p>
<img src="C:/Users/Sunzh/AppData/Roaming/Typora/typora-user-images/image-20210717190020679.png" srcset="/img/loading.gif" alt="image-20210717190020679" style="zoom:67%;">

<img src="C:/Users/Sunzh/AppData/Roaming/Typora/typora-user-images/image-20210716203822712.png" srcset="/img/loading.gif" alt="image-20210716203822712" style="zoom: 50%;">
</li>
<li><p>VPN server 可以ping 通两台主机</p>
<p><img src="C:/Users/Sunzh/AppData/Roaming/Typora/typora-user-images/image-20210717185939151.png" srcset="/img/loading.gif" alt="image-20210717185939151" style="zoom: 67%;"><img src="C:/Users/Sunzh/AppData/Roaming/Typora/typora-user-images/image-20210717185952701.png" srcset="/img/loading.gif" alt="image-20210717185952701" style="zoom:67%;"></p>
<img src="C:/Users/Sunzh/AppData/Roaming/Typora/typora-user-images/image-20210716203744476.png" srcset="/img/loading.gif" alt="image-20210716203744476" style="zoom: 50%;">
</li>
<li><p>host V可以ping 通VPNserver (192.168.60.0/24)</p>
<img src="C:/Users/Sunzh/AppData/Roaming/Typora/typora-user-images/image-20210717190103613.png" srcset="/img/loading.gif" alt="image-20210717190103613" style="zoom:67%;">

<img src="C:/Users/Sunzh/AppData/Roaming/Typora/typora-user-images/image-20210716203807499.png" srcset="/img/loading.gif" alt="image-20210716203807499" style="zoom: 50%;">



</li>
</ul>
<h3 id="CA和证书设置"><a href="#CA和证书设置" class="headerlink" title="CA和证书设置"></a>CA和证书设置</h3><p>(1)、为 CA 生成一个自签名证书，它将作为根证书，如下所示：</p>
<div class="hljs"><pre><code class="hljs vim">openssl req -<span class="hljs-keyword">new</span> -x509 -keyout <span class="hljs-keyword">ca</span>.key -out <span class="hljs-keyword">ca</span>.crt -config openssl.<span class="hljs-keyword">cnf</span>
//文件 <span class="hljs-keyword">ca</span>.key 包含 CA 的私钥，而 <span class="hljs-keyword">ca</span>.crt 包含公钥证书。</code></pre></div>

<img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210717192409460.png" srcset="/img/loading.gif" alt="image-20210717192409460" style="zoom:80%;">



<p>(2)、接下来，我们使用以下命令为服务器创建一个 RSA 公私钥对</p>
<div class="hljs"><pre><code class="hljs apache"><span class="hljs-attribute">openssl</span> genrsa -aes<span class="hljs-number">128</span> -out server.key <span class="hljs-number">1024</span></code></pre></div>

<p><img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210717192456568.png" srcset="/img/loading.gif" alt="image-20210717192456568"></p>
<p>(3)、创建一个包含服务器公钥的证书签名请求 (CSR)。 CSR 具有以下详细信息，服务器的通用名称为 <code>sunzy.com</code>：</p>
<div class="hljs"><pre><code class="hljs pgsql">openssl req -<span class="hljs-built_in">new</span> -key <span class="hljs-keyword">server</span>.key -<span class="hljs-keyword">out</span> <span class="hljs-keyword">server</span>.csr -config openssl.cnf</code></pre></div>

<img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210717192547722.png" srcset="/img/loading.gif" alt="image-20210717192547722" style="zoom:80%;">



<p>(4)、然后将上述 CSR 发送到 CA 以生成密钥和通用名称的证书。</p>
<div class="hljs"><pre><code class="hljs pgsql">openssl x509 -req -days <span class="hljs-number">365</span> -<span class="hljs-keyword">in</span> <span class="hljs-keyword">server</span>.csr -signkey <span class="hljs-keyword">server</span>.key -<span class="hljs-keyword">out</span> <span class="hljs-keyword">server</span>.crt</code></pre></div>

<img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210716211833071.png" srcset="/img/loading.gif" alt="image-20210716211833071" style="zoom: 67%;">



<p>(5)、将服务器的证书和密钥存储为 pem 文件，这里是</p>
<div class="hljs"><pre><code class="hljs axapta">cp <span class="hljs-keyword">server</span>.crt <span class="hljs-keyword">server</span>-cert.pem
cp <span class="hljs-keyword">server</span>.key <span class="hljs-keyword">server</span>-key.pem</code></pre></div>

<p>VPN Server 程序使用这些文件来加载证书和私钥，如下所示</p>
<p><img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210717105652371.png" srcset="/img/loading.gif" alt="image-20210717105652371"></p>
<p>(6)、使用名称作为主题字段的哈希存储服务器的证书。这是因为在接收服务器的证书时，TLS 会根据颁发者的身份信息生成一个哈希值，并使用此哈希值在“./cert”文件夹中查找颁发者的证书，命令如下:(以下命令在ca_client 文件下执行)</p>
<div class="hljs"><pre><code class="hljs apache"><span class="hljs-attribute">openssl</span> x<span class="hljs-number">509</span> -in ca.crt -noout -subject_hash
<span class="hljs-attribute">ln</span> -s ca.crt b<span class="hljs-number">4386</span>d<span class="hljs-number">70</span>.<span class="hljs-number">0</span></code></pre></div>

<p><img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210717105919161.png" srcset="/img/loading.gif" alt="image-20210717105919161"></p>
<p><img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210717200542030.png" srcset="/img/loading.gif" alt="image-20210717200542030"></p>
<h2 id="建立TLS通信"><a href="#建立TLS通信" class="headerlink" title="建立TLS通信"></a>建立TLS通信</h2><h3 id="VPN-server"><a href="#VPN-server" class="headerlink" title="VPN server"></a>VPN server</h3><p>首先在VPN服务器上执行以下命令，将c程序编译为可执行程序</p>
<div class="hljs"><pre><code class="hljs llvm">gcc -o vpnserver_tls vpnserver_tls.<span class="hljs-keyword">c</span> -lssl -lcrypto -lcrypt</code></pre></div>

<p>执行编译好的程序，此时该程序处于监听状态等待客户端的连接</p>
<p><img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210717110722763.png" srcset="/img/loading.gif" alt="image-20210717110722763"></p>
<p>此时该程序将创建一个<code>tun0</code>虚拟网卡，使用以下命令配置网卡信息</p>
<div class="hljs"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> ifconfig tun<span class="hljs-number">0</span> <span class="hljs-number">192.168.53.1</span>/<span class="hljs-number">24</span> up</code></pre></div>

<p>配置完后的网卡信息如图：</p>
<img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210717104726586.png" srcset="/img/loading.gif" alt="image-20210717104726586" style="zoom:67%;">

<p>编辑路由表并将设置为转发模式</p>
<div class="hljs"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> route add –net <span class="hljs-number">192.168.53.0</span>/<span class="hljs-number">24</span> tun<span class="hljs-number">0</span>
<span class="hljs-attribute">sudo</span> sysctl net.ipv<span class="hljs-number">4</span>.ip_forward=<span class="hljs-number">1</span></code></pre></div>

<p><img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210717092728424.png" srcset="/img/loading.gif" alt="image-20210717092728424"></p>
<h3 id="VPN-client"><a href="#VPN-client" class="headerlink" title="VPN client"></a>VPN client</h3><p>与服务器上一样，首先编译c程序</p>
<div class="hljs"><pre><code class="hljs llvm">gcc -o vpnclient_tls vpnclient_tls.<span class="hljs-keyword">c</span> -lssl -lcrypto</code></pre></div>

<p>执行该程序（该域名与上面创建的证书中的通用名称一样）</p>
<div class="hljs"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> ./vpnclient_tls <span class="hljs-string">&quot;sunzy.com&quot;</span> <span class="hljs-number">4433</span></code></pre></div>

<p><img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210717111325426.png" srcset="/img/loading.gif" alt="image-20210717111325426"></p>
<p>创建连接后，服务器端确认后，开始身份认证</p>
<p><img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210717111437904.png" srcset="/img/loading.gif" alt="image-20210717111437904"></p>
<p>服务器端收到的消息如下</p>
<p><img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210717111535076.png" srcset="/img/loading.gif" alt="image-20210717111535076"></p>
<p>此时TLS连接已经建立。</p>
<p>配置tun0和路由表</p>
<div class="hljs"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> ifconfig tun<span class="hljs-number">0</span> <span class="hljs-number">192.168.53.5</span>/<span class="hljs-number">24</span> up
<span class="hljs-attribute">sudo</span> route add -net <span class="hljs-number">192.168.60.0</span>/<span class="hljs-number">24</span></code></pre></div>

<h3 id="Host-V"><a href="#Host-V" class="headerlink" title="Host V"></a>Host V</h3><p>要实现内外网主机之间的通信，还需要在内网主机上添加路由表信息</p>
<div class="hljs"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> route add -net <span class="hljs-number">192.168.53.0</span>/<span class="hljs-number">24</span> gw <span class="hljs-number">192.168.60.1</span> enp<span class="hljs-number">0</span>s<span class="hljs-number">3</span></code></pre></div>

<p><img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210717113001100.png" srcset="/img/loading.gif" alt="image-20210717113001100"></p>
<h3 id="VPN-server和VPN-client-的连接信息"><a href="#VPN-server和VPN-client-的连接信息" class="headerlink" title="VPN server和VPN client 的连接信息"></a>VPN server和VPN client 的连接信息</h3><p><code>VPN server</code></p>
<p><img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210717160935019.png" srcset="/img/loading.gif" alt="image-20210717160935019"></p>
<p><code>VPN client</code></p>
<p><img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210717161031264.png" srcset="/img/loading.gif" alt="image-20210717161031264"></p>
<h2 id="通信验证"><a href="#通信验证" class="headerlink" title="通信验证"></a>通信验证</h2><h3 id="ping-测试-1"><a href="#ping-测试-1" class="headerlink" title="ping 测试"></a>ping 测试</h3><ul>
<li>客户端（10.0.2.7）ping 内网主机（192.168.60.101）</li>
</ul>
<img src="C:/Users/Sunzh/AppData/Roaming/Typora/typora-user-images/image-20210717104553457.png" srcset="/img/loading.gif" alt="image-20210717104553457" style="zoom:67%;">

<ul>
<li>内网主机(192.168.60.101) ping 10.0.2.7 </li>
</ul>
<img src="C:/Users/Sunzh/AppData/Roaming/Typora/typora-user-images/image-20210717104633291.png" srcset="/img/loading.gif" alt="image-20210717104633291" style="zoom:67%;">

<p>查看客户端上的 Wireshark 数据时，我们看到 ping 请求从 tun0 发送到内部网络 IP，并且此数据包从 VPN 客户端发送到 VPN tunnel</p>
<img src="C:/Users/Sunzh/AppData/Roaming/Typora/typora-user-images/image-20210717153451936.png" srcset="/img/loading.gif" alt="image-20210717153451936" style="zoom:67%;">

<p>在服务器端，我们看到类似的流量——主机 U 和主机 V 之间的 ping 请求和回复通信，中间有 VPN 服务器。 </p>
<img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210717133757659.png" srcset="/img/loading.gif" alt="image-20210717133757659" style="zoom:67%;">

<h3 id="telnet-测试"><a href="#telnet-测试" class="headerlink" title="telnet 测试"></a>telnet 测试</h3><ul>
<li>首先在在Host U上使用telnet控制Host V</li>
</ul>
<img src="C:/Users/Sunzh/AppData/Roaming/Typora/typora-user-images/image-20210717114933233.png" srcset="/img/loading.gif" alt="image-20210717114933233" style="zoom: 67%;">

<ul>
<li>在内网主机Host V 上telnet 客户端HostU </li>
</ul>
<img src="C:/Users/Sunzh/AppData/Roaming/Typora/typora-user-images/image-20210717115511290.png" srcset="/img/loading.gif" alt="image-20210717115511290" style="zoom: 67%;">

<p>wireshark抓取的telnet的通信数据包</p>
<p>VPN server上的数据包信息</p>
<img src="https://raw.githubusercontent.com/sunzhengyu99/image/master/img/image-20210717153538769.png" srcset="/img/loading.gif" alt="image-20210717153538769" style="zoom:67%;">

<h2 id="命令集合"><a href="#命令集合" class="headerlink" title="命令集合"></a>命令集合</h2><h3 id="VPN-server-1"><a href="#VPN-server-1" class="headerlink" title="VPN server"></a>VPN server</h3><div class="hljs"><pre><code class="hljs shell">//编译程序
gcc -o vpnserver_tls vpnserver_tls.c -lssl -lcrypto -lcrypt
//启动程序
sudo ./vpnserver_tls 4433</code></pre></div>

<div class="hljs"><pre><code class="hljs shell">//设置tun0信息 添加转发功能 添加路由
sudo ifconfig tun0 192.168.53.1/24 up
sudo sysctl net.ipv4.ip_forward=1
sudo route add -net 192.168.53.0/24 tun0
sudo route add -net 192.168.60.0/24 tun0</code></pre></div>

<h3 id="VPN-client-1"><a href="#VPN-client-1" class="headerlink" title="VPN client"></a>VPN client</h3><div class="hljs"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>编译程序
gcc -o vpnclient_tls vpnclient_tls.c -lssl -lcrypto
<span class="hljs-regexp">//</span>启动程序
sudo ./vpnclient_tls sunzy.com <span class="hljs-number">4433</span></code></pre></div>

<div class="hljs"><pre><code class="hljs armasm"><span class="hljs-comment">//设置tun0信息  添加路由</span>
<span class="hljs-symbol">sudo</span> ifconfig tun0 <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">53</span>.<span class="hljs-number">5</span>/<span class="hljs-number">24</span> up
<span class="hljs-symbol">sudo</span> route <span class="hljs-keyword">add</span> -net <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">60</span>.<span class="hljs-number">0</span>/<span class="hljs-number">24</span></code></pre></div>

<h3 id="内网主机"><a href="#内网主机" class="headerlink" title="内网主机"></a>内网主机</h3><div class="hljs"><pre><code class="hljs apache"><span class="hljs-attribute">route</span> add -net <span class="hljs-number">192.168.53.0</span>/<span class="hljs-number">24</span> gw <span class="hljs-number">192.168.60.1</span> enp<span class="hljs-number">0</span>s<span class="hljs-number">3</span></code></pre></div>


            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/homework/">homework</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/socket/">socket</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/07/28/IDscan/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">IDscan</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/07/21/RSA-AES/">
                        <span class="hidden-mobile">RSA_AES</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <div id="vcomments"></div>
  <script type="text/javascript">
    function loadValine() {
      addScript('https://cdn.jsdelivr.net/gh/HCLonely/Valine@latest/dist/Valine.min.js', function () {
        new Valine({
          el: "#vcomments",
          app_id: "2rPljbm5WOxA9BCPXqy3VE5y-gzGzoHsz",
          app_key: "SCoIn2Qp99a7ITtPhkAi6Chw",
          placeholder: "说点什么吧~~~",
          path: window.location.pathname,
          avatar: "retro",
          meta: ["nick","mail","link"],
          pageSize: "10",
          lang: "zh-CN",
          highlight: true,
          recordIP: false,
          serverURLs: "",
          master: "4cd096660a71d786a2a4d9d0bb4e8996",
          friends: "b275f0fc8103331da645a878cf60f841",
          tagMeta: ["博主","友人","访客"],
        });
      });
    }
    waitElementVisible('vcomments', loadValine);
  </script>
  <noscript>Please enable JavaScript to view the <a target="_blank" href="https://valine.js.org" rel="nofollow noopener noopener">comments
      powered by Valine.</a></noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-md">
    <div class="container custom post-content mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "VPN&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: true,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
      icon: "§"
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>












  

  

  

  

  

  



<div class="text-center py-1">   
  <div>
    <span>Copyright © 2020</span></a>
    <a href="http://sunzy.icu/" target="_blank" rel="nofollow noopener">
     <span>my blog</span></a>    <br>
  </div>
<div>
  <span id="timeDate">载入天数...</span>
  <span id="times">载入时分秒...</span>
  <script>
  var now = new Date();
  function createtime(){
      var grt= new Date("03/02/2020 00:00:00");//此处修改你的建站时间或者网站上线时间
      now.setTime(now.getTime()+250);
      days = (now - grt ) / 1000 / 60 / 60 / 24;
      dnum = Math.floor(days);
      hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
      hnum = Math.floor(hours);
      if(String(hnum).length ==1 ){
          hnum = "0" + hnum;
      }
      minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
      mnum = Math.floor(minutes);
      if(String(mnum).length ==1 ){
                mnum = "0" + mnum;
      }
      seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
      snum = Math.round(seconds);
      if(String(snum).length ==1 ){
                snum = "0" + snum;
      }
      document.getElementById("timeDate").innerHTML = "🚀 for&nbsp"+dnum+"&nbspdays";  //此次自定义显示内容
      document.getElementById("times").innerHTML = hnum + "&nbsphr&nbsp" + mnum + "&nbspmin&nbsp" + snum + "&nbspsec";
  }  //此次自定义显示内容
  setInterval("createtime()",250);
  </script>
</div>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
